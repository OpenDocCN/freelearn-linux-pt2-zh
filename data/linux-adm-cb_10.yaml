- en: Git, Configuration Management, and Infrastructure as Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git、配置管理和基础设施即代码
- en: 'In this chapter, we will examine the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将研究以下主题：
- en: What is Git?
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Git？
- en: Setting up a Git server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Git服务器
- en: Committing to our Git repository
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交到我们的Git仓库
- en: Branching our Git repository and committing changes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支我们的Git仓库并提交更改
- en: Installing Ansible
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Ansible
- en: Using Ansible to install Java from a role
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible从一个角色安装Java
- en: Storing our Ansible configuration in Git
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的Ansible配置存储在Git中
- en: Exploring options for IaC
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索IaC的选项
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: There was a time when a system administrator knew their server intimately. They
    could tell you every fan noise, the meaning of every beep, and what it sounded
    like when the metal expanded as the server got hot.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一段时间，系统管理员对他们的服务器了如指掌。他们可以告诉你每个风扇的噪音，每个蜂鸣的含义，以及服务器变热时金属膨胀的声音。
- en: As with the hardware, the software was almost supernaturally indexed in the
    system administrator's head, and they could tell you at the drop of a pin what
    version of OpenSSL, Apache, or Midnight Commander they were running.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与硬件一样，软件几乎是以超自然的方式索引在系统管理员的头脑中，他们可以在一瞬间告诉你他们正在运行的OpenSSL、Apache或Midnight Commander的版本。
- en: 'There''s an obvious problem with this: the *hit by a bus* effect.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然存在一个问题：*被公交车撞倒*的效应。
- en: If a sysadmin were to be unfortunately mowed down one morning, his Walkman being
    thrown to the road alongside the shattered remains of his Game Boy Color, all
    the knowledge of the server would be lost in a singular moment. The knowledge
    of the strange way in which the server was set to boot, meaning it has to have
    the keyboard unplugged at just the right moment, will be gone forever.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一名系统管理员不幸在一个早晨被撞倒，他的随身听被扔到了路边，与他的Game Boy Color的残骸一起，那么服务器的所有知识将在瞬间丧失。服务器设置的奇怪方式，意味着必须在恰到好处的时刻拔掉键盘，这样的知识将永远消失。
- en: You don't want one person to be intimately aware of everything to do with a
    server—you want multiple people, and to take it one step further, you want it
    written down in a format that's not only easily reproduced and modified, but also
    preferably so simple that even a computer could understand it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望一个人对服务器的所有事情了如指掌——你希望有多个人，并且更进一步，你希望它以一种不仅易于复制和修改的格式书写，而且最好是如此简单，以至于连计算机都能理解。
- en: In this chapter, we're going to look at three things that are relatively close
    together in the software world—a version control system, called Git; the concept
    of configuration management, mostly in the form of Ansible; and Infrastructure
    as Code, featuring everyone's favorites, Terraform and Packer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将看一下软件世界中相对接近的三件事——一个版本控制系统，叫做Git；配置管理的概念，主要是Ansible；以及基础设施即代码，以及每个人都喜欢的Terraform和Packer。
- en: We've actually already done a lot of this by using Vagrant as we have been doing.
    Vagrant is effectively a method of having infrastructure as code, though on a
    very small scale. The small scripts that we've put into a couple of our Vagrantfiles
    could easily be considered configuration management, though at a base level.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们已经通过使用Vagrant来完成了很多工作。Vagrant实际上是一种基础设施即代码的方法，尽管规模很小。我们在一些Vagrantfiles中放入的小脚本可以很容易地被视为配置管理，尽管在基本层面上。
- en: These tools are some of the best you'll come across on your journey, and Git
    especially is used pretty much universally, so it's good to understand.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具是你在旅途中遇到的最好的工具之一，特别是Git几乎被普遍使用，所以了解它是很好的。
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we're going to need a couple of **virtual machines** (**VMs**).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将需要一些虚拟机（VMs）。
- en: 'Feel free to use the `Vagrantfile` that follows. We''re mostly going to work
    across the private network, between the VMs:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随意使用以下的`Vagrantfile`。我们将主要在虚拟机之间的私有网络上工作：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What is Git?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Git？
- en: In this section, we're going to look at the supreme overlord when it comes to
    **version control systems** (**VCSs**). There have been others, and there will
    be more to come, but right now, there's Git, and it's by far the most widely used
    and most popular (though not without its fair share of criticism).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一下**版本控制系统**（VCSs）的至高无上者。还有其他的，将来还会有更多，但现在有Git，它是目前使用最广泛、最受欢迎的（尽管不是没有批评）。
- en: Git was initially developed by Linus Torvalds—yes, that same Linus Torvalds
    who kick-started Linux kernel development, though these days it's primarily developed
    by Junio C Hamano, and many other talented hackers. It's found in software development
    primarily, but is increasingly used to store configuration for things like Ansible,
    Terraform, and any other infrastructure as code tool, enabling a historic and
    versioned picture of your infrastructure.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Git最初是由Linus Torvalds开发的——是的，就是那个开启Linux内核开发的Linus Torvalds，尽管如今它主要由Junio C
    Hamano和许多其他才华横溢的黑客开发。它主要用于软件开发，但越来越多地用于存储诸如Ansible、Terraform和任何其他基础设施即代码工具的配置，从而实现对基础设施的历史和版本化的描述。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To understand Git, we''re going to install it and start your VMs and jump onto
    your first CentOS box:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解Git，我们将安装它，启动你的虚拟机，并跳到你的第一个CentOS盒子上：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Installing Git is simple, as it''s in most default repositories (in fact, I''ve
    yet to come across a Linux distribution where it wasn''t in the default repositories):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Git很简单，因为它在大多数默认仓库中（事实上，我还没有遇到过一个Linux发行版，它不在默认仓库中）：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Warning: You will most likely get Perl, and while this is not inherently a
    bad thing, the very mention of the word perl can make developers and sysadmins
    alike cringe.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：你很可能会得到Perl，虽然这本质上并不是一件坏事，但提到perl这个词会让开发人员和系统管理员感到不适。
- en: We should now have Git, so let's run through some basics.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该有Git了，所以让我们来了解一些基础知识。
- en: Cloning
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆
- en: Fundamentally, Git is a version control system that's primarily used for source
    code versioning (though it has other uses, too).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上说，Git是一个主要用于源代码版本控制的版本控制系统（尽管它还有其他用途）。
- en: 'To demonstrate how it works, let''s clone a smallish repository (in this case,
    Ansible):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示它是如何工作的，让我们克隆一个较小的存储库（在这种情况下是Ansible）：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This may take a couple of minutes based on your connection, but, once finished,
    you''ll be left with an `ansible` folder:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要几分钟，根据您的连接，但完成后，您将得到一个“ansible”文件夹：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Exploring and making changes
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索和进行更改
- en: We now have a like-for-like copy of the `devel` Ansible code branch. It's `devel`
    because that's what the repository owners want the default branch to be, though
    frequently it will be `master` or `develop`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个与“devel”Ansible代码分支相似的副本。它是“devel”，因为这是存储库所有者希望默认分支的名称，尽管通常它将是“master”或“develop”。
- en: 'Taking a look inside the folder, we''ll see a lot of files with a lot of code
    inside:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件夹，我们会看到很多文件，里面有很多代码：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As with any good source code, there should be a `README` file, which is generally
    a good place to start, but we're not here for Ansible right now—we're here for
    Git.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何良好的源代码一样，应该有一个“README”文件，这通常是一个很好的起点，但我们现在不是为了Ansible而在这里，我们是为了Git。
- en: 'Run a `git status`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`git status`：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This tells us that we've made no changes and, as a result, our working directory
    is clean, given that we've done nothing yet.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，我们没有进行任何更改，因此我们的工作目录是干净的，因为我们还没有做任何事情。
- en: 'Make the following change to the `README` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对“README”文件进行以下更改：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, if we apply `git status` again, we''ll see our change:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次应用`git status`，我们将看到我们的更改：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As the message suggests, we could add and commit our changes, and then attempt
    to get them merged upstream (don't), but for now, we're going to simply revert
    the change we've just done that mangled the `README` file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如消息所暗示的，我们可以添加和提交我们的更改，然后尝试将它们合并到上游（不要这样做），但现在，我们只是简单地恢复我们刚刚对“README”文件所做的更改。
- en: 'First, let''s take a look at what we did:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看我们做了什么：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Oh dear—let''s fix that:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，亲爱的，让我们修复一下：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note how, when we checked out the `README` file, we basically reset the file
    to its default state, meaning that git doesn't think we have anything to commit,
    and the file is back to normal.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们检出“README”文件时，我们基本上将文件重置为其默认状态，这意味着git认为我们没有任何要提交的内容，文件恢复正常。
- en: Checking out is the act of overwriting our uncommitted local changes with the
    Git repository's version.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 检出是用Git存储库的版本覆盖我们未提交的本地更改的行为。
- en: 'We can see the fact that these changes have been reverted by once again catting
    the file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这些变化已经被再次猫的文件所撤销：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Neat, eh?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不错，是吧？
- en: It's worth remembering, though, that any changes you made prior to overwriting
    the file will be lost (because they weren't staged, and the repository wasn't
    made aware of them).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，覆盖文件之前所做的任何更改都将丢失（因为它们没有被暂存，存储库也没有意识到它们）。
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Fundamentally, Git is a version control system, meaning that it controls the
    versions of the files under its care.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上说，Git是一个版本控制系统，这意味着它控制着其管理的文件的版本。
- en: Most folders can theoretically be made into a Git repository, though it's usually
    code or configuration that gets this privilege.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数文件夹理论上都可以成为Git存储库，尽管通常是代码或配置才能获得这种特权。
- en: When you check out a repository, you get a snapshot of where the code on the
    branch is at the time you check it out. If you then make changes, those changes
    need to be staged and either kept in a separate branch or merged into the branch
    you changed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当您检出存储库时，您会获得该分支上代码的快照。然后，如果您进行更改，这些更改需要被暂存，并且要么保留在一个单独的分支中，要么合并到您更改的分支中。
- en: Don't worry too much about this yet—I was incredibly confused the first time
    someone told me about Git.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要太担心这个——第一次有人告诉我Git的时候，我也感到非常困惑。
- en: In the real world, there are a few different ways that people tend to use Git,
    and some relatively popular tools and practices that have been developed. The
    kernel method of using Git, for example, is extremely different to the GitFlow
    method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，人们倾向于使用Git的几种不同方式，以及一些相对流行的工具和实践。例如，使用Git的内核方法与GitFlow方法极为不同。
- en: We'll be going over examples of changes in the rest of this chapter, but for
    now, you just need to understand that if you commit and push something into a
    Git repository, it will have a record of that change, meaning that you can go
    back to an earlier version of your code at any point in the life cycle of the
    repository, and either copy old fixes or back-port changes into stable branches.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的其余部分介绍更改的示例，但现在，您只需要了解，如果您将某些内容提交并推送到Git存储库中，它将记录该更改，这意味着您可以在存储库的生命周期的任何时候返回到代码的早期版本，并将旧的修复或更改回移植到稳定分支中。
- en: Sadly, Git doesn't have the ability to import code you haven't written yet from
    some weird future file, but I'm still holding out hope for this feature.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，Git无法从一些奇怪的未来文件中导入您尚未编写的代码，但我仍然对此功能抱有希望。
- en: 'Your configuration per repository is stored in the `.git` folder that''s created
    upon a repository being imported/created:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 每个存储库的配置都存储在创建存储库时创建的`.git`文件夹中：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This folder also contains the history (in a binary format) of your repository.
    It is the place that's searched for when you're trying to look for changes and
    differences in files that aren't in your checked-out branch. Therefore, it can
    also be quite large.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件夹还包含您存储库的历史记录（以二进制格式）。当您尝试查找不在您检出的分支中的文件的更改和差异时，它是搜索的地方。因此，它也可能相当大。
- en: 'Looking into the configuration file, we can see the defaults drawn down when
    we cloned the repository:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 查看配置文件，我们可以看到克隆存储库时绘制的默认值：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note the remote sections, detailing where our `origin` resides.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意远程部分，详细说明我们的“origin”所在的位置。
- en: There's also a `global` configuration file and a `system` file that can be used
    to make changes that affect every repository your user interacts with, along with
    every repository any user on the system interacts with.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个“全局”配置文件和一个“系统”文件，可以用来进行更改，影响用户与系统上任何用户交互的每个存储库。
- en: This should give you a good indication as to why Git is so great—it allows easy
    collaboration because people can work on different branches or even the same branch,
    and there are functions in place to stop you stamping over each other's work.
    You can also make changes safe in the knowledge that the history of a file is
    there, meaning that when you inevitably break something, you can fix it with a
    few keystrokes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该让您对Git为何如此出色有一个很好的了解——它允许轻松协作，因为人们可以在不同的分支上甚至相同的分支上工作，并且有一些功能可以阻止您覆盖彼此的工作。您还可以放心地进行更改，因为文件的历史记录在那里，这意味着当您不可避免地出现问题时，您可以用几个按键来解决它。
- en: There's more...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Git is extremely powerful, but it also has some functionality that is just plain
    nice.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Git非常强大，但它也具有一些非常好的功能。
- en: '`log`, for example, can be useful for reading commit messages:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`log`对于阅读提交消息很有用：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output should look like the following screenshot:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下截图所示：
- en: '![](img/ff6c981d-7bbd-454e-8418-ed7de204081c.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff6c981d-7bbd-454e-8418-ed7de204081c.png)'
- en: '`tag` can be useful for listing the tags people have added to different points-in-time
    of the code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`tag`对于列出人们已添加到代码不同时间点的标签很有用：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`branch` can be used to see all the different branches that Git is aware of:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`branch`可用于查看Git知道的所有不同分支：'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we used `-a`, so remote branches are included, as well as your single
    local one (`devel`).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`-a`，因此远程分支和您的单个本地分支（`devel`）都包括在内。
- en: Setting up a Git server
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Git服务器
- en: In this section, we're going to look at setting up a small Git server, literally
    using what we got when we installed `git` from the CentOS repositories.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何设置一个小型的Git服务器，实际上就是使用我们从CentOS存储库安装`git`时得到的内容。
- en: We'll create a basic repository on centos2 and work with it from centos1.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在centos2上创建一个基本存储库，并从centos1上使用它。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this section, we're going to be using both of our machines, using centos2
    as a server, and centos1 as the client.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用我们的两台机器，使用centos2作为服务器，centos1作为客户端。
- en: 'In this instance, ensure that `git` is installed on both your machines:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，请确保您的两台机器上都安装了`git`：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'On `centos2`, let''s create our empty repository:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`centos2`上，让我们创建我们的空存储库：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, on our `centos1` machine, we can clone the repository:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`centos1`机器上，我们可以克隆存储库：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You'll be prompted for the `vagrant` user password (`vagrant` by default), and
    then you'll see a message informing you that you've cloned an empty repository.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被提示输入`vagrant`用户密码（默认为`vagrant`），然后您将看到一条消息，通知您已经克隆了一个空存储库。
- en: 'This is fine, though, as you should now see a new `example` directory:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，因为现在您应该看到一个新的`example`目录：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When you initialize your repository on centos2, you're creating the first of
    a repository that can exist on any number of devices, and that don't necessarily
    have to be cloned from your central location (centos2).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在centos2上初始化存储库时，您正在创建一个可以存在于任意数量的设备上的存储库，不一定需要从您的中央位置（centos2）克隆。
- en: If, for some reason, you're in a situation where you can't clone from the initial
    server (centos2), you could also clone the repository from another machine that
    already had the repository checked out (though you do run the risk of that repository
    not being up to date with the first node).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，您无法从初始服务器（centos2）克隆，您还可以从已经检出存储库的另一台机器克隆存储库（尽管您可能面临存储库与第一个节点不同步的风险）。
- en: When you clone the repository, you're actually communicating over SSH with the
    `centos2` box, and Git sends specific commands that are understood by the repository
    on the other side and answered.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当您克隆存储库时，实际上是通过SSH与`centos2`进行通信，并且Git发送特定命令，这些命令被另一侧的存储库理解并回答。
- en: 'Again, if we check out the `.git` repository on `centos1`, within the cloned
    repository, we can see the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们在`centos1`上检出`.git`存储库，在克隆的存储库中，我们可以看到以下内容：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note the URL printed as the remote `origin`. Also be aware that this isn't a
    `bare` repository.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意打印为远程`origin`的URL。还要注意这不是一个`bare`存储库。
- en: 'Let''s take a look at the `config` file on the server (`centos2`):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看服务器（`centos2`）上的`config`文件：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It's considerably smaller, with `bare` set to `true` here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里设置为`true`的`bare`要小得多。
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This is the simplest of Git repositories, and there's a bit more you can do
    if you want to make it a bit more interesting.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的Git存储库，如果您想使其更有趣，还有更多事情可以做。
- en: First, you might consider creating a dedicated `git` user on your system, and
    using this as the user that manages and owns the Git repositories. This is generally
    a pretty standard approach, and one shared by the off-the-shelf Git solutions,
    like GitLab and GitHub.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可能考虑在系统上创建一个专用的`git`用户，并使用此用户来管理和拥有Git存储库。这通常是一个非常标准的方法，也是GitLab和GitHub等现成的Git解决方案所共享的方法。
- en: Secondly, you could think about setting up a `cgit` server, which is a small
    server that can be used to visualize a Git repository.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您可以考虑设置一个`cgit`服务器，这是一个小型服务器，可用于可视化Git存储库。
- en: 'The most famous `cgit` instance is probably [git.kernel.org](https://git.kernel.org/):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最著名的`cgit`实例可能是[git.kernel.org](https://git.kernel.org/)：
- en: '![](img/50656c38-f1d5-431e-8307-6138b86432bb.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50656c38-f1d5-431e-8307-6138b86432bb.png)'
- en: Committing to our Git repository
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交到我们的Git存储库
- en: In this section, we're going to put together a small file, add it to the files
    being tracked by Git, commit our changes, and push them to the origin server.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个小文件，将其添加到Git正在跟踪的文件中，提交我们的更改，并将其推送到原始服务器。
- en: Getting ready
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you haven't already, set up a Git server based on the previous section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未这样做，请根据上一节设置基于Git的服务器。
- en: Ensure that you've checked out your repository on `centos1`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已在`centos1`上检出您的存储库。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s give our new repository a bit of information and push this to the server
    (proving it works):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的新存储库添加一些信息并将其推送到服务器（证明它有效）：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s start by running a `git status` to see where we''re at:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先运行`git status`来查看我们的进度：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Good—it's empty.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好的-它是空的。
- en: 'Now, let''s echo out some text to a file, stage the file, and commit it with
    a message:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回显一些文本到一个文件中，将文件放入暂存区，并提交带有消息的文件：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Ah! Now, because this is a new installation, Git prompts us to set some defaults:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！现在，因为这是一个新的安装，Git提示我们设置一些默认值：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s try that commit again:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一次提交：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Okay, we've committed our file, meaning that the local version of `master` is
    up to date.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们已经提交了我们的文件，这意味着本地版本的`master`是最新的。
- en: 'However, this means that we''re now out of sync with our origin repository,
    so we need to `push` our changes up to there, too:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这意味着我们现在与我们的源存储库不同步，所以我们也需要将我们的更改`push`到那里：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Woo! Another prompt—we should set it. Personally, I chose the new behavior,
    because while CentOS 7 ships with an old version of Git, the march of progress
    continues:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！又一个提示-我们应该设置它。就我个人而言，我选择了新行为，因为虽然CentOS 7附带了一个旧版本的Git，但进步的步伐仍在继续：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Phew! Alright, let''s try a push again:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！好吧，让我们再试一次推送：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, you can see that we were prompted for our password, but once that's entered,
    the changes are written to the origin server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们被提示输入密码，但一旦输入密码，更改就会被写入原始服务器。
- en: This means that when we clone the repository from the origin again, our changes
    will come with it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当我们再次从原始克隆存储库克隆存储库时，我们的更改将随之而来。
- en: 'Try the following from your home directory to prove this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从您的主目录运行以下命令以证明这一点：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Excelsior!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 卓越！
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we're doing a few things.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在做一些事情。
- en: 'First, after we''ve created our foo file with some text in, we `add` that file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们创建了带有一些文本的foo文件后，我们`add`了该文件：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this small command, we're actually adding the `README` file to Git's index.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小命令中，我们实际上是将`README`文件添加到Git的索引中。
- en: 'Anything we stage in this manner is added in the next commit:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以这种方式暂存的任何东西都将在下一次提交中添加：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we're committing (as the name suggests) our added changes to the repository.
    We also include a message as part of the command (with `-m`) instead of letting
    `git commit` drop us into whatever our default editor is set to (because every
    commit should have a message, since it prompts you to write one).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在提交（正如名称所示）我们对存储库的添加更改。我们还在命令中包括消息（使用`-m`）作为命令的一部分，而不是让`git commit`将我们放入默认编辑器中（因为每次提交都应该有一个消息，因为它提示您写一个）。
- en: 'Lastly, we pushed our change:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们推送了我们的更改：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In technical terms, we're informing the remote repository (on `192.168.33.11`)
    that some references have changed, and we tell it which ones. We also push any
    associated objects with these referenced changes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术术语上，我们正在通知远程存储库（在`192.168.33.11`上）一些引用已经改变，并告诉它哪些引用已经改变。我们还推送了与这些引用更改相关的任何对象。
- en: Matching versus simple
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配与简单
- en: A quick word on this, as we set our default in this section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点，我们在本节中设置了我们的默认值。
- en: Had we set our option as matching, we would push all of our branches at once
    when running a `git push` command. This means that not only your current branch,
    but also `master`, `develop`, and any others you might have will also get pushed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将选项设置为匹配，那么在运行`git push`命令时，我们将一次推送所有分支。这意味着不仅您当前的分支，而且`master`，`develop`和您可能拥有的任何其他分支也将被推送。
- en: Simple, on the other hand, will only push the branch that you're currently working
    on. From a logic point of view, it's understandable that simple would be the default
    behavior, as it assumes that most people will only work in one branch at any one
    time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，简单只会推送你当前正在工作的分支。从逻辑上讲，简单会成为默认行为是可以理解的，因为它假设大多数人一次只会在一个分支上工作。
- en: Branching our Git repository and committing changes
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支我们的Git存储库并提交更改
- en: In this section, we're going to look at branching our cloned repository and
    pushing those changes to our server.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何分支我们的克隆存储库并将这些更改推送到我们的服务器。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: Ensure that you've run through at least the *setup* section, but preferably
    the section where you committed your first file, too.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您至少已经完成了*设置*部分，但最好是您也提交了第一个文件的部分。
- en: All work will be done on `centos1`, in the `example` repository.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工作将在`centos1`的`example`存储库中完成。
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Change into the `example` repository:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到`example`存储库：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, check that you''re on `master` to start:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查一下你是否在`master`上开始：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Your current branch is denoted with an asterisk.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您当前的分支用星号表示。
- en: 'Good! Now, we''re going to `branch` off from `master`, and make some changes:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！现在，我们要从`master`上`branch`出去，并做一些更改：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run `git branch` again:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`git branch`：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Note that now, we have two branches, but we''re still on the `master` branch.
    We need to run a different command to flip to our new branch:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在我们有两个分支，但我们仍然在`master`分支上。我们需要运行不同的命令来切换到我们的新分支：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, list what''s in this branch:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，列出这个分支中有什么：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We've effectively made a copy of the `master` branch, meaning that all of the
    files committed to that branch are available in our new one.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上已经复制了`master`分支，这意味着提交到该分支的所有文件都可以在我们的新分支中使用。
- en: 'Let''s create a new file and give it some content:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新文件并给它一些内容：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Running `git status` again informs us of our untracked changes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`git status`会告诉我们我们的未跟踪更改：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As it says, let''s `add` and `commit` this file:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它所说，让我们`add`和`commit`这个文件：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We've now got a branch locally, with a committed file that doesn't exist on
    the origin server at all.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在本地有一个分支，有一个提交的文件，在原始服务器上根本不存在。
- en: 'Let''s try to `push` our branch to `192.168.33.11`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将我们的分支`push`到`192.168.33.11`：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Oh no!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 哦不！
- en: Because our local `develop` branch has no upstream counterpart configured, the
    `push` fails.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的本地`develop`分支没有配置上游对应项，所以`push`失败了。
- en: 'However, you already knew that because you''re a diligent sysadmin and you
    actually read the error message, along with the helpful command it gave us to
    rectify this problem:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您已经知道这一点，因为您是一个勤奋的系统管理员，实际上阅读了错误消息，以及它给我们提供的有用命令来纠正这个问题：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Okay, so we've now got a `develop` and `master` branch locally, as well as a
    copy on the upstream server.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在我们在本地有一个`develop`和`master`分支，以及一个在上游服务器上的副本。
- en: 'Let''s check out `master` to see what it looks like now:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检出`master`看看现在是什么样子：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: What? Where's our file? It was in this directory!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？我们的文件在哪里？它就在这个目录里！
- en: Ah, but no, this is a different branch of the same directory, and, in this dark,
    dark timeline, our work doesn't exist.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，但不，这是同一个目录的不同分支，在这个黑暗的时间线中，我们的工作并不存在。
- en: 'Let''s just check the differences between our two branches:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们只检查一下我们两个分支之间的差异：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There's our work!
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作在这里！
- en: Okay, so what if we want to merge our changes in from `develop`?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么如果我们想要从`develop`合并我们的更改怎么办？
- en: 'Git does that:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Git就是这样的：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Boom! We're still on our `master` branch, but the file is back.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 砰！我们仍然在我们的`master`分支上，但文件又回来了。
- en: 'Confusingly, though, if we now run `git status`, we see a new message:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑的是，如果我们现在运行`git status`，我们会看到一个新消息：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Thankfully, again, the message is nice and explanatory. Our local `master` branch
    is fine, but `upstream` isn't yet aware of our changes.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，再次，这条消息很好地解释了。我们的本地`master`分支很好，但`upstream`还不知道我们的更改。
- en: 'We can prove this with another `diff`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用另一个`diff`来证明这一点：
- en: '[PRE50]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s get our changes up there:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的更改上传：
- en: '[PRE51]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Magic.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 魔术。
- en: How it works...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Okay, so it's not really magic, just the product of some extremely brilliant
    coding.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这并不是真正的魔术，只是一些极其出色的编码的产物。
- en: When we branched from `master` (or any branch, for that matter), we created
    a point-in-time clone of that branch in our new one. We then made changes to the
    branch, doing things like testing configuration changes, or purposefully breaking
    things, without affecting the `master` branch (and our known good configuration).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从`master`（或者任何分支）分支出来时，我们在新分支中创建了一个时间点的克隆。然后我们对分支进行了更改，做了一些像测试配置更改或者故意破坏东西的事情，而不会影响`master`分支（和我们已知的良好配置）。
- en: That much is easy to understand (I think), but the problems begin when we want
    to make sure that our changes are pushed to the server.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点很容易理解（我认为），但当我们想要确保我们的更改被推送到服务器时，问题就开始了。
- en: We ran `git push`, which complained. This was because we didn't have a section
    in our .git/config file that told git where to push our local branch.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行了`git push`，但它抱怨了。这是因为我们的.git/config文件中没有一个告诉git在哪里推送我们的本地分支的部分。
- en: 'After we run the suggested command, our `.git/config` now looks like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行建议的命令之后，我们的`.git/config`现在看起来是这样的：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note the inclusion of a new branch definition.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意包含一个新分支定义。
- en: So, the push is done, and remote looks good.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，推送完成了，远程看起来很好。
- en: 'We then flipped back to `master` and performed our `git diff` command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们切换回`master`并执行我们的`git diff`命令：
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This should be reasonably self-explanatory, but we're performing a `diff` against
    the branch we're on right now, as well as the designated branch.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是相当容易理解的，但我们正在执行一个`diff`，对比我们现在所在的分支以及指定的分支。
- en: 'You could achieve the same thing with the following syntax, which is a bit
    more explicit:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下更明确的语法来实现相同的事情：
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Alternatively, you could even check the two branches you''re not on:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你甚至可以检查你不在的两个分支：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this way, we start to see how powerful Git can be as a development tool.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们开始看到Git作为开发工具的强大之处。
- en: It also neatly segues me into talking about `origin` branches.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 它也很好地引出了我谈论`origin`分支。
- en: 'In this section, we compared our local master with `origin/master`, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将我们的本地主分支与`origin/master`进行了比较，如下所示：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'From our `.git/config`, we learned that `origin` is the name of the remote
    repository, as far as Git is concerned:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的`.git/config`中，我们了解到`origin`是远程仓库的名称，就Git而言：
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Ergo, `origin/master` is the `master` branch on the `remote` server.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`origin/master`是`remote`服务器上的`master`分支。
- en: Our pushing to the `origin/master` (in the form of `git push`) keeps our code
    up to date.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推送到`origin/master`（以`git push`的形式）保持我们的代码是最新的。
- en: There's more...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You might be wondering why you'd bother pushing to a `remote` branch if you're
    just going to locally merge your branch into `master` anyway.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果你只是要在本地将你的分支合并到`master`，为什么还要推送到一个`remote`分支。
- en: 'The answer is simple: in most environments, you end up working with a lot of
    other people, and it''s a good development tool to be able to show what you''ve
    changed and what you''re working on. It also allows for things such as in-branch
    collaboration prior to merging, as anyone else is able to check out your branch
    for themselves.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 答案很简单：在大多数环境中，你最终会与许多其他人一起工作，能够展示你的改动和你正在处理的内容是一个很好的开发工具。它还允许诸如合并之前的分支协作之类的事情，因为任何其他人都可以检出你的分支进行查看。
- en: It's also true that most people don't just use a Git server in their infrastructure,
    instead looking for solutions such as Gogs and GitLab, which are Git servers with
    added functionality (like user management).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人并不只是在他们的基础设施中使用Git服务器，而是寻找诸如Gogs和GitLab之类的解决方案，这些是具有附加功能的Git服务器（如用户管理）。
- en: You could also be thinking about the server, and appreciating that in this section,
    it dragged along a bit, and wasn't really needed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也在考虑服务器，并且欣赏到在这一部分，它有点拖沓，实际上并不是真正需要的。
- en: 'Let''s have a quick look at the changes to our server by first creating and
    checking out a new branch:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看一下服务器的更改，首先创建并切换到一个新的分支：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: I used the shorthand for creating and checking out a branch here, adding `-b`
    to the `git checkout` command. There's hundreds of little tricks with Git, and
    people tend to have their favorites.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里使用了创建和检出分支的简写，将`-b`添加到`git checkout`命令中。Git有数百种小技巧，人们倾向于有自己的喜好。
- en: 'In this branch, let''s create a new file and `push` it `upstream`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个分支中，让我们创建一个新文件并将其`push`到`upstream`：
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next, flip on to `centos2` and nip into the repository:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，切换到`centos2`并进入仓库：
- en: '[PRE60]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'By running `ls`, you won''t see your actual files:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`ls`，你看不到你的实际文件：
- en: '[PRE61]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Instead, your files are in the `objects` directory, unreadable in their current
    format:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你的文件在`objects`目录中，以它们当前的格式是无法阅读的：
- en: '[PRE62]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can see our branches by their `ref`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过它们的`ref`看到我们的分支：
- en: '[PRE63]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You wouldn't work in the bare repository on the server—you'd clone and adjust
    your repository on another machine—but it's neat to look into the inner working
    occasionally.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您不会在服务器上的裸仓库中工作-您会在另一台机器上克隆并调整您的仓库，但偶尔查看内部工作情况也是很好的。
- en: See also
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You might want to install GitLab, or Gogs, or any of the other GUI-Git implementations
    so that you can play around with them. Personally, I find them to be reasonably
    intuitive, and teams of people tend to work better when they have a GUI to jointly
    despise than a series of console commands.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要安装GitLab、Gogs或其他GUI-Git实现，以便您可以尝试它们。就我个人而言，我发现它们相当直观，当团队有一个共同厌恶的GUI而不是一系列控制台命令时，他们往往能更好地工作。
- en: Installing Ansible
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Ansible
- en: In this section, we're going to look at one of the most popular configuration
    management tools in the form of Ansible. Like others (such as Chef, Puppet, and
    Salt), Ansible is a way of codifying your server configuration, by which I mean
    that any changes you want to make can be written into a file and applied to a
    server, or a collection of servers, programatically.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一种最受欢迎的配置管理工具，即Ansible。与其他工具（如Chef、Puppet和Salt）一样，Ansible是一种将服务器配置编码的方式，也就是说，您想要进行的任何更改都可以写入文件并以程序方式应用于服务器或一组服务器。
- en: The configuration files you put together can be saved to a central store, most
    commonly Git, and you can build things such as automatic pipelines around your
    configuration so that changes to that configuration are applied automatically.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您组合在一起的配置文件可以保存到一个中央存储库，最常见的是Git，您可以构建诸如自动管道之类的东西，围绕您的配置，以便对该配置的更改会自动应用。
- en: In the default scenario, your Ansible is run from a designated box in your infrastructure
    (usually a GitLab, Jenkins, or Ansible Tower install), or in smaller environments.
    It's not unusual to see engineers making changes from their own machines.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认情况下，您的Ansible是从基础架构中的指定框中运行的（通常是GitLab、Jenkins或Ansible Tower安装），或者在较小的环境中。工程师们经常在自己的机器上进行更改并不是不寻常的。
- en: Ansible isn't just for servers with modules that cover a wide range of scenarios,
    such as cloud provider configuration, switch configuration, and even certificate
    management.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible不仅适用于具有涵盖各种场景的模块的服务器，例如云提供商配置、交换机配置，甚至证书管理。
- en: We're going to run through some small Ansible commands on centos1, applying
    changes to centos2.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在centos1上运行一些小的Ansible命令，对centos2进行更改。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open a connection to your `centos1` machine, installing Ansible at the same
    time:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 打开到您的`centos1`机器的连接，同时安装Ansible：
- en: '[PRE64]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How to do it...
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we''re going to just check the version of Ansible that we''ve got installed:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将检查我们安装的Ansible的版本：
- en: '[PRE65]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is version `2.4.2.0`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是版本`2.4.2.0`。
- en: As with a lot of packages from the standard repositories, they tend to be a
    stable (older) version. If you wanted to, it's also possible to install `pip`
    (covered in [Chapter 11](373b755f-2d54-4d28-9259-cc91d1893cf6.xhtml), Web Servers,
    Databases, and Mail Servers) and use it to install a more recent version of Ansible.
    For now, we're going to stick with `2.4.2.0`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准存储库中的许多软件包一样，它们往往是稳定的（较旧的）版本。如果您愿意，也可以安装`pip`（在[第11章](373b755f-2d54-4d28-9259-cc91d1893cf6.xhtml)中介绍了Web服务器、数据库和邮件服务器），并使用它安装更近期的Ansible版本。现在，我们将坚持使用`2.4.2.0`。
- en: 'To test whether our connectivity is there, we can use a default Ansible module
    called `ping` (though this isn''t ICMP). You will be prompted for an `SSH password`
    (vagrant):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的连接是否存在，我们可以使用一个名为`ping`的默认Ansible模块（尽管这不是ICMP）。您将被提示输入`SSH密码`（vagrant）：
- en: '[PRE66]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We add the 'ANSIBLE_HOST_KEY_CHECKING=false' variable to ensure the remote machine's
    SSH host key get's accepted when we run our command. Subsequent commands shouldn't
    require this. In a production scenario, you should always confirm you trust the
    remote machine's key.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了'ANSIBLE_HOST_KEY_CHECKING=false'变量，以确保在运行命令时远程机器的SSH主机密钥被接受。后续命令不应该需要这个。在生产场景中，您应该始终确认您信任远程机器的密钥。
- en: Awesome! Our `centos2` box responded, and better still, our command tells us
    that this didn't result in a change to the remote machine (more on this later).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的`centos2`框做出了响应，更好的是，我们的命令告诉我们这并没有导致对远程机器的更改（稍后会详细介绍）。
- en: Next, let's try installing something using a different module. We want to install
    a package, but we don't know how.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试使用不同的模块安装一些东西。我们想要安装一个软件包，但我们不知道如何操作。
- en: 'For this, you could either go to the Ansible website ([https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html))
    and search for `package`, or you could use `ansible-doc`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您可以访问Ansible网站（[https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html)）并搜索`package`，或者您可以使用`ansible-doc`：
- en: '[PRE67]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When run, you will be dropped into a pager, along with a list of all the Ansible
    modules available. Run a search (typing the `/` character, followed by the search
    string) for `package` and keep going until you find a module of that name:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时，您将进入一个分页器，以及所有可用Ansible模块的列表。运行搜索（输入`/`字符，然后输入搜索字符串）以搜索`package`，并继续直到找到该名称的模块：
- en: '![](img/4825c804-0d1f-4b06-b2c1-392d931370a4.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4825c804-0d1f-4b06-b2c1-392d931370a4.png)'
- en: There's no guarantee that a module exists for the functionality you want, but
    there's also a good chance it does. Search for keywords that relate to what you're
    trying to do, and, nine times out of ten, you might be pleasantly surprised.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 不能保证有一个模块存在于您想要的功能中，但也有很大的可能性。搜索与您尝试执行的操作相关的关键字，十有八九您可能会感到惊喜。
- en: Assuming you've found out that the package module is called `package`, you can
    quit out of this pager.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经发现了称为`package`的软件包模块，您可以退出此分页器。
- en: 'Now, let''s see what the syntax is for `package`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`package`的语法是什么：
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This looks good, and what it tells us is that the requirements are just what
    we need in order to `name` the package, and dictate what state it should be in.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，它告诉我们的是要`name`软件包的要求正是我们需要的，以及它应该处于什么状态。
- en: 'Excellent! We can use this knowledge:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们可以利用这个知识：
- en: '[PRE69]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We could have also included `-K` if the sudo action required a password on the
    remote machine, ours didn't.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果远程机器上的sudo操作需要密码，我们也可以包括`-K`，我们的没有。
- en: Cool! So we managed to use Ansible to install the `zip` package on our remote
    machine (I'll leave it up to the reader to guess what this package does). Let's
    run that command again—what's going to happen? Will it reinstall the package?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！所以我们成功使用Ansible在我们的远程机器上安装了`zip`软件包（我会让读者猜测这个软件包的作用）。让我们再次运行这个命令——会发生什么？它会重新安装软件包吗？
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As it turns out, no, Ansible won't reinstall the package. This is one of the
    fundamental ideals, if you will, of Ansible. Jobs run against a remote host should
    be idempotent, that is, they shouldn't make any changes when they don't need to.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，不，Ansible不会重新安装软件包。这是Ansible的一个基本理念，远程主机上运行的作业应该是幂等的，也就是说，当不需要时它们不应该做任何更改。
- en: It is good practice, when writing Ansible, to ensure that the code you write
    is idempotent, rather than having it making a change each time it's run. The code
    won't be idempotent if changes are constantly made, and you can't ever guarantee
    the state of your systems.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Ansible时，确保你编写的代码是幂等的，而不是每次运行都进行更改，这是一个很好的实践。如果不断进行更改，代码就不会是幂等的，你无法保证系统的状态。
- en: Sometimes, especially when executing straight commands on a remote system, idempotence
    will have to be thought about carefully, and occasionally manually constructed
    into the logic of your Ansible runs, though this is a more advanced discipline.
    Even I occasionally defer to far smarter friends on the subject.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，特别是在远程系统上执行直接命令时，幂等性必须仔细考虑，有时必须手动构建到你的Ansible运行逻辑中，尽管这是一门更高级的学科。即使我偶尔也会在这个问题上求助于更聪明的朋友。
- en: 'For the sake of completeness, let''s do one last thing:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，让我们做最后一件事：
- en: '[PRE71]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Can you spot the difference between this command and our last?
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现这个命令和我们上一个命令之间的区别吗？
- en: It's yum!
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 是yum！
- en: Specifically, what we've now done is used the Ansible `yum` module in place
    of `package`, meaning that we've not made it so that our command will only work
    on YUM-based systems. This highlights that there's more than one way to accomplish
    the same goals, and we'll talk about why you might want to use either module soon.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们现在所做的是使用Ansible的`yum`模块代替`package`，这意味着我们已经使得我们的命令只能在基于YUM的系统上工作。这突显了实现相同目标的方法不止一种，我们很快会讨论为什么你可能想使用其中一个模块。
- en: How it works...
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Now that we''ve had a quick look at how Ansible can be used to run jobs on
    remote machines, let''s break down what we did, starting with the `ping` module:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经快速看了一下Ansible如何用于在远程机器上运行作业，让我们来分解一下我们做了什么，从`ping`模块开始：
- en: '[PRE72]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s go over those arguments in order:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按顺序讨论这些参数：
- en: '[PRE73]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here, `-k` means that Ansible will know to prompt us for a password, with which
    we''re going to connect to the remote machine (our Vagrant user''s SSH password):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`-k`表示Ansible将知道提示我们输入密码，我们将用它连接到远程机器（我们Vagrant用户的SSH密码）：
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Here, we''re telling Ansible that we want to use the `ping` module:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉Ansible我们要使用`ping`模块：
- en: '[PRE75]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, we're building an inventory, though admittedly an inventory of one machine.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在构建一个清单，尽管可以承认只有一个机器的清单。
- en: 'Ansible needs to know the list of hosts it can work with—its inventory—but
    here, we only have one, so we''re using that (being sure to end with a comma):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible需要知道它可以使用的主机列表——它的清单——但在这里，我们只有一个，所以我们使用它（确保以逗号结尾）：
- en: '[PRE76]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Finally, we end with the IP of the host we're trying to hit, which, somewhat
    counter-intuitively, we have to repeat.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们以我们要访问的主机的IP结束，有点反直觉的是，我们必须重复。
- en: One thing we are missing here is the `-u` flag, which we would use if we wanted
    to `SSH` to the remote host as a user that wasn't `vagrant`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们缺少的一件事是`-u`标志，如果我们想要作为一个不是`vagrant`的用户`SSH`到远程主机，我们会使用它。
- en: 'Since we''re here, we''re going to also take a look at our second `ansible-doc`
    command:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在这里，我们也要看一下我们的第二个`ansible-doc`命令：
- en: '[PRE77]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, we wanted to see a snippet of the code that we could write for use with
    the `package` module. This is extremely useful on a server in a pinch, or in an
    exam situation where you may not have access to the wider internet.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想要看到我们可以为`package`模块编写的代码片段。这在服务器上很有用，或者在考试情况下非常有用，你可能无法访问更广泛的互联网。
- en: 'Lastly, let''s break down our final command (though the same principles can
    be applied to the `package` example):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们分解一下我们的最后一个命令（尽管相同的原则可以应用到`package`示例中）：
- en: '[PRE78]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here, there are a couple of differences:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有一些区别：
- en: '[PRE79]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We use `-b` here because we're making a change that requires us to "become"
    on the remote machine. This means running a command with privilege escalation
    (becoming root).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`-b`，因为我们正在进行需要我们在远程机器上“变成”（become）的更改。这意味着以特权升级（变成root）运行命令。
- en: '[PRE80]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we've added `-a` to our list of arguments, specifically because the `yum`
    module requires arguments of its own, which we then place inside quotes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在我们的参数列表中添加了`-a`，具体是因为`yum`模块需要自己的参数，然后我们将这些参数放在引号内。
- en: These arguments can get quite long based on the module you're using, but here
    it's a relatively small amount.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你使用的模块，这些参数可能会变得很长，但在这里它的数量相对较少。
- en: We used `yum` the second time, specifically to highlight that while the same
    goals were achieved (the installation of the `zip` package), we have the option
    to tie our command to particular distributions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次我们使用了`yum`，特别是为了突出虽然实现了相同的目标（安装`zip`软件包），我们有选择将我们的命令与特定的发行版绑定。
- en: 'The reason for this is simple when you look at the list of arguments available
    to the `package` module:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因很简单，当你看一下`package`模块可用的参数列表时就明白了：
- en: '`name`'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`'
- en: '`state`'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`'
- en: '`use`'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`use`'
- en: 'You can also look at those available to the `yum` module to help with this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以查看`yum`模块可用的内容，以帮助解决这个问题：
- en: '`allow_downgrade`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allow_downgrade`'
- en: '`conf_file`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conf_file`'
- en: '`disable_gpg_check`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disable_gpg_check`'
- en: '`disablerepo`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`disablerepo`'
- en: '`enablerepo`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enablerepo`'
- en: '`exclude`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exclude`'
- en: '`installroot`'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`installroot`'
- en: '`list`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`'
- en: '`name`'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`'
- en: '`security`'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security`'
- en: '`skip_broken`'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip_broken`'
- en: '`state`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`'
- en: '`update_cache`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_cache`'
- en: '`validate_certs`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validate_certs`'
- en: Hopefully, you can see how the `yum` module could be used to craft much more
    specific and detailed instructions for Ansible to follow.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您能看到`yum`模块如何被用来为Ansible制定更具体和详细的指令。
- en: In the real world, I have seen engineers write code that attempts to satisfy
    all use cases with one role, that is, a role can be applied and accomplish the
    same thing on a Debian, CentOS, or Alpine system. This is perhaps a noble goal,
    but it usually results in immense frustration on the part of the engineer, or
    the engineer who comes next, due to inflexibility. Generally, I have found it
    easier to simply use the distro-specific modules, and get Ansible to check what
    sort of distro it's running on prior to choosing which commands to execute or,
    better yet, just use one distribution in your infrastructure instead of a mixture.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，我看到工程师编写代码，试图用一个角色满足所有用例，也就是说，一个角色可以在Debian、CentOS或Alpine系统上应用并完成相同的事情。这也许是一个崇高的目标，但通常会导致工程师或接下来的工程师因为不灵活而感到极度沮丧。通常情况下，我发现更容易的方法是简单地使用特定于发行版的模块，并让Ansible在选择要执行的命令之前检查它正在运行的发行版的类型，或者更好的是，只在您的基础设施中使用一个发行版，而不是混合使用。
- en: There's more...
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There's a couple more small things to be aware of.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些小事情需要注意。
- en: The raw module
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始模块
- en: In this case, centos2 already had Python installed (which Ansible needs in order
    to run modules on remote machines). However, if it hadn't, you would have had
    to install it on the machine first, or use Ansible's built-in `raw` module prior
    to any others.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，centos2已经安装了Python（Ansible需要在远程机器上运行模块）。但是，如果没有安装，您将需要首先在机器上安装它，或者在任何其他模块之前使用Ansible的内置`raw`模块。
- en: 'When you use `raw`, you''re actually running commands directly on the remote
    machine. This is most commonly seen with a line similar to the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`raw`时，实际上是直接在远程机器上运行命令。这通常是通过类似以下的行来看到的：
- en: '[PRE81]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note that the remote machine simply responded with `SUCCESS` and the resulting
    command.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，远程机器只是简单地回应了`SUCCESS`和结果命令。
- en: 'We would use this to install `python`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个来安装`python`：
- en: '[PRE82]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: It's not nicely formatted, but as we now have `python` on the `remote` machine,
    we will be able to use proper Ansible modules instead of relying on simple `SSH`
    executions.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 它的格式不太好，但是现在我们在`remote`机器上有了`python`，我们将能够使用适当的Ansible模块，而不是依赖简单的`SSH`执行。
- en: The shell and command modules
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: shell和command模块
- en: Like `raw`, you can pass native commands to a remote machine using Ansible (in
    fact, you could translate an entire bash script into an Ansible role remarkably
    easily), though usually this type of functionality is reserved for instances where
    you absolutely can't achieve what you're trying to do with dedicated Ansible modules.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 与`raw`一样，您可以使用Ansible将本机命令传递给远程机器（实际上，您可以非常容易地将整个bash脚本转换为Ansible角色），尽管通常这种功能是为您绝对无法使用专用Ansible模块来实现的情况保留的。
- en: These two do, however, require Python to be on the remote machine.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这两个确实需要Python在远程机器上。
- en: 'First, let''s look at the `shell` module:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`shell`模块：
- en: '[PRE83]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note that I'm basically running a small one-liner within my Ansible command.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我基本上是在我的Ansible命令中运行一个小的一行命令。
- en: 'Next, let''s use the `command` module:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用`command`模块：
- en: '[PRE84]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Ah... this failed.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 啊...这失败了。
- en: 'This is because `command` doesn''t explicitly run a shell (such as Bash), so
    when we tried to use a bashism in the form of >, it failed. The `command` module
    is only really good for short commands:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`command`并没有显式地运行一个shell（比如Bash），所以当我们尝试使用bashism形式的>时，它失败了。`command`模块只对短命令真正有效：
- en: '[PRE85]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: See also
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Here, we used an `SSH` passphrase to run remote commands on our box, but this
    is not usually done (especially in automated environments). Generally, SSH keys
    are used, with privileges being carefully controlled.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`SSH`密码来在我们的盒子上运行远程命令，但这通常不会这样做（特别是在自动化环境中）。通常情况下，使用SSH密钥，并且权限要得到仔细控制。
- en: Using Ansible to install Java from a role
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible从角色安装Java
- en: Ansible is great for doing what we just did, running easy-to-understand commands
    by using modules on remote machines.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible非常适合做我们刚刚做的事情，通过在远程机器上使用模块运行易于理解的命令。
- en: But that isn't its bread and butter. Instead, Ansible really shines when it
    comes to running a whole slew of commands against a remote machine, and making
    vast configuration changes in seconds.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 但这不是它的核心。相反，当需要对远程机器运行一系列命令并在几秒钟内进行大规模配置更改时，Ansible真正发挥作用。
- en: In this section, we're going to write a small Ansible Playbook to import an
    Ansible Role from a public repository, and apply that role to our centos2 machine.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个小的Ansible Playbook来从公共存储库导入一个Ansible角色，并将该角色应用到我们的centos2机器上。
- en: Hang on to your hats!
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 抓住你的帽子！
- en: Getting ready
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this section, we are again using our `Vagrantfile` and two CentOS VMs.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，我们再次使用我们的`Vagrantfile`和两个CentOS虚拟机。
- en: It would be a good idea to complete the previous section before working on this
    one.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理这一部分之前，最好先完成上一部分。
- en: '`SSH` to your `centos1` machine:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`SSH`到您的`centos1`机器：'
- en: '[PRE86]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: How to do it...
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by creating a directory in which we''re going to work and dropping
    into it:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个目录，在这个目录中我们将要工作并进入其中：
- en: '[PRE87]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now, we said we''re going to use a public Ansible role for this job, so let''s
    run a search for one:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们说我们要使用一个公共的Ansible角色来完成这项工作，所以让我们搜索一个：
- en: '[PRE88]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You could also use the [https://galaxy.ansible.com/](https://galaxy.ansible.com/) website:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用[https://galaxy.ansible.com/](https://galaxy.ansible.com/)网站：
- en: '![](img/bfcbda58-16c4-4465-bae2-f7b45a14d722.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfcbda58-16c4-4465-bae2-f7b45a14d722.png)'
- en: Searching for java on Ansible Galaxy
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ansible Galaxy上搜索java
- en: I actually tend to use the website more than the command line, simply because
    it gives you a good overview of role popularity at a glance. I already knew that
    the one written by `geerlingguy` was very popular, so I chose to explicitly include
    his name in the search.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我实际上更倾向于使用网站而不是命令行，因为它可以让您一目了然地了解角色的流行程度。我已经知道`geerlingguy`编写的角色非常受欢迎，所以我选择在搜索中明确包含他的名字。
- en: 'Now that we know what role we want to use, let''s download it:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们想要使用哪个角色，让我们下载它：
- en: '[PRE89]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Awesome! We have our role.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们有了我们的角色。
- en: Now how do we apply it?
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们如何应用它？
- en: With a Playbook, of course!
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当然是用Playbook！
- en: 'Run the following on your system:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的系统上运行以下命令：
- en: '[PRE90]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, run our `playbook` against centos2:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对centos2运行我们的`playbook`：
- en: '[PRE91]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'You should see a stream of information run across your screen, as the role
    we downloaded earlier is applied to the remote machine:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的屏幕上出现一系列信息时，我们之前下载的角色将被应用到远程机器上：
- en: '![](img/5e5e3019-191f-40bc-8e21-09d5b32c2b29.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5e5e3019-191f-40bc-8e21-09d5b32c2b29.png)'
- en: Note `ok=6` and `changed=1` at the bottom of the run. If you now run the playbook
    a second time, you should get `changed=0` since the role is idempotent.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意运行底部的`ok=6`和`changed=1`。如果您现在再次运行playbook，您应该会得到`changed=0`，因为该角色是幂等的。
- en: And there you have it! With only three commands (realistically), you've got
    a Java installation on your remote machine.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！只用三个命令（实际上），您就可以在远程机器上安装Java。
- en: How it works...
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Running through what we did in this section, command by command, we'll break
    down what happened.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 通过逐条命令运行我们在本节中所做的事情，我们将分解发生的事情。
- en: '[PRE92]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Initially, we needed to know whether someone had already written an Ansible
    role to install Java on a box. As it happens, we were able to search for Java
    for Linux while passing in an author's name, resulting in seven roles being found.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们需要知道是否有人已经编写了一个在服务器上安装Java的Ansible角色。事实上，我们能够搜索到Linux的Java，同时传入作者的名字，结果找到了七个角色。
- en: I have a friend who likes to write his own Ansible for a job, but I've always
    been of the opinion that if a solution already exists (and it's suitable), there's
    no harm in adopting work that others have written, providing that its license
    allows you to do so, and your company is fine with it. The open source community
    is good, and if someone's already invented the wheel, try putting down the hammer
    and chisel.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个朋友喜欢为工作编写自己的Ansible，但我一直认为，如果解决方案已经存在（而且合适），采用其他人编写的工作是没有害处的，只要其许可证允许您这样做，并且您的公司也没有意见。开源社区很好，如果有人已经发明了轮子，那么尝试放下锤子和凿子。
- en: '[PRE93]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Once we knew of the role we wanted, we ran the `install` command. Specifically,
    we had to use `sudo` for this, as the role in question is pulled onto your box
    and placed in the shared `/etc/ansible/roles/` directory, which our user doesn't
    have write access to.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道我们想要的角色，我们就运行了`install`命令。具体来说，我们必须使用`sudo`，因为所涉及的角色被拉到您的服务器上，并放在共享的`/etc/ansible/roles/`目录中，我们的用户没有写入权限。
- en: You can see this role (and copy or tweak it required) by looking in the directory.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在目录中看到这个角色（并复制或调整它）。
- en: '[PRE94]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The actual role starts in `tasks/main.yml`, so it's a good idea to take a look
    in there, too.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的角色从`tasks/main.yml`开始，所以最好也看一下那里。
- en: '[PRE95]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Next, we created a small `playbook.yml` file to dictate which role we should
    install where.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个小的`playbook.yml`文件，来指定我们应该在哪里安装哪个角色。
- en: '[PRE96]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Of note here is the fact that we listed the `hosts` as `all` rather than a specific
    hostname or IP, and the roles are in the form of a YAML list.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这里值得注意的是，我们将`hosts`列为`all`而不是特定的主机名或IP，角色以YAML列表的形式存在。
- en: You can make a playbook into quite a complex beast by adding different variables,
    different rules on where to apply different roles, and a variety of other options.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加不同的变量，不同的规则以及各种其他选项，您可以将playbook变成一个相当复杂的东西。
- en: '[PRE97]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Finally, we used `ansible-playbook` to actually apply the contents of `playbook.yml`
    to `centos2`. We used the common options `-k`, `-b`, and `-i` to build up our
    command.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`ansible-playbook`将`playbook.yml`的内容实际应用到`centos2`。我们使用了常见的选项`-k`，`-b`和`-i`来构建我们的命令。
- en: This now goes to `centos2`, and executes every line of the `geerlingguy.java`
    role.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它转到`centos2`，并执行`geerlingguy.java`角色的每一行。
- en: There's more...
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It might seem like overkill to put together a playbook for the sake of one role,
    but the beauty of playbooks is that they're not bound to one role. You can include
    as many as you want in the list within the `playbook.yml` file, and, as long as
    they don't conflict with each other, you should have a very smooth Ansible experience.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 也许为了一个角色而组合一个playbook似乎有点多余，但playbook的美妙之处在于它们不局限于一个角色。您可以在`playbook.yml`文件中包含尽可能多的角色，只要它们不相互冲突，您应该会有一个非常顺利的Ansible体验。
- en: 'Take a look at this `playbook.yml` file instead:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '[PRE98]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We also used `galaxy` in a very specific way, using `ansible-galaxy` to install
    the role from the internet first. You could also include a `requirements.yml`
    file with your code, which `ansible-galaxy` is able to read so that it might download
    any listed roles it finds, prior to attempting to apply them to a remote box:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还以非常特定的方式使用了`galaxy`，使用`ansible-galaxy`首先从互联网安装角色。您还可以在您的代码中包含一个`requirements.yml`文件，`ansible-galaxy`能够读取它，以便在尝试将它们应用到远程服务器之前，它可能会下载找到的任何列出的角色：
- en: '[PRE99]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Then, prior to your `playbook` run, you would first run `galaxy`:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在运行`playbook`之前，您首先会运行`galaxy`：
- en: '[PRE100]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This means that when you do run `ansible-playbook`, you''ve got your roles
    ready:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当您运行`ansible-playbook`时，您的角色已经准备好了：
- en: '[PRE101]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: See also
  id: totrans-435
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: As I mentioned in the *How to do it...* section, I was already aware of `geerlingguy.java` because
    the author (`geerlingguy`) is prolific in the Ansible he writes. There's a good
    chance you'll see the name again, regardless of the institution you end up working
    for.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在*如何做...*部分中提到的，我已经知道`geerlingguy.java`，因为作者（`geerlingguy`）在他写的Ansible中非常活跃。无论您最终为哪个机构工作，您都很有可能再次看到这个名字。
- en: Storing our Ansible configuration in Git
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的Ansible配置存储在Git中
- en: Let's combine what we've learned so far and store the Ansible configuration
    we wrote in the last section on our Git server.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们结合到目前为止学到的知识，并将我们在上一节中编写的Ansible配置存储在我们的Git服务器上。
- en: Getting ready
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this section, we're going to primarily use `centos1`, but we're going to
    upload our configuration to `centos2`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将主要使用`centos1`，但我们将上传我们的配置到`centos2`。
- en: 'SSH to both of your virtual machines:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: SSH到你的两台虚拟机：
- en: '[PRE103]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'On centos2, create another bare `Git repository` from your home directory:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在centos2上，从你的主目录创建另一个空的`Git存储库`：
- en: '[PRE104]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: How to do it...
  id: totrans-445
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'On `centos1`, switch to your `ansible-example` directory:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在`centos1`上，切换到你的`ansible-example`目录：
- en: '[PRE105]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Next, initialize the directory to be a `Git repository`:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，初始化目录为`Git存储库`：
- en: '[PRE106]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Add the files we had in the directory already, and `commit` them to the repository:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们已经在目录中的文件，并将它们`提交`到存储库：
- en: '[PRE107]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Once done, your local repository is good, but we still want to `push` them to
    a remote destination.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你的本地存储库就可以了，但我们仍然希望将它们`推送`到远程目的地。
- en: 'Add your remote with the alias `origin`:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 使用别名`origin`添加你的远程：
- en: '[PRE108]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Finally, we can `push` our changes to the `remote` repository:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将我们的更改`推送`到`远程`存储库：
- en: '[PRE109]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: How it works...
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'All we''ve done here is combine what we''ve done in the last few sections:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是将我们在最近几节中所做的结合起来：
- en: We created a Git repository on the centos2 machine
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在centos2机器上创建了一个Git存储库
- en: We took the Ansible configuration we'd written and initialized a repository
    around it
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们拿出了我们编写的Ansible配置，并在其周围初始化了一个存储库
- en: We set our `remote` destination to be centos2
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将我们的`远程`目的地设置为centos2
- en: We pushed our configuration to the remote machine
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将我们的配置推送到远程机器
- en: Now, even if centos1 were to go away, you'll have a copy of your configuration
    on centos2, and others can clone that information down, make changes, and push
    back up.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使centos1消失了，你也会在centos2上有一份你的配置副本，其他人可以克隆这些信息，进行更改，然后推送回来。
- en: There's a reason you traditionally see a  "build server" of some description
    or other in the land of system administration. This is because you can claim it
    as a focal point for distribution configuration and managing your infrastructure.
    It's easy to see how out of sync you could get were five people in a team to work
    on one project at the same time, each in a different branch, with their own changes.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上在系统管理领域，你会看到一个叫做“构建服务器”的东西。这是因为你可以将它作为分发配置和管理基础架构的焦点。很容易看出，如果一个团队中的五个人同时在一个项目上工作，每个人都在不同的分支上进行自己的更改，你可能会变得不同步。
- en: Exploring options for IaC
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索IaC的选项
- en: In this section, we'll be downloading some binaries from Hashicorp's site, and
    also using our `centos1` VM.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将从Hashicorp的网站下载一些二进制文件，并使用我们的`centos1`虚拟机。
- en: Completely automating your infrastructure is beyond the scope of this book,
    but there's no reason we can't talk about a couple of the most popular tools on
    the market at the moment.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 完全自动化你的基础架构超出了本书的范围，但我们可以谈谈目前市场上一些最流行的工具。
- en: Both Terraform and Packer are made by Hashicorp, who have a reputation for making
    life easier for system administrators, or never releasing a version 1.0.0 of their
    products, depending on who you ask.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform和Packer都是由Hashicorp制作的，他们以为系统管理员们简化生活而闻名，或者根据你问的人而定，从来没有发布过1.0.0版本的产品。
- en: Hashicorp are also the people who maintain Vagrant, though they did once try
    to replace it with a program called Otto—we don't talk about Otto.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: Hashicorp也是维护Vagrant的人，尽管他们曾经试图用一个叫做Otto的程序来替换它——我们不谈论Otto。
- en: Terraform is a way of writing your infrastructure as declarative code, with
    a wide range of providers to choose from, including AWS, Azure, Scaleway, Digital
    Ocean, and more.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform是一种以声明性代码编写基础架构的方式，有多种提供商可供选择，包括AWS、Azure、Scaleway、Digital Ocean等。
- en: Packer, on the other hand, is a way of building your base image for your provider
    of choice, baking all the software you think you're going to need globally into
    a default image, that you can then expand on with programs such as Chef, Ansible,
    or Puppet.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Packer是一种构建你选择的提供商的基础镜像的方式，将你认为全局需要的所有软件都嵌入到默认镜像中，然后你可以用Chef、Ansible或Puppet等程序进行扩展。
- en: If you've ever clicked your way through a provider's online portal for provisioning
    VMs, object storage, or networking, you probably already appreciate why Terraform
    and Packer sound amazing.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经通过提供商的在线门户为VM、对象存储或网络进行配置，你可能已经意识到为什么Terraform和Packer听起来很棒。
- en: Neither of these tools were the first to do what they intended to do, but they
    do them well, and, at the time of writing, they have a vast, vast chunk of the
    collective mind-share.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个工具都不是第一个做它们打算做的事情的工具，但它们做得很好，并且在撰写本文时，它们在集体意识中占据了很大的份额。
- en: Getting ready
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'SSH to `centos1` and download both Terraform and Packer:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: SSH到`centos1`并下载Terraform和Packer：
- en: '[PRE110]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now, we need to unzip these binaries, so first install the appropriate tool.
    Then, unzip both of our applications and move them to `/usr/local/bin/`:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要解压这些二进制文件，首先安装适当的工具。然后，解压我们的两个应用程序并将它们移动到`/usr/local/bin/`：
- en: '[PRE111]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Terraform and Packer evolve so quickly that remarkably few repositories will
    actually have them. The programs also complain if you use a version that's out
    of date, displaying a large banner every time you use them. The only repository
    I've come across that seems to consistently package Terraform is the FreeBSD default
    repo (and even that's out of date).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform和Packer的发展速度如此之快，以至于实际上很少有存储库会有它们。这些程序还会抱怨如果你使用的版本过时，每次使用它们时都会显示一个大横幅。我遇到的唯一一个似乎一直打包Terraform的存储库是FreeBSD默认存储库（即使那个也已经过时）。
- en: 'We''re also going to be using `docker` for this, so if you haven''t got it
    installed on your virtual machine, run the following (this was covered in more
    detail earlier in this book):'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在这里使用`docker`，所以如果你的虚拟机上还没有安装它，运行以下命令（这在本书的前面部分有更详细的介绍）：
- en: '[PRE112]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: How to do it...
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: We'll go over our two programs in turn.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次介绍我们的两个程序。
- en: Terraform
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform
- en: Starting at the top, we're going to use Terraform to create a small Docker deployment
    locally. This is the easiest to show as we have all of the tools we need on our
    VM, and it doesn't mean I have to tell you to go out and start a free trial on
    some cloud provider.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始，我们将使用Terraform在本地创建一个小的Docker部署。这是最容易展示的，因为我们在我们的VM上有所有我们需要的工具，这并不意味着我必须告诉您去开始某个云提供商的免费试用。
- en: 'Start by creating a directory for us to work in:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个供我们工作的目录：
- en: '[PRE113]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next, shove the following configuration into a `main.tf` file:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下配置放入`main.tf`文件中：
- en: '[PRE114]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Then, initialize Terraform:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，初始化Terraform：
- en: '[PRE115]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: We're using `sudo` here because our user isn't in the group that can control
    Docker and, as a result, Terraform won't be able to talk to Docker either when
    invoked by us.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`sudo`，因为我们的用户不在可以控制Docker的组中，因此当我们调用时，Terraform也无法与Docker通信。
- en: Once initialized, you should now be able to apply our configuration.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，现在应该能够应用我们的配置。
- en: 'Look at `docker ps` first:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看一下`docker ps`：
- en: '[PRE116]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Then, run `terraform apply`:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行`terraform apply`：
- en: '[PRE117]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'You should see a breakdown of the actions about to be taken, and a prompt to
    get you to type `yes`. Do so and hit *Enter*:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到即将执行的操作的详细信息，并提示您输入“yes”。这样做并按*Enter*：
- en: '[PRE118]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Excellent!
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！
- en: 'Run `docker ps` again to find out what you''ve just created:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`docker ps`，找出您刚刚创建的内容：
- en: '[PRE119]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now, let''s `destroy` our container, again using Terraform:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次使用Terraform`destroy`我们的容器：
- en: '[PRE120]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Once again, we're prompted to type `yes` in the field provided. Do so and hit
    *Enter:*
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提示我们在提供的字段中输入“yes”。这样做并按*Enter*：
- en: '[PRE121]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Boom! Our container is gone.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我们的容器消失了。
- en: Packer
  id: totrans-508
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Packer
- en: Say we don't want to just use the container from Docker Hub. Say we want to
    tweak it slightly before we deploy it using Terraform.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不只是想使用Docker Hub上的容器。假设我们想在使用Terraform部署之前稍微调整一下它。
- en: This is where Packer comes in, which is a very versatile tool. Packer has builders
    for AWS, Scaleway, LXC, VirtualBox, QEMU, and others, but the one we're interested
    in is Docker.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Packer的用武之地，它是一个非常多才多艺的工具。Packer有适用于AWS、Scaleway、LXC、VirtualBox、QEMU和其他平台的构建器，但我们感兴趣的是Docker。
- en: 'Head back into your home directory and create an `example-packer` directory:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到您的主目录并创建一个`example-packer`目录：
- en: '[PRE122]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Next, output the following to a file:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下内容输出到文件中：
- en: '[PRE123]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Once done, you should be able to run `packer` to `build` and tweak your container:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您应该能够运行`packer`来`build`和调整您的容器：
- en: '[PRE124]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Great! We''ve now got an image we can use elsewhere:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在有了一个可以在其他地方使用的镜像：
- en: '[PRE125]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: How it works...
  id: totrans-519
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Let's break this down a bit, starting with Terraform.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来详细了解一下，从Terraform开始。
- en: 'In this section, we defined what we wanted our infrastructure to look like
    by writing the configuration to a `main.tf` file:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们通过编写配置到`main.tf`文件中定义了我们希望我们的基础设施看起来像什么：
- en: '[PRE126]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Specifically, what we''re doing here is giving Terraform its provider and the
    necessary information to connect with said provider (in this case, a Unix socket):'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们在这里做的是为Terraform提供其提供程序和连接所需信息（在本例中是Unix套接字）：
- en: '[PRE127]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'We''re then informing Terraform of the image we want to use as the base of
    our container:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通知Terraform我们想要用作容器基础的镜像：
- en: '[PRE128]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Finally, we''re saying that the container should be called `nginx-example`
    and that it should use the image that we defined previously (note the use of a
    referencing variable to the preceding block):'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们说容器应该被称为`nginx-example`，并且应该使用我们之前定义的镜像（注意引用变量到前面的块）：
- en: '[PRE129]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Once we saved it, we ran a command to initialize the directory for Terraform
    use:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，我们运行了一个命令来初始化Terraform使用的目录：
- en: '[PRE130]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'This downloads the provider (docker) and sets up the directory for us to use
    it. We then applied our configuration:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载提供程序（docker）并为我们设置目录以供使用。然后我们应用了我们的配置：
- en: '[PRE131]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Terraform looks for any files ending in `.tf` within the directory it's invoked
    from.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform在调用它的目录中寻找任何以`.tf`结尾的文件。
- en: 'Afterward, we destroyed our setup:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们销毁了我们的设置：
- en: '[PRE132]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Your directory will end up looking something like this:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 您的目录最终会看起来像这样：
- en: '[PRE133]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Note the `state` file. This is important as it contains the known state of the
    infrastructure you've provisioned. Looking inside, you'll see a JSON-like syntax,
    though this can change. The Terraform state file shouldn't be altered by hand.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`state`文件。这很重要，因为它包含了您已经配置的基础设施的已知状态。在里面看到一个类似JSON的语法，尽管这可能会改变。Terraform状态文件不应该手动更改。
- en: I have horror stories revolving around having to manually recover the state
    of infrastructure, as I'm sure many others do too, and believe me when I tell
    you that losing a state file is not fun, nor is it going to be a quick recovery
    process. Needless to say, it's a good idea to keep this file backed up.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我有很多关于手动恢复基础设施状态的恐怖故事，我相信其他人也有，相信我，当我告诉你丢失状态文件既不好玩，也不会是一个快速的恢复过程。不用说，保留这个文件的备份是个好主意。
- en: It's also worth noting that you can store the Terraform state file in a remote
    location. This can be configured to "lock" when in use (to avoid conflicting changes
    from two users trying to access the state file at once.) It also means the state
    file doesn't live on your local machine, or a Jenkins slave, making distributed
    building easier.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，您也可以将Terraform状态文件存储在远程位置。这可以配置为在使用时“锁定”（以避免两个用户尝试同时访问状态文件时发生冲突的更改）。这也意味着状态文件不存储在您的本地计算机或Jenkins从属机上，使得分布式构建更容易。
- en: The preceding `terraform` directory contains the actual plugin that we downloaded
    when we initialized the repository.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`terraform`目录包含了我们在初始化存储库时下载的实际插件。
- en: On to Packer!
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是Packer！
- en: 'With Packer, things are a little different. First, we set up this configuration
    file:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Packer，情况有些不同。首先，我们设置了这个配置文件：
- en: '[PRE134]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: It's a very vanilla example, but it serves its purpose.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个非常基本的例子，但它达到了它的目的。
- en: The first thing you might notice is that it's JSON formatted, rather than using
    HCL (as Terraform does for its configuration). Secondly, you might note that while
    we have a builder configured (docker), we also have a provisioner (shell).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到的第一件事是它是JSON格式化的，而不是使用HCL（Terraform用于其配置）。其次，您可能会注意到，虽然我们配置了构建器（docker），但我们还配置了一个配置程序（shell）。
- en: '[PRE135]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Starting with the builder, you can see that we're using `docker` as the type
    so that Packer knows what builder this is, and we're also using the `nginx` image
    we used previously as the base.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 从构建器开始，您可以看到我们正在使用`docker`作为类型，以便Packer知道这是什么构建器，并且我们还使用了之前使用的`nginx`图像作为基础。
- en: 'We apply some metadata changes in the form of a label and expose a different
    port to the default in the image (80). We can see these in the resulting Docker
    image:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用了一些元数据更改，以标签的形式暴露了一个不同于图像（80）中默认端口的端口。我们可以在生成的Docker图像中看到这些：
- en: '[PRE136]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Next, we proceed to the meat of the Packer job, the provisioning step:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们继续进行Packer工作的核心部分，即配置步骤：
- en: '[PRE137]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: This is the part in which you would make changes to the container such as here,
    where we used `shell` to `echo` a poignant statement to the screen, and then aggressively
    removed the container's sole purpose in protest.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您可以对容器进行更改的部分，比如在这里，我们使用`shell`向屏幕`echo`了一条意味深长的声明，然后激烈地删除了容器的唯一目的以示抗议。
- en: Packer has other provisioners, such as Ansible, Chef, and Puppet, but `shell`
    is the easiest to understand and implement.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: Packer还有其他配置程序，例如Ansible，Chef和Puppet，但`shell`是最容易理解和实现的。
- en: 'Lastly, we built our image:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们构建了我们的图像：
- en: '[PRE138]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Packer pulled the designated image from Docker Hub and then proceeded to make
    the changes we specified to both metadata and contents, before finally packing
    up the image and storing it locally.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: Packer从Docker Hub中提取了指定的图像，然后进行了我们指定的元数据和内容的更改，最后打包图像并将其存储在本地。
- en: We could have introduced a post-processor step too, to variously tag and upload
    our new image to somewhere for safe keeping.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以引入一个后处理步骤，以各种方式标记并上传我们的新图像到某个地方进行安全保存。
- en: There's more...
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here''s a small but interesting titbit. Terraform has a built-in command for
    making sure that all of your syntax is nicely formatted (meaning that everyone
    can conform to the same standard, without getting into silly arguments about spacing):'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个小而有趣的片段。Terraform有一个内置命令，用于确保所有语法都被良好格式化（这意味着每个人都可以遵循相同的标准，而不会陷入关于间距的愚蠢争论）：
- en: '[PRE139]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Honestly, I think this is one of the greatest things about Terraform, because
    it means that no one can have an opinion of their own, and if there's a world
    I want to live in, it's that one.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，我认为这是Terraform最伟大的地方之一，因为这意味着没有人可以有自己的意见，如果有一个世界我想生活在其中，那就是这个世界。
- en: See also
  id: totrans-563
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Hashicorp make a lot of stuff, and while it's important to remember that there
    are several options out there when it comes to Infrastructure as Code, it's undeniable
    to say that at the moment, if you know their suite well, you'll be seriously bolstering
    your chances of getting a job.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: Hashicorp制作了很多东西，虽然重要的是要记住在基础设施即代码方面有几个选择，但不可否认的是，如果您对他们的套件了解得很好，那么您将大大增加获得工作的机会。
- en: 'Other tools from Hashicorp include the following:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: Hashicorp的其他工具包括以下内容：
- en: Vagrant, as we know and love
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vagrant，正如我们所知道和喜爱的那样
- en: Vault, for secret storage
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vault，用于秘密存储
- en: Consul, for service discovery
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Consul，用于服务发现
- en: Roundup - Git, Configuration Management, and Infrastructure as Code
  id: totrans-569
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结- Git，配置管理和基础设施即代码
- en: This is not a book on Ansible, and while I'm tempted to write one, there are
    already a considerable number out there (though truth be told, Ansible is so fast
    paced that you're better off learning as you go, and I don't usually advocate
    that). That said, I do like Ansible, and, along with the other tools listed in
    this chapter (Git, Terraform, Packer), it has made my life so much easier over
    the last couple of years that I've been using it.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本关于Ansible的书，虽然我很想写一本，但已经有相当多的书出版了（尽管实话实说，Ansible发展非常迅速，最好是边学边用，我通常不提倡这样做）。也就是说，我喜欢Ansible，以及本章中列出的其他工具（Git，Terraform，Packer），在过去几年中，它们使我的生活变得轻松了许多。
- en: There's something to be said for the idea that administrators are lazy, because
    all we really want to do is make our jobs easier, by automating away the tedious
    bits. We all used to joke that we'd end up automating ourselves out of a job one
    day, but some of the less lazy in our clan didn't like that idea, and seemingly
    decided that they were going to develop a new thing on an almost monthly basis,
    just so we could pick up the thing and decide we desperately needed to use it
    in our infrastructure.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 有人说管理员是懒惰的，因为我们真正想做的就是通过自动化来简化工作，消除繁琐的部分。我们曾经开玩笑说，总有一天我们会自动化自己的工作，但我们部落中一些不那么懒惰的人不喜欢这个想法，似乎决定几乎每个月都要开发一个新东西，这样我们就可以拿起这个东西，并决定我们迫切需要在我们的基础设施中使用它。
- en: Git is magical making our needs around source control and distribution seamless
    (except when you forget how to recover from the complete mess you've got yourself
    in, and decide it's easier to just delete the directory and clone it again).
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: Git是神奇的，使我们在源代码控制和分发方面的需求无缝（除非您忘记了如何从您陷入的完全混乱中恢复，并决定更容易地删除目录并重新克隆）。
- en: Ansible is a savior, meaning that we no longer have to call up long-retired
    graybeards in the early hours of the morning just to find out how the heck they
    managed to get half of that old snowflake server running in RAM, and the rest
    seemingly pulling itself in from a network drive.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个救世主，这意味着我们不再需要在清晨的早些时候打电话给早已退休的老人，只是为了弄清楚他们是如何设法让那台旧的雪花服务器的一半在RAM中运行的，而另一半似乎是从网络驱动器中拉取的。
- en: 'Don''t assume that just because somewhere uses Ansible, and they claim to be
    fully automated, that they don''t have one server kicking around somewhere that
    no one wants to touch because it does something silly like handle the IVR for
    the phone server. In these cases, you can do one of two things. Either option
    A: offer to automate the old and crusty snowflake, bringing it in line with the
    rest of the infrastructure; or option B: stick your head in the sand like everyone
    else, and hope it doesn''t break while you''re on shift (though it will... it
    will...).'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 不要假设只因为某个地方使用Ansible，并声称是完全自动化的，他们就没有一个服务器被搁置在那里，因为没有人想去碰它，因为它做一些愚蠢的事情，比如处理电话服务器的IVR。在这些情况下，你可以选择两种做法。要么选择A：提出自动化旧的、陈旧的特殊情况，使其与其他基础设施保持一致；要么选择B：像其他人一样把头埋在沙子里，希望在你值班时它不会出问题（尽管它会……它会……）。
- en: Terraform is a headache in code form, though for all of the grievances users
    occasionally have with it, there's no denying that in a cloud-orientated world,
    having a tool that can automatically provision hundreds of boxes in your Azure
    subscription is a must, and if it means that you don't have to learn PowerShell—so
    much the better. It is worth saying, though, that I have a friend who insists
    Terraform isn't ready yet, and, as a result, he wraps the generation of Terraform
    files in an Ansible role... don't ask.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform在代码形式上是一个头疼的东西，尽管用户偶尔对它有所抱怨，但在一个以云为导向的世界中，拥有一个可以自动在Azure订阅中创建数百个箱子的工具是必不可少的，如果这意味着你不必学习PowerShell，那就更好了。不过，值得一提的是，我有一个朋友坚持认为Terraform还没有准备好，因此，他将Terraform文件的生成包装在一个Ansible角色中……别问。
- en: Packer removes tedium and ensures that your Ansible playbooks don't take an
    age to apply because you've done the sensible thing and incorporated all your
    sane defaults into a base image (hint, hint!).
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: Packer消除了繁琐，并确保你的Ansible剧本不会花费太长时间，因为你已经把所有合理的默认值都合并到了一个基础镜像中（暗示，暗示！）。
- en: To round off this chapter, let's talk about the age of the cloud.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们谈谈云的时代。
- en: All the tools we've mentioned are great in an ephemeral world, where servers
    can spin up for a few minutes, complete their purpose in life, and then be unceremoniously
    removed from existence by an omnipotent cronjob. They do have their drawbacks,
    though, and it's important to be careful when using tools such as Terraform to
    manage an estate.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到的所有工具在一个短暂的世界中都很棒，在这个世界中，服务器可以在几分钟内启动，完成它们的使命，然后被一个全能的定时任务无情地从存在中移除。然而，它们也有缺点，使用诸如Terraform之类的工具来管理一个庄园时要小心是很重要的。
- en: There's a reason why Terraform prompts you with an effective "are you really
    sure" message before it'll let you delete infrastructure. I would always advise
    being one hundred percent confident in what you're about to do, before you do
    it. You don't want to be the one responsible for destroying production (make sure
    you have good backups).
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform在让你删除基础设施之前会提示你“你真的确定吗”，这是有原因的。我总是建议在你要做某事之前，要百分之百地确定自己。你不想成为摧毁生产的责任人（确保你有良好的备份）。
- en: In the old days, when I accidentally turned off a server because I got it confused
    with a different server of a similar name, and it was down for twelve hours before
    anyone noticed, the ramifications were minimal. I could simply turn the box back
    on while apologising profusely to the client.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，当我不小心关闭了一个服务器，因为我把它和一个名字相似的服务器搞混了，而且在任何人注意到之前它已经关闭了12个小时，后果是最小的。我可以简单地重新打开这个箱子，同时向客户道歉。
- en: Now, if you accidentally run `terraform destroy` against prod, and it also takes
    the data with it, you've done more than just flipped the boxes off. They're gone,
    kaput, Avada Kedavra'd, so be careful. We have these tools to make our lives easier,
    but sometimes I wonder if we're not also giving ourselves the capability for so
    much more accidental destruction.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你不小心对生产环境运行了`terraform destroy`，并且它也带走了数据，你做的不仅仅是关闭了箱子。它们消失了，完蛋了，被阿瓦达·凯达瓦了，所以要小心。我们有这些工具是为了让我们的生活更轻松，但有时我想知道我们是否也给自己带来了更多意外的破坏的能力。
- en: That story about me turning off a box may or may not be true......it's true.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我关闭一个箱子的故事可能是真的，也可能不是……它是真的。
