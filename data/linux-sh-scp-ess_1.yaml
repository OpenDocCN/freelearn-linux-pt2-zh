- en: Chapter 1. The Beginning of the Scripting Journey
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 脚本之旅的开始
- en: Unix, Unix-like, or Linux-based OS provide a lot of powerful features to work
    upon. Among them, the most powerful and important feature is executing a wide
    range of commands to perform a task quickly and easily; for example, `ls`, `cat`,
    `sort`, `grep`, and so on. We will come to know about a subset of commands and
    usages throughout this book. In order to run a command, we need an interface that
    is widely known as **shell**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Unix、类Unix或基于Linux的操作系统提供了许多强大的功能。其中，最强大和重要的功能是执行各种命令以快速轻松地执行任务；例如，`ls`、`cat`、`sort`、`grep`等。我们将在本书中了解一部分命令和用法。为了运行命令，我们需要一个被广泛称为**shell**的接口。
- en: Shell is a program that acts as an interface between the users (we) and the
    OS kernel (Linux, Unix, and so on). Understanding in terms of Windows OS, shell
    serves a similar purpose DOS does. Different shells are available for Unix, Unix-like,
    or Linux OS. Some of the popular shells are Bourne shell (sh), C shell (csh),
    Korn shell (ksh), Bourne Again shell (bash), and Z shell (zsh).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Shell是一个充当用户（我们）和操作系统内核（Linux、Unix等）之间接口的程序。就Windows操作系统而言，shell的作用类似于DOS。Unix、类Unix或Linux操作系统提供了不同的shell。一些流行的shell包括Bourne
    shell（sh）、C shell（csh）、Korn shell（ksh）、Bourne Again shell（bash）和Z shell（zsh）。
- en: 'In this book, we will be using Linux OS and Bourne Again shell, popularly known
    by its acronym `bash`. Linux-based systems generally have `bash` already installed.
    In case `bash` is not installed, try installing the bash package from your distribution''s
    package manager. In order to know which shell currently your Linux console is
    using, run the following command in terminal:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用Linux操作系统和Bourne Again shell，通常简称为`bash`。基于Linux的系统通常已经安装了`bash`。如果没有安装`bash`，请尝试从您的发行版软件包管理器中安装bash软件包。要知道当前您的Linux控制台正在使用哪个shell，请在终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding ouput, we see that the `CMD` column has value `bash`. This
    means, we are currently using `bash` shell in our current console.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们看到`CMD`列的值为`bash`。这意味着我们当前在当前控制台中使用`bash` shell。
- en: 'If your console is not using the `bash` shell, then you can run the following
    command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的控制台未使用`bash` shell，则可以运行以下命令：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also, your shell will be `bash` now. To make `bash` as a default login shell,
    run the following command:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，您的shell现在将是`bash`。要将`bash`设置为默认登录shell，请运行以下命令：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output obtained is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的输出如下：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We are now set with `bash` shell and ready to learn shell scripting in detail.
    Shell scripts are nothing but plain text files with a series of commands that
    are run by `bash` in a specified order. Writing shell scripts is very useful when
    you have to perform a series of tasks by running various commands, as `bash` will
    read each line from a script file and run it without any need of user intervention.
    The general file extension used for shell scripts are `.sh`, `.bash`, `.zsh`,
    `.ksh`, and so on. Rather than using a file extension for shell scripts, it''s
    preferred to keep a filename without extension and let an interpreter identify
    the type by looking into shebang (`#!`). Shebang is used in scripts to indicate
    an interpreter for execution. It is written in the first line of a script file,
    for example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置了`bash` shell，并准备详细学习shell脚本。Shell脚本只是一系列按指定顺序由`bash`运行的命令的纯文本文件。当您必须通过运行各种命令执行一系列任务时，编写shell脚本非常有用，因为`bash`将从脚本文件中读取每一行并在没有用户干预的情况下运行它。用于shell脚本的一般文件扩展名是`.sh`、`.bash`、`.zsh`、`.ksh`等。与使用文件扩展名不同，最好将文件名保持无扩展名，并让解释器通过查看shebang（`#!`）来识别类型。Shebang用于指示脚本的解释器以进行执行。例如，它写在脚本文件的第一行中：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It means use the `bash` shell to execute a given script. To run a shell script,
    make sure it has execute permission. To provide execute permission to an owner
    of a file, run the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着使用`bash` shell来执行给定的脚本。要运行shell脚本，请确保它具有执行权限。要为文件的所有者提供执行权限，请运行以下命令：
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `foo` is the shell script file. After running this command, `foo` will
    have execute permission for the owner of the file.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`foo`是shell脚本文件。运行此命令后，`foo`将对文件的所有者具有执行权限。
- en: Now, we are ready to proceed further on learning shell scripting concepts in
    detail. Each topic and subtopic covered in the chapters with examples will lead
    us progressively towards a good shell script programmer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备进一步学习shell脚本概念的细节。本书中涵盖的每个主题和子主题都将通过示例逐步引导我们成为优秀的shell脚本程序员。
- en: 'In this chapter, we will talk broadly about the following topics:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将广泛讨论以下主题：
- en: Hello World in shell
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell中的Hello World
- en: Define variables of choice
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义所需的变量
- en: Builtin shell variables
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置shell变量
- en: Operators
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作符
- en: Shell expansions
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell扩展
- en: Construct commands using eval
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用eval构建命令
- en: Make bash behave using set
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用set使bash行为
- en: Hello World in shell
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell中的Hello World
- en: Whenever we learn a new programming language, we first learn how to write the
    Hello World program in it. It is the best way to know and interact with a new
    language. This also helps in confirming that the basic environment for a program
    in a given language has been set up and you are good to dive deep inside this
    language.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们学习一种新的编程语言时，我们首先学习如何在其中编写Hello World程序。这是了解和与新语言交互的最佳方式。这也有助于确认已经设置了给定语言中程序的基本环境，并且您可以深入了解这种语言。
- en: Interacting with shell
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与shell交互
- en: 'We can print the output of commands in console in an interactive way. Console
    is also known as a standard input and output stream. To print anything in a `bash`
    console, use the `echo` command followed by what is to be printed:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以交互方式在控制台中打印命令的输出。控制台也被称为标准输入和输出流。要在`bash`控制台中打印任何内容，请使用`echo`命令，然后跟上要打印的内容：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternatively, put the text to be printed in double quotes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，将要打印的文本放在双引号中：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also put the text to be printed in single quotes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将要打印的文本放在单引号中：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also use the `printf` command in shell programming for printing. The
    `printf` command also supports formatted printing, similar to what we have in
    C programming language— the `printf( )` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在shell编程中使用`printf`命令进行打印。`printf`命令也支持格式化打印，类似于C编程语言中的`printf()`函数：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, after the output, we see the command prompt (`$`) because `printf` doesn''t
    add a default newline after execution while echo does. So, we have to explicitly
    add the newline `(\n`) in the `printf` statement to add a newline:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在输出之后，我们看到命令提示符（`$`），因为`printf`在执行后不会添加默认换行符，而`echo`会。因此，我们必须在`printf`语句中显式添加换行符（`\n`）以添加换行符：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similar to the C `printf( )`, we can specify formatted printing in `bash`.
    The syntax of `bash` `printf` is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于C中的`printf()`，我们可以在`bash`中指定格式化打印。`bash`的`printf`语法如下：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`FORMAT` is a string that describes the format specifications and is specified
    within double quotes. `ARGUMENTS` can be the value or a variable corresponding
    to format specification. Format specification consists of the percentage (`%`)
    sign followed by format specifier. Format specifiers are explained in the following
    table:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`FORMAT`是描述格式规范的字符串，并在双引号内指定。`ARGUMENTS`可以是与格式规范对应的值或变量。格式规范由百分号（`％`）后跟格式说明符组成。格式说明符在下表中解释：'
- en: '| Format specification | Description |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '|格式规范|描述|'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%u` | This prints an unsigned integer value |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|`％u`|这将打印一个无符号整数值|'
- en: '| `%i` or `%d` | This prints an associated argument as a signed number |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|`％i`或`％d`|这将打印一个关联的参数作为有符号数|'
- en: '| `%f` | This prints an associated argument as a floating point number |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|`％f`|这将打印一个关联的参数作为浮点数|'
- en: '| `%o` | This prints an unsigned octal value |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '|`％o`|这将打印一个无符号八进制值|'
- en: '| `%s` | This prints a string value |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '|`％s`|这将打印一个字符串值|'
- en: '| `%X` | This prints an unsigned hexadecimal value (0 to 9 and A to F) |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|`％X`|这将打印一个无符号十六进制值（0到9和A到F）|'
- en: '| `%x` | This prints an unsigned hexadecimal value (0 to 9 and a to f) |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '|`％x`|这将打印一个无符号十六进制值（0到9和a到f）|'
- en: 'The following examples demonstrate how to use format specification for printing
    different data type format in shell:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何在shell中使用格式规范打印不同的数据类型格式：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also optionally specify a modifier in format specification to align
    an output to provide better formatting to the output. Format modifiers are placed
    between `%` and the format specifier character. The following table explains format
    modifiers:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在格式规范中可选地指定修饰符，以对齐输出以提供更好的格式。格式修饰符放置在`％`和格式说明符字符之间。以下表格解释了格式修饰符：
- en: '| Format Modifiers | Description |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|格式修饰符|描述|'
- en: '| --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| N | This is any number that specifies a minimum field width. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|N|这是指定最小字段宽度的任何数字。|'
- en: '| . | This is used together with field width. The field doesn''t expand when
    the text is longer. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|。|这与字段宽度一起使用。文本变长时，字段不会扩展。|'
- en: '| - | This is the left-bound text printing in the field. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| - |这是字段中左边界文本打印。|'
- en: '| 0 | This is used to fill padding with zeros (0) instead of whitespaces. By
    default, padding is done with whitespaces. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|0|这用于用零（0）而不是空格填充填充。默认情况下，使用空格填充。|'
- en: 'The following example demonstrates how to use format modifiers to improve printing
    formatting:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何使用格式修饰符来改进打印格式：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's make it scripted
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们把它写成脚本
- en: Interactive printing is good if we have to print one or two lines, but for a
    lot of printing, it's good and preferred to write a script file. A script file
    will contain all the instructions and we can run a script file to perform the
    needed task.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要打印一两行，交互式打印是很好的，但是对于大量打印，编写脚本文件是很好且更可取的。脚本文件将包含所有指令，我们可以运行脚本文件来执行所需的任务。
- en: 'Now, we are going to create a `bash` script file that makes use of the `echo`
    and `printf` commands and print messages:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`bash`脚本文件，利用`echo`和`printf`命令并打印消息：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The first line in `bash` script represents the path of the interpreter used.
    The second line is a comment line telling the filename of a script file. In shell
    script, we use `#` to add a comment. Furthermore, the `echo` command will print
    strings written within double quotes. For the rest, we have used `printf` to print
    formatted output.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`bash`脚本中的第一行表示所使用的解释器的路径。第二行是一个注释行，告诉脚本文件的文件名。在shell脚本中，我们使用`#`添加注释。此外，`echo`命令将打印在双引号内写的字符串。对于其余部分，我们使用`printf`来打印格式化输出。'
- en: 'To run this script, we will first provide execute permission to a user/owner
    of this script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，我们将首先为此脚本的用户/所有者提供执行权限：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, run the script file in console as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在控制台中运行脚本文件如下：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The result after running this script will look as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后的结果如下：
- en: '![Let''s make it scripted](img/4335_01_01.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![让我们把它写成脚本](img/4335_01_01.jpg)'
- en: Define variables of choice
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义所需的变量
- en: Now we know how to write a simple hello world shell script. Next, we will be
    getting familiar with variables in shell and how to define and use variables in
    shell.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何编写一个简单的hello world shell脚本。接下来，我们将熟悉shell中的变量以及如何定义和使用shell中的变量。
- en: Nomenclature
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名规则
- en: 'A variable name can be a combination of alphanumeric and underscore. Also,
    the name of the variable can''t start with a number. The variable names in shell
    script are case-sensitive. Special characters, such as *, -, +, ~, ., ^, and so
    on, are not used in variable names because they have a special meaning in shell.
    The following table illustrates the correct and incorrect ways of naming a variable:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名可以是字母数字和下划线的组合。变量的名称也不能以数字开头。shell脚本中的变量名称是区分大小写的。特殊字符，如*，-，+，〜，。，^等，在变量名称中不使用，因为它们在shell中具有特殊含义。以下表格说明了命名变量的正确和不正确的方式：
- en: '| Correct variable names | Incorrect variable names |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|正确的变量名|不正确的变量名|'
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| variable | 2_variable |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|variable|2_variable|'
- en: '| variable1 | 2variable |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|variable1|2variable|'
- en: '| variable_2 | variable$ |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|variable_2|variable$|'
- en: '| _variable3 | variable*^ |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|_variable3|variable*^|'
- en: Assigning a value
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配一个值
- en: 'We can assign a value to a variable by using an assignment (`=`) operator and
    followed by a value. While assigning a variable value, there shouldn''t be any
    space before and after the assignment operator. Also, a variable can''t be declared
    alone; it has to be followed by its initial value assignment:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用赋值（`=`）运算符为变量赋值，然后是一个值。在分配变量值时，赋值运算符前后不应有任何空格。还有，变量不能单独声明；必须跟随其初始值分配：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, it's quite easy to declare and assign a value to a variable in shell script.
    You don't have to worry about the data type of a variable on the left-hand side.
    Whatever value you provide on the right-hand side, the variable stores that value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在shell脚本中声明和赋值变量非常容易。您不必担心左侧的变量的数据类型。无论您在右侧提供什么值，变量都会存储该值。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载示例代码文件，用于您购买的所有Packt
    Publishing图书。如果您在其他地方购买了本书，可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接将文件发送到您的电子邮件。
- en: Accessing a value
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问值
- en: 'To access a variable value, use a dollar sign (`$`) operator followed by a
    variable name:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问变量值，请使用美元符号（`$`）运算符，后跟变量名：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result of this script will look as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的结果如下：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can remove the value of a variable using the `unset` keyword in `bash`.
    Using `unset` to a variable deletes and resets it to null:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`unset`关键字在`bash`中删除变量的值。使用`unset`将变量删除并重置为空：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result after running this script will look as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后的结果如下：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It's clear that we used unset on a fruit variable, so when we try to access
    a variable fruit after unsetting it in line no. 8, it prints nothing. The `quantity`
    variable still retains its value because we haven't used unset on it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，我们在水果变量上使用了unset，所以当我们尝试在第8行取消设置变量水果后，它什么也不打印。`quantity`变量仍保留其值，因为我们没有在其上使用unset。
- en: Constant variables
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量变量
- en: 'We can also create the `constant` variable in `bash` whose value can''t be
    changed. The `readonly` keyword is used to declare a constant variable. We can
    also use `declare -r` followed by a variable name to make it constant:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`bash`中创建`constant`变量，其值无法更改。使用`readonly`关键字声明常量变量。我们还可以使用`declare -r`后跟变量名使其成为常量：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The result after running this script will look as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后的结果如下：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: From the error message, it's clear that we can't change the value of a constant
    variable, and also we can't unset the value of the constant variable.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从错误消息中可以明显看出，我们无法更改常量变量的值，也无法取消常量变量的值。
- en: Reading variables from a user input
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从用户输入中读取变量
- en: We can ask the user to provide input using the `read` shell built in command.
    The number of inputs to be given by a user is equivalent to the number of arguments
    provided to `read`. The value inserted by a user is stored in respective parameters
    passed to `read`. All parameters act as variables in which the corresponding user
    input value is stored.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`read` shell内置命令要求用户提供输入。用户要提供的输入数量等于提供给`read`的参数数量。用户插入的值存储在传递给`read`的相应参数中。所有参数都充当变量，其中存储相应的用户输入值。
- en: 'The syntax of `read` is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`的语法如下：'
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If no variable in an argument is specified, the input value by a user will be
    stored in the inbuilt variable `REPLY` and can be accessed further using `$REPLY`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定参数中的变量，则用户的输入值将存储在内置变量`REPLY`中，并且可以使用`$REPLY`进一步访问。
- en: 'We can read a user input in its input variable as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式在其输入变量中读取用户输入：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can read a value from user input as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式从用户输入中读取值：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can read multiple values from user input as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按如下方式从用户输入中读取多个值：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can read only the `n` characters and don''t wait for the user to input a
    complete line as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以仅读取`n`个字符，而不必等待用户输入完整行，如下所示：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can prompt the user a message before reading user input as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在读取用户输入之前提示用户消息如下：
- en: '[PRE30]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Hiding an input character when reading in console:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中读取时隐藏输入字符：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following example shows the `read` command''s usage:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了`read`命令的用法：
- en: '[PRE32]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is the result of running the `read.sh` script in `bash`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`bash`中运行`read.sh`脚本的结果如下：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, the `find` command has been used to search for the filename in the specified
    path. The detailed discussion of the command `find` will be done in [Chapter 6](ch06.html
    "Chapter 6. Working with Files"), *Working with Files*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`find`命令已用于在指定路径中搜索文件名。命令`find`的详细讨论将在[第6章](ch06.html "Chapter 6. Working
    with Files")中进行，*处理文件*。
- en: Builtin shell variables
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置shell变量
- en: Builtin shell variables are predefined and are global variables that we can
    use in our script at any point of time. These are reserved shell variables and
    some of them may have a default value assigned by `bash`. Some variables' value
    will depend upon your current shell environment setup. The different type of shell
    may have a few specific reserved variables to it. All builtin shell variables'
    name will be in uppercase.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 内置shell变量是预定义的全局变量，我们可以在脚本的任何时间点使用它们。这些是保留的shell变量，其中一些可能由`bash`分配默认值。某些变量的值将取决于当前的shell环境设置。不同类型的shell可能具有一些特定的保留变量。所有内置shell变量的名称都将是大写。
- en: 'A few reserved shell variables available in `bash` shell are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`bash` shell中可用的一些保留shell变量如下：'
- en: '| Shell variables available in bash | Description |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 在bash中可用的shell变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `BASH` | This is the absolute path of the current `bash` being invoked |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `BASH` | 这是当前调用的`bash`的绝对路径 |'
- en: '| `BASH_VERSION` | This is the version number of `bash` |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `BASH_VERSION` | 这是`bash`的版本号 |'
- en: '| `BASHPID` | This is the process ID of the current `bash` process |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `BASHPID` | 这是当前`bash`进程的进程ID |'
- en: '| `EUID` | This is the effective user ID of the current user, which is assigned
    during startup |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `EUID` | 这是当前用户的有效用户ID，在启动时分配 |'
- en: '| `HOME` | This is the current user''s home directory |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `HOME` | 这是当前用户的主目录 |'
- en: '| `HOSTNAME` | This is the name of the current host |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `HOSTNAME` | 这是当前主机的名称 |'
- en: '| `PATH` | This is the colon-separated list of directories where shell will
    look for commands |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `PATH` | 这是shell将查找命令的以冒号分隔的目录列表 |'
- en: '| `PPID` | This is the process ID of the shell''s parent |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `PPID` | 这是shell父进程的进程ID |'
- en: '| `PWD` | This is the present working directory |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `PWD` | 这是当前工作目录 |'
- en: More shell variables can be found in `man bash`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`man bash`中找到更多的shell变量。
- en: 'We will see what values these shell variables contain by printing its value
    in a shell script:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在shell脚本中打印其值来查看这些shell变量包含的值：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After running this script, the output may vary depending upon what the value
    of these variables is set in your system. The sample output will be as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后，输出可能会有所不同，具体取决于系统中这些变量的值设置为何。示例输出如下：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The shell variables, such as `PWD`, `PATH`, `HOME`, and so on, are very useful
    and help in getting the information quickly by just echoing a value in it. We
    can also add or modify the value of some of shell variables, such as `PATH`, in
    order to add a custom path in which we want shell to look for commands.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: shell变量，如`PWD`、`PATH`、`HOME`等，非常有用，可以通过简单地回显其中的值来快速获取信息。我们还可以添加或修改一些shell变量的值，如`PATH`，以便在其中添加我们希望shell查找命令的自定义路径。
- en: 'One of the use-cases of modifying the `PATH` variable value is: suppose, I
    have compiled a source code that generates a few binaries such as, `foo` and `bar`.
    Now, if I want shell to search in that particular directory for command as well,
    then add this directory path in the `PATH` variable and we are done. The following
    small shell script example shows how to do this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`PATH`变量值的一个用例是：假设我已经编译了一个生成一些二进制文件（如`foo`和`bar`）的源代码。现在，如果我希望shell也在该特定目录中搜索命令，那么将该目录路径添加到`PATH`变量中即可。以下是一个小的shell脚本示例，显示了如何执行此操作：
- en: '[PRE36]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output after running this script will be somewhat as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后的输出将如下所示：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We see from the output that a new `PATH` variable has my custom path added.
    From the next time, whenever I run the `foo` or `bar` commands with this custom
    `PATH` variable set, the absolute path of the `foo` and the `bar` command/binary
    won't be required. Shell will find out these variables by looking into its `PATH`
    variable. This is true only during the current session of shell. We will see this
    in [Chapter 5](ch05.html "Chapter 5. Customizing the Environment"), *Customizing
    Environment* in recipe, *Modifying a shell environment*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，新的`PATH`变量已经添加了我的自定义路径。从下一次开始，每当我使用设置了这个自定义`PATH`变量的`foo`或`bar`命令时，就不需要`foo`和`bar`命令/二进制文件的绝对路径了。Shell将通过查看其`PATH`变量来找到这些变量。这仅在当前shell会话期间有效。我们将在[第5章](ch05.html
    "第5章。自定义环境")中看到这一点，*自定义环境*中的配方，*修改shell环境*。
- en: Operators
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符
- en: 'Similar to other programming languages, shell programming also supports various
    types of operators to perform tasks. Operators can be categorized as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言类似，shell编程也支持各种类型的操作符来执行任务。操作符可以分为以下几类：
- en: Assignment operator
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值操作符
- en: Arithmetic operators
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术操作符
- en: Logical operators
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑操作符
- en: Comparison operators
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较操作符
- en: The assignment operator
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值操作符
- en: 'Equal to an operator (`=`) is the assignment operator that is used to initialize
    or change the value of a variable. This operator works on any data such as a string,
    integer, float, array, and so on. For example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 等于操作符（`=`）是用于初始化或更改变量值的赋值操作符。此操作符适用于任何数据，如字符串、整数、浮点数、数组等。例如：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Arithmetic operators
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术操作符
- en: 'Arithmetic operators are used for doing arithmetic operations on integers.
    They are as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 算术操作符用于对整数执行算术运算。它们如下：
- en: + (plus)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +（加）
- en: '- (minus)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -（减）
- en: '* (multiplication)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*（乘法）'
- en: / (division)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /（除法）
- en: '** (exponentiation)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**（指数）'
- en: '% (modulo)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%（取模）'
- en: += (plus-equal)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +=（加等于）
- en: -= (minus-equal)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -=（减等于）
- en: '*= (multiplication-equal)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*=（乘等于）'
- en: /= (slash-equal)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: /=（斜杠等于）
- en: '%= (mod-equal)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '%=（模等于）'
- en: 'To perform any arithmetic operation, we prefix the `expr` and `let` keywords
    before the actual arithmetic expression. The following example shows how to perform
    an arithmetic operation in `bash`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行任何算术操作，在实际算术表达式之前，我们需要在`bash`中加上`expr`和`let`关键字。以下示例显示了如何在`bash`中执行算术操作：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The result after running this script will look as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后的结果如下：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Logical operators
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑操作符
- en: 'Logical operators are also known as Boolean operators. They are:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑操作符也被称为布尔操作符。它们是：
- en: '**!** (**NOT**), **&&** (**AND**), and **||** (**OR**)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**!**（**非**）、**&&**（**与**）和**||**（**或**）'
- en: Performing a logical operation returns a Boolean value as `true (1)` or `false
    (0)` depending upon the values of variable(s) on which the operation is done.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 执行逻辑操作返回一个布尔值，如`true（1）`或`false（0）`，具体取决于操作所涉及的变量的值。
- en: 'One of the useful use-case is: suppose that we want to execute a command if
    the first command or operation returns successfully. In this case, we can use
    the `&&` operator. Similarly, if we want to execute another command, irrespective
    of the first command that got executed or not, then we can use the || operator
    between two commands. We can use the ! operator to negate the true value. For
    example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的用例是：假设我们希望在第一个命令或操作成功返回时执行一个命令。在这种情况下，我们可以使用`&&`操作符。同样，如果我们想要执行另一个命令，无论第一个命令是否执行，我们都可以在两个命令之间使用`||`操作符。我们可以使用!操作符来否定真值。例如：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `cd` command is used to change the current path to the specified argument.
    Here, the `cd ~/Documents/` command will change the directory to `Documents if
    exists`. If it fails, then `ls` won''t get executed, but if `cd` to `Documents`
    succeeds, the `ls` command will display the content of `Documents directory`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`cd`命令用于将当前路径更改为指定的参数。在这里，`cd ~/Documents/`命令将更改目录到`Documents`（如果存在）。如果失败，则`ls`不会被执行，但如果`cd`到`Documents`成功，则`ls`命令将显示`Documents目录`的内容：'
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `cat` command displays the content of `file.txt` if it exists. Irrespective
    of the `cat ~/file.txt` command execution, later the command that is `echo "Current
    Working directory $PWD"` will be executed:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令显示`file.txt`的内容（如果存在）。无论`cat ~/file.txt`命令是否执行，稍后将执行的命令是`echo "当前工作目录
    $PWD"`：'
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By running the preceding commands, first it will try to change the directory
    to `/tmp/foo`. Here, `! cd /tmp/foo` means if change directory to `/tmp/foo` doesn't
    succeed, then run the second command, which is `mkdir /tmp/foo`. The `mkdir` command
    is used to create a new directory. As a result of proceeding command execution,
    directory `/tmp/foo` will be created if it doesn't exist.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行上述命令，首先会尝试更改目录到`/tmp/foo`。在这里，`! cd /tmp/foo`表示如果更改目录到`/tmp/foo`不成功，则运行第二个命令，即`mkdir
    /tmp/foo`。`mkdir`命令用于创建一个新目录。由于进行命令执行，如果目录`/tmp/foo`不存在，它将被创建。
- en: '[PRE44]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Since the `/tmp/foo` directory has been created, a successful change of the
    directory will occur.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 自从`/tmp/foo`目录被创建后，目录的成功更改将发生。
- en: Comparison operators
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Comparison operators compare two variables and check whether a condition is
    satisfied or not. They are different for integers and strings.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符比较两个变量，并检查条件是否满足。它们对整数和字符串有所不同。
- en: 'Comparison operators that are valid for integer variables (consider `a` and
    `b` as two integer variables; for example, `a=20, b=35`) are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对整数变量有效的比较运算符（将`a`和`b`视为两个整数变量；例如，`a=20, b=35`）如下：
- en: -eq (is equal to) - `[ $a -eq $b ]`
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -eq（等于）- `[ $a -eq $b ]`
- en: -ne (is not equal to) - [ $a -ne $b ]
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -ne（不等于）- [ $a -ne $b ]
- en: -gt (is greater than) - [ $a -gt $b ]
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -gt（大于）- [ $a -gt $b ]
- en: -ge or >= (is greater than or equal to) - [ $a -ge $b ]
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -ge或>=（大于或等于）- [ $a -ge $b ]
- en: -lt (is less than) - [ $a -lt $b ]
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -lt（小于）- [ $a -lt $b ]
- en: -le (is less than or equal to) - [ $a -le $b ]
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -le（小于或等于）- [ $a -le $b ]
- en: < (is less than) - (($a < $b))
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <（小于）- (($a < $b))
- en: <= (is less than or equal to) - (($a <= $b))
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <=（小于或等于）- (($a <= $b))
- en: (is greater than) - (($a > $b))
  id: totrans-205
  prefs:
  - PREF_UL
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (is greater than) - (($a > $b))
- en: '>= (is greater than or equal to) - (($a >= $b))'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '>=（大于或等于）- (($a >= $b))'
- en: 'Comparison operators that are valid for string variables (consider a and b
    as two string variables; for example, a="Hello" b="World") are as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对字符串变量有效的比较运算符（将a和b视为两个字符串变量；例如，a="Hello" b="World"）如下：
- en: = (is equal to); for example, `[ $a = $b ]`
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: =（等于）；例如，`[ $a = $b ]`
- en: '!= (is not equal to); for example, [ $a != $b ]'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '!=（不等于）；例如，[ $a != $b ]'
- en: < (is less than); for example, [ $a \< $b ] or [[ $a \< $b ]] or (( $a \< $b
    ))
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <（小于）；例如，[ $a \< $b ]或[[ $a \< $b ]]或(( $a \< $b ))
- en: (is greater than); for example,[ $a \> $b ] or [[ $a > $b ]] or (( $a \> $b
    ))
  id: totrans-211
  prefs:
  - PREF_UL
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （大于）；例如，[ $a \> $b ]或[[ $a > $b ]]或(( $a \> $b ))
- en: -n (string is non-empty); for example,[ -n $a ]
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -n（字符串非空）；例如，[ -n $a ]
- en: -z (string has zero length or null); for example,[ -z $a ]
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -z（字符串长度为零或为空）；例如，[ -z $a ]
- en: Shell uses the `<` and `>` operators for redirection, so it should be used with
    an escape (`\`) if used under [ … ]. Double parentheses, (( ... )) or [[ … ]],
    doesn't need an escape sequence. Using [[ … ]] also supports pattern matching.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Shell使用`<`和`>`操作符进行重定向，因此如果在[ … ]下使用，应该使用转义（`\`）。双括号，(( ... ))或[[ … ]]，不需要转义序列。使用[[
    … ]]还支持模式匹配。
- en: We will see the usage and examples of operators in more detail in [Chapter 3](ch03.html
    "Chapter 3. Effective Script Writing"), *Effective Script Writing*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](ch03.html "第3章 有效脚本编写")中更详细地看到操作符的用法和示例，*有效脚本编写*。
- en: Shell expansions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell扩展
- en: 'While working with shell, we perform a lot of similar and repetitive tasks.
    For example, in the current directory, there are 100 files but we are interested
    only in shell script whose file extension is `.sh`. We can execute following command
    to view only shell script files in current directory:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用shell时，我们执行了许多类似和重复的任务。例如，在当前目录中，有100个文件，但我们只对文件扩展名为`.sh`的shell脚本感兴趣。我们可以执行以下命令来查看当前目录中的shell脚本文件：
- en: '[PRE45]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will show all the files ending with `.sh`. An interesting take away from
    here is the `*` wildcard. It means a match list of files whose name can be anything
    and that ends with `.sh`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所有以`.sh`结尾的文件。从这里可以得到一个有趣的启示是`*`通配符。它表示文件名可以是任何东西，并以`.sh`结尾的文件列表。
- en: 'Shell expands all wildcard patterns. A list of the latest wildcard patterns
    are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Shell扩展所有通配符模式。最新通配符模式列表如下：
- en: ~ (Tilde)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ~（波浪号）
- en: '* (Asterisk)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*（星号）'
- en: '? (Question mark)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ?（问号）
- en: '[ ] (Square brackets)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ ]（方括号）'
- en: '{ } (Curly brackets)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '{ }（花括号）'
- en: 'To explain shell expansion for different wildcards, we will create a test folder
    in our `home` directory using the `mkdir` command containing different files mentioned
    as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释不同通配符的shell扩展，我们将在我们的`home`目录中使用`mkdir`命令创建一个测试文件夹，其中包含如下所述的不同文件：
- en: '[PRE46]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `touch` command creates an empty file if it doesn''t exist. If a file exists,
    then the file timestamp changes:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`touch`命令如果文件不存在则创建一个空文件。如果文件存在，则文件时间戳会更改：'
- en: '[PRE47]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Running the preceding commands will create a test directory, and inside test
    directory creates files given as parameter to the `touch` command.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '运行上述命令将创建一个测试目录，并在测试目录中创建作为`touch`命令参数给出的文件。 '
- en: ~ (Tilde)
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ~（波浪号）
- en: '~ (Tilde) gets expanded by `bash` when it is present at the beginning of an
    unquoted string. The expansion depends upon what `tilde-prefix` is used. Tilde
    prefixes are characters until the first unquoted (`/`) slash. Some of the `bash`
    expansions are as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当`~`出现在未引用字符串的开头时，`~`会被`bash`扩展。扩展取决于使用了什么`tilde-prefix`。`tilde-prefix`是直到第一个未引用的（/）斜杠的字符。一些`bash`扩展如下：
- en: '`~`: This is the user''s home directory; the value is set in the `$HOME` variable'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~`：这是用户的主目录；该值设置在`$HOME`变量中'
- en: '`~user_name`: This is the home directory of the user''s `user_name`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~user_name`：这是用户`user_name`的主目录'
- en: '`~user_name`/`file_name`: This is the file/directory `file_name` in the user''s
    `user_name` home directory'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~user_name`/`file_name`：这是用户`user_name`主目录中的文件/目录`file_name`'
- en: '`~/file_name`: This is the file/directory `file_name` in the home directory
    that is `$HOME`/`file_name`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/file_name`：这是`$HOME`/`file_name`中的文件/目录'
- en: '`~+`: This is the current working directory; the value is set in the `$PWD`
    variable'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~+`：这是当前工作目录；该值设置在`$PWD`变量中'
- en: '`~-`: This is the old or last working directory; the value is set in the `$OLDPWD`
    variable'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~-`：这是旧的或上一个工作目录；该值设置在`$OLDPWD`变量中'
- en: '`~+/file_name`: This is the file/directory `file_name` in the current directory
    that is `$PWD/file_name`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~+/file_name`：这是当前目录中的文件/目录`file_name`，即`$PWD/file_name`'
- en: '`~-/file_name`: This is the file/directory `file_name` in the old/last working
    directory that is `$OLDPWD/file_name`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~-/file_name`：这是旧/上一个工作目录中的文件/目录`file_name`，即`$OLDPWD/file_name`'
- en: '* (Asterisk)'
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*（星号）'
- en: 'It matches zero or more characters. Take a test directory as an example:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 它匹配零个或多个字符。以测试目录为例：
- en: 'Display all files as follows:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按如下方式显示所有文件：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Display the C source files as follows:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按如下方式显示C源文件：
- en: '[PRE49]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Display files that have `a` in its name, as follows:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按如下方式显示具有`a`的文件：
- en: '[PRE50]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Deleting files with an extension .txt as follows:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按如下方式删除具有扩展名.txt的文件：
- en: '[PRE51]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '? (Question mark)'
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ？（问号）
- en: 'It matches any single character: ? (single question mark will match a single
    character), ?? (double question mark matches any two characters), and so on. Take
    a test directory as an example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 它匹配任何单个字符：？（单个问号将匹配一个字符），??（双问号匹配任何两个字符），依此类推。以测试目录为例：
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This will recreate files that were removed during the previous example, and
    also update the access and modification time of the existing files:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重新创建在上一个示例中删除的文件，并更新现有文件的访问和修改时间：
- en: 'Get files whose name length is irrespective of what the extension file has:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取文件名长度与扩展文件无关：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Get files whose name length is 2 or 5:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取文件名长度为2或5的文件：
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Delete files whose name is four characters long:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件名为四个字符长的文件：
- en: '[PRE55]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Move files to the `/tmp` directory whose name is at least three characters
    long:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件移动到`/tmp`目录，文件名至少为三个字符长：
- en: '[PRE56]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We see only two files in the test directory because the rest of the files were
    of the length 3 or more.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只在测试目录中看到两个文件，因为其余的文件长度为3或更长。
- en: '[ ] (Square brackets)'
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '[ ]（方括号）'
- en: Square brackets match any character from the characters mentioned inside the
    square brackets. Characters can be specified as a word or range.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号匹配方括号内提到的字符集中的任何字符。字符可以指定为单词或范围。
- en: 'A range of characters can be specified using - (hyphen). For example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 -（连字符）可以指定一系列字符。例如：
- en: '`[a-c]`: This matches a, b, or c'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[a-c]`：这匹配a、b或c'
- en: '`[a-z]`: This matches any character from a to z'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[a-z]`：这匹配从a到z的任何字符'
- en: '`[A-Z]`: This matches any character from A to Z'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[A-Z]`：这匹配从A到Z的任何字符'
- en: '`[0-9]`: This matches any character from 0 to 9'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[0-9]`：这匹配0到9之间的任何字符'
- en: 'Take a test directory as an example and recreate files in a test directory:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以测试目录为例，在测试目录中重新创建文件：
- en: '[PRE57]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Get files whose name starts with `a`, `b`, `c`, or `d` with the following command:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文件名以`a`、`b`、`c`或`d`开头的文件，使用以下命令：
- en: '[PRE58]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Get files whose name starts with any letter and ends with a letter `o` or `h`,
    with the following command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文件名以任何字母开头并以字母`o`或`h`结尾的文件，使用以下命令：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Get files that have at least the letter `o` twice in its name, with the following
    command:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文件名中至少包含两个字母`o`的文件，使用以下命令：
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`[!characters]` (Exclamation mark) is used to match a character that is not
    part of a charter set mentioned inside square brackets.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`[!characters]`（感叹号）用于匹配不在方括号内提到的字符集中的字符。'
- en: 'Get files that don''t have a number in its name, with the following command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 获取文件名中不包含数字的文件，使用以下命令：
- en: '[PRE61]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '{ } (Curly brackets)'
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '{ }（花括号）'
- en: It creates multiple wildcard patterns to match. A brace expression may contain
    either a comma-separated list of strings, a range, or a single character.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建多个通配符模式进行匹配。花括号表达式可以包含逗号分隔的字符串列表、范围或单个字符。
- en: 'A range can be specified by using the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下方式指定范围：
- en: '`{a..z}`: This matches all the charterer from a to z'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{a..z}`：这匹配从a到z的所有字符'
- en: '`{0..6}`: This matches numbers 0, 1, 2, 3, 4, 5 and 6'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{0..6}`：这匹配数字0、1、2、3、4、5和6'
- en: 'Take a test directory as an example and recreate files in the test directory:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以测试目录为例，重新创建测试目录中的文件：
- en: '[PRE62]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Get files that have the file extension `.sh` or `.c`, with the following command:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 获取具有文件扩展名`.sh`或`.c`的文件，使用以下命令：
- en: '[PRE63]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Copy `bar.c` to `bar.html` by using the following command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将`bar.c`复制到`bar.html`：
- en: '[PRE64]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Print the number from `1` to `50` by using the following command:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令打印从`1`到`50`的数字：
- en: '[PRE65]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Create 10 files that start with `hello` and has an extension `.cpp`:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以`hello`开头并具有扩展名`.cpp`的10个文件：
- en: '[PRE66]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: To avoid shell expansion of a wildcard, use backslash (\) or write a string
    within a single quote (' ').
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免通配符的shell扩展，使用反斜杠（\）或在单引号（' '）中写入字符串。
- en: Construct commands using eval
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用eval构建命令
- en: The `eval` command is a shell builtin command used to construct a command by
    concatenating arguments passed to `eval`. A concatenated command is further executed
    by shell and returns a result. If no arguments are given to `eval`, it returns
    `0`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`命令是一个shell内置命令，用于通过连接传递给`eval`的参数来构造一个命令。连接的命令进一步由shell执行并返回结果。如果没有给`eval`传递参数，则返回`0`。'
- en: 'The syntax of the `eval` command is as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`命令的语法如下：'
- en: '[PRE67]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The following example shows the expansion of a variable to the name of another
    variable using `eval`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了使用`eval`将变量扩展为另一个变量的名称：
- en: '[PRE68]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Another example where `eval` can be useful is as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval`有用的另一个示例如下：'
- en: '[PRE69]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here, the `df` command shows a system disk''s usage:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`df`命令显示了系统磁盘的使用情况：
- en: '[PRE70]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Running the script will give you the following result:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本将给出以下结果：
- en: '[PRE71]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Make bash behave using set
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用set使bash行为
- en: The `set` command is a shell builtin command that is used to set and unset a
    value of the local variables in shell.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`set`命令是一个shell内置命令，用于在shell中设置和取消设置本地变量的值。'
- en: 'The syntax of using set is as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 使用set的语法如下：
- en: '[PRE72]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Some of the option values are `allexport`, `braceexpand`, `history`, `keyword`,
    `verbose`, and `xtrace`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 一些选项值是`allexport`、`braceexpand`、`history`、`keyword`、`verbose`和`xtrace`。
- en: Using `set` without any option displays the name and value of all shell variables
    and functions, in a format that can be reused as an input for setting and unsetting
    the currently set variables.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不带任何选项的`set`命令以一种格式显示所有shell变量和函数的名称和值，该格式可以作为设置和取消当前设置变量的输入重用。
- en: Exit on the first failure
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在第一次失败时退出
- en: In a shell script, by default, the next line is executed if an error occurs
    in the current line. Sometimes, we may want to stop running a script further after
    an error has been encountered. The `-e` option of `set` ensures to exit a script
    once any of the commands in a pipeline fails.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell脚本中，默认情况下，如果当前行发生错误，则会执行下一行。有时，我们可能希望在遇到错误后停止运行脚本。`set`的`-e`选项确保一旦管道中的任何命令失败，脚本就会退出。
- en: 'In the following shell script, `do_not_exit_on_failure.sh` doesn''t use `set`
    with the option `-e`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下shell脚本中，`do_not_exit_on_failure.sh`不使用带有`-e`选项的`set`：
- en: '[PRE73]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'After running this script, the output is as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后，输出如下：
- en: '[PRE75]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We see that the command after the error gets executed as well. In order to
    stop the execution after an error is encountered, use `set -e` in the script.
    The following script demonstrates the same:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到错误后的命令也被执行了。为了在遇到错误后停止执行，请在脚本中使用`set -e`。以下脚本演示了相同的情况：
- en: '[PRE76]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The output after running the preceding script is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述脚本后的输出如下：
- en: '[PRE78]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We can see that the script has been terminated after encountering an error at
    the line number `7`.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在第7行遇到错误后，脚本已经终止。
- en: Enabling/disabling symbolic link's resolution path
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用/禁用符号链接的解析路径
- en: 'Using `set` with the `-P` option doesn''t resolve symbolic links. Following
    example demonstrate how we can enable or disable symbolic link resolution of `/bin`
    directory which is symbolic link of `/usr/bin/` directory:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`-P`选项的`set`不解析符号链接。以下示例演示了如何启用或禁用`/bin`目录的符号链接解析，该目录是`/usr/bin/`目录的符号链接：
- en: '[PRE79]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Setting/unsetting variables
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置/取消设置变量
- en: We can use the `set` command to see all local variables accessible for the current
    process. The local variables are not accessible in the subprocess.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`set`命令查看当前进程可访问的所有本地变量。本地变量在子进程中不可访问。
- en: 'We can create our own variable and set it locally as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的变量并将其设置为本地，如下所示：
- en: '[PRE80]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To make a variable accessible to its subprocesses as well, use the `export`
    command followed by the variable to be exported:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 要使变量对其子进程也可访问，请使用`export`命令，后跟要导出的变量：
- en: '[PRE81]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This will export the `MYVARIABLE` variable to any subprocess that ran from
    that process. To check whether `MYVARIABLE` has exported or not, run the following
    command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`MYVARIABLE`变量导出到从该进程运行的任何子进程。要检查`MYVARIABLE`是否已导出，请运行以下命令：
- en: '[PRE82]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To unset local or exported variables, use the `unset` command and it will reset
    the value of the variable to null:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消本地或导出的变量，请使用`unset`命令，它将将变量的值重置为null：
- en: '[PRE83]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After reading this chapter, you understood how to write simple shell script
    in bash by printing, echoing, and asking user input. You should now have a good
    understanding of defining and using variables in shell and what builtin shell
    variables exist. You are now familiar with what operators are available in shell
    and how they can create and evaluate their own expression. With information about
    wildcards available in this chapter, it makes work easier for you while you are
    dealing with similar kind of data or pattern. The shell builtin command `set`
    enables modifying shell variables easily.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您了解了如何通过打印、回显和询问用户输入来在bash中编写简单的shell脚本。您现在应该对在shell中定义和使用变量以及存在哪些内置shell变量有了很好的理解。您现在熟悉shell中有哪些操作符，以及它们如何创建和评估自己的表达式。有关通配符的信息在本章中可用，这使得在处理类似类型的数据或模式时，工作变得更加容易。shell内置命令`set`可以轻松修改shell变量。
- en: This chapter has built a foundation for upcoming chapters. Now, in next chapter,
    you will get to know about standard inputs, outputs, and errors. Also, there will
    be a detailed coverage of how to use an output from commands and then filter/transform
    them to show the data according to your need.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为即将到来的章节奠定了基础。现在，在下一章中，您将了解有关标准输入、输出和错误的信息。此外，将详细介绍如何使用命令的输出，然后过滤/转换它们以根据您的需要显示数据。
