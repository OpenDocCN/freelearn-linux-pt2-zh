- en: '*Chapter 12*: Debugging Your Programs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：调试您的程序'
- en: No program is perfect on the first try. In this chapter, we'll learn how to
    debug our programs using **GDB** and **Valgrind**. With the latter tool, Valgrind,
    we can find **memory leaks** in our programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个程序在第一次尝试时就是完美的。在本章中，我们将学习如何使用GDB和Valgrind来调试我们的程序。使用Valgrind这个工具，我们可以找到程序中的内存泄漏。
- en: We'll also take a look at what memory leaks are, what they can cause, and how
    to prevent them. Debugging programs and looking at memory is an important step
    to understanding system programming fully.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看看内存泄漏是什么，它们可能引起什么问题，以及如何防止它们。调试程序并查看内存是理解系统编程的重要步骤。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Starting GDB
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动GDB
- en: Stepping inside functions with GDB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GDB进入函数
- en: Investigating memory with GDB
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GDB调查内存
- en: Modifying variables during runtime
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时修改变量
- en: Using GDB on a program that forks
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分叉程序上使用GDB
- en: Debugging programs with multiple threads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多线程调试程序
- en: Finding a simple memory leak with Valgrind
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Valgrind找到一个简单的内存泄漏
- en: Finding buffer overflows with Valgrind
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Valgrind查找缓冲区溢出
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need the GBD tool, Valgrind, the GCC compiler, a generic
    Makefile, and the Make tool.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将需要GBD工具、Valgrind、GCC编译器、通用Makefile和Make工具。
- en: If you haven't installed GDB and Valgrind yet, you can do so now. Follow these
    instructions depending on your distributions. If you don't have `sudo` installed
    or don't have `sudo` privileges, you can switch to root using `su` instead (and
    leave out the `sudo` part).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有安装GDB和Valgrind，现在可以这样做。根据您的发行版，按照以下说明进行操作。如果您没有安装`sudo`或没有`sudo`权限，您可以使用`su`切换到root用户（并省略`sudo`部分）。
- en: 'For Debian and Ubuntu systems, run the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Debian和Ubuntu系统，请运行以下命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For CentOS, Fedora, and Red Hat systems, run the following command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CentOS、Fedora和Red Hat系统，请运行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All the code samples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch12](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch12).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到：[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch12](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch12)。
- en: 'Check out the following link to see the Code in Action videos: [https://bit.ly/3rvAvqZ](https://bit.ly/3rvAvqZ)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以查看“代码实战”视频：[https://bit.ly/3rvAvqZ](https://bit.ly/3rvAvqZ)
- en: Starting GDB
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动GDB
- en: In this recipe, we'll learn the basics of **GDB**, the **GNU debugger**. We'll
    learn how to start GDB, how to set a breakpoint, and how to step forward in a
    program, one step at a time. We'll also learn what **debugging symbols** are and
    how we enable them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习**GDB**，即**GNU调试器**的基础知识。我们将学习如何启动GDB，如何设置断点，以及如何逐步执行程序。我们还将学习**调试符号**是什么以及如何启用它们。
- en: GDB is the most popular debugger for Linux and other Unix-like systems. It allows
    you to examine—and change—variables on the fly, step through instructions one
    at a time, view the code as the program is running, read return values, and much
    more.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: GDB是Linux和其他类Unix系统中最流行的调试器。它允许您在程序运行时检查和更改变量，逐步执行指令，查看程序运行时的代码，读取返回值等等。
- en: Knowing how to use a debugger can save you many hours of frustration. Instead
    of guessing what the problem is with your program, you can follow the execution
    with GDB and spot the error. This can save you a lot of time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用调试器可以节省您很多时间。您可以跟踪GDB的执行并发现错误，而不是猜测程序的问题。这可以节省您很多时间。
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need the GCC compiler, the Make tool, and the GDB tool.
    For installation instructions for GDB, see the *Technical requirements* section
    of this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，您将需要GCC编译器、Make工具和GDB工具。有关GDB的安装说明，请参阅本章的*技术要求*部分。
- en: How to do it…
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll use GDB on a working program. There are no bugs here.
    Instead, we want to focus on how to do some basic things in GDB:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将在一个正常工作的程序上使用GDB。这里没有错误。相反，我们想专注于如何在GDB中做一些基本的事情：
- en: 'Write the following small program in a file and save it as `loop.c`. Later,
    we will examine the program using GDB:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个文件中编写以下简单程序，并将其保存为`loop.c`。稍后，我们将使用GDB检查程序：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Before we can use GDB to its fullest, we need to enable `Makefile` in the same
    directory as the `loop.c` program. Notice we added the `-g` option to `CFLAGS`.
    These debugging symbols make it possible to see the code as we execute it in GDB:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们充分利用GDB之前，我们需要在与loop.c程序相同的目录中启用`Makefile`。请注意，我们在`CFLAGS`中添加了`-g`选项。这些调试符号使我们能够在GDB中执行代码时看到代码：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, it''s time to compile the program using our new Makefile:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候使用我们的新Makefile编译程序了：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s try the program before we move on:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，让我们尝试一下程序：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'From the same directory as `loop` and `loop.c`, start GDB with the loop program
    by typing the following (the source code, `loop.c`, is needed to display the code
    within GBD):'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从与`loop`和`loop.c`相同的目录中，通过输入以下内容启动GDB并使用loop程序（需要源代码`loop.c`以在GBD中显示代码）：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You are now presented with some copyright text and version information. Down
    at the bottom, there''s a prompt saying `(gdb)`. This is where we type our commands.
    Let''s run the program and see what happens. We run the program by simply typing
    `run` and hitting *Enter*:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您看到了一些版权文本和版本信息。在底部，有一个提示写着`(gdb)`。这是我们输入命令的地方。让我们运行程序看看会发生什么。我们只需输入`run`并按*Enter*：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That didn''t really tell us much; we could have just run the program directly
    from the terminal. So, this time we set a `include` line. Instead, GDB automatically
    sets it on the first logical place where there is actual code. A breakpoint is
    where the execution should stop in the code so that we''ll have a chance to investigate
    it:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这并没有告诉我们太多；我们本可以直接从终端运行程序。所以，这次我们设置了一个`include`行。相反，GDB会自动将其设置在第一个有实际代码的逻辑位置。断点是执行应该停止的代码位置，这样我们就有机会对其进行调查。
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we can rerun the program. This time the execution will stop at line 6 (the
    breakpoint):'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以重新运行程序。这次执行将在第6行（断点处）停止：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can start watching over the `y` variable using the `watch` command. GDB
    will then tell us every time `y` is updated:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`watch`命令开始监视`y`变量。GDB会告诉我们每次`y`被更新时：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now we can execute the next statement in the code by using the `next` command.
    To avoid having to type `next` every time we want to move forward in the code,
    we can just hit *Enter*. Doing so will make GDB execute the last command. Notice
    the updated `y` variable. Also, notice that we see the code we are executing for
    every step we take:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`next`命令执行代码中的下一条语句。为了避免每次向前移动代码时都要输入`next`，我们可以直接按*Enter*。这样做会让GDB执行上一条命令。注意更新的`y`变量。还要注意到我们每走一步都能看到我们正在执行的代码：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The line of code being displayed is the next statement that is to be executed.
    So, from the previous step, we see that the next line to execute is line 10, which
    is `y = (y*3)-x`. So let''s hit *Enter* here, and that will update the `y` variable,
    and the **watchpoint** will tell us about it:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示的代码行是下一个要执行的语句。所以，从上一步开始，我们看到下一个要执行的是第10行，即`y = (y*3)-x`。所以让我们在这里按*Enter*，这将更新`y`变量，并且**watchpoint**会告诉我们这一点：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Before we go any further, let''s examine the content of the `text` character
    array and the `x` variable. We print the content of variables and arrays with
    the `print` command. Here we see that the `text` array is filled with **null characters**
    after the actual text:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，让我们检查一下`text`字符数组和`x`变量的内容。我们用`print`命令打印变量和数组的内容。在这里我们看到`text`数组在实际文本之后填满了**空字符**：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s continue the execution. After the process has exited in the last step,
    we can exit GDB with `quit`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续执行。在上一步中进程退出后，我们可以使用`quit`退出GDB：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: We've just learned all the basics of GDB. With these commands, we can do a lot
    of debugging. There are a few more things to learn, but we've already come a long
    way.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学会了GDB的所有基础知识。使用这些命令，我们可以进行大量的调试。还有一些东西要学，但我们已经走了很长的路。
- en: We started the GDB program with the `loop` program. To prevent GDB from running
    through the entire program without investigating things, we set a breakpoint using
    the `break` command. In our example, we set the break on a line, using `break
    1`. It's also possible to set a breakpoint on a specific function, such as `main()`.
    We can do this with the `break main` command.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`loop`程序启动了GDB程序。为了防止GDB在不调查情况下运行整个程序，我们使用`break`命令设置了一个断点。在我们的示例中，我们使用`break
    1`在一行上设置了断点。也可以在特定函数上设置断点，比如`main()`。我们可以使用`break main`命令来做到这一点。
- en: Once the breakpoint was in place, we could run the program with `run`. We then
    watched over the `y` variable with `watch`. We executed one statement at a time,
    using the `next` command. We also learned how to print variables and arrays using
    the `print` command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦断点设置好了，我们就可以用`run`命令运行程序。然后我们用`watch`监视`y`变量。我们使用`next`命令逐条执行语句。我们还学会了如何使用`print`命令打印变量和数组。
- en: For all of this to be possible, we had to compile the program with the `-g`
    option to GCC. That enables debugging symbols. But, to see the actual code in
    GDB, we also need the source code file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有这些成为可能，我们必须使用GCC的`-g`选项编译程序。这样可以启用调试符号。但是，为了在GDB中看到实际的代码，我们还需要源代码文件。
- en: There's more…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容…
- en: GDB has some nice built-in help. Start GDB without a program. Then type `help`
    at the `(gdb)` prompt. This will give you a list of different classes of commands.
    If we want to read more about breakpoints, we type `help breakpoints`. This gives
    you a long list of breakpoint commands, for example, `break`. To read more about
    the `break` command, type `help break`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: GDB有一些很好的内置帮助。启动GDB而不加载程序。然后在`(gdb)`提示符下键入`help`。这将给您一个不同类别命令的列表。如果我们想要了解更多关于断点的信息，我们可以键入`help
    breakpoints`。这将给您一个很长的断点命令列表，例如`break`。要了解更多关于`break`命令的信息，键入`help break`。
- en: Stepping inside a function with GDB
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GDB进入函数内部
- en: When we use the `next` command in a program with a function, it will simply
    execute the function and move on. However, there's another command called `step`
    that will enter the function, step through it, and then return to `main()` again.
    In this recipe, we'll examine the difference between `next` and `step`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在具有函数的程序中使用`next`命令时，它将简单地执行该函数并继续。但是，还有另一个命令叫做`step`，它将进入函数，逐步执行它，然后返回到`main()`。在这个示例中，我们将检查`next`和`step`之间的区别。
- en: Knowing how to step into a function with GDB will help you debug an entire program,
    including its functions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用GDB进入函数将帮助您调试整个程序，包括其函数。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need the GDB tool, the GCC compiler, the Makefile we
    wrote in the *Starting GDB* recipe in this chapter, and the Make tool.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您将需要GDB工具、GCC编译器、本章中*Starting GDB*示例中编写的Makefile以及Make工具。
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'In this recipe, we''ll write a small program that has a function. Then, we''ll
    step into that function with GDB, using the `step` command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个包含函数的小程序。然后，我们将使用`step`命令在GDB中进入该函数：
- en: 'Write the following code in a file and save it as `area-of-circle.c`. The program
    takes the radius of a circle as an argument and prints its area:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入文件并保存为`area-of-circle.c`。该程序以圆的半径作为参数，并打印其面积：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Compile the program using the Makefile from the *Starting GDB* recipe:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Starting GDB*示例中的Makefile编译程序：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s try it out before stepping through it with GDB:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用GDB逐步调试之前，让我们尝试一下：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now it''s time to step through the program with GDB. Start GDB with the `area-of-circle`
    program:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候使用GDB逐步执行程序了。使用`area-of-circle`程序启动GDB：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We start by setting a breakpoint at the `main()` function:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在`main()`函数处设置断点：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we run the program. To specify an argument to a program while inside GDB,
    we set the argument at the `run` command:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行程序。在GDB中为程序指定参数，我们在`run`命令中设置参数：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s move ahead one step with the `next` command:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`next`命令向前移动一步：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see from the previous step, the next statement to execute will be
    the `atof()` function. This is a standard library function, so we don''t have
    any debugging symbols or source code for it. Therefore, we can''t see anything
    inside the function. However, we can still step inside it. Once we are inside
    the function, we can let it execute and finish using the `finish` command. This
    will tell us the function''s **return value**, which can be very handy:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一步可以看出，要执行的下一个语句将是`atof()`函数。这是一个标准库函数，所以我们没有任何调试符号或源代码。因此，我们无法看到函数内部的任何东西。但是，我们仍然可以步进到它内部。一旦我们进入函数内部，我们可以让它执行并使用`finish`命令完成。这将告诉我们函数的**返回值**，这可能非常方便：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we do another `next`, which will take us to our `area` function. We want
    to step inside the `area` function, so we use `step` here. This will tell us that
    the value it was called with is 9\. Since there isn''t much left to do inside
    the area function but to return, we can type `finish` to get its return value:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们再次使用`next`，这将带我们到我们的`area`函数。我们想要步进到`area`函数内部，所以我们在这里使用`step`。这将告诉我们它被调用的值是9。由于在`area`函数内部没有太多要做的，只需要返回，我们可以输入`finish`来得到它的返回值：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And now, we can walk through the rest of the program with `next`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`next`来遍历程序的其余部分：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: With the `step` command, we step inside a function. However, functions from
    the standard library don't have any debugging symbols or source code available;
    therefore, we can't see what's happening inside them. If we wanted to, we could
    get the source code and compile it with debugging symbols; Linux is, after all,
    open source.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`step`命令，我们可以步进到一个函数内部。但是，标准库中的函数没有任何调试符号或可用的源代码；因此，我们无法看到它们内部发生了什么。如果我们想要，我们可以获取源代码并使用调试符号进行编译；毕竟，Linux是开源的。
- en: But even when we don't see what's happening inside a function, it can still
    be valuable to step inside them since we can get their return value with `finish`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但即使我们看不到函数内部发生了什么，步进到函数内部仍然是有价值的，因为我们可以使用`finish`得到它们的返回值。
- en: Investigating memory with GDB
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GDB调查内存
- en: With GDB, we can learn more about how things work under the hood, for example,
    strings. A **string** is an array of characters terminated by a null character.
    In this recipe, we'll investigate a character array with GDB and see how the null
    character ends a string.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GDB，我们可以更多地了解事情在幕后是如何工作的，例如字符串。**字符串**是由空字符终止的字符数组。在这个示例中，我们将使用GDB调查一个字符数组，并看看空字符是如何结束一个字符串的。
- en: Knowing how to examine the memory using GDB can be really handy if you encounter
    weird **bugs**. Instead of guessing or looping over each character in C, we can
    directly examine them in GDB.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用GDB检查内存，如果遇到奇怪的**错误**，这将非常方便。我们可以直接在GDB中检查它们，而不是在C中猜测或循环遍历每个字符。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: For this recipe, you'll need the Makefile we wrote in the *Starting GDB* recipe.
    You'll also need the GCC compiler and the Make tool.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您将需要我们在*开始GDB*示例中编写的Makefile。您还需要GCC编译器和Make工具。
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll write a simple program that fills a character array
    with the character *x*. Then we''ll copy a new, shorter string on top of that
    and finally print the string. It''s only the newly copied string that is printed,
    even if all the *x* characters are still there. With GDB, we can confirm this
    fact:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个简单的程序，用字符*x*填充一个字符数组。然后我们将一个新的、较短的字符串复制到上面，最后打印字符串。只有新复制的字符串被打印出来，即使所有的*x*字符仍然存在。使用GDB，我们可以确认这一事实：
- en: 'Write the following code in a file and save it as `memtest.c`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码并将其保存为`memtest.c`：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Compile the program using the Makefile from the *Starting GDB* recipe:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*开始GDB*示例中的Makefile编译程序：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s run it as we would with any other program:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们像运行其他程序一样运行它：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s start GDB with our `memtest` program:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用我们的`memtest`程序启动GDB：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s examine what''s really inside the `text` array using GDB. First,
    we set a breakpoint on `main()`, then we run the program and step forward in the
    program with `next` until after the `strcpy()` function has been executed. Then,
    we examine the `x` command in GDB (`x` for eXamine). We must also tell GDB to
    examine 20 bytes and print the content using decimal notation. The `x` command
    will therefore be `x/20bd text`. To interpret the decimals to characters, see
    the ASCII table we talked about in [*Chapter 2*](B13043_02_Final_SK_ePub.xhtml#_idTextAnchor050),
    *Making Your Programs Easy to Script,* at [https://github.com/PacktPublishing/B13043-Linux-System-Programming-Cookbook/blob/master/ch2/ascii-table.md](https://github.com/PacktPublishing/B13043-Linux-System-Programming-Cookbook/blob/master/ch2/ascii-table.md):'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用GDB检查`text`数组内部的内容。首先，在`main()`上设置一个断点，然后运行程序，并使用`next`在`strcpy()`函数执行后向前步进。然后，在GDB中使用`x`命令进行检查（`x`表示检查）。我们还必须告诉GDB检查20个字节，并使用十进制表示打印内容。因此，`x`命令将是`x/20bd
    text`。要将十进制数解释为字符，请参阅我们在[*第2章*](B13043_02_Final_SK_ePub.xhtml#_idTextAnchor050)中讨论的ASCII表，*使您的程序易于脚本化*，网址为[https://github.com/PacktPublishing/B13043-Linux-System-Programming-Cookbook/blob/master/ch2/ascii-table.md](https://github.com/PacktPublishing/B13043-Linux-System-Programming-Cookbook/blob/master/ch2/ascii-table.md)：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To examine the memory using GDB, we used the `x` command. `20bd` says the size
    we want to read is 20, and we want to present it in groups of bytes (the `b`)
    and print the content using decimal notation (the `d`). With this command, we
    get a nice-looking table that shows us every character in the array printed as
    a decimal number.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GDB检查内存时，我们使用了`x`命令。`20bd`表示我们要读取的大小为20，我们要以字节组的形式（`b`）呈现它，并使用十进制表示打印内容（`d`）。使用这个命令，我们得到了一个漂亮的表格，显示了数组中的每个字符作为一个十进制数打印出来。
- en: The content of the memory—when translated to characters—is `Hello\0xxxxxxxxxxxxxx`.
    The null character separates the *Hello* string from all the *x* characters. There's
    a lot to learn by using GDB and examining the memory during runtime.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 内存的内容——当转换为字符时是`Hello\0xxxxxxxxxxxxxx`。空字符将*Hello*字符串与所有*x*字符分隔开。通过使用GDB并在运行时检查内存，我们可以学到很多东西。
- en: There's more...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Instead of just printing the content as decimal notation, it's also possible
    to print as regular characters (`c`), hexadecimal notation (`x`), floating points
    (`f`), and so on. These letters are the same as for `printf()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以十进制表示形式打印内容之外，还可以以常规字符（`c`）、十六进制表示形式（`x`）、浮点数（`f`）等形式打印。这些字母与`printf()`的用法相同。
- en: See also
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can learn more about how to use the `x` command by typing `help x` while
    inside GDB.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GDB中键入`help x`来了解如何使用`x`命令。
- en: Modifying variables during runtime
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时修改变量
- en: With GDB it's even possible to modify variables during runtime. This can be
    very handy for experimentation. Instead of changing the source code and recompiling
    the program, you can change the variable with GDB and see what happens.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GDB甚至可以在运行时修改变量。这对实验非常方便。您可以使用GDB更改变量，而不是更改源代码并重新编译程序，然后查看发生了什么。
- en: Knowing how to change variables and arrays during runtime can speed up your
    debugging and experimentation phase.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何在运行时更改变量和数组可以加快调试和实验阶段的速度。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need the `memtest.c` program from the previous recipe.
    You'll also need the Makefile from the *Starting GDB* recipe in this chapter,
    the Make tool, and the GCC compiler.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，您需要上一节中的`memtest.c`程序。您还需要本章中*开始使用GDB*配方中的Makefile，Make工具和GCC编译器。
- en: How to do it…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll continue using the program from the previous recipe.
    Here, we''ll replace the **null character** in the sixth place with another character
    and the last character with a null character:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将继续使用上一节的程序。在这里，我们将用另一个字符替换第六个位置的**空字符**，并用一个空字符替换最后一个字符：
- en: 'If you haven''t yet compiled the `memtest` program from the previous recipe,
    do so now:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未编译上一节中的`memtest`程序，请立即这样做：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Start GDB with the `memtest` program you just compiled:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您刚刚编译的`memtest`程序启动GDB：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Start by setting a breakpoint at `main()` and run the program. Step forward
    to just after the `strcpy()` function using `next`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在`main()`处设置断点，然后运行程序。使用`next`向前步进到`strcpy()`函数之后：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Before changing the array, let''s print it first using the `x` command like
    in the previous recipe:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更改数组之前，让我们首先使用`x`命令打印它，就像在上一节中一样：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that we know what the content looks like, we can replace the null character
    at the sixth position—the fifth actually, we start counting from 0—with a `y`.
    We also replace the last position with a null character. Setting `set` command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道内容是什么样的，我们可以用`y`替换第六个位置的空字符（实际上是第五个，我们从0开始计数）。我们还将最后一个位置替换为一个空字符。设置`set`命令：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s continue running the rest of the program. Instead of stepping forward
    with the `next` command one step at a time, we can use the `continue` command
    to let the program run until the end. Notice that the `printf()` function will
    now print the string `Helloyxxxxxxxxxxxxxx`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续运行程序的其余部分。我们可以使用`continue`命令让程序一直运行到结束，而不是使用`next`命令一步步向前。请注意，`printf()`函数现在将打印字符串`Helloyxxxxxxxxxxxxxx`：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Using the `set` command in GDB, we managed to change the content of the `text`
    array during runtime. With the `set` command, we removed the first null character
    and inserted a new one at the end, making it a long valid string. Since we had
    removed the null character after *Hello*, `printf()` then printed the entire string.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GDB中的`set`命令，我们成功在运行时更改了`text`数组的内容。使用`set`命令，我们删除了第一个空字符，并在末尾插入了一个新的字符，使其成为一个长有效的字符串。由于我们在*Hello*后删除了空字符，`printf()`然后打印了整个字符串。
- en: Using GDB on a program that forks
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在分叉程序上使用GDB
- en: Using GDB to debug a program that **forks** will automatically follow the **parent
    process**, just like a regular non-forking program. But it's possible to follow
    the **child process** instead, which is what we will learn in this recipe.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GDB调试**分叉**程序将自动跟踪**父进程**，就像普通的非分叉程序一样。但是也可以跟踪**子进程**，这就是我们将在本节中学习的内容。
- en: Being able to follow the child process is important in debugging since many
    programs spawn child processes. We don't want to limit ourselves to only non-forking
    programs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 能够跟踪子进程在调试中很重要，因为许多程序会产生子进程。我们不想局限于只有非分叉程序。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need the Makefile from the *Starting GDB* recipe in
    this chapter, the Make tool, and the GCC compiler.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，您需要本章中*开始使用GDB*配方中的Makefile，Make工具和GCC编译器。
- en: How to do it…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll write a small program that forks. We''ll put a `for`
    loop inside the child to confirm whether we are inside the child or the parent.
    On the first run in GDB, we''ll run through the program like we usually would.
    This will make GDB follow the parent process. Then, in the next run, we''ll follow
    the child process instead:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个小程序进行分叉。我们将在子进程中放置一个`for`循环，以确认我们是在子进程还是父进程中。在GDB中的第一次运行中，我们将像通常一样运行程序。这将使GDB跟踪父进程。然后，在下一次运行中，我们将跟踪子进程：
- en: 'Write the following code in a file and save it as `forking.c`. The code is
    similar to the `forkdemo.c` program we wrote in [*Chapter 6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245),
    *Spawning Processes and Using Job Control*:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码，并将其保存为`forking.c`。该代码类似于我们在[*第6章*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245)中编写的`forkdemo.c`程序，*生成进程和使用作业控制*：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Compile the program:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s try the program before we run it in GDB:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们在GDB中运行程序之前，让我们先尝试一下：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'On the first run through GDB, we''ll run it like we usually would. This will
    make GDB follow the parent process automatically. Begin with starting GDB with
    the `forking` program:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一次通过GDB运行时，我们将像通常一样运行它。这将使GDB自动跟踪父进程。首先使用`forking`程序启动GDB：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Set the breakpoint at `main()` as usual and run it. Then, we''ll step forward
    with the next command until we see the *Counter in child* text. That will prove
    that we are indeed in the parent process since we never stepped through the `for`
    loop. Also, notice that GDB tells us that the program has forked and detached
    from the child process (meaning we are in the parent process). GDB also prints
    the PID of the child process:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像往常一样，在`main()`设置断点并运行。然后，我们将使用`next`命令向前一步，直到看到*Counter in child*文本。这将证明我们确实在父进程中，因为我们从未通过`for`循环。还要注意，GDB告诉我们程序已经fork并且从子进程中分离（意味着我们在父进程中）。GDB还打印了子进程的PID：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s run through the program again. But this time, we will tell GDB
    to follow the child process instead. Start GDB with the `forking` program as before:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行程序。但是这次，我们会告诉GDB跟随子进程。像之前一样用`forking`程序启动GDB：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Set the breakpoint at `main()` as we did before. After that, we tell GDB to
    follow the child process using the `set` command as we''ve seen before. Only this
    time, we set something called `follow-fork-mode`. We set it to `child`. Then run
    the program as usual:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像之前一样，在`main()`设置断点。之后，我们告诉GDB使用`set`命令跟随子进程，就像之前看到的那样。只是这次，我们设置了一个叫做`follow-fork-mode`的东西。我们将它设置为`child`。然后像往常一样运行程序：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, move forward one step at a time with the `next` command twice. The program
    will now fork, and GDB will tell us that it''s attaching to the child process
    and detaching from the parent process. This means that we are now inside the child
    process:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`next`命令向前移动一步两次。程序现在会fork，并且GDB会告诉我们它正在附加到子进程并且从父进程中分离。这意味着我们现在在子进程中：
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let''s move forward a bit again to see that we end up inside the `for` loop,
    which is inside the child process:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再向前移动一点，看看我们最终进入了子进程中的`for`循环：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下…
- en: With `set follow-fork-mode`, we can tell GDB which process to follow when the
    program forks. This is handy for debugging daemons that fork. You can set `follow-fork-mode`
    to either `parent` or `child`. The default is `parent`. The process that we don't
    follow will continue to run as usual.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`set follow-fork-mode`，我们可以告诉GDB在程序fork时跟随哪个进程。这对于调试fork的守护进程很方便。您可以将`follow-fork-mode`设置为`parent`或`child`。默认值是`parent`。我们不跟随的进程将继续像往常一样运行。
- en: There's more…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There's also `follow-exec-mode`, which tells GDB which process to follow if
    the program calls an `exec()` function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`follow-exec-mode`，它告诉GDB如果程序调用`exec()`函数要跟随哪个进程。
- en: For more information about `follow-exec-mode` and `follow-fork-mode`, you can
    use the `help set follow-exec-mode` and `help set follow-fork-mode` commands inside
    GDB.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`follow-exec-mode`和`follow-fork-mode`的更多信息，您可以在GDB中使用`help set follow-exec-mode`和`help
    set follow-fork-mode`命令。
- en: Debugging programs with multiple threads
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多线程调试程序
- en: It's possible to view threads in a program using GBD and also to jump between
    **threads**. Knowing how to jump between the threads in a program will make threaded
    programs easier to debug. Writing threaded programs can be hard, but with GDB
    it's easier to make sure they are working correctly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GBD可以查看程序中的线程，并且可以在**线程**之间跳转。了解如何在程序中跳转线程将使多线程程序更容易调试。编写多线程程序可能很困难，但使用GDB可以更容易地确保它们正常工作。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll use the `first-threaded.c` program from [*Chapter 11*](B13043_11_Final_SK_ePub.xhtml#_idTextAnchor460),
    *Using Threads in Your Programs*. There's a copy of the source code in this chapter's
    GitHub directory.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用[*第11章*](B13043_11_Final_SK_ePub.xhtml#_idTextAnchor460)中的`first-threaded.c`程序，*在程序中使用线程*。本章的GitHub目录中有源代码的副本。
- en: You'll also need the GCC compiler.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要GCC编译器。
- en: How to do it…
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下…
- en: 'In this recipe, we''ll look at the threads from the `first-threaded.c` program
    using GDB:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用GDB查看`first-threaded.c`程序中的线程：
- en: 'Let''s start by compiling the program:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从编译程序开始：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Before we run the program through the debugger, let''s first run it to recap
    how the program works:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在通过调试器运行程序之前，让我们先运行一下，回顾一下程序的工作方式：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now that we know how the programs works, let''s start it up in GDB:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道程序如何工作，让我们在GDB中启动它：
- en: '[PRE47]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s set a breakpoint at `main()` as we have done previously. Then we run
    it with the same two numbers:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们像之前一样在`main()`设置断点。然后用相同的两个数字运行它：
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we move forward using the `next` command. Once a thread has started, GDB
    will notify us with the text *New thread*:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用`next`命令向前移动。一旦线程启动，GDB会用文本*New thread*通知我们：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now we can print information about the current threads using the `info threads`
    command. Notice that this will also tell us what function the threads are currently
    executing. The number before the word *Thread* on each line is GDB''s thread ID:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`info threads`命令打印当前线程的信息。注意这也会告诉我们线程当前正在执行的函数。每行上单词*Thread*前面的数字是GDB的线程ID：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, let''s switch over to thread number 3, which is currently executing the
    `isprime` function. We switch threads with the `thread` command:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们切换到当前执行`isprime`函数的第3个线程。我们使用`thread`命令切换线程：
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'While inside the thread, we can print the content of variables, move forward
    using the `next` command, and so on. Here we also see that the other thread is
    starting:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在线程内部，我们可以打印变量的内容，使用`next`命令向前移动等。在这里我们还看到另一个线程正在启动：
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How it works…
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下…
- en: Just like we could follow a child process, we can follow a thread. It's a bit
    of a different approach with threads, but still. Once each thread started, GDB
    notified us about it. We could then print information about the currently running
    threads using the `info threads` command. That command gave us a thread ID for
    each thread, its address, and what frame or function it was currently on. We then
    jumped to thread 3 using the `thread` command. Once we were inside the thread,
    we could print the content of the `number` and `j` variables, move forward in
    the code, and so on.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以跟踪子进程一样，我们也可以跟踪线程。虽然处理线程的方法有些不同，但仍然可以。每个线程启动后，GDB会通知我们。然后我们可以使用`info threads`命令打印有关当前运行线程的信息。该命令为每个线程提供了一个线程ID、其地址以及当前所在的帧或函数。然后我们使用`thread`命令跳转到线程3。一旦我们进入线程，我们就可以打印`number`和`j`变量的内容，向代码中前进等等。
- en: There's more…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are more things you could do with threads in GDB. To find more commands
    regarding threads, you can use the following commands inside GDB:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在GDB中，还有更多关于线程的操作。要查找有关线程的更多命令，可以在GDB中使用以下命令：
- en: '`help thread`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help thread`'
- en: '`help info threads`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help info threads`'
- en: See also
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There's a lot of information about GDB at [https://www.gnu.org/software/gdb](https://www.gnu.org/software/gdb),
    so check it out for more in-depth information.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 关于GDB还有很多信息在[https://www.gnu.org/software/gdb](https://www.gnu.org/software/gdb)，所以可以查看更深入的信息。
- en: Finding a simple memory leak with Valgrind
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Valgrind查找简单的内存泄漏
- en: '**Valgrind** is a neat program for finding **memory leaks** and other memory-related
    bugs. It can even tell you if you put too much data inside an allocated memory
    area. These can all be hard bugs to find without a tool like Valgrind. Even if
    a program leaks memory or puts too much data in a memory area, it can still run
    fine for a long time. That''s what makes those bugs so hard to find. But with
    Valgrind, we can check the program for all sorts of memory-related problems.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**Valgrind**是一个很棒的程序，可以找到**内存泄漏**和其他与内存相关的错误。它甚至可以告诉你是否在分配的内存区域中放入了太多数据。这些都是很难在没有Valgrind这样的工具的情况下找到的错误。即使程序泄漏内存或者在内存区域中放入了太多数据，它仍然可以长时间正常运行。这就是这些错误如此难以找到的原因。但是有了Valgrind，我们可以检查程序是否存在各种与内存相关的问题。'
- en: Getting started
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: For this recipe, you'll need the Valgrind tool installed on your computer. If
    you haven't already installed it, you can follow the instructions listed in the
    *Technical requirements* section of this chapter.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您需要在计算机上安装Valgrind工具。如果您还没有安装它，可以按照本章的*技术要求*部分中列出的说明进行操作。
- en: You'll also need the Make tool, the GCC compiler, and the Makefile from the
    *Starting GDB* recipe.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要Make工具、GCC编译器和*开始使用GDB*示例中的Makefile。
- en: How to do it…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll write a program that allocates memory using `calloc()`
    but never frees it with `free()`. We then run the program through Valgrind and
    see what it says about it:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个使用`calloc()`分配内存但从未使用`free()`释放的程序。然后我们通过Valgrind运行程序，看看它对此有何说法：
- en: 'Write the following program and save it as `leak.c`. First, we create a pointer
    to a character. Then we allocate 20 bytes of memory using `calloc()` and return
    its address to `c`. Then we copy a string into that memory and print the content
    using `printf()`. However, we never free the memory using `free()`, which we always
    should:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下程序，并将其保存为`leak.c`。首先，我们创建一个指向字符的指针。然后，我们使用`calloc()`分配了20个字节的内存，并将其地址返回给`c`。然后我们将一个字符串复制到该内存中，并使用`printf()`打印内容。但是，我们从未使用`free()`释放内存，这是我们应该始终要做的：
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Compile the program:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE54]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'First, we run the program as we normally would. Everything works just fine:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们像平常一样运行程序。一切都很顺利：
- en: '[PRE55]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we run the program through Valgrind. Under `HEAP SUMMARY`, it will tell
    us that there are 20 bytes still allocated when the program exits. Under `LEAK
    SUMMARY`, we also see that there are 20 bytes *definitely lost*. What this means
    is that we forgot to free the memory using `free()`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过Valgrind运行程序。在`HEAP SUMMARY`下，它会告诉我们程序退出时仍有20个字节被分配。在`LEAK SUMMARY`下，我们还看到有20个字节*明确丢失*。这意味着我们忘记使用`free()`释放内存：
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Open up `leak.c` and add `free(c);` just before `return 0;`. Then, recompile
    the program.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`leak.c`，在`return 0;`之前添加`free(c);`。然后重新编译程序。
- en: 'Rerun the program in Valgrind. This time, there won''t be any bytes lost or
    in use when the program exits. We also see that there have been two allocations,
    and they were both freed:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Valgrind中重新运行程序。这次，程序退出时不会有任何丢失或使用的字节。我们还看到有两个分配，并且它们都已被释放：
- en: '[PRE57]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works…
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The reason Valgrind said we had two allocations even though we only allocated
    one block of memory is that other functions in the program have allocated memory.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind说我们有两个分配的原因是，尽管我们只分配了一个内存块，程序中的其他函数也分配了内存。
- en: At the end of the output from Valgrind, we also saw the text *All heap blocks
    were freed*, meaning we have freed all memory using `free()`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在Valgrind的输出末尾，我们还看到了文本*所有堆块都已被释放*，这意味着我们已经使用`free()`释放了所有内存。
- en: Valgrind doesn't strictly require debugging symbols; we can test just about
    any program for memory leaks. For example, we can run `valgrind cat leak.c`, and
    Valgrind will check `cat` for memory leaks.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind并不严格要求调试符号；我们可以测试几乎任何程序是否存在内存泄漏。例如，我们可以运行`valgrind cat leak.c`，Valgrind将检查`cat`是否存在内存泄漏。
- en: See also
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There's a lot more you can do with Valgrind. Check out its manual page with
    `man valgrind`. There's also a lot of useful information at [https://www.valgrind.org](https://www.valgrind.org).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind还有很多其他用途。查看其手册页面，使用`man valgrind`。还有很多有用的信息在[https://www.valgrind.org](https://www.valgrind.org)上。
- en: Finding buffer overflows with Valgrind
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Valgrind查找缓冲区溢出
- en: Valgrind can also help us find **buffer overflows**. That is when we put more
    data in a buffer than it can hold. Buffer overflows are the cause of many security
    bugs and are hard to detect. But with Valgrind, it gets a little easier. It might
    not be 100% accurate at all times, but it's a really good help along the way.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind还可以帮助我们找到**缓冲区溢出**。当我们在缓冲区中放入的数据超过其容量时，就会发生缓冲区溢出。缓冲区溢出是许多安全漏洞的原因，很难检测到。但是有了Valgrind，情况会变得稍微容易一些。它可能并非始终100%准确，但在一路上确实是一个很好的帮助。
- en: Knowing how to find buffer overflows will make your program more secure.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何找到缓冲区溢出将使您的程序更加安全。
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need the GCC compiler, the Make tool, and the Makefile
    from the *Starting GDB* recipe in this chapter.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您将需要GCC编译器，Make工具以及本章中*开始GDB*示例中的Makefile。
- en: How to do it…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll write a small program that copies too much data into
    a buffer. We''ll then run the program through Valgrind and see how it points out
    the problem:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个小程序，将过多的数据复制到缓冲区中。然后我们将通过Valgrind运行程序，看看它如何指出问题：
- en: 'Write the following code in a file and save it as `overflow.c`. The program
    allocates 20 bytes with `calloc()`, then copies a string of 26 bytes into that
    buffer. It then frees up the memory using `free()`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码，并将其保存为`overflow.c`。程序使用`calloc()`分配了20个字节，然后将一个26个字节的字符串复制到该缓冲区中。然后使用`free()`释放内存：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Compile the program:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'First, we run the program like we normally would. Most likely, we won''t see
    any problems with it. It will just work. That''s why these kinds of bugs are so
    hard to find:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们像平常一样运行程序。很可能，我们不会看到任何问题。它会正常工作。这就是为什么这种类型的错误很难找到的原因：
- en: '[PRE60]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, let''s run the program through Valgrind and see what it has to say about
    it:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们通过Valgrind运行程序，看看它对此有何看法：
- en: '[PRE61]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Since the program writes data outside of the allocated memory, Valgrind will
    detect it as invalid writes and invalid reads. We can even follow how many bytes
    are written after the allocated memory and its addresses. This will make it even
    easier to find the problem in the code. We might have allocated several buffers,
    but here we clearly see that it's the buffer of 20 bytes that's overflowed.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序在分配的内存之外写入数据，Valgrind将检测到它为无效写入和无效读取。我们甚至可以跟踪分配内存后写入了多少字节及其地址。这将使在代码中找到问题变得更容易。我们可能已经分配了几个缓冲区，但在这里我们清楚地看到，溢出的是20个字节的缓冲区。
- en: There's more...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For a more detailed output, you can add `-v` to Valgrind, for example, `valgrind
    -v ./overflow`. This will output several pages of detailed output.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更详细的输出，您可以在Valgrind中添加`-v`，例如，`valgrind -v ./overflow`。这将输出几页详细的输出。
