- en: Shell Scripting and SQL Data Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell脚本和SQL数据管理
- en: In the last chapter, we covered a wide array of security features that are available
    in the Linux environment. First, we discussed executing commands with root privileges.
    We then moved on to TCP wrappers, focusing on the `/etc/hosts.allow` and `/etc/hosts.deny`
    files. Next, we covered SSH; we looked at setting up SSH access between a client
    and a server. Finally, we covered encryption in depth.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们涵盖了Linux环境中可用的各种安全功能。首先，我们讨论了以root权限执行命令。然后，我们转向TCP包装，重点放在`/etc/hosts.allow`和`/etc/hosts.deny`文件上。接下来，我们涵盖了SSH；我们看了如何在客户端和服务器之间设置SSH访问。最后，我们深入讨论了加密。
- en: In this chapter, the final chapter of this book—we will be covering the basics
    of shell scripting and SQL management. First, we will look at the syntax for writing
    a shell script; this will be followed by writing scripts with various loops, such
    as the `for` and `while` loops. Next, we will cover writing shell scripts using
    `if` statements. Finally, we will finish this chapter (and book) by covering the
    basics of SQL management.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，也是本书的最后一章，我们将涵盖Shell脚本和SQL管理的基础知识。首先，我们将看一下编写shell脚本的语法；然后是使用各种循环编写脚本，比如`for`和`while`循环。接下来，我们将涵盖使用`if`语句编写shell脚本。最后，我们将通过涵盖SQL管理的基础知识来结束本章（和本书）。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Shell scripting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell脚本
- en: SQL data management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL数据管理
- en: Shell scripting
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell脚本
- en: In this section, we will cover shell scripting, starting with the basics and
    moving on to writing scripts using loops and `if` statements.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖shell脚本，从基础知识开始，然后转向使用循环和`if`语句编写脚本。
- en: 'The following topics will be covered in this section:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下主题将在本节中涵盖：
- en: The basics of shell scripting
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell脚本的基础知识
- en: Writing scripts using `for` loops
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for`循环编写脚本
- en: Writing scripts using `while` loops
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`while`循环编写脚本
- en: Writing scripts using `if` statements
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if`语句编写脚本
- en: The basics of shell scripting
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell脚本的基础知识
- en: 'On the command line, we often work with a series of the same commands on a
    regular basis. It would be ideal to somehow bundle those commands and simplify
    the process, executing a single command or script to accomplish an overall objective
    that would take longer if we had to type out a single command repetitively. This
    is where shell scripting shines. We can place our commands, regardless of how
    long they may be, into a single file; give it an appropriate name; and execute
    the script as needed. The following code shows the basic syntax for creating a
    shell script:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上，我们经常需要定期执行一系列相同的命令。将这些命令捆绑在一起并简化这个过程，执行单个命令或脚本来完成一个需要重复输入单个命令的整体目标将是理想的。这就是shell脚本的优势所在。我们可以将我们的命令，无论有多长，放入一个单独的文件中；给它一个合适的名称；并根据需要执行脚本。以下代码显示了创建shell脚本的基本语法：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding command is the first line in the script; it is used to define
    the shell interpreter. The first characters, `#!`, are often known as shebang,
    sha-bang, hashbang, pound-bang, or hash-pling. The `/bin/sh` object defines which
    interpreter should be used for this script; in this case, it''s the Shell Command
    Language (`sh`). Another popular interpreter that you are bound to see is the
    following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令是脚本中的第一行；它用于定义shell解释器。前面的字符`#!`通常被称为shebang、sha-bang、hashbang、pound-bang或hash-pling。`/bin/sh`对象定义了应该使用哪个解释器来运行这个脚本；在这种情况下，它是Shell命令语言（`sh`）。另一个常见的解释器是：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is similar to the previous declaration, in that we have `#!`, which indicates
    that we are going to define the shell interpreter to use; in this case, we''re
    using the Bourne Again Shell, or Bash. This shell offers more extensions that
    the regular `sh` shell; in fact, most newer Linux distributions are ported with
    Bash as a defacto shell. We can easily identify which shell is in play by issuing
    the following command in the Terminal:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这与先前的声明类似，我们有`#!`，这表明我们将定义要使用的shell解释器；在这种情况下，我们使用的是Bourne Again Shell，或者说是Bash。这个shell提供了比常规的`sh`
    shell更多的扩展；事实上，大多数较新的Linux发行版都默认使用Bash作为shell。我们可以通过在终端中输入以下命令来轻松识别正在使用的shell：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Awesome! The environment variable, `SHELL`, stores the current shell; the value
    returned indicates that we are running the bash shell. Another way to identify
    the shell is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！环境变量`SHELL`存储当前的shell；返回的值表明我们正在运行bash shell。另一种识别shell的方法如下：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Excellent! The bash shell is being used. Also, we can use the `ps` command
    to display the current shell, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！正在使用bash shell。此外，我们可以使用`ps`命令来显示当前的shell，如下所示：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Awesome! For our purposes, we will be using `#!/bin/bash` for written scripts.
    To begin writing your very first script, open a text editor, such as vi or nano,
    and enter the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！对于我们的目的，我们将使用`#!/bin/bash`来编写脚本。要开始编写你的第一个脚本，打开一个文本编辑器，比如vi或nano，然后输入以下内容：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/00169.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00169.jpeg)'
- en: 'Excellent! We have our declaration in the first line; we''ve defined the `/bin/bash`
    shell. Next, we have two lines that begin with a `#` symbol. Any line (other than
    the first line at the top) is referred to as a comment. That being said, the last
    two lines are comments. We can prove this by saving our script; we can use `:wq`,
    which will save and exit our script, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们在第一行中有我们的声明；我们定义了`/bin/bash` shell。接下来，我们有两行以`#`符号开头。除了顶部的第一行之外的任何行都被称为注释。也就是说，最后两行是注释。我们可以通过保存我们的脚本来证明这一点；我们可以使用`:wq`，这将保存并退出我们的脚本，如下所示：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![](img/00170.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00170.jpeg)'
- en: 'Excellent! We''ve used `+x`, which turns on the execute bit for the user, group,
    and others; also, the script''s name has been changed to the color green, to indicate
    that the file is now executable. In order to run this script, we use the following
    commands:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们使用了`+x`，它为用户、组和其他人打开了执行位；此外，脚本的名称已更改为绿色，表示该文件现在可执行。要运行此脚本，我们使用以下命令：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Awesome! The script was executed; however, the contents were not displayed.
    This is due to the fact that we''ve only defined comments so far; we have not
    defined anything else inside of our script. Let''s make our script display a short
    message. Open the script using either vi or nano, and enter the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！脚本被执行了；但是内容没有显示。这是因为到目前为止我们只定义了注释；在脚本内部还没有定义其他内容。让我们让我们的脚本显示一条简短的消息。使用vi或nano打开脚本，输入以下内容：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Awesome! We''ve added our first command to be executed: the `echo` command.
    This will simply respond with whatever is passed, as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经添加了要执行的第一个命令：`echo`命令。这将简单地回复传递的内容，如下所示：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Excellent! We''ve successfully written our very first script. Let''s add another
    command, to illustrate the effectiveness of scripting; we''ll add the `date` command,
    which will provide the date whenever we execute our script, as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们成功地编写了我们的第一个脚本。让我们添加另一个命令，以说明脚本的有效性；我们将添加`date`命令，每次执行脚本时都会提供日期，如下所示：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Wonderful! We now have two commands that are executed every time our script
    runs. In addition to sending output to the display, we can carry out other tasks.
    For instance, we can create an archive file; let''s create a `.tar` file of the `/home/philip/Downloads`
    directory for illustration, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在有两个命令，每次运行脚本时都会执行。除了将输出发送到显示器，我们还可以执行其他任务。例如，我们可以创建一个归档文件；让我们以创建`/home/philip/Downloads`目录的`.tar`文件为例，如下所示：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code, we used the `tar` command to create an archive of the
    `/home/philip/Downloads` directory. Now, we can run the script to see the results,
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用`tar`命令创建了`/home/philip/Downloads`目录的归档。现在，我们可以运行脚本来查看结果，如下所示：
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Excellent! Our script was successful, and an archive was created with the `.tar`
    extension. Additionally, we can create a script that takes input from the user,
    using the `read` command. Let''s create another script and name it `input.sh`,
    using vi or nano, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的脚本成功了，并且创建了一个扩展名为`.tar`的归档文件。此外，我们可以创建一个从用户那里获取输入的脚本，使用`read`命令。让我们创建另一个脚本，命名为`input.sh`，使用vi或nano，如下所示：
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Awesome! We''ve created an `input.sh` script; we''ve used the `read` command
    to store the input from the user. The value stored in the name is called a variable.
    It is displayed in the last line, by adding a `$` in front of the variable''s
    name. The result of the script is shown as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们创建了一个`input.sh`脚本；我们使用`read`命令来存储用户的输入。存储在`name`中的值称为变量。通过在变量名前面加上`$`来显示它在最后一行中。脚本的结果如下所示：
- en: '![](img/00171.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00171.jpeg)'
- en: 'The prompt is paused until we enter something; we will enter a name and look
    at the results, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 提示会暂停，直到我们输入内容；我们将输入一个名字并查看结果，如下所示：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Excellent! The name that we entered was appended to the last line. Another
    way that we can define a variable is by using the following syntax:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们输入的名字被添加到了最后一行。我们还可以通过以下语法来定义变量：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we give the variable a name, and then specify a value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们给变量命名，然后指定一个值。
- en: 'Let''s create a new script named `myvar.sh`, using either vi or nano. The following
    code shows how we can define a variable using a new script:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`myvar.sh`的新脚本，使用vi或nano。以下代码显示了如何使用新脚本定义变量：
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Awesome! We defined a variable, `OUR_VAR`, and we gave it the value, `Philip
    Inshanally`; this was then called inside of the `echo` command, by placing a `$`
    symbol in front of the variable name. As you can see, there are various ways to
    define a variable. The variable value needs to be enclosed in parentheses whenever
    there is a space between the words. If there is only a single word, or numbers,
    you do not have to enclose the value in parentheses.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们定义了一个变量`OUR_VAR`，并给它赋值`Philip Inshanally`；然后在`echo`命令中调用它，通过在变量名前面放置`$`符号。正如你所看到的，有多种定义变量的方式。当单词之间有空格时，变量值需要用括号括起来。如果只有一个单词或数字，就不需要用括号括起来。
- en: Do not enclose a single word or a number in parentheses.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 不要用括号括住单词或数字。
- en: Writing scripts using for loops
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用for循环编写脚本
- en: 'It is possible to write out each command in a script line by line, which can
    be cumbersome at times. We can achieve the same objective by using loops, which
    execute based on an expression being met, generating the commands for us. The
    basic syntax of a `for` loop is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，逐行在脚本中写出每个命令可能会很麻烦。我们可以通过使用循环来实现相同的目标，根据满足的表达式执行命令。`for`循环的基本语法如下：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first line defines a condition and, once the condition is met, we have
    a series of commands. To see this in action, let''s create a script, called `myForLoop.sh`,
    using either vi or nano:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了一个条件，一旦条件满足，我们就有一系列命令。为了看到这个过程，让我们创建一个脚本，名为`myForLoop.sh`，使用vi或nano：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Awesome! The line that begins with `for o in {1..10}` defines how many times
    we would like to execute the `for` loop; it will be executed 10 times. The command
    under the `do` section is the command that will be executed; the `$o` is the variable
    that was defined in the `for` section. The result will be as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！以`for o in {1..10}`开头的行定义了我们想要执行`for`循环的次数；它将被执行10次。`do`部分下的命令是将要执行的命令；`$o`是在`for`部分中定义的变量。结果如下：
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Excellent! This condition can also be written in the following format:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这个条件也可以用以下格式来写：
- en: '[PRE21]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Awesome! We wrote the values, separated by spaces, and the script was successful.
    We can also specify the condition in three parts, similar to the C programming
    language, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们写下了用空格分隔的值，脚本成功了。我们还可以像C编程语言一样，用三个部分指定条件，如下所示：
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Excellent! In the preceding code, the `for ((p=1; p<=6; p++))` line defines
    a variable and assigns it a value of `p=1;` the `p<=6` checks for the condition,
    and the `p++` means to increment the value of the variable as long as the condition
    is met.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！在上述代码中，`for ((p=1; p<=6; p++))`行定义了一个变量并为其赋值`p=1;`，`p<=6`检查条件，`p++`表示只要条件满足就递增变量的值。
- en: Writing scripts using the while loop
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用while循环编写脚本
- en: 'Another popular loop that can be used in scripting is the `while` loop. The
    basic syntax of a `while` loop is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在脚本中可以使用的流行循环是`while`循环。`while`循环的基本语法如下：
- en: '[PRE23]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, we specify a condition, and, as long as the condition
    is met, the loop will be executed.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们指定一个条件，只要条件满足，循环就会被执行。
- en: 'Create a script named `myWhile.sh`, using either vi or nano, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用vi或nano创建一个名为`myWhile.sh`的脚本，如下所示：
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Excellent! First, we defined a variable, `d=1`, and we then specified a condition,
    `(( $d <= 8 ))`, which checks whether the variable, `d`, is less than or equal
    to `8`; following this, we are using the `echo` command to provide the text, based
    on the condition. The last part, `d=$(( d+1 ))`, will increment the variable after
    each condition is met, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！首先，我们定义了一个变量，`d=1`，然后我们指定了一个条件，`(( $d <= 8 ))`，它检查变量`d`是否小于或等于`8`；随后，我们使用`echo`命令根据条件提供文本。最后一部分，`d=$((
    d+1 ))`，将在满足每个条件后递增变量，如下所示：
- en: '[PRE25]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Awesome! Another technique that can be used for a condition is `:`, used after
    the `while` statement. The `:` will always be `True`; this means that the loop
    will not end until we end the script, using *Ctrl* + *C*. Let''s create another
    script, named `infinite.sh`, using either vi or nano, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！用于条件的另一种技术是在`while`语句之后使用`:`。`:`将始终为`True`；这意味着循环直到我们使用*Ctrl* + *C*结束脚本才会结束。让我们使用vi或nano创建另一个名为`infinite.sh`的脚本，如下所示：
- en: '[PRE26]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'A prompt will appear, allowing us to type anything; as soon as we press the
    *Enter* key, another message will be displayed, including whatever we typed. This
    will continue infinitely, until we exit the script using *Ctrl* + *C*, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 会出现提示，允许我们输入任何内容；一旦我们按下*Enter*键，将显示另一条消息，包括我们输入的任何内容。这将无限继续，直到我们使用*Ctrl* + *C*退出脚本，如下所示：
- en: '[PRE27]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Awesome! The script did not quit until we used the *Ctrl* + *C* combination.
    Another way to illustrate the effectiveness of the `while` loop is to look for
    a string before the script exits. Create another script, named `whileString.sh`,
    using either vi or nano, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！脚本直到我们使用*Ctrl* + *C*组合键才退出。展示`while`循环有效性的另一种方法是在脚本退出前查找一个字符串。使用vi或nano创建另一个名为`whileString.sh`的脚本，如下所示：
- en: '[PRE28]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Awesome! We declared a variable, `someString=begin`; this can be any value
    that you choose. Next, we checked for a condition, `[ "$someString" != "quit"
    ]`, which looks for the `quit` string. As long as the string is not `quit`, the
    script will keep running infinitely, until we type `quit` or press *Ctrl* + *C*,
    which will exit the script, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们声明了一个变量，`someString=begin`；这可以是您选择的任何值。接下来，我们检查了一个条件，`[ "$someString"
    != "quit" ]`，它寻找`quit`字符串。只要字符串不是`quit`，脚本将无限运行，直到我们输入`quit`或按下*Ctrl* + *C*退出脚本，如下所示：
- en: '[PRE29]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Excellent! We could keep entering text, and the script would continue to run,
    unless we entered quit or pressed *Ctrl* + *C*, which would exit the script.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们可以继续输入文本，脚本将继续运行，除非我们输入quit或按下*Ctrl* + *C*，这将退出脚本。
- en: Notice that we used square brackets ([]) to enclose the text; the script would
    not work with the regular parantheses (()) when testing for a string value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用方括号([])括住文本；当测试字符串值时，脚本将无法使用常规括号(())。
- en: Writing scripts using if statements
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用if语句编写脚本
- en: 'We can use `if` statements in scripting, in order to test a condition. The
    basic syntax of an `if` statement is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在脚本中使用`if`语句来测试条件。`if`语句的基本语法如下：
- en: '[PRE30]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can create a simple `if` script, using the preceding code as guidance. Sometimes,
    we may need to use double square brackets, which offer enhancements over the older,
    single-bracket style. Let''s create a script named `myif.sh`, using vi or nano, as
    follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个简单的`if`脚本，使用上述代码作为指导。有时，我们可能需要使用双方括号，它们比旧的单方括号样式提供了增强功能。让我们使用vi或nano创建一个名为`myif.sh`的脚本，如下所示：
- en: '[PRE31]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We used the `echo` command to display a welcome message; we then used `if [[
    $1 == 4 ]]; then`; this statement is checking for `4`. The script executed; however,
    we did not see the `echo` command inside of the `if` statement being executed.
    In order to see the message inside of the `if` statement, we have to type a value
    when we run our script, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`echo`命令显示欢迎消息；然后我们使用`if [[ $1 == 4 ]]; then`；此语句正在检查`4`。脚本被执行；但是我们没有看到`if`语句内的`echo`命令被执行。为了看到`if`语句内的消息，我们必须在运行脚本时输入一个值，如下所示：
- en: '[PRE32]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Wonderful; the statement inside of the `if` construct was executed, but, if
    we passed any value other than `4`, we would see the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了；`if`结构内的语句被执行，但是，如果我们传递的值不是`4`，我们将看到以下内容：
- en: '[PRE33]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The command inside of the `if` statement was not executed, due to the fact
    that the value that we passed is not equal to the value being checked against.
    We can add another bit to the `if` statement, to handle an alternate response;
    we can use the `else` clause. The following is the syntax of the `else` clause
    that is injected into the `if` statement:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们传递的值不等于被检查的值，`if`语句内的命令没有被执行。我们可以在`if`语句中添加另一个部分来处理另一个响应；我们可以使用`else`子句。以下是注入到`if`语句中的`else`子句的语法：
- en: '[PRE34]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can edit our `my.sh` script, using either vi or nano, and add an `else`
    clause to handle any alternate responses, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用vi或nano编辑我们的`my.sh`脚本，并添加一个`else`子句来处理任何其他响应，如下所示：
- en: '[PRE35]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Awesome! We can run our script with the `else` clause injected; the result
    will be as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们可以运行注入了`else`子句的脚本，结果如下：
- en: '[PRE36]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Excellent! We''re shown a different message whenever the user enters a value
    other than `4`. Furthermore, we can nest an `if` statement inside of another `if`
    statement. The basic syntax for nesting `if` statements is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！当用户输入除`4`以外的值时，我们会看到不同的消息。此外，我们可以在另一个`if`语句中嵌套一个`if`语句。嵌套`if`语句的基本语法如下：
- en: '[PRE37]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can edit our `myif.sh` script, using either vi or nano, and add a second
    `elif` statement, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编辑我们的`myif.sh`脚本，使用vi或nano，并添加第二个`elif`语句，如下所示：
- en: '[PRE38]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We''ve added `elif [[ $1 == 2 ]]; then`, which checks for the value `2`. Once
    this condition is met, a message will be displayed, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了`elif [[ $1 == 2 ]]; then`，它检查值`2`。一旦满足此条件，将显示一条消息，如下所示：
- en: '[PRE39]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Excellent! We can see that when we enter a value that matches the `elif` condition,
    the command under the `elif` condition is executed. Additionally, when we enter
    a value that does not match either the `if` or `elif` condition, a catch-all message
    is displayed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们可以看到当我们输入与`elif`条件匹配的值时，`elif`条件下的命令将被执行。此外，当我们输入与`if`或`elif`条件都不匹配的值时，将显示一个全捕获消息。
- en: 'It is also possible to test multiple conditions on a single `if` statement
    or `elif` statement. Let''s edit our `myif.sh`, using vi or nano, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在单个`if`语句或`elif`语句上测试多个条件。让我们使用vi或nano编辑我们的`myif.sh`，如下所示：
- en: '[PRE40]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the preceding code, we''ve added a second condition in the `if` statement;
    namely, `if [[ $1 == 4 ]] || [[ $1 == 3 ]] ; then`. The || means *or*. This is
    checking for either condition to be met, and the command will be executed under
    the `if` statement, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们在`if`语句中添加了第二个条件；即`if [[ $1 == 4 ]] || [[ $1 == 3 ]] ; then`。`||`表示*或*。这是检查是否满足任一条件，并且命令将在`if`语句下执行，如下所示：
- en: '[PRE41]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Excellent! Once either condition is met in the `if` clause, the command is
    executed under the `if` clause. Additionally, there is the `&&` command, used
    for comparing conditions; this means that both conditions must be met. We can
    quickly edit our `myif.sh` script and add in `&&`, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！一旦`if`子句中满足任一条件，命令就会在`if`子句下执行。此外，还有`&&`命令，用于比较条件；这意味着必须满足两个条件。我们可以快速编辑我们的`myif.sh`脚本，并添加`&&`，如下所示：
- en: '[PRE42]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When the user enters `2`, the `elif` condition will be met; this is due to
    the fact that both conditions need to be true. If the user enters any value other
    than `2`, the catch-all `else` clause will be executed as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入`2`时，将满足`elif`条件；这是因为两个条件都需要为真。如果用户输入除`2`以外的任何值，将执行全捕获`else`子句，如下所示：
- en: '[PRE43]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Excellent! Both conditions were met in the `elif` clause, resulting in the command
    being executed under the `elif` clause.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！`elif`子句中满足了两个条件，导致命令在`elif`子句下执行。
- en: SQL data management
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL数据管理
- en: '**Structured Query Language** (**SQL**) is a well-known language used for database
    manipulation. There are various versions of SQL. We will be working with an open
    standard of MySQL: the `mysql-community-server` package. First, we will need the
    MySQL `YUM` repository in our Fedora 28 system; we will use the `dnf` command,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构化查询语言**（**SQL**）是用于数据库操作的一种广为人知的语言。有各种版本的SQL。我们将使用MySQL的开放标准：`mysql-community-server`软件包。首先，我们需要在我们的Fedora
    28系统中安装MySQL `YUM`存储库；我们将使用`dnf`命令，如下所示：'
- en: '[PRE44]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Awesome! The repository was successfully installed. Now, we will install the
    server, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！存储库已成功安装。现在，我们将安装服务器，如下所示：
- en: '[PRE45]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding code, some output has been omitted for brevity. The package
    is going to take up over 1 GB in space; the time it will take to download will
    vary, depending on your internet connection. The progress will look as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，为了简洁起见，省略了一些输出。该软件包将占用超过1GB的空间；下载所需的时间将根据您的互联网连接而有所不同。进度将如下所示：
- en: '![](img/00172.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00172.jpeg)'
- en: 'After some time, we will see the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 过一段时间，我们将看到以下内容：
- en: '[PRE46]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Excellent! The next step is to enable the `mysqld` service; we will use the
    `systemctl` command, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！下一步是启用`mysqld`服务；我们将使用`systemctl`命令，如下所示：
- en: '[PRE47]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![](img/00173.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00173.jpeg)'
- en: 'Awesome! The `mysqld.service` was started successfully. During the installation,
    a random `root` password for the `mysql` server was generated; we have to look
    inside of the `/var/log/mysqld.log` file, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！`mysqld.service`已成功启动。在安装过程中，为`mysql`服务器生成了一个随机的`root`密码；我们必须查看`/var/log/mysqld.log`文件中的内容，如下所示：
- en: '[PRE48]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The random password for the `root` of the `mysql` is `#a7RCyoyzwOF`. Finally,
    we should secure our `mysql` database; we will use the `mysql_secure_installation`
    command, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`mysql`的`root`的随机密码是`#a7RCyoyzwOF`。最后，我们应该保护我们的`mysql`数据库；我们将使用`mysql_secure_installation`命令，如下所示：'
- en: '[PRE49]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'First, we have to enter the random password; then, we have to set a new password,
    as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须输入随机密码；然后，我们必须设置一个新密码，如下所示：
- en: '[PRE50]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `validate_password` plugin is installed by default; this sets the password
    specifications. We will have to enter a password that is a combination that consists
    of at least one uppercase character, one lowercase character, one digit, and one
    special character. The total password length must be at least eight characters,
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，安装了`validate_password`插件；这设置了密码规范。我们必须输入一个密码，该密码由至少一个大写字符、一个小写字符、一个数字和一个特殊字符组成。总密码长度必须至少为八个字符，如下所示：
- en: '[PRE51]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'By default, an anonymous user account is generated; we will select `y` to remove
    it and continue:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，会生成一个匿名用户帐户；我们将选择`y`来删除它并继续：
- en: '[PRE52]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will allow the `root` user to log in remotely, so we will press a key, and
    this step will be skipped, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将允许`root`用户远程登录，因此我们将按下一个键，这一步将被跳过，如下所示：
- en: '[PRE53]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `mysql` is now more secure, as compared to the default installation. We
    can now log in to the `mysql` database using the `mysql` command, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与默认安装相比，`mysql`现在更安全了。我们现在可以使用`mysql`命令登录`mysql`数据库，如下所示：
- en: '[PRE54]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Excellent! We will now create our first database; we will use the `create database`
    command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在将创建我们的第一个数据库；我们将使用`create database`命令：
- en: '[PRE55]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Awesome! We will now create a user that can access our database; we will use
    the `create user` command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在将创建一个可以访问我们数据库的用户；我们将使用`create user`命令：
- en: '[PRE56]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the preceding code, once again, the password requirements are not being
    met; we can remedy this by either lowering the settings or removing the `validate_password`
    components. We will remove the `validate_password` components, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，密码要求再次未被满足；我们可以通过降低设置或删除`validate_password`组件来解决这个问题。我们将删除`validate_password`组件，如下所示：
- en: '[PRE57]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Excellent! We used the `UNINSTALL COMPONENT` command to remove `component_validate_password`.
    Now, we can log in as we did earlier and continue:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们使用`UNINSTALL COMPONENT`命令删除了`component_validate_password`。现在，我们可以像之前一样登录并继续：
- en: '[PRE58]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Awesome! The last step is to reload the grant tables; we will use the `flush`
    command, as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！最后一步是重新加载授权表；我们将使用`flush`命令，如下所示：
- en: '[PRE59]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Awesome! When we left off `;`, the command was not executed. We always need
    to end with a semicolon (;). Now, we can test over the network, from our Ubuntu
    system. We will have to install the `mysql-client` on the Ubuntu 18 system, as
    follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！当我们离开`;`时，命令没有被执行。我们总是需要以分号（;）结束。现在，我们可以从我们的Ubuntu系统通过网络进行测试。我们将不得不在Ubuntu
    18系统上安装`mysql-client`，如下所示：
- en: '[PRE60]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Excellent! We successfully connected the `mysql` server hosted on our Fedora
    28 system over the network, using the Ubuntu 18 client. We can now use a variety
    of commands, such as the `show databases` command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们成功连接了托管在我们的Fedora 28系统上的`mysql`服务器，使用Ubuntu 18客户端通过网络。我们现在可以使用各种命令，比如`show
    databases`命令：
- en: '[PRE61]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Awesome! We can see two databases: the one that we created earlier and an internal
    database. However, if we run this command as the root user, we will see all of
    the available databases, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们可以看到两个数据库：我们之前创建的一个和一个内部数据库。但是，如果我们以root用户身份运行此命令，我们将看到所有可用的数据库，如下所示：
- en: '[PRE62]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Excellent! Another way to view the databases is to use the `mysql` command
    with the `-e` option; this allows us to perform commands from the shell. The following
    code snippet shows how we can list the databases:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！查看数据库的另一种方法是使用带有`-e`选项的`mysql`命令；这允许我们从shell执行命令。以下代码片段显示了我们如何列出数据库：
- en: '[PRE63]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Awesome! Following this, we can use the `use` command to switch to a given
    database. The following code shows how we can specify the database to use:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！接下来，我们可以使用`use`命令切换到指定的数据库。以下代码显示了我们如何指定要使用的数据库：
- en: '[PRE64]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We are now inside of the `netaccess` database. To begin using the databases,
    we have to first create a table; before we create a table, we need to know what
    type of table we would like to create. For instance, let''s suppose that we want
    to create a table about public places; we will want to have a field for the name
    of the place. If we just create a table with the name of the place, it will not
    be that appealing; we will want to add other aspects, such as the service provided
    and the location, to name a couple. As you can see, a table can contain a variety
    of options. To start, we will use the fields mentioned in our example; we''re
    going to use the `create table` command, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在`netaccess`数据库中。要开始使用数据库，我们必须首先创建一个表；在创建表之前，我们需要知道要创建什么类型的表。例如，假设我们想创建一个关于公共场所的表；我们将希望有一个用于场所名称的字段。如果我们只创建一个带有场所名称的表，那将不太吸引人；我们将希望添加其他方面，比如提供的服务和位置等。正如您所看到的，表可以包含各种选项。首先，我们将使用我们示例中提到的字段；我们将使用`create
    table`命令，如下所示：
- en: '[PRE65]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Excellent! We successfully created our first table. We can view the tables
    using the `show tables` command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们成功创建了我们的第一个表。我们可以使用`show tables`命令查看表：
- en: '[PRE66]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We can see our table listed. We can view the fields that we created using the
    `describe` command. The following code shows how we can use the `describe` command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的表已列出。我们可以使用`describe`命令查看我们创建的字段。以下代码显示了我们如何使用`describe`命令：
- en: '[PRE67]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Awesome! We can see the fields, along with their types; the `varchar` type length
    can be a value between 0 and 65,535\. Currently, the table is empty, so we have
    to populate it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们可以看到字段及其类型；`varchar`类型的长度可以是0到65,535之间的值。目前，表是空的，所以我们必须填充它。
- en: The insert command
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入命令
- en: 'We can use the `insert` command to populate a table. The basic syntax is as
    follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`insert`命令填充表。基本语法如下：
- en: '[PRE68]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can add some information to the table that we created earlier, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向我们之前创建的表中添加一些信息，如下所示：
- en: '[PRE69]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Wonderful! We specified the values and passed them with the `insert` command,
    which stored the data in the table. Another way to insert data is to insert data
    in only some of the fields; we have to specify the field names to do selective
    insertion. The following code shows how we can insert data into some portions
    of the table:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们指定了值并使用`insert`命令传递了这些值，将数据存储在表中。插入数据的另一种方法是只插入部分字段的数据；我们必须指定字段名称以进行选择性插入。以下代码显示了如何将数据插入到表的某些部分：
- en: '[PRE70]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Awesome! We only inserted values for two fields (`name` and `location`). Another
    way to insert data is to use the `mysql` command with the `-e` option, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们只为两个字段（`name`和`location`）插入了值。插入数据的另一种方法是使用带有`-e`选项的`mysql`命令，如下所示：
- en: '[PRE71]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Awesome! The data was successfully entered into the table.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！数据已成功输入到表中。
- en: The select command
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择命令
- en: 'So far, we''ve been adding contents to our table. However, we have not seen
    the values that we''ve added. We can use the `select` command to view the contents
    of a table, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在向我们的表中添加内容。但是，我们还没有看到我们添加的值。我们可以使用`select`命令查看表的内容，如下所示：
- en: '[PRE72]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Excellent! We can see all of the values that we have entered so far in our
    table. Furthermore, we can perform selective searches by specifying the `where`
    clause, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们可以看到我们迄今为止在我们的表中输入的所有值。此外，我们可以通过指定`where`子句执行选择性搜索，如下所示：
- en: '[PRE73]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Wonderful! We can also perform searches using the following methods:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们还可以使用以下方法进行搜索：
- en: '[PRE74]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Awesome!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！
- en: The update command
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新命令
- en: 'We can use the `update` command to make changes to a table, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`update`命令对表进行更改，如下所示：
- en: '[PRE75]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Excellent! We''ve filled in the data for the `service_provided` field of `Telephone
    Company`; this can be verified using the `select` command, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们已经填写了“Telephone Company”的“service_provided”字段的数据；可以使用`select`命令进行验证，如下所示：
- en: '[PRE76]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Awesome! We can see that the field for `service_provided` has been filled.
    Additionally, we can change the data by using the `update` command, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们可以看到`service_provided`字段已经填充。此外，我们可以使用`update`命令更改数据，如下所示：
- en: '[PRE77]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Excellent!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！
- en: The delete command
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除命令
- en: 'We can remove values from the fields of a table using the `delete` command,
    as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`delete`命令从表的字段中删除值，如下所示：
- en: '[PRE78]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Awesome! The field that was specified with the `delete` command was removed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！使用`delete`命令指定的字段已被删除。
- en: The from option
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: from选项
- en: 'We can use the `from` option to specify which table to use; for instance, if
    we specify a non-existing table, we will see the following messages:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`from`选项来指定要使用的表；例如，如果我们指定一个不存在的表，我们将看到以下消息：
- en: '[PRE79]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The table does not exist, so we have to enter the correct table when performing
    queries, using the `from` option.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 表不存在，因此在执行查询时，我们必须使用`from`选项输入正确的表。
- en: The where condition
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: where条件
- en: 'We can use the `where` condition when we want to perform some selective manipulation.
    We''ve used the `where` condition previously, with the `select`, `update`, and `delete`
    commands. As a refresher, we can use the `where` condition as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要执行一些选择性操作时，我们可以使用`where`条件。我们之前使用过`select`，`update`和`delete`命令的`where`条件。作为提醒，我们可以如下使用`where`条件：
- en: '[PRE80]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Excellent! Only the results from the condition are displayed.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！只显示符合条件的结果。
- en: The group by option
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: group by选项
- en: 'We can use the `group by` option to provide results based on the criteria that
    we specify, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`group by`选项根据我们指定的条件提供结果，如下所示：
- en: '[PRE81]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Awesome! The results are grouped by the specified criteria. This is useful when
    we have tables that consist of numbers, for instance, customer ID, employee ID,
    and ordered, to name a few.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！结果根据指定的条件进行分组。当我们有包含数字的表时，这是非常有用的，例如客户ID，员工ID和订单等。
- en: The order by option
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: order by选项
- en: 'We can use the `order by` option to sort the data in the table, in either an
    ascending or descending order. The following code shows how to use the `order
    by` option:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`order by`选项按升序或降序对表中的数据进行排序。以下代码显示了如何使用`order by`选项：
- en: '[PRE82]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Based on the default, the data is sorted in an ascending order; however, we
    can display the results in a descending order by passing the `DESC` keyword, as
    follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 根据默认设置，数据按升序排序；但是，我们可以通过传递`DESC`关键字以降序显示结果，如下所示：
- en: '[PRE83]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Excellent! The results are displayed in a descending order.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！结果以降序显示。
- en: The join option
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接选项
- en: 'We can use a simple join by passing the `join` option; this can be used to
    combine rows from separate tables, to look at a common factor between the tables.
    I''ve created two tables, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过传递`join`选项来使用简单的连接；这可以用于合并来自不同表的行，以查看表之间的共同因素。我创建了两个表，如下所示：
- en: '[PRE84]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The columns that are identical are the first columns of each table; the `Cust`
    table refers to this as `custID`, whereas the `Purchase` table refers to this
    as ordered. Based on this, we can create a select query that will merge the two
    tables, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的列是每个表的第一列；`Cust`表将其称为`custID`，而`Purchase`表将其称为ordered。基于此，我们可以创建一个选择查询，将两个表合并，如下所示：
- en: '[PRE85]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Excellent! We referenced the fields by placing the table's name in front of
    `Purchase.orderID`, `Cust.custName`, `Purchase.orderDate`; this defined how the
    table would be presented.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们通过在`Purchase.orderID`，`Cust.custName`，`Purchase.orderDate`前放置表的名称来引用字段；这定义了表的呈现方式。
- en: The next portion, `FROM Purchase INNER JOIN Cust ON Purchase.orderID=Cust.custID;`,
    defined that the content would be coming from the `Purchase` table, and it would
    be joined by using the common column of `Purchase.orderID=Cust.custID`, hence
    producing the results containing data from both tables.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分，“FROM Purchase INNER JOIN Cust ON Purchase.orderID=Cust.custID;”，定义了内容将来自`Purchase`表，并且将使用`Purchase.orderID=Cust.custID`的共同列进行连接，从而产生包含来自两个表的数据的结果。
- en: This is known as an inner join; it returns data that has matching values in
    both tables.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为内部连接；它返回在两个表中具有匹配值的数据。
- en: Summary
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at shell scripting and SQL management. First, we
    covered the basics of shell scripting. Next, we worked our way through writing
    scripts using `for` loops. This was followed by using the `while` loop. We finished
    off with `if` statements in scripts.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了shell脚本和SQL管理。首先，我们介绍了shell脚本的基础知识。接下来，我们通过使用`for`循环编写脚本。然后，我们使用了`while`循环。最后，我们在脚本中使用了`if`语句。
- en: Next, we worked with SQL management. First, we installed the MySQL repository,
    and then, we installed the community-server edition of MySQL. This was followed
    by securing our `mysql` server. Then, we dove into the creation of a database,
    followed by creating a table. We then started to manage the data in the table
    by using a variety of techniques; we finished by creating additional tables, in
    order to demonstrate inner joins.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用了SQL管理。首先，我们安装了MySQL存储库，然后安装了MySQL的社区服务器版本。然后，我们对我们的`mysql`服务器进行了安全设置。然后，我们开始创建数据库，然后创建表。然后，我们开始使用各种技术管理表中的数据；最后，我们创建了额外的表，以演示内部连接。
- en: I've had an awesome time compiling every chapter in this book. I'm confident
    that you will learn a lot from this book as you move forward with your career.
    I want to thank you for choosing this book and making it a part of your collection.
    Until next time, this is Philip Inshanally, reminding you to always be grateful.
    I'll see you soon!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我很高兴编写了这本书中的每一章。我相信您在职业生涯中会从这本书中学到很多。感谢您选择这本书并将其收入您的收藏。下次再见，我是Philip Inshanally，提醒您要时刻心存感激。很快再见！
- en: Questions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What characters identify is at the start the line where the interpreter is defined?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些字符标识了定义解释器的行的开头？
- en: A. `#$`
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: A. `＃$`
- en: B. `#@`
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: B. `＃@`
- en: C. `#!`
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: C. `＃！`
- en: D. `#^`
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: D. `＃^`
- en: Which of the following environment variables stores the current shell?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个环境变量存储当前的shell？
- en: A. `SHELL`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: A. `SHELL`
- en: B. `BASH`
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: B. `BASH`
- en: C. `SH`
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: C. `SH`
- en: D. `TCSH`
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: D. `TCSH`
- en: Which of the following keywords ends a `for` loop?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个关键字结束了`for`循环？
- en: A. `do`
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: A. `do`
- en: B. `do loop`
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: B. `do循环`
- en: C. `done`
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: C. `完成`
- en: D. `fi`
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: D. `fi`
- en: If a script resides in the present directory, what character needs to be placed
    in front of `/`, in order to run the script?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果脚本位于当前目录中，需要在`/`前面放置哪个字符才能运行脚本？
- en: A. `.`
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: A. `.`
- en: B. `:`
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: B. `：`
- en: C. `;`
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: C. `;`
- en: D. `“`
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: D. `“`
- en: Which of the following commands can create a variable to store the user's input?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令可以创建一个变量来存储用户的输入？
- en: A. `execute`
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: A. `执行`
- en: B. `pause`
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: B. `暂停`
- en: C. `write`
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: C. `写入`
- en: D. `read`
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: D. `读取`
- en: Which of the following characters can be used to test two conditions and return
    `TRUE` if either condition is true?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个字符可以用来测试两个条件，并在任一条件为真时返回`TRUE`？
- en: A. `&&`
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: A. `&&`
- en: B. `||`
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: B. `||`
- en: C. `//`
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: C. `//`
- en: D. `==`
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: D. `==`
- en: Which of the following characters is used as a wildcard when using the `select`
    command to perform a `mysql` query?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`select`命令执行`mysql`查询时，以下哪个字符用作通配符？
- en: A. `+`
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: A. `+`
- en: B. `/`
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: B. `/`
- en: C. `*`
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: C. `*`
- en: D. `-`
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: D. `-`
- en: Which of the following options is used to check for a condition when using the
    `select` command?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`select`命令时，以下哪个选项用于检查条件？
- en: A. `from`
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: A. `来自`
- en: B. `if`
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: B. `if`
- en: C. `where`
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: C. `where`
- en: D. `JOIN`
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: D. `连接`
- en: Which of the following commands would create a table using mysql?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令将使用mysql创建一个表？
- en: A. `create tables`
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: A. `创建表`
- en: B. `CREATE TABLE`
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: B. `创建表`
- en: C. `CREATE TABLES`
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: C. `创建表`
- en: D. `create TABLEs`
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: D. `创建表`
- en: Which of the following commands can be used to change a value using `mysql`?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令可以用于使用`mysql`更改值？
- en: A. `INSERT`
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: A. `插入`
- en: B. `DELETE`
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: B. `删除`
- en: C. `UPDATE`
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: C. `更新`
- en: D. `JOIN`
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: D. `连接`
- en: Further reading
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The following site provides useful information about shell scripting: [https://www.shellscript.sh](https://www.shellscript.sh)
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下网站提供有关shell脚本的有用信息：[https://www.shellscript.sh](https://www.shellscript.sh)
- en: The following site provides useful information about loops: [https://www.tutorialspoint.com](https://www.tutorialspoint.com)
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下网站提供有关循环的有用信息：[https://www.tutorialspoint.com](https://www.tutorialspoint.com)
- en: The following site provides useful information about mysql: [https://www.w3schools.com](https://www.w3schools.com)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下网站提供有关mysql的有用信息：[https://www.w3schools.com](https://www.w3schools.com)
