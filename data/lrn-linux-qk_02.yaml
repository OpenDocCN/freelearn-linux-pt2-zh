- en: Climbing the Tree
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 攀爬树
- en: 'In this chapter, you will climb a very special tree, which is the Linux filesystem.
    During this climbing journey, you will learn:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将攀爬一个非常特殊的树，那就是Linux文件系统。在这次攀爬的旅程中，你将学到：
- en: The Linux filesystem hierarchy.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux文件系统层次结构。
- en: What is the root directory?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根目录是什么？
- en: Absolute versus Relative paths.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对路径与相对路径。
- en: How to navigate the Linux filesystem.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何浏览Linux文件系统。
- en: The Linux filesystem
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux文件系统
- en: 'Alright, you are at the root of the tree and ready to climb up. In Linux, just
    like an actual tree, the beginning of the filesystem starts at the root directory.
    You can use the `cd` command followed by a forward slash to get to the root:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，你已经在树的根部准备好攀爬了。在Linux中，就像实际的树一样，文件系统的开始是从根目录开始的。你可以使用`cd`命令后跟一个斜杠来到达根目录：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `cd` command is short for **Change Directory** and is one of the most used
    commands in Linux. You can't move around in Linux without it. It's like your limbs
    (arms and legs), can you climb a tree without your limbs?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`cd`命令是**Change Directory**的缩写，是Linux中最常用的命令之一。没有它，你无法在Linux中移动。就像你的四肢（手臂和腿），你能在没有四肢的情况下爬树吗？'
- en: 'The forward slash character represents the root directory. Now to make sure
    you''re at the root directory, you can run `pwd`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 斜杠字符代表根目录。现在为了确保你在根目录，你可以运行`pwd`：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And sure enough, we are at the root of the Linux filesystem. Whenever you are
    lost and you don't know where you are, `pwd` is here to rescue you.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 果然，我们在Linux文件系统的根目录。每当你迷失方向不知道自己在哪里时，`pwd`就在这里拯救你。
- en: 'Alright, while we are still at the root directory, let''s see what''s in there!
    Run the `ls` command to view the contents of the current directory:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，当我们还在根目录时，让我们看看里面有什么！运行`ls`命令来查看当前目录的内容：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To have a better view of the contents, you can use the long listing `-l` option
    with the `ls` command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地查看内容，你可以使用`ls`命令的长列表`-l`选项：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This output gives you a lot of valuable information that we will discuss in
    detail in the upcoming chapters. But for now, we focus on the first letter in
    the first column of the output. Take a look at the first column of the output:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出给了你很多有价值的信息，我们将在接下来的章节中详细讨论。但现在，我们关注输出的第一列的第一个字母。看一下输出的第一列：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You will see that the first letter is `d`, which means that the file is a directory.
    The first letter reveals the file type. The last column of the output displays
    the filename.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到第一个字母是`d`，这意味着文件是一个目录。第一个字母揭示了文件类型。输出的最后一列显示了文件名。
- en: '**OTHER FILES!**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他文件！**'
- en: You will have more files under your root (`/`) directory. I have only chosen
    the most important and common ones that should exist on every Linux distribution.
    So don't freak out when you see way more files than those listed in this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你的根目录下会有更多的文件。我只选择了最重要和最常见的文件，这些文件应该存在于每个Linux发行版中。所以当你看到比这本书中列出的文件更多时，不要惊慌。
- en: 'Now each one of these directories has a special purpose, as you can see in
    the following table:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每个目录都有特殊的用途，就像你在下表中看到的那样：
- en: '| `/` | This is the root of your filesystem, where everything begins. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: / | 这是你的文件系统的根，一切都从这里开始。
- en: '| `/etc` | This directory contains system configuration files. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: /etc | 这个目录包含系统配置文件。
- en: '| `/home` | This is the default home directory for all users (except the root
    user). |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: /home | 这是所有用户（除了root用户）的默认主目录。
- en: '| `/root` | This is the home directory for the root user. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: /root | 这是root用户的主目录。
- en: '| `/dev` | This is where your devices such as your hard disks, USB drives,
    and optical drives reside on your system. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: /dev | 这是你的设备，比如硬盘、USB驱动器和光驱所在的地方。
- en: '| `/opt` | This is where you can install additional 3rd party software. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: /opt | 这是你可以安装额外第三方软件的地方。
- en: '| `/bin` | This is where essential binaries (programs) reside on your system.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: /bin | 这是你的系统上必要的二进制文件（程序）所在的地方。
- en: '| `/sbin` | This is where system binaries (programs) that are typically used
    by the system administrator are stored. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: /sbin | 这是系统管理员通常使用的系统二进制文件（程序）存储的地方。
- en: '| `/tmp` | This is where temporary files are stored; they are usually deleted
    after a system reboot, so never store important files here! |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: /tmp | 这是临时文件存储的地方；它们通常在系统重启后被删除，所以不要在这里存储重要文件！
- en: '| `/var` | This directory contains files that may change in size, such as mail
    spools and log files. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: /var | 这个目录包含可能会改变大小的文件，比如邮件储存和日志文件。
- en: '| `/boot` | All the files required for your system to boot are stored here.
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: /boot | 所有系统启动所需的文件都存储在这里。
- en: '| `/lib` | This directory contains libraries needed by the essential binaries
    in the `/bin` and `/sbin` directories. A library is basically a set of precompiled
    functions that can be used by a program. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: /lib | 这个目录包含了/bin和/sbin目录中必要二进制文件所需的库。库基本上是一组可以被程序使用的预编译函数。
- en: '| `/proc` | This is where information about running processes is stored. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: /proc | 运行进程的信息存储在这里。
- en: '| `/usr` | This directory contains files and utilities that are shared between
    users. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: /usr | 这个目录包含了用户之间共享的文件和实用程序。
- en: 'Table 2: Linux Directories Explained'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 表2：解释Linux目录
- en: 'You can also run the `man hier` command to read more about the Linux filesystem
    hierarchy:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以运行`man hier`命令来阅读更多关于Linux文件系统层次结构的信息：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Alright, now let's do further climbing on the Linux directory tree. Take a look
    at *figure 1*, and you will understand why we choose a tree to describe the structure
    of the Linux filesystem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在让我们在Linux目录树上进一步攀爬。看一下*图1*，你就会明白为什么我们选择了一棵树来描述Linux文件系统的结构。
- en: '![](img/79a50d42-f14e-4fe6-a412-62b50953310c.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79a50d42-f14e-4fe6-a412-62b50953310c.png)'
- en: 'Figure 1: The Linux directory tree'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：Linux目录树
- en: The preceding figure only features very few files and by no means is a representation
    for the whole directory tree, as the Linux filesystem literally contains thousands
    of files. So you can think of the preceding figure as a subtree of the actual
    Linux directory tree.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图只显示了很少的文件，绝不代表整个目录树，因为Linux文件系统实际上包含成千上万的文件。因此，您可以将前面的图像视为实际Linux目录树的子树。
- en: Navigating through the directory tree
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览目录树
- en: 'Alright, let''s do more climbing. For example, let''s climb to the `/home`
    directory to see how many users we have on the system. You can do that by simply
    running the `cd /home` command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们再爬一点。例如，让我们进入`/home`目录，看看系统上有多少用户。您只需运行`cd /home`命令即可：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice how your command prompt changes as it's now showing that you are at the
    home directory.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意您的命令提示符如何更改，因为它现在显示您在主目录。
- en: '![](img/53676501-79e3-4dbd-97d3-a5d42af9fc78.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53676501-79e3-4dbd-97d3-a5d42af9fc78.png)'
- en: 'Figure 2: You are now at /home'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：您现在在/home
- en: 'Now let''s run `ls` to view the contents of the `/home` directory:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行`ls`来查看`/home`目录的内容：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These are the two users on my system (besides the root user). The `/root` is
    the home directory for the root user. You probably have only one user in `/home`;
    you will learn later in the book how to add other users to your system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我系统上的两个用户（除了root用户）。`/root`是root用户的主目录。您可能只有一个用户在`/home`；您将在本书后面学习如何向系统添加其他用户。
- en: '**WHO IS ROOT?**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**谁是root用户？**'
- en: The root user is a superuser who is allowed to do anything on the system. The
    root user can install software, add users, manage disk partitions, etc. The home
    directory of the root user is `/root`, which is NOT to be confused with `/` (the
    root of the filesystem).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: root用户是允许在系统上执行任何操作的超级用户。root用户可以安装软件，添加用户，管理磁盘分区等。root用户的主目录是`/root`，不要与`/`（文件系统的根）混淆。
- en: 'If you want proof that you are currently at the `/home` directory, you can
    run the `pwd` command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要证明您当前在`/home`目录，可以运行`pwd`命令：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Sure enough! We are at the `/home` directory. Now let''s climb to the home
    directory of user `elliot`. Now, believe it or not, there are two ways to navigate
    to `elliot`''s home directory. You can simply run the `cd elliot` command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 确实！我们在`/home`目录。现在让我们进入用户`elliot`的主目录。现在，信不信由你，有两种方法可以导航到`elliot`的主目录。您可以简单地运行`cd
    elliot`命令：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Or you can run the `cd /home/elliot` command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以运行`cd /home/elliot`命令：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/7254d293-d5d7-4f55-aa19-27333469d3d1.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7254d293-d5d7-4f55-aa19-27333469d3d1.png)'
- en: 'Figure 3: Now you are at /home/elliot'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：现在您在/home/elliot
- en: Notice that both commands have landed us in `elliot`'s home directory. However,
    running `cd elliot` is much easier than running `cd /home/elliot`, of course.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个命令都将我们带到了`elliot`的主目录。但是，运行`cd elliot`比运行`cd /home/elliot`要容易得多，当然。
- en: Well, think about it, we were initially at the `/home` directory, and that's
    why we were able to run `cd elliot` to land in `/home/elliot`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，想想吧，我们最初在`/home`目录，这就是为什么我们能够运行`cd elliot`进入`/home/elliot`的原因。
- en: 'However, in other situations, we would be forced to use the full path (absolute
    path) `/home/elliot` to reach our destination. To demonstrate, let''s first change
    to the `/etc` directory:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在其他情况下，我们将被迫使用完整路径（绝对路径）`/home/elliot`来到达我们的目的地。为了演示，让我们首先切换到`/etc`目录：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![](img/54cd2e8c-6b0e-42cb-b217-160e38baf5a4.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54cd2e8c-6b0e-42cb-b217-160e38baf5a4.png)'
- en: 'Figure 4: Now you are at /etc'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图4：现在您在/etc
- en: '![](img/5392da2b-ffd7-48bb-82ce-cebea60f31c5.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5392da2b-ffd7-48bb-82ce-cebea60f31c5.png)'
- en: 'Figure 5: You want to go to /home/elliot'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图5：您想要进入/home/elliot
- en: '*Figures 4* and *5* help you visualize it. You are at `/etc` and you want to
    go to `/home/elliot`. To get to `elliot`''s home directory, we can no longer use
    a short path (relative path) by running the `cd elliot` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4*和*5*可以帮助您可视化。您现在在`/etc`，想要进入`/home/elliot`。为了进入`elliot`的主目录，我们不能再使用短路径（相对路径）运行`cd
    elliot`命令：'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, the Shell got mad and returned an error `bash: cd: elliot:
    No such file or directory`. In this case, we have to use the full path (absolute
    path)`/home/elliot`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，Shell生气了并返回了一个错误`bash: cd: elliot: No such file or directory`。在这种情况下，我们必须使用完整路径（绝对路径）`/home/elliot`：'
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In case you haven't noticed by now, we have been using the forward slash (`/`)
    as a directory separator.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在还没有注意到，我们一直在使用斜杠(`/`)作为目录分隔符。
- en: '**THE DIRECTORY SEPARATOR**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**目录分隔符**'
- en: In Linux, the forward slash (`/`) is the directory separator or sometimes referred
    to as the path separator. In Windows, it's the other way around because a backward
    slash (`\`) is used instead as a directory separator. However, be careful since
    the leading forward slash is the root of our filesystem. For example, in `/home/elliot/Desktop`,
    only the second and third forward slashes are directory separators, but the first
    forward slash represents the root of the filesystem.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，斜杠(`/`)是目录分隔符，有时也称为路径分隔符。在Windows中，情况正好相反，因为反斜杠(`\`)被用作目录分隔符。但是，要小心，因为前导斜杠是我们文件系统的根。例如，在`/home/elliot/Desktop`中，只有第二个和第三个斜杠是目录分隔符，但第一个斜杠代表文件系统的根。
- en: It's crucial to realize the difference between absolute paths and relative paths.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到绝对路径和相对路径之间的区别是至关重要的。
- en: '**ABSOLUTE VERSUS RELATIVE PATHS**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**绝对路径与相对路径**'
- en: An absolute path of a file is simply the full path of that file and, it **ALWAYS**
    begins with a leading forward slash. For example, `/opt/- google/chrome` is an
    example of an absolute path.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的绝对路径只是该文件的完整路径，并且始终以前导斜杠开头。例如，`/opt/- google/chrome`是绝对路径的一个例子。
- en: On the other hand, a relative path of a file never starts with the root directory
    and is always relative to the current working directory. For example, if you are
    currently at `/var`, then `log/boot.log` is a valid relative path.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，文件的相对路径从不以根目录开头，始终相对于当前工作目录。例如，如果您当前在`/var`，那么`log/boot.log`就是有效的相对路径。
- en: As a rule of thumb, if you want to distinguish between a relative path and an
    absolute path, look and see if the path starts with the root directory (forward
    slash); if it does, then you can conclude the path is absolute, otherwise, the
    path is relative.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，如果你想区分相对路径和绝对路径，看一下路径是否以根目录（斜杠）开头；如果是的话，你可以得出结论这是绝对路径，否则，这是相对路径。
- en: The following diagram shows you the relative path `Desktop/hello.txt` and will
    only work if your current working directory is `/home/elliot`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表显示了相对路径`Desktop/hello.txt`，只有当你的当前工作目录是`/home/elliot`时才有效。
- en: '![](img/fb656147-eb70-42d1-b62e-030c994f0873.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fb656147-eb70-42d1-b62e-030c994f0873.png)'
- en: 'Figure 6: This Is a Relative Path'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图6：这是一个相对路径
- en: The following image shows you the absolute path `/home/elliot/Desktop` and will
    always work regardless of your current working directory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图片显示了绝对路径`/home/elliot/Desktop`，无论你当前的工作目录是什么，它都会一直有效。
- en: '![](img/64478dee-c47a-46c2-b446-6f439ad8fda7.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64478dee-c47a-46c2-b446-6f439ad8fda7.png)'
- en: 'Figure 7: This Is an Absolute Path'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7：这是一个绝对路径
- en: 'Now let''s climb to Elliot''s `Desktop` directory to see what he has there.
    We will use an absolute path:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们进入Elliot的`Desktop`目录看看他在那里有什么。我们将使用绝对路径：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We follow it with a `pwd` to confirm that we are indeed in the desired directory.
    Now let''s run `ls` to view the contents of Elliot''s desktop:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着运行`pwd`来确认我们确实在想要的目录中。现在让我们运行`ls`来查看Elliot的桌面上的内容：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that the file `hello.txt` is on Elliot's desktop, so we can actually
    see it right there on the desktop.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`hello.txt`文件在Elliot的桌面上，所以我们实际上可以在桌面上看到它。
- en: '![](img/f8f7032f-daed-4827-a8f0-7cc625997a36.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f8f7032f-daed-4827-a8f0-7cc625997a36.png)'
- en: 'Figure 8: Elliot''s desktop'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图8：Elliot的桌面
- en: 'As you can see in the preceding image, there is a file named `hello.txt` on
    Elliot''s desktop. You can use the `cat` command to view the contents of a text
    file:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在上面的图片中所见，Elliot的桌面上有一个名为`hello.txt`的文件。你可以使用`cat`命令来查看文本文件的内容：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you open the file `hello.txt` on the desktop, you will see the same contents,
    of course, as you can see in the following screenshot.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在桌面上打开`hello.txt`文件，你会看到相同的内容，当然，就像你在下面的截图中看到的那样。
- en: '![](img/e97ae210-c57e-4df2-8c73-c1305666bf74.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e97ae210-c57e-4df2-8c73-c1305666bf74.png)'
- en: 'Figure 9: The contents of hello.txt'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：hello.txt的内容
- en: Parent and current directories
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 父目录和当前目录
- en: 'There are two special directories under every directory in the filesystem:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件系统的每个目录下都有两个特殊的目录：
- en: Current working directory represented by one dot (`.`)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前工作目录用一个点(`.`)表示
- en: Parent directory represented by two dots (`..`)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 父目录用两个点(`..`)表示
- en: '![](img/525d4989-07bd-4e5a-96aa-8831c012a775.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/525d4989-07bd-4e5a-96aa-8831c012a775.png)'
- en: 'Figure 10: Visualizing Parent and Current Directories'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：可视化父目录和当前目录
- en: 'It''s easy to understand both directories by going through a few examples.
    To demonstrate, let''s first change to `/home/elliot` so that it becomes our current
    working directory:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过几个例子很容易理解这两个目录。举个例子，让我们首先切换到`/home/elliot`，这样它就成为我们的当前工作目录：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now run the `cd .` command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`cd .`命令：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you would expect, nothing happened! We are still at `/home/elliot`, and that
    is because one dot (`.`) represents the current working directory. It's like if
    you told someone, "Go where you are!"
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，什么都没有发生！我们仍然在`/home/elliot`，这是因为一个点(`.`)代表当前工作目录。就好像你告诉某人，“去你所在的地方！”
- en: 'Now run the `cd ..` command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`cd ..`命令：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We moved back one directory! In other words, we changed to the parent directory
    of `/home/elliot`, which is `/home`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回到了上一个目录！换句话说，我们切换到了`/home/elliot`的父目录，也就是`/home`。
- en: 'Let''s run another `cd ..`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再运行一个`cd ..`：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Indeed we keep going back, and now we are at the root of our directory tree.
    Well, let''s run `cd ..` one more time:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实一直在回去，现在我们在我们的目录树的根目录。好吧，让我们再次运行`cd ..`：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Hmmm, we are at the same directory! Our path didn't change, and that's because
    we are at the root of our directory tree already, so we can't go any further back.
    As a result, the root directory (`/`) is the only directory where the **parent
    directory = current directory**, and you can visualize it by looking at *figure
    10*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们还在同一个目录！我们的路径没有改变，这是因为我们已经在我们的目录树的根目录了，所以我们无法再回去了。因此，根目录(`/`)是唯一一个**父目录=当前目录**的目录，你可以通过查看*图10*来进行可视化。
- en: 'You can also insert the directory separator `cd ../..` to move back two directories
    at once:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以插入目录分隔符`cd ../..`一次性回到两个目录：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can also run `cd ../../..` to move back three directories and so on.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以运行`cd ../../..`来回到三个目录，依此类推。
- en: Moving around quickly
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速移动
- en: Now I will show you some cool tricks that will make you fast and efficient in
    navigating the Linux directory tree.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我将向你展示一些很酷的技巧，这些技巧将使你在浏览Linux目录树时更快更高效。
- en: Go back home!
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回到家！
- en: 'Let''s change to the `/var/log` directory:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换到`/var/log`目录：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can now run the `cd ~` command to go to your home directory:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以运行`cd ~`命令来进入你的家目录：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'WOW! Let''s do it again, but this time, we switch to user `angela`. In case
    you don''t know, the character is called tilde and should be located next to your
    number *1* key on your keyboard:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！让我们再做一次，但这次，我们切换到用户`angela`。如果你不知道，这个字符叫做波浪号，应该位于键盘上数字*1*键的旁边：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice here I used two new commands. The `whoami` command prints the name of
    the currently logged-in user. I also used the switch user `su` command to switch
    to user `angela`. You can use the `su` command to switch to any user on your system;
    you just need to run `su`, followed by the username.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里我使用了两个新命令。`whoami`命令打印当前登录用户的名称。我还使用了切换用户`su`命令来切换到用户`angela`。你可以使用`su`命令来切换到系统上的任何用户；你只需要运行`su`，然后跟上用户名。
- en: 'Now, as user `angela`, I will navigate to the `/var/log` directory:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为用户`angela`，我将导航到`/var/log`目录：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then I run the `cd ~` command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我运行`cd ~`命令：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Boom! I am at Angela's home directory. Regardless of your current working directory,
    running the `cd ~` command will land you straight to your home directory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！我在Angela的主目录。无论您当前的工作目录是什么，运行`cd ~`命令都会直接将您带回到您的主目录。
- en: Take me back!
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带我回去！
- en: Now, what if `angela` wants to go back as quickly as possible to her previous
    working directory?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果`angela`想尽快返回到她以前的工作目录怎么办？
- en: 'Running the `cd -` command is the fastest method that will land `angela` back
    to her previous working directory:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`cd -`命令是将`angela`快速返回到她以前的工作目录的最快方法：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Cool! `angela` is back in `/var/log`. So anytime you want to go back to your
    previous working directory, just run the `cd -` command.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 酷！`angela`回到了`/var/log`。所以每当您想返回到以前的工作目录时，只需运行`cd -`命令。
- en: Hidden Files
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐藏文件
- en: The current directory `.` and the parent directory `..` exist under each directory
    in the Linux filesystem. But how come we can't see them when we run the `ls` command?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux文件系统的每个目录下都存在当前目录` .`和父目录` ..`。但是当我们运行`ls`命令时为什么看不到它们呢？
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, I even tried to run `ls -l` and still can't see the current
    directory or the parent directory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我甚至尝试运行`ls -l`，仍然看不到当前目录或父目录。
- en: 'You need to use the `-a` option with the `ls` command as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用`ls`命令的`-a`选项如下：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Hooray! Now you can see all the files. The `-a` option shows you all the files,
    including hidden files and of course you can use the full option name `--all`,
    which will do the same thing:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！现在您可以看到所有文件了。`-a`选项显示所有文件，包括隐藏文件，当然您也可以使用完整的选项名称`--all`，它将做同样的事情：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It turns out that any filename that starts with `.` (a dot) is hidden.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 原来，任何以` .`（点）开头的文件名都是隐藏的。
- en: Hidden filenames start with `.`
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏的文件名以` .`开头
- en: Any filename that starts with a dot is hidden. That's why current and parent
    directories are hidden.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以点开头的文件名都是隐藏的。这就是为什么当前目录和父目录是隐藏的。
- en: 'To demonstrate further, go to your user home directory and run the `ls` command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步演示，进入您的用户主目录并运行`ls`命令：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now run the `ls -a` command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`ls -a`命令：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can now see the hidden files in your home directory! Notice all the hidden
    filenames start with a dot.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以看到主目录中的隐藏文件！请注意，所有隐藏的文件名都以点开头。
- en: Passing command arguments
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传递命令参数
- en: 'So far, we ran the `ls` command only on the current working directory. However,
    you can list the contents of any directory without having to change to it. For
    example, if your current working directory is `/home/elliot`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在当前工作目录上运行了`ls`命令。但是，您可以列出任何目录的内容，而无需更改到该目录。例如，如果您当前的工作目录是`/home/elliot`：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can list all the files in `/home/angela` by running the `ls -a /home/angela`
    command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`ls -a /home/angela`命令列出`/home/angela`中的所有文件：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: I was able to list the contents of `/home/angela` while still being in `/home/elliot`.
    This is possible because the `ls` command accepts any file as an argument.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我能够在`/home/elliot`的同时列出`/home/angela`的内容。这是可能的，因为`ls`命令接受任何文件作为参数。
- en: '**WHAT IS AN ARGUMENT?**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是参数？**'
- en: An argument, also called a command-line argument, is simply any filename or
    data that is provided to a command as an input.![](img/1605fa32-1bc3-4a70-a403-d093fab29d97.png)
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 参数，也称为命令行参数，只是作为输入提供给命令的任何文件名或数据。![](img/1605fa32-1bc3-4a70-a403-d093fab29d97.png)
- en: 'Figure 11: Linux Command Structure'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图11：Linux命令结构
- en: You can see in the preceding image the general structure of a Linux command.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在前面的图像中看到Linux命令的一般结构。
- en: In Linux terminology, we use the verb **pass** when talking about command options
    and arguments. To use the correct Linux terminology, for example, in the preceding
    image, we say, "We passed the `/home/angela` directory as an argument to the `ls`
    command."
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux术语中，当谈论命令选项和参数时，我们使用动词**传递**。为了使用正确的Linux术语，例如，在前面的图像中，我们说：“我们将`/home/angela`目录作为`ls`命令的参数传递。”
- en: You will often find Linux users very keen on using the right terminology. Moreover,
    using the proper terminology can help you pass a job interview and land your dream
    job!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您会经常发现Linux用户非常热衷于使用正确的术语。此外，使用正确的术语可以帮助您通过工作面试并获得梦想的工作！
- en: Notice in the preceding figure, we used the plural nouns *options* and *arguments*.
    That's because some commands can accept multiple options and arguments.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在前面的图中，我们使用了复数名词*选项*和*参数*。这是因为一些命令可以接受多个选项和参数。
- en: 'For example, we can do a long listing for all the files in `/home/angela` by
    running the `ls -a -l /home/angela` command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过运行`ls -a -l /home/angela`命令来列出`/home/angela`中的所有文件的长列表：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So now you see a long listing of all the files in `/home/angela` including
    the hidden files, also notice that the ordering of the options doesn''t matter
    here, so if you run the `ls -l -a /home/angela` command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在您可以看到`/home/angela`中所有文件的长列表，包括隐藏文件，还要注意这里选项的顺序无关紧要，所以如果您运行`ls -l -a /home/angela`命令：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will get the same result. This was an example of passing two commands options,
    what about passing two arguments? Well, you can do a long listing for all the
    files in `/home/angela` and `/home/elliot` at the same time by passing `/home/elliot`
    as a second argument:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到相同的结果。这是传递两个命令选项的示例，那么传递两个参数呢？好吧，您可以通过将`/home/elliot`作为第二个参数，同时对`/home/angela`和`/home/elliot`中的所有文件进行长列表，而无需更改到它：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So now, you can see the contents of both the `/home/elliot` and `/home/angela`
    directories at the same time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所以现在，您可以同时看到`/home/elliot`和`/home/angela`目录的内容。
- en: The touch command
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: touch命令
- en: 'Let''s do a long listing for all the files in `/home/elliot` one more time
    to discuss something very important:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次对`/home/elliot`中的所有文件进行长列表，讨论一些非常重要的事情：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Focus on the last two columns of the output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 关注输出的最后两列：
- en: '| `Jan 20 16:26` | `.` |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `Jan 20 16:26` | `.` |'
- en: '| `Jan 17 04:37` | `..` |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| `Jan 17 04:37` | `..` |'
- en: '| `Jan 20 13:43` | `.bash_history` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `Jan 20 13:43` | `.bash_history` |'
- en: '| `Dec 26 23:47` | `.bash_logout` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `Dec 26 23:47` | `.bash_logout` |'
- en: '| `Dec 26 23:47` | `.bashrc` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `Dec 26 23:47` | `.bashrc` |'
- en: '| `Jan 19 14:20` | `Desktop` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `Jan 19 14:20` | `Desktop` |'
- en: '| `Apr 4 2018` | `.profile` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `Apr 4 2018` | `.profile` |'
- en: 'Table 3: Last Two Columns of ls -a -l /home/elliot'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table 3`：`ls -a -l /home/elliot` 的最后两列'
- en: You already know that the last column of the output (2nd column of `Table 3`)
    shows the filenames, but what about all these dates that are displayed in the
    preceding column (1st column of `Table 3`)?
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道输出的最后一列（`Table 3` 的第二列）显示文件名，但是前一列（`Table 3` 的第一列）显示的所有这些日期是什么呢？
- en: The dates in the first column of `Table 3` represent the last modification time
    of each file, which is the last time a file was modified (edited).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table 3` 的第一列中的日期表示每个文件的最后修改时间，即文件被修改（编辑）的最后时间。'
- en: You can use the `touch` command to change the modification time of a file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `touch` 命令更改文件的修改时间。
- en: 'To demonstrate, let''s first get the modification time on `elliot`''s `Desktop`
    directory, you can do that by running the `ls -l -d /home/elliot/Desktop` command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，让我们首先获取 `elliot` 的 `Desktop` 目录的修改时间，你可以通过运行 `ls -l -d /home/elliot/Desktop`
    命令来实现：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice we used the `-d` option, so it does a long listing on the directory `/home/elliot/Desktop`
    instead of listing the contents of the directory.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们使用了 `-d` 选项，因此它对目录 `/home/elliot/Desktop` 进行了长列表，而不是列出目录的内容。
- en: 'The last modification time is shown to be: `Jan 19 14:20`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后修改时间显示为：`Jan 19 14:20`。
- en: 'Now if you run the `touch /home/elliot/Desktop` command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你运行 `touch /home/elliot/Desktop` 命令：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You will see that the last modification time of the directory `/home/elliot/Desktop`
    has now changed to `Jan 20 19:42`, which reflects the current time.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到目录 `/home/elliot/Desktop` 的最后修改时间现在已经更改为 `Jan 20 19:42`，这反映了当前时间。
- en: Of course, you will get a different result on your system because you will not
    be running the command at the same time as me.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你会在你的系统上得到不同的结果，因为你不会和我同时运行命令。
- en: Ok, great, so now we understand that the `touch` command can be used to update
    a file's modification time. Can it do something else? Hmmm, let's see.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很好，现在我们明白了 `touch` 命令可以用来更新文件的修改时间。它还能做其他事情吗？嗯，让我们看看。
- en: 'What if we try to update the modification time of a file that doesn''t exist?
    What will happen? The only way to know is to try it. Notice that user `elliot`
    has only one visible (not hidden) file in his home directory, which happens to
    be the `Desktop` directory:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试更新一个不存在的文件的修改时间会发生什么？只有尝试才能知道。请注意，用户 `elliot` 的主目录中只有一个可见（非隐藏）文件，那就是 `Desktop`
    目录：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now watch what will happen when user `elliot` runs the `touch blabla` command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 看看当用户 `elliot` 运行 `touch blabla` 命令时会发生什么：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It created an empty file named `blabla`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了一个名为 `blabla` 的空文件。
- en: 'You can do two things with the `touch` command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `touch` 命令做两件事：
- en: You can update the last modification and access times of existing files.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以更新现有文件的最后修改和访问时间。
- en: You can create new empty files.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以创建新的空文件。
- en: The `touch` command can only create regular files; it cannot create directories.
    Also, notice that it updates modification and access times, so what is the difference?
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`touch` 命令只能创建常规文件；它不能创建目录。另外，请注意它更新修改和访问时间，那么有什么区别呢？'
- en: Modification Time > Last time a file was changed or modified.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改时间 > 文件最后一次被更改或修改的时间。
- en: Access Time > Last time a file was accessed (read).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问时间 > 文件最后一次被访问（读取）的时间。
- en: 'By default, the `touch` command changes both the modification and access times
    of a file. I have created three files in `elliot`''s home directory: `file1`,
    `file2`, and `file3`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`touch` 命令会同时更改文件的修改和访问时间。我在 `elliot` 的主目录中创建了三个文件：`file1`、`file2` 和 `file3`：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now to change only the modification time of `file1`. We pass the `-m` option
    to the `touch` command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只更改 `file1` 的修改时间。我们向 `touch` 命令传递 `-m` 选项：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see, the modification time of `file1` has now changed. I promised
    you I would only change the modification time, right? If you pass the `-u` option
    along with the `-l` option to the `ls` command, you will get the last access times
    instead of the modification times:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`file1` 的修改时间现在已经改变。我答应过只更改修改时间，对吧？如果你向 `ls` 命令传递 `-u` 选项和 `-l` 选项，你将得到最后访问时间而不是修改时间：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, the last modification time of `file1` is changed to `Jan 25
    23:08`, but the access time is left unchanged: `Feb 29 2004`. Now this time around,
    let''s only change the access time of `file2`. To do this, we pass the `-a` option
    to the `touch` command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`file1` 的最后修改时间已经改变为 `Jan 25 23:08`，但访问时间保持不变：`Feb 29 2004`。这一次，让我们只改变
    `file2` 的访问时间。为此，我们向 `touch` 命令传递 `-a` 选项：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, the modification time of `file2` was left unchanged, but the
    access time is changed to the current time. Now to change both the modification
    and access times of `file3`, you can run the `touch` command with no options:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`file2` 的修改时间保持不变，但访问时间已更改为当前时间。现在要同时更改 `file3` 的修改和访问时间，你可以运行不带选项的
    `touch` 命令：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Awesome! You can also pass the `-t` option to the `ls` command to list the
    files sorted by modification times, newest first:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你还可以向 `ls` 命令传递 `-t` 选项，按修改时间排序列出文件，最新的排在前面：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can add the `-u` option to sort by access times instead:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加 `-u` 选项以按访问时间排序：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can also pass the `-r` option to reverse the sorting:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以传递 `-r` 选项来反向排序：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Making directories
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建目录
- en: To create directories in Linux, we use the `mkdir` command, which is short for
    **make directory**.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中创建目录，我们使用 `mkdir` 命令，它是 **make directory** 的缩写。
- en: 'In `elliot`''s desktop, let''s create a directory named `games` by running
    the `mkdir games` command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `elliot` 的桌面上，通过运行 `mkdir games` 命令创建一个名为 `games` 的目录：
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice that my current working directory is `/home/elliot/Destkop`; that's why
    I was able to use a relative path.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我的当前工作目录是 `/home/elliot/Destkop`；这就是为什么我能够使用相对路径的原因。
- en: '![](img/53b62972-d736-4a08-87ed-b880f540c414.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53b62972-d736-4a08-87ed-b880f540c414.jpg)'
- en: 'Figure 12: games Directory Created on the Desktop'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12：桌面上创建的 `games` 目录
- en: 'You can also create multiple directories at the same time. For example, you
    can create three directories – `Music`, `Movies`, and `Books` – on your desktop
    by running the `mkdir Music Movies Books` command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以同时创建多个目录。例如，您可以通过运行`mkdir Music Movies Books`命令在桌面上创建三个目录-`Music`，`Movies`和`Books`：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![](img/ce2df5e4-c1ec-4ecd-afb5-0789d584b925.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce2df5e4-c1ec-4ecd-afb5-0789d584b925.jpg)'
- en: 'Figure 13: Directories Created on the Desktop'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图13：在桌面上创建的目录
- en: 'You can also use the `-p` option to create a whole path of directories. For
    example, you can create the path `/home/elliot/dir1/dir2/dir3` by running the
    `mkdir -p dir1/dir2/dir3` command:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`-p`选项创建整个目录路径。例如，您可以通过运行`mkdir -p dir1/dir2/dir3`命令创建路径`/home/elliot/dir1/dir2/dir3`：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It created `dir1` in the `/home/elliot` directory, and then it created `dir2`
    inside of `dir1`, and finally, it created `dir3` inside of `dir2`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 它在`/home/elliot`目录中创建了`dir1`，然后在`dir1`中创建了`dir2`，最后在`dir2`中创建了`dir3`。
- en: 'You can use the recursive `-R` option to do a recursive listing on `/home/elliot/dir1`
    and see all the files underneath `/home/elliot/dir1` without the hassle of changing
    to each directory:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用递归的`-R`选项对`/home/elliot/dir1`进行递归列表，并查看`/home/elliot/dir1`下的所有文件，而无需更改每个目录：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, it listed all the files under `/home/elliot/dir1`. It even displayed
    the hierarchy.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它列出了`/home/elliot/dir1`下的所有文件。它甚至显示了层次结构。
- en: 'You can also create a new directory with multiple subdirectories by including
    them inside a pair of curly brackets and each subdirectory separated by a comma
    like in the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过将它们包含在一对大括号中，并且每个子目录之间用逗号分隔，来创建具有多个子目录的新目录，就像以下示例中一样：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, we created `dir4`, and inside it, we created three directories
    – `dir5`, `dir6`, and `dir7`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们创建了`dir4`，并在其中创建了三个目录-`dir5`，`dir6`和`dir7`。
- en: Combining command options
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合命令选项
- en: You have learned a lot of different options that you can use with the `ls` command.
    `Table 4` summarizes all the options we have used so far.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了许多可以与`ls`命令一起使用的不同选项。`表4`总结了到目前为止我们使用过的所有选项。
- en: '| **ls option** | **What it does** |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| **ls选项** | **作用** |'
- en: '| `-l` | Long and detailed listing of files. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `-l` | 文件的长格式和详细列表。 |'
- en: '| `-a` | List the hidden files. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `-a` | 列出隐藏文件。 |'
- en: '| `-d` | List directories themselves, not their contents. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `-d` | 仅列出目录本身，而不是它们的内容。 |'
- en: '| `-t` | Sort files by modification times. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `-t` | 按修改时间对文件进行排序。 |'
- en: '| `-u` | When used with `-l`, it shows access times instead of modification
    times. When used with `-lt`, it will sort by, and show, access times. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `-u` | 与`-l`一起使用时，显示访问时间而不是修改时间。与`-lt`一起使用时，将按访问时间排序并显示访问时间。 |'
- en: '| `-r` | Will reverse listing order. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `-r` | 将列表顺序反转。 |'
- en: '| `-R` | List subdirectories recursively. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `-R` | 递归列出子目录。 |'
- en: 'Table 4: Popular ls Command Options'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 表4：常用ls命令选项
- en: You will often be wanting to use two or more command options at a time. For
    example, `ls -a -l` is commonly used to do a long listing for all the files in
    a directory.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您经常会希望同时使用两个或更多的命令选项。例如，`ls -a -l`通常用于对目录中的所有文件进行长列表。
- en: 'Also, `ls -l -a -t -r` is a very popular combination because sometimes you
    would want to see the listing of the files sorted by modification times (oldest
    first). For that reason, combining the command options is more efficient and so
    running the `ls -latr` command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`ls -l -a -t -r`是一个非常受欢迎的组合，因为有时您可能希望按修改时间排序文件的列表（从最旧到最新）。因此，组合命令选项更有效，因此运行`ls
    -latr`命令：
- en: '[PRE57]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Will yield the same result as running the `ls -l -a -t -r` command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生与运行`ls -l -a -t -r`命令相同的结果：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Before this chapter comes to an end, I want to show you a pretty cool tip.
    First, let''s create a directory named `averylongdirectoryname`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束之前，我想向您展示一个非常酷的技巧。首先，让我们创建一个名为`averylongdirectoryname`的目录：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**Tab Completion** is one of the most useful features in the Linux command
    line. You can use this to feature to let the shell automatically complete (suggest)
    command names and file paths. To demonstrate, type (don''t run) the following
    text on your terminal:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**制表完成**是Linux命令行中最有用的功能之一。您可以使用此功能让shell自动完成（建议）命令名称和文件路径。为了演示，输入（不要运行）以下文本到您的终端：'
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now press the *Tab* key on your keyboard, and the shell will automatically
    complete the directory name for you:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按下键盘上的*Tab*键，shell将自动为您完成目录名称：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Pretty cool! Alright, this takes us to the end of this chapter, and it's time
    for you to do the lovely knowledge check.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 相当酷！好的，这就是本章的结束，现在是时候进行可爱的知识检查了。
- en: Knowledge check
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 知识检查
- en: 'For the following exercises, open up your terminal and try to solve the following
    tasks:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下练习，打开终端并尝试解决以下任务：
- en: Do a long listing for all the files in `/var/log`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`/var/log`中的所有文件进行长列表。
- en: Display the contents of the file `/etc/hostname`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示文件`/etc/hostname`的内容。
- en: Create three files – `file1`, `file2`, and `file3` – in `/home/elliot`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/home/elliot`中创建三个文件-`file1`，`file2`和`file3`。
- en: List all the files (including hidden files) of `elliot`'s home directory.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出`elliot`的主目录中的所有文件（包括隐藏文件）。
- en: Create a directory named `fsociety` in `/home/elliot`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/home/elliot`中创建一个名为`fsociety`的目录。
- en: True or false
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真或假
- en: '`/home/root` is the home directory of the root user.'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/home/root`是root用户的主目录。'
- en: '`dir1/dir2/dir3` is an example of an absolute path.'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dir1/dir2/dir3`是绝对路径的一个例子。'
- en: '`/home/elliot/Desktop` is an example of an absolute path.'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/home/elliot/Desktop`是绝对路径的一个例子。'
- en: '`touch -m file1` will update `file1` access time.'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`touch -m file1`将更新`file1`的访问时间。'
- en: '`mkdir dir1 dir2 dir3` will create three directories – `dir1`, `dir2`, and
    `dir3`.'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mkdir dir1 dir2 dir3`将创建三个目录-`dir1`，`dir2`和`dir3`。'
