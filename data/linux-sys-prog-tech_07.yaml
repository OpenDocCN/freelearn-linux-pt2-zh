- en: '*Chapter 7*: Using systemd to Handle Your Daemons'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：使用systemd处理您的守护进程'
- en: Now that we know how to build our own daemons, it's time to see how we can get
    Linux to handle them using **systemd**. In this chapter, we will learn what systemd
    is, how to start and stop services, what unit files are, and how to create them.
    We will also learn how daemons are logged to systemd and how we read those logs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何构建我们自己的守护进程，是时候看看我们如何使用**systemd**让Linux来处理它们了。在本章中，我们将学习systemd是什么，如何启动和停止服务，什么是单元文件，以及如何创建它们。我们还将学习守护进程如何记录到systemd中以及如何读取这些日志。
- en: We will then learn about different kinds of services and daemons that systemd
    can handle and put the daemon from the previous chapter under systemd control.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将了解systemd可以处理的不同类型的服务和守护进程，并将上一章的守护进程放到systemd控制下。
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Getting to know systemd
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解systemd
- en: Writing a unit file for a daemon
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为守护进程编写一个单元文件
- en: Enabling and disabling a service—and starting and stopping it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用和禁用服务，以及启动和停止它
- en: Creating a more modern daemon for systemd
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为systemd创建一个更现代的守护进程
- en: Making the new daemon a systemd service
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使新的守护进程成为systemd服务
- en: Reading the journal
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读日志
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this recipe, you'll need a computer with a Linux distribution that uses
    systemd—which, today, is pretty much every distribution, with some rare exceptions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您需要一台使用systemd的Linux发行版的计算机——今天几乎每个发行版都是如此，只有一些少见的例外。
- en: You'll also need the GCC compiler and the Make tool. Installation instructions
    for these tools are covered in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*. You'll also
    need the generic Makefile for this chapter, which is found in this chapter's repository
    on GitHub, along with all the code samples for this chapter. The URL for this
    chapter's repository folder on GitHub is [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch7](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch7).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要GCC编译器和Make工具。这些工具的安装说明在[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中有涵盖。您还需要本章的通用Makefile，在本章的GitHub存储库中可以找到，以及本章的所有代码示例。本章的GitHub存储库文件夹的URL是[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch7](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch7)。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3cxmXab](https://bit.ly/3cxmXab)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以查看“代码实战”视频：[https://bit.ly/3cxmXab](https://bit.ly/3cxmXab)
- en: Getting to know systemd
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解systemd
- en: In this recipe, we'll explore what systemd is, how it handles the system, and
    all of the system's services.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将探讨systemd是什么，它如何处理系统以及所有系统的服务。
- en: Historically, Linux has been managed with several smaller pieces. For example,
    `init` was the first process on the system, which started other processes and
    daemons to bring up the system. System daemons were handled by shell scripts,
    also called *init scripts*. Logging was done either by the daemon itself via files
    or `syslog`. Networking was also handled by multiple scripts (and still is in
    some Linux distributions).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，Linux一直由几个较小的部分管理。例如，`init`是系统上的第一个进程，它启动其他进程和守护进程来启动系统。系统守护进程由shell脚本处理，也称为*init脚本*。日志记录是通过守护进程自己通过文件或`syslog`来完成的。网络也是由多个脚本处理的（在一些Linux发行版中仍然是这样）。
- en: Nowadays, though, the entire system is handled by systemd. For example, the
    first process on the system is now `systemd` (which we have seen in previous chapters).
    Daemons are handled by something called *unit files*, which create a unified way
    of controlling daemons on the system. Logging is handled by **journald**, systemd's
    logging daemon. But do note that **syslog** is still used by many daemons to do
    extra logging. Later in this chapter, in the *Making the new daemon a systemd
    service* section, we'll re-write the daemon from [*Chapter 6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245),
    *Spawning Processes and Using Job Control*, to log to the journal.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在整个系统都由systemd处理。例如，系统上的第一个进程现在是`systemd`（我们在之前的章节中已经看到了）。守护进程由称为*单元文件*的东西处理，它在系统上创建了一种统一的控制守护进程的方式。日志记录由**journald**处理，它是systemd的日志记录守护进程。但请注意，**syslog**仍然被许多守护进程用于额外的日志记录。在本章的*使新的守护进程成为systemd服务*部分中，我们将重新编写[*第6章*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245)中的守护进程，以记录到日志中。
- en: Knowing how systemd works will enable you to use it properly when, for example,
    writing unit files for daemons. It will also help you to write daemons in the
    "new" way, to make use of systemd's logging features. You will become a better
    system administrator as well as a better Linux developer.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 了解systemd的工作原理将使您能够在编写守护进程的单元文件时正确使用它。它还将帮助您以“新”的方式编写守护进程，以利用systemd的日志记录功能。您将成为一个更好的系统管理员，也将成为一个更好的Linux开发人员。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll only need a Linux distribution that uses systemd, which
    most distributions do today.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您只需要一个使用systemd的Linux发行版，大多数发行版今天都使用systemd。
- en: How to do it...
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll take a look at some of the components involved in systemd.
    This will give us a bird''s eyes view of systemd, journald, its commands, and
    **unit files**. All the details will come in later recipes in this chapter:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看一下systemd涉及的一些组件。这将让我们俯瞰systemd、journald、它的命令和**单元文件**。所有的细节将在本章的后续示例中介绍：
- en: Start by typing `systemctl` in a console window and hit *Enter*. This will show
    you all active *units* on your machine right now. If you skim through the list,
    you'll notice that a unit can be just about anything—hard drives, sound cards,
    mounted network drives, miscellaneous services, timers, and so on.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台窗口中键入`systemctl`并按*Enter*。这将显示您机器上当前所有活动的*单元*。如果您浏览列表，您会注意到一个单元可以是任何东西——硬盘、声卡、挂载的网络驱动器、各种服务、定时器等等。
- en: All the services we saw in the previous step reside as unit files in `/lib/systemd/system`
    or `/etc/systemd/system`. Navigate to those directories and look around at the
    files. These are all typical unit files.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在上一步看到的所有服务都作为单元文件存储在`/lib/systemd/system`或`/etc/systemd/system`中。转到这些目录并查看文件。这些都是典型的单元文件。
- en: Now it's time to take a look at the journal, the log of systemd. We need to
    run this command as `sudo journalctl`, or switch to root first with `su`, and
    then type `journalctl`. This will show you the entire log of systemd and all of
    its services. Hit *Spacebar* several times to scroll down in the log. To go to
    the end of the log, type a capital *G* while the log is displayed.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候来看一下日志，即systemd的日志。我们需要以`sudo journalctl`命令运行此命令，或者首先切换到root用户，然后输入`journalctl`。这将显示systemd和其所有服务的整个日志。按*Spacebar*键几次以在日志中向下滚动。要转到日志的末尾，在日志显示时输入大写*G*。
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: These three steps give us an overview of systemd. In the coming recipes, we'll
    cover the details in much more depth.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个步骤让我们对systemd有了一个概述。在接下来的教程中，我们将更深入地介绍细节。
- en: Installed packages place their unit files in `/lib/systemd/system` if it's a
    Debian/Ubuntu system, and in `/usr/lib/systemd/system` if it's a CentOS/Fedora
    system. On CentOS/Fedora, though, `/lib` is a symbolic link to `/usr/lib`, so
    `/lib/systemd/system` is universal.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 已安装的软件包将其单元文件放在`/lib/systemd/system`中，如果是Debian/Ubuntu系统，则放在`/usr/lib/systemd/system`中，如果是CentOS/Fedora系统。但是，在CentOS/Fedora上，`/lib`是指向`/usr/lib`的符号链接，因此`/lib/systemd/system`是通用的。
- en: So-called *local* unit files are placed in `/etc/systemd/system`. Local unit
    files mean unit files specific to this system, for example, modified by the administrator
    or manually added for some program.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的*local*单元文件放在`/etc/systemd/system`中。本地单元文件意味着特定于此系统的单元文件，例如，由管理员修改或手动添加的某些程序。
- en: There's more...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There have been other init systems for Linux before systemd. We have already
    mentioned the first one briefly, `init`. That init system, `init`, is often called
    *Sys-V-style init*, from UNIX version five (V).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在systemd之前，Linux有其他的初始化系统。我们已经简要提到了第一个`init`。那个初始化系统`init`通常被称为*Sys-V-style
    init*，来自UNIX版本五（V）。
- en: After the Sys-V-style init came Upstart, a full replacement for `init` developed
    by Ubuntu. Upstart was also used by CentOS 6 and Red Hat Enterprise Linux 6.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sys-V-style init之后，出现了Upstart，这是Ubuntu开发的`init`的完全替代品。Upstart也被CentOS 6和Red
    Hat Enterprise Linux 6使用。
- en: Nowadays, though, most major Linux distributions use systemd. Since systemd
    is a huge part of Linux, this makes all the distributions pretty much alike. Fifteen
    years ago, it wasn't easy to jump from one distribution to another one. Nowadays,
    it's much easier.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今，大多数主要的Linux发行版都使用systemd。由于systemd是Linux的一个重要组成部分，这使得所有发行版几乎都是相似的。十五年前，从一个发行版跳到另一个发行版并不容易。如今，这变得更容易了。
- en: See also
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'There are multiple manual pages on the system we can read to understand systemd,
    its commands, and the journal at a deeper level:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 系统上有多个手册页面，我们可以阅读以更深入地了解systemd、其命令和日志：
- en: '`man systemd`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man systemd`'
- en: '`man systemctl`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man systemctl`'
- en: '`man journalctl`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man journalctl`'
- en: '`man systemd.unit`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man systemd.unit`'
- en: Writing a unit file for a daemon
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为守护进程编写单元文件
- en: In this recipe, we will take the daemon we wrote in [*Chapter 6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245),
    *Spawning Processes and Using Job Control*, and make it a service under systemd.
    This daemon is what systemd calls a *forking daemon* because it does just that.
    It forks. This is traditionally how daemons have worked, and they are still widely
    used. Later in this chapter, in the *Making the new daemon a systemd service*
    section, we will modify it slightly to log to systemd's journal. But first things
    first, let's make our existing daemon into a service.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将把我们在[*第6章*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245)中编写的守护程序，*生成进程和使用作业控制*，变成systemd下的一个服务。这个守护程序是systemd称之为*forking
    daemon*的，因为它就是这样。它分叉。这通常是守护程序的工作方式，它们仍然被广泛使用。在本章的*将新守护程序变成systemd服务*部分中，我们将稍微修改它以记录到systemd的日志中。但首先，让我们将我们现有的守护程序变成一个服务。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you'll need the file `my-daemon-v2.c` that we wrote in [*Chapter
    6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245), *Spawning Processes and Using
    Job Control*. If you don't have that file, there is a copy of it in this chapter's
    directory on GitHub at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch7/my-daemon-v2.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch7/my-daemon-v2.c).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将需要我们在[*第6章*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245)中编写的文件`my-daemon-v2.c`，*生成进程和使用作业控制*。如果您没有该文件，在GitHub的本章目录中有一份副本，网址为[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch7/my-daemon-v2.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch7/my-daemon-v2.c)。
- en: Apart from `my-daemon-v2.c`, you'll need the GCC compiler, the Make tool, and
    the generic Makefile covered in the *Technical requirements* section of this chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`my-daemon-v2.c`，您还需要GCC编译器、Make工具和本章*技术要求*部分中涵盖的通用Makefile。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here we will put our daemon under systemd''s control:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将把我们的守护程序置于systemd的控制之下：
- en: 'If you haven''t compiled `my-daemon-v2` yet, we''ll need to begin with that.
    Compile it like any other program we have made so far:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有编译`my-daemon-v2`，我们需要从那里开始。像我们迄今为止制作的任何其他程序一样编译它：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For this to be a system daemon, we should place it in one of the directories
    for that purpose. A good place for this is `/usr/local/sbin`. The `/usr/local
    directory` is where we usually want to place things that we have added to the
    system ourselves, that is, third-party stuff. The `sbin` subdirectory is for system
    binaries or super-user binaries (hence the *s* before *bin*). To move our daemon
    here, we need to be root:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其成为系统守护程序，我们应该将其放在其中一个专门用于此目的的目录中。一个很好的地方是`/usr/local/sbin`。`/usr/local目录`通常是我们想要放置我们自己添加到系统中的东西的地方，也就是第三方的东西。`sbin`子目录用于系统二进制文件或超级用户二进制文件（因此在*bin*之前有一个*s*）。要将我们的守护程序移到这里，我们需要成为root用户：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now comes the exciting stuff, writing the *unit file* for the daemon. Create
    the file `/etc/systemd/system/my-daemon.service` as root. Use either `sudo` or
    `su` to become root. Write the content shown below in the file and save it. The
    unit file is divided into several sections. In this file, the sections are `[Unit]`,
    `[Service]`, and `[Install]`. The `[Unit]` section contains information about
    the unit, such as the description in our case. The `[Service]` section contains
    information about how this service should work and behave. Here, we have `ExecStart`,
    which contains the path to the daemon. We also have `Restart=on-failure`. This
    tells systemd to restart the daemon if it should crash. Then we have the `Type`
    directive, which in our case is forking. Remember that our daemon creates a fork
    of itself and the parent process exits. This is what the type *forking* means.
    We tell systemd the type so it knows how it should handle the daemon. Then we
    have `PIDFile`, which contains the path to our `WantedBy` set to `multi-user.target`.
    What this means is that this daemon should start when the system enters the multi-user
    stage:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来写守护程序的*单元文件*，这才是令人兴奋的部分。以root身份创建文件`/etc/systemd/system/my-daemon.service`。使用`sudo`或`su`成为root。在文件中写入下面显示的内容并保存。单元文件分为几个部分。在这个文件中，部分是`[Unit]`、`[Service]`和`[Install]`。`[Unit]`部分包含有关单元的信息，例如我们的描述。`[Service]`部分包含有关此服务应如何工作和行为的信息。在这里，我们有`ExecStart`，其中包含守护程序的路径。我们还有`Restart=on-failure`。这告诉systemd如果守护程序崩溃，应重新启动它。然后我们有`Type`指令，在我们的情况下是forking。请记住，我们的守护程序创建了一个自己的分支，父进程退出。这就是*forking*类型的含义。我们告诉systemd类型，以便它知道如何处理守护程序。然后我们有`PIDFile`，其中包含我们的`WantedBy`设置为`multi-user.target`。这意味着当系统进入多用户阶段时，此守护程序应该启动：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For our new unit file to be recognized by the system, we need to *reload* the
    systemd daemon itself. This will read in our new file. This must be done as root:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让系统识别我们的新单元文件，我们需要*重新加载*systemd守护程序本身。这将读取我们的新文件。这必须以root身份完成：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now see if systemd recognizes our new daemon by using the `status` command
    for `systemctl`. Note that we see both the description here from the unit file
    and the actual unit file used. We also see that the daemon is currently *disabled*
    and *inactive*:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用`systemctl`的`status`命令来查看systemd是否识别我们的新守护程序。请注意，我们在这里从单元文件中看到了描述，以及实际使用的单元文件。我们还看到守护程序当前是*禁用*和*未激活*的：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: It's not harder than this to create a service for a daemon in systemd. Once
    we have learned systemd and unit files, it's easier than writing *init scripts*
    as we did in the old days. With only nine lines, we have put the daemon under
    the control of systemd.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为守护程序创建一个systemd服务并不比这更难。一旦我们学会了systemd和单元文件，就比在旧日写*init脚本*更容易。只用了九行，我们就将守护程序置于systemd的控制之下。
- en: The unit file is mostly self-explanatory. In our case, with a traditional daemon
    that forks, we set the type to *forking* and specify a PID file. Systemd then
    uses the PID number from the PID file to track the daemon state. This way, systemd
    can restart the daemon if it notices that the PID has disappeared from the system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件大部分都是不言自明的。在我们的情况下，对于一个传统的分叉守护程序，我们将类型设置为*forking*并指定一个PID文件。然后systemd使用PID文件中的PID号来跟踪守护程序的状态。这样，如果systemd注意到PID从系统中消失，它就可以重新启动守护程序。
- en: In the status message, we saw that the service is *disabled* and *inactive*.
    **Disabled** means that it won't start automatically when the system boots. **Inactive**
    means that it hasn't started yet.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态消息中，我们看到服务被*禁用*和*未激活*。**禁用**意味着系统启动时不会自动启动。**未激活**意味着它还没有启动。
- en: There's more...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If you are writing a unit file for a daemon that uses the network, for example,
    an internet daemon, you can explicitly tell systemd to wait with this daemon until
    the network is ready. To achieve this, we add these lines under the `[Unit]` section:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为使用网络的守护程序编写一个单元文件，例如互联网守护程序，您可以明确告诉systemd等待直到网络准备就绪。为了实现这一点，我们在`[Unit]`部分下添加以下行：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can, of course, use `After` and `Wants` for other dependencies as well.
    There is also another dependency statement you can use, called `Requires`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以为其他依赖关系使用`After`和`Wants`。还有另一个依赖语句可以使用，称为`Requires`。
- en: The difference between them is that `After` specifies the order of the units.
    A unit with `After` will wait to start after the unit required is started. `Wants`
    and `Requires`, however, only specify the dependency, not the ordering. With `Wants`,
    a unit will still start even if the other unit required isn't started successfully.
    But with `Requires`, the unit will fail to start if the required unit isn't started.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的区别在于`After`指定了单元的顺序。具有`After`的单元将在所需单元启动后等待启动。然而，`Wants`和`Requires`只指定了依赖关系，而不是顺序。使用`Wants`，即使其他所需单元未成功启动，单元仍将启动。但是使用`Requires`，如果所需单元未启动，单元将无法启动。
- en: See also
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In `man systemd.unit` is a lot of information about the different sections of
    a unit file and which directives we can use in each section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`man systemd.unit`中有关于单元文件的不同部分以及我们可以在每个部分中使用的指令的大量信息。
- en: Enabling and disabling a service – and starting and stopping it
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用和禁用服务 - 以及启动和停止它
- en: In the previous recipe, we added our daemon as a service to systemd with a unit
    file. In this recipe, we'll learn how to enable it, start it, stop it, and disable
    it. There is a difference between enabling and starting and disabling and stopping
    a service.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们使用一个单元文件将我们的守护程序添加为systemd的一个服务。在这个教程中，我们将学习如何启用、启动、停止和禁用它。启用和启动以及禁用和停止服务之间有区别。
- en: Enabling a service means that it will start automatically when the system boots.
    Starting a service means that it will start right now, regardless of it being
    enabled or not. And disabling a service means that it will no longer start when
    the system boots. Stopping a service stops it right now, regardless of it being
    enabled or disabled.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 启用服务意味着系统启动时将自动启动。启动服务意味着它将立即启动，无论它是否已启用。禁用服务意味着它将不再在系统启动时启动。停止服务会立即停止它，无论它是否已启用或禁用。
- en: Knowing how to do all of this enables you to control the system's services.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何做所有这些可以让你控制系统的服务。
- en: Getting ready
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe to work, you'll first need to complete the previous recipe,
    *Writing a unit file for a daemon*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个教程起作用，你首先需要完成前面的教程，*为守护进程编写一个单元文件*。
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start by checking out the daemon status again. It should be both disabled
    and inactive:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先再次检查守护进程的状态。它应该是禁用和未激活的：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we''ll *enable* it, meaning it will start automatically on boot (when the
    system enters *multi-user mode*). We must issue this command as root since it''s
    a command that modifies the system. Notice also what''s happening when we enable
    it. There''s no arcane stuff going on; it just creates a symbolic link from our
    unit file to `/etc/systemd/system/multi-user.target.wants/my-daemon.service`.
    Remember that `multi-user.target` was the target we specified in the unit file.
    So when the system reaches the multi-user level, systemd will start all services
    in that directory:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将*启用*它，这意味着它将在启动时自动启动（当系统进入*多用户模式*时）。由于这是一个修改系统的命令，我们必须以root身份发出此命令。还要注意当我们启用它时发生了什么。没有什么神秘的事情发生；它只是从我们的单元文件创建一个符号链接到`/etc/systemd/system/multi-user.target.wants/my-daemon.service`。请记住，`multi-user.target`是我们在单元文件中指定的目标。因此，当系统达到多用户级别时，systemd将启动该目录中的所有服务：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s check out the status of the daemon now that we have enabled it. It should
    now say *enabled* instead of *disabled*. However, it is still *inactive* (not
    started):'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们检查一下守护进程的状态，因为我们已经启用了它。现在它应该显示*已启用*而不是*已禁用*。但是，它仍然是*未激活*（未启动）：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now it''s time to start the daemon:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是启动守护进程的时候了：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And let''s check out the status one more time. It should be both enabled and
    active (that is, started). This time, we''ll get more information about the daemon
    than before. We''ll see its PID, its status, its memory usage, and so on. We''ll
    also see a snippet from the log at the end:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次检查状态。它应该是启用和活动的（也就是已启动）。这一次，我们将获得比以前更多关于守护进程的信息。我们将看到它的PID、状态、内存使用情况等。我们还将在最后看到日志的片段：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s verify that systemd restarts the daemon if it crashes or gets killed.
    First, we check out the process with `ps`. Then we kill it with the `KILL` signal,
    so it has no chance of exiting normally. Then we check it out again with `ps`
    and notices that it has a new PID since it''s a new process. The old one got killed,
    and systemd started a new instance of it:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们验证一下，如果守护进程崩溃或被杀死，systemd是否会重新启动它。首先，我们用`ps`查看进程。然后我们用`KILL`信号杀死它，所以它没有机会正常退出。然后我们再次用`ps`查看它，并注意到它有一个新的PID，因为它是一个新的进程。旧的进程被杀死了，systemd启动了一个新的实例：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also check out the file that the daemon writes to in the `/tmp` directory:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以查看守护进程在`/tmp`目录中写入的文件：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And finally, let''s stop the daemon. We''ll also check its status and check
    that the process is gone with `ps`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们停止守护进程。我们还将检查它的状态，并检查进程是否已经消失了`ps`：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To prevent the daemon from starting when the system reboots, we must also *disable*
    the service. Notice what''s happening here. The symbolic link that got created
    when we enabled the service is now removed:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了防止守护进程在系统重新启动时启动，我们还必须*禁用*该服务。请注意这里发生了什么。当我们启用服务时创建的符号链接现在被删除了：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we enable or disable a service, systemd creates a symbolic link in the
    *target* directory. In our case, the target was *multi-user*, that is, when the
    system has reached the multi-user level.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启用或禁用一个服务时，systemd会在*target*目录中创建一个符号链接。在我们的情况下，目标是*multi-user*，也就是当系统达到多用户级别时。
- en: In step five, when we started the daemon, we saw the *Main PID* in the status
    output. This PID matches the PID from the `/var/run/my-daemon.pid` file that the
    daemon creates. This is how systemd keeps track of *forking* daemons. In the next
    recipe, we'll see how we can create a daemon for systemd without forking.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第五步，当我们启动守护进程时，我们在状态输出中看到了*Main PID*。这个PID与守护进程创建的`/var/run/my-daemon.pid`文件中的PID匹配。这就是systemd如何跟踪*forking*守护进程的方式。在下一个教程中，我们将看到如何在systemd中创建一个不需要fork的守护进程。
- en: Creating a more modern daemon for systemd
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为systemd创建一个更现代的守护进程
- en: Daemons that are handled by systemd don't need to fork or close their file descriptors.
    Instead, it's advised to use standard output and standard error to write the daemon's
    logs to the journal. The journal is systemd's logging facility.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由systemd处理的守护进程不需要fork或关闭它们的文件描述符。相反，建议使用标准输出和标准错误将守护进程的日志写入日志。日志是systemd的日志记录设施。
- en: In this recipe, we'll write a new daemon, one that doesn't fork and leaves `/tmp/my-daemon-is-alive.txt
    file`, as before). This kind of daemon is sometimes referred to as a `my-daemon-v2.c`,
    is referred to as a **SysV-style daemon**. **SysV** was the name of the init system
    before systemd.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将编写一个新的守护进程，一个不会fork并留下`/tmp/my-daemon-is-alive.txt`文件的守护进程（与之前一样）。这种类型的守护进程有时被称为`my-daemon-v2.c`，被称为**SysV风格守护进程**。**SysV**是systemd之前的init系统的名称。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll only need what's listed in the *Technical requirements*
    section of this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，你只需要本章节*技术要求*部分列出的内容。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll write a **new-style daemon**:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将编写一个**新式守护进程**：
- en: 'This program is a bit long, so I''ve split it up into several steps. Write
    the code in a file and save it as `new-style-daemon.c`. All the code goes into
    a single file, even though there are several steps. We''ll start by writing all
    the `include` statements, the function prototype for the signal handler, and the
    `main()` function body. Notice that we don''t fork here. We also don''t close
    any file descriptors or streams. Instead, we write the "*Daemon alive*" text to
    standard output. Note that we need to *flush* stdout here. Normally, streams are
    line-buffered, meaning they get flushed on each new line. But when stdout is redirected
    to something else, like with systemd, it''s instead fully buffered. To be able
    to see the text as it gets printed, we need to flush it; otherwise, we wouldn''t
    see anything in the log until we stop the daemon or the buffer gets filled:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个程序有点长，所以我把它分成了几个步骤。将代码写入文件并保存为`new-style-daemon.c`。所有代码都放在一个文件中，即使有几个步骤。我们将首先编写所有的`include`语句，信号处理程序的函数原型和`main()`函数体。请注意，我们这里不进行fork。我们也不关闭任何文件描述符或流。相反，我们将“*守护程序活着*”文本写入标准输出。请注意，我们需要在这里*刷新*stdout。通常，流是行缓冲的，这意味着它们在每个新行上都会被刷新。但是当stdout被重定向到其他地方时，比如使用systemd，它会被完全缓冲。为了能够看到打印的文本，我们需要刷新它；否则，在停止守护程序或缓冲区填满之前，我们将看不到日志中的任何内容：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we''ll write the function for the signal handler. Note that we catch both
    `SIGHUP` and `SIGTERM` here. `SIGHUP` is often used to reload any configuration
    files without restarting the entire daemon. `SIGTERM` is caught so that the daemon
    can clean up after itself (close all open file descriptors or streams and remove
    any temporary files). We don''t have any configuration files or temporary files
    here, so we print a message to standard output instead:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将编写信号处理程序的函数。请注意，我们在这里捕获了`SIGHUP`和`SIGTERM`。`SIGHUP`经常用于重新加载任何配置文件，而无需重新启动整个守护程序。捕获`SIGTERM`是为了让守护程序在自己之后进行清理（关闭所有打开的文件描述符或流并删除任何临时文件）。我们这里没有任何配置文件或临时文件，所以我们将消息打印到标准输出：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now it''s time to compile the daemon so we can use it:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候编译守护程序，这样我们就可以使用它了：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can run it interactively to verify that it''s working:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以交互式运行它以验证它是否正常工作：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This daemon works pretty much like any other program we have written. There's
    no need to do any forking, change the working directory, close file descriptors
    or streams, or anything like that. It's just a regular program.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个守护程序的工作方式几乎与我们编写的任何其他程序一样。无需进行任何forking、更改工作目录、关闭文件描述符或流，或者其他任何操作。它只是一个常规程序。
- en: Note that we don't flush the stdout buffer in the signal handler. Every time
    the program receives a signal and prints a message, the program goes back into
    the `for` loop, prints another "*Daemon alive*" message, and then flushes when
    the program reaches `fflush(stdout)` in the `for` loop. If the signal is `SIGTERM`,
    all buffers are flushed on `exit(0)`, so we don't need to flush here either.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不在信号处理程序中刷新stdout缓冲区。每次程序接收到信号并打印消息时，程序都会回到`for`循环中，打印另一条“*守护程序活着*”消息，然后在`for`循环中的`fflush(stdout)`处刷新。如果信号是`SIGTERM`，则在`exit(0)`时刷新所有缓冲区，因此我们这里也不需要刷新。
- en: In the next recipe, we'll make this program a systemd service.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个食谱中，我们将使这个程序成为systemd服务。
- en: See also
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: You can get much more in-depth information about the `man 7 daemon`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`man 7 daemon`中获取更多深入的信息。
- en: Making the new daemon a systemd service
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使新守护程序成为systemd服务
- en: Now that we've made a **new-style daemon** in the previous recipe, we'll see
    that it's even easier to make a unit file for this daemon.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在上一个食谱中制作了一个**新式守护程序**，我们将看到为这个守护程序制作一个单元文件更容易。
- en: Knowing how to write unit files to new-style daemons is important since more
    and more daemons are written this way. When making new daemons for Linux, we should
    make them in this new style.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何编写单元文件以适应新式守护程序非常重要，因为越来越多的守护程序是以这种方式编写的。在为Linux制作新的守护程序时，我们应该以这种新的方式制作它们。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need to complete the previous one. It's the daemon from
    that recipe that we'll use here.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，您需要完成上一个食谱。我们将在这里使用那个食谱中的守护程序。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here, we will make the **new-style daemon** a systemd service:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使**新式守护程序**成为systemd服务：
- en: 'Let''s begin by moving the daemon to `/usr/local/sbin`, just as we did with
    the traditional daemon. Remember, you''ll need to be root for this:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先将守护程序移动到`/usr/local/sbin`，就像我们对传统守护程序所做的那样。请记住，您需要以root身份进行操作：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we''ll write the new unit file. Create the `/etc/systemd/system/new-style-daemon.service`
    file and give it the following content. Remember, you''ll need to be root to create
    that file. Notice that we don''t need to specify any PID file here. Also, note
    that we have changed `Type=forking` to `Type=simple`. Simple is the default type
    for systemd services:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将编写新的单元文件。创建`/etc/systemd/system/new-style-daemon.service`文件，并给它以下内容。请注意，我们不需要在这里指定任何PID文件。另外，请注意，我们已将`Type=forking`更改为`Type=simple`。Simple是systemd服务的默认类型：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Reload the systemd daemon, so the new unit file gets recognized:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新加载systemd守护程序，以便识别新的单元文件：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Start the daemon, and check out its status. Notice that we''ll also see a "*Daemon
    alive*" message here. This is a snippet from the journal. Notice that we don''t
    *enable* the service this time. We don''t need to enable the service unless we
    want it to start automatically:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动守护程序，并检查其状态。请注意，我们也会在这里看到一个“*守护程序活着*”消息。这是日志中的一个片段。请注意，这次我们不会*启用*服务。除非我们希望它自动启动，否则我们不需要启用服务：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Leave the daemon running, and we'll take a look at the journal in the next recipe.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让守护程序运行，并在下一个食谱中查看日志。
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Since this daemon isn't forking, systemd can keep track of it without a PID
    file. For this daemon, we used `Type=simple`, which is the default type in systemd.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个守护程序没有forking，systemd可以在没有PID文件的情况下跟踪它。对于这个守护程序，我们使用了`Type=simple`，这是systemd中的默认类型。
- en: When we started the daemon in *Step 4* and checked out the status of it, we
    saw the first line of the "*Daemon alive*" message. We can see a daemon's status
    without using `sudo`, but then we can't see the journal's snippet (since it might
    contain sensitive data).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*Step 4*中启动守护进程并检查其状态时，我们看到了“*守护进程活动*”消息的第一行。我们可以在不使用`sudo`的情况下查看守护进程的状态，但是我们就看不到日志的片段（因为它可能包含敏感数据）。
- en: Since we flush the stdout buffer after each `printf()` in the `for` loop, the
    journal is updated live as each new entry is written to it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`for`循环中的每个`printf()`后刷新了标准输出缓冲区，因此每次写入新条目时，日志都会实时更新。
- en: In the next recipe, we'll take a look at the journal.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个步骤中，我们将查看日志。
- en: Reading the journal
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读日志
- en: In this recipe, we'll learn how to read the journal. The journal is systemd's
    logging facility. All messages that a daemon prints to either stdout or stderr
    gets added to the journal. But we can find more than just the system daemons logs
    here. There's also the system's boot messages, among other things.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将学习如何阅读日志。日志是systemd的日志记录设施。守护进程打印到标准输出或标准错误的所有消息都会添加到日志中。但是我们在这里可以找到的不仅仅是系统守护进程的日志。还有系统的引导消息，等等。
- en: Knowing how to read the journal enables you to find errors in the system and
    the daemons more easily.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何阅读日志可以让您更轻松地找到系统和守护进程中的错误。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need to have the `new-style-daemon` service running.
    If you don't have it running on your system, go back to the previous recipe for
    information on how to start it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个步骤，您需要`new-style-daemon`服务正在运行。如果您的系统上没有运行它，请返回到上一个步骤，了解如何启动它。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll explore how to read the journal and what kind of information
    we can find in it. We''ll also learn how to follow a particular service''s log:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将探讨如何阅读日志以及我们可以在其中找到什么样的信息。我们还将学习如何跟踪特定服务的日志：
- en: 'We''ll start by examining the logs from our service, `new-style-daemon`. The
    `-u` option stands for *unit*:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先检查来自我们的服务`new-style-daemon`的日志。 `-u`选项代表*单元*：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The log is probably pretty long by now, so you can scroll down in the log by
    hitting *Spacebar*. To quit the journal, press *Q*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在日志可能已经很长了，所以您可以通过按*Spacebar*向下滚动日志。要退出日志，请按*Q*。
- en: 'Remember that we implemented a signal handler for `SIGUSR1`? Let''s try sending
    our daemon that signal and then view the log again. But this time, we''ll only
    show the last five lines in the journal with `--lines 5`. Find the PID of the
    process by using `systemctl status`. Notice the "*Hello world*" message (it''s
    highlighted in the following code):'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，我们为`SIGUSR1`实现了一个信号处理程序？让我们尝试向我们的守护进程发送该信号，然后再次查看日志。但是这次，我们将使用`--lines 5`仅显示日志中的最后五行。通过使用`systemctl
    status`找到进程的PID。注意“*Hello world*”消息（在以下代码中已突出显示）：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It''s also possible to *follow* the journal for a service, that is, view it
    "live." Open up a second terminal and run the following command. The `-f` stands
    for *follow*:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以*跟踪*服务的日志，即“实时”查看。打开第二个终端并运行以下命令。`-f`代表*跟踪*：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, in the first terminal, send another `USR1` signal with `sudo kill -USR1
    8421`. You'll see the "*Hello world*" message in the second terminal right away
    without any delay. To quit the follow mode, you just hit *Ctrl* + *C*.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在第一个终端中，使用`sudo kill -USR1 8421`发送另一个`USR1`信号。您会立即在第二个终端中看到“*Hello world*”消息，而不会有任何延迟。要退出跟踪模式，只需按*Ctrl*
    + *C*。
- en: 'The `journalctl` command offers a wide range of filtering. For example, it''s
    possible to select only log entries between two dates using `--since` and `--until`.
    It''s also possible to leave out either one of them to view all messages since
    or until a particular date. Here, we show all messages between two dates:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`journalctl`命令提供了广泛的过滤功能。例如，可以使用`--since`和`--until`仅选择两个日期之间的日志条目。也可以省略其中一个来查看自特定日期以来或直到特定日期的所有消息。在这里，我们展示了两个日期之间的所有消息：'
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By leaving out the `-u` option and the unit name, we can see all log entries
    from all services. Try it out and scroll through it with *Spacebar*. You can also
    try to only view the last 10 lines as we did before with `--line 10`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过省略`-u`选项和单元名称，我们可以查看所有服务的所有日志条目。试一下，用*Spacebar*滚动浏览。您还可以尝试只查看最后10行，就像我们之前用`--line
    10`一样。
- en: 'Now it''s time to stop the `new-style-daemon service`. We''ll also view the
    last five lines from the log after we have stopped the service. Notice the goodbye
    message from the daemon. This is from the signal handler we made for the `SIGTERM`
    signal. When we stop a service in systemd, it sends the service a `SIGTERM` signal:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候停止`new-style-daemon`服务了。在停止服务后，我们还将查看日志中的最后五行。注意来自守护进程的告别消息。这是我们为`SIGTERM`信号制作的信号处理程序。当我们在systemd中停止服务时，它会发送一个`SIGTERM`信号给服务：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Since the journal takes care of all messages that go to stdout and stderr, we
    don't need to handle logging ourselves. This makes it easier to write daemons
    for Linux that are handled by systemd. As we saw when we viewed the journal, every
    message gets a timestamp. This makes it easy to filter out a specific day or time
    when looking for errors.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日志负责处理所有发送到标准输出和标准错误的消息，我们不需要自己处理日志记录。这使得编写由systemd处理的Linux守护进程变得更容易。正如我们在查看日志时看到的那样，每条消息都有一个时间戳。这使得在寻找错误时可以轻松地过滤出特定的日期或时间。
- en: Following the log for a specific service with the `-f` option is common when
    experimenting with new or unknown services.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-f`选项跟踪特定服务的日志在尝试新的或未知服务时很常见。
- en: See also
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The manual page at `man journalctl` has even more tips and tricks on how to
    filter the journal.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`man journalctl`的手册页面上甚至有更多关于如何过滤日志的技巧和提示。'
