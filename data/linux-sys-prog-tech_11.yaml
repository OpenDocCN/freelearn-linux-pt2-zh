- en: '*Chapter 11*: Using Threads in Your Programs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：在程序中使用线程'
- en: In this chapter, we will learn what threads are and how to use them in Linux.
    We will write several programs using **POSIX threads**, otherwise known as **pthreads**.
    We will also learn what race conditions are and how to prevent them by using mutexes.
    Then, we'll learn how to make a mutex program more efficient. Lastly, we'll learn
    what condition variables are.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习什么是线程以及如何在Linux中使用它们。 我们将使用**POSIX线程**（也称为**pthreads**）编写几个程序。 我们还将学习什么是竞争条件，以及如何使用互斥锁来防止它们。
    然后，我们将学习如何使互斥程序更高效。 最后，我们将学习什么是条件变量。
- en: Knowing how to write threaded programs will make them faster and more efficient.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何编写多线程程序将使它们更快，更高效。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Writing your first threaded program
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你的第一个多线程程序
- en: Reading return values from threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从线程读取返回值
- en: Causing a race condition
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引发竞争条件
- en: Avoiding race conditions with mutexes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用互斥锁避免竞争条件
- en: Making the mutex program more efficient
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使互斥程序更高效
- en: Using condition variables
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件变量
- en: Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need the GCC compiler, the Make tool, and the generic
    Makefile. If you haven't installed these tools yet, please refer to [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the Necessary Tools
    and Writing Our First Linux Programs*, for installation instructions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要GCC编译器，Make工具和通用Makefile。 如果您尚未安装这些工具，请参考[*第1章*]（B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020），*获取必要的工具并编写我们的第一个Linux程序*，以获取安装说明。
- en: You'll also need a program called `htop` to view the CPU load. You install it
    with your distribution's package manager. The program is called `htop` on all
    distributions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个名为`htop`的程序来查看CPU负载。 您可以使用发行版的软件包管理器安装它。 所有发行版都称该程序为`htop`。
- en: 'All of the code samples for this chapter can be downloaded from GitHub at the
    following URL: [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch11](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch11).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以从GitHub下载，网址如下：[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch11](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch11)。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/2O4dnlN](https://bit.ly/2O4dnlN)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以查看代码演示视频：[https://bit.ly/2O4dnlN](https://bit.ly/2O4dnlN)
- en: Writing your first threaded program
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的第一个多线程程序
- en: In this first recipe, we'll write a small program that checks whether two numbers
    are prime numbers—in parallel. While those two numbers are checked, each in their
    own **thread**, another thread will write dots in the terminal to indicate that
    the program is still running. A total of three threads will run in this program.
    Each thread will print its own result, so there's no need to save and return the
    values in this program.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个示例中，我们将编写一个小程序，检查两个数字是否为质数-并行进行。 在检查这两个数字时，每个数字都在自己的**线程**中，另一个线程将在终端中写入点以指示程序仍在运行。
    该程序将运行三个线程。 每个线程将打印自己的结果，因此在此程序中不需要保存和返回值。
- en: Knowing the basics of threading will give the foundation to move along to more
    advanced programs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 了解线程的基础知识将为进一步学习更高级的程序打下基础。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: For this recipe, you'll need the `htop` program so you can see the **CPU** load
    go up for two CPU cores. Of course, other similar programs work as well, such
    as KSysGuard for **K Desktop Environment** (**KDE**). It's also best if your computer
    has more than one CPU **core**. Most computers today have more than one core,
    even Raspberry Pis and similar small computers, so this shouldn't be a problem.
    The program still works, even if you only have a single-core CPU, but it's harder
    to visualize the threads.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您将需要`htop`程序，以便您可以看到两个CPU核心的**CPU**负载增加。 当然，其他类似的程序也可以工作，例如**KDE**的**K
    Desktop Environment**（**KDE**）的KSysGuard。 如果您的计算机有多个CPU **core**，那就更好了。 大多数计算机今天都有多个核心，即使是树莓派和类似的小型计算机，所以这不应该是一个问题。
    即使您只有单核CPU，该程序仍然可以工作，但是很难可视化线程。
- en: You also require the GCC compiler and the Make tool.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要GCC编译器和Make工具。
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this chapter, we are going to use `Makefile`. Notice the added `-lpthread`,
    something we didn''t have in the generic Makefile:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`Makefile`。 注意添加的`-lpthread`，这是通用Makefile中没有的东西：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s move on and write the program. The code is a bit long, so it''s
    broken up into several steps. All the code goes into a single file, though. Save
    the code as `first-threaded.c`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续编写程序。 代码有点长，所以它被分成了几个步骤。 尽管所有的代码都放在一个文件中。 将代码保存为`first-threaded.c`：
- en: 'Let''s start with the header files, some function prototypes, the `main()`
    function, and some necessary variables. Notice the new header file, `pthread.h`.
    We have a new type here also, called `pthread_t`. This type is used for thread
    IDs. There''s also a `pthread_attr_t` type, which is used for the attributes of
    the threads. We also perform a check to see whether the user entered two arguments
    (the numbers that will be checked to establish whether they are prime numbers).
    Then, we''ll convert the first and second arguments to `long long` integers with
    `atoll()`:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从头文件开始，一些函数原型，`main()`函数和一些必要的变量。 注意新的头文件`pthread.h`。 我们还有一个新类型，称为`pthread_t`。
    此类型用于线程ID。 还有一个`pthread_attr_t`类型，用于线程的属性。 我们还执行检查，以查看用户是否输入了两个参数（将检查这些参数是否为质数）。
    然后，我们将使用`atoll()`将第一个和第二个参数转换为`long long`整数：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we'll initialize the threads attribute structure, `threadattr`, with some
    default settings using `pthread_attr_init()`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`pthread_attr_init()`初始化线程属性结构`threadattr`，并使用一些默认设置。
- en: 'Then, we will create the three threads using `pthread_create()`. The `pthread_create()`
    function takes four arguments. The first argument is the thread ID variable; the
    second argument is the attributes for the thread; the third argument is the function
    that will execute in the thread; the fourth argument is the argument for that
    function. We will also mark the thread for the "progress bar" as detached using
    `pthread_detach()`. This makes the thread''s resources release automatically when
    it terminates:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用`pthread_create()`创建三个线程。`pthread_create()`函数有四个参数。第一个参数是线程ID变量；第二个参数是线程的属性；第三个参数是将在线程中执行的函数；第四个参数是该函数的参数。我们还将使用`pthread_detach()`将"进度条"线程标记为分离状态，这样当线程终止时，线程的资源将自动释放：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To make the program wait for all the threads to finish, we must use `pthread_join()`
    for each thread. Notice that we don''t wait for the progress thread, but we did
    mark it as detached. Here, we will cancel the progress thread before we exit the
    program using `pthread_cancel()`:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使程序等待所有线程完成，我们必须为每个线程使用`pthread_join()`。请注意，我们不等待进度线程，但我们确实将其标记为分离状态。在这里，我们将在退出程序之前取消进度线程，使用`pthread_cancel()`：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now it''s time to write the body for the function that will calculate whether
    the given number is a prime number. Notice that the return type of the function
    is a void pointer. The argument is also a void pointer. This is the requirement
    in order for `pthread_create()` to work. Since the argument is a void pointer,
    and we want it as a `long long int`, we must first convert it. We do this by casting
    the void pointer to a `long long int` and save what it''s pointing to in a new
    variable (refer to the *See also* section for a more verbose option). Notice that
    we return `NULL` in this function. This is because we have to return *something*,
    so `NULL` will do just fine here:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候编写将计算给定数字是否为质数的函数体了。请注意，函数的返回类型是void指针。参数也是void指针。这是`pthread_create()`要求的。由于参数是void指针，而我们希望它是`long
    long int`，因此我们必须先进行转换。我们通过将void指针转换为`long long int`并将其指向的内容保存在一个新变量中来实现这一点（有关更详细的选项，请参阅*参见*部分）。请注意，在这个函数中我们返回`NULL`。这是因为我们必须返回*something*，所以在这里使用`NULL`就可以了：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we write the function for the progress meter. It isn''t really a progress
    meter; it just prints a dot every second to show the user that the program is
    still running. We must use `fflush()` after the call to `printf()` since we aren''t
    printing any newline characters (remember that stdout is line-buffered):'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们编写进度表的函数。它并不是真正的进度表；它只是每秒打印一个点，以向用户显示程序仍在运行。在调用`printf()`后，我们必须使用`fflush()`，因为我们没有打印任何换行符（请记住stdout是行缓冲的）：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now it''s time to compile the program using our new Makefile. Note that we
    receive a warning regarding an unused variable here. This is the `arg` variable
    for the progress function. We can safely ignore this warning since we know we
    aren''t using it:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候使用我们的新Makefile编译程序了。请注意，我们收到了一个关于未使用的变量的警告。这是进度函数的`arg`变量。我们可以放心地忽略这个警告，因为我们知道我们没有使用它。
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, before we run the program, start a new terminal and start `htop` in it.
    Place it somewhere where you can see it.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在运行程序之前，打开一个新的终端并在其中启动`htop`。将它放在一个可以看到的地方。
- en: 'Now we run the program in the first terminal. Choose two numbers that aren''t
    so small that the program will finish immediately but not so large that it will
    run forever. For me, the following numbers are sufficiently large to make the
    program run for about a minute and a half. This will vary depending on the CPU.
    While you run the program, check the `htop` program. You''ll notice that two cores
    will use 100% until the first number is computed, and then it will only use one
    core at 100%:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在第一个终端中运行程序。选择两个数字，不要太小，以至于程序会立即完成，但也不要太大，以至于程序会永远运行。对我来说，以下数字足够大，可以使程序运行大约一分半钟。这将取决于CPU。在运行程序时，检查`htop`程序。您会注意到两个核心将使用100%，直到计算第一个数字，然后它将只使用一个核心以100%：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The two numbers are checked individually, each in their own thread. This speeds
    up the process when compared to a non-threaded program. A non-threaded program
    would check each number after the other. That is, the second number would have
    to wait until the first number was completed. But with a threaded program, like
    the one we made here, check both numbers simultaneously.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 两个数字分别在各自的线程中进行检查。与非线程化程序相比，这加快了进程。非线程化程序将依次检查每个数字。也就是说，第二个数字必须等到第一个数字完成后才能进行检查。但是使用线程化程序，就像我们在这里做的一样，可以同时检查两个数字。
- en: The `isprime()` function is where the calculations are performed. The same function
    is used for both threads. We also use the same default attributes for both threads.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`isprime()`函数是进行计算的地方。相同的函数用于两个线程。我们还为两个线程使用相同的默认属性。'
- en: We execute the functions in threads by calling `pthread_create()` for each number.
    Notice that we don't put any parentheses after the `isprime()` function in the
    `pthread_create()` argument. Putting parentheses after the function name executes
    the function. However, we want the `pthread_create()` function to execute the
    function instead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过为每个数字调用`pthread_create()`在线程中执行函数。请注意，在`pthread_create()`参数中的`isprime()`函数后面没有括号。在函数名后面加上括号会执行该函数。但是，我们希望`pthread_create()`函数执行该函数。
- en: Since we won't be `pthread_cancel()` is called—we mark it as detached so that
    its resources will be released when the thread terminates. We mark it as detached
    with `pthread_detach()`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不会调用`pthread_cancel()`，我们将其标记为分离状态，以便在线程终止时释放其资源。我们使用`pthread_detach()`将其标记为分离状态。
- en: By default, a thread has its `sleep()` is one such function; therefore, the
    progress thread will cancel once it executes `sleep()`. The *cancelability type*
    can be changed to asynchronous, meaning it can cancel at any time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，线程具有其自己的`sleep()`函数是其中之一；因此，进度线程将在执行`sleep()`后取消。*可取消类型*可以更改为异步，这意味着它可以随时取消。
- en: At the end of the `main()` function, we called `pthread_join()` on both of the
    thread IDs (that are executing `isprime()`). This is necessary to make the process
    wait until the threads are finished; otherwise, it would end right away. The first
    argument for `pthread_join()` is the thread ID. The second argument is a variable
    wherein the thread's return value can be saved. But since we aren't interested
    in the return value here—it just returns `NULL`—we set it to `NULL`, which ignores
    it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数的末尾，我们对两个线程ID（执行`isprime()`的线程）调用了`pthread_join()`。这是必要的，以使进程等待线程完成；否则，它会立即结束。`pthread_join()`的第一个参数是线程ID。第二个参数是一个变量，可以保存线程的返回值。但由于我们对返回值不感兴趣——它只返回`NULL`——我们将其设置为`NULL`，以忽略它。
- en: There's more…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: To change the *cancelability state* of a thread, you use `pthread_setcancelstate()`.
    See `man 3 pthread_setcancelstate` for more information.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改线程的*可取消性状态*，您可以使用`pthread_setcancelstate()`。有关更多信息，请参阅`man 3 pthread_setcancelstate`。
- en: To change the *cancelability type* of a thread, you use `pthread_setcanceltype()`.
    See `man 3 pthread_setcanceltype` for more information.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改线程的*可取消性类型*，您可以使用`pthread_setcanceltype()`。有关更多信息，请参阅`man 3 pthread_setcanceltype`。
- en: To see a list of which functions are `man 7 pthreads` and search for *cancelation
    points* in that manual page.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看哪些函数是`man 7 pthreads`，并在该手册页面中搜索*取消点*。
- en: 'The conversion from a void pointer to a `long long int` can seem a bit cryptic.
    Instead of doing it all in one line, as we did here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从void指针转换为`long long int`可能看起来有点神秘。与我们在这里所做的一样，不要一行搞定：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We could have written it in two steps, which is a bit more verbose, like so:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以分两步写，这样会更详细一些，就像这样：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There's a lot of useful information in the manual pages for `pthread_create()`
    and `pthread_join()`. You can read them with `man 3 pthread_create` and `man 3
    pthread_join`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`pthread_create()`和`pthread_join()`的手册页面中有很多有用的信息。您可以使用`man 3 pthread_create`和`man
    3 pthread_join`来阅读它们。'
- en: For more information regarding `pthread_detach()`, see `man 3 pthread_detach`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`pthread_detach()`的更多信息，请参阅`man 3 pthread_detach`。
- en: For information regarding `pthread_cancel()`, see `man 3 pthread_cancel`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`pthread_cancel()`的信息，请参阅`man 3 pthread_cancel`。
- en: Reading return values from threads
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从线程中读取返回值
- en: In this recipe, we'll continue from the previous recipe. Here, we'll fetch the
    answers as **return values** from the threads instead of letting them print the
    result themselves. This is like the return values from functions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将继续上一个配方。在这里，我们将从线程中获取答案作为**返回值**，而不是让它们自己打印结果。这就像从函数中返回值一样。
- en: Knowing how to fetch the return values from threads enables you to do much more
    complicated things with threads.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何从线程中获取返回值使您能够用线程做更复杂的事情。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order for this recipe to make sense, it's advised that you complete the previous
    recipe first.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个配方有意义，建议您先完成上一个配方。
- en: You'll also need the Makefile that we wrote in the previous recipe.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要我们在上一个配方中编写的Makefile。
- en: How to do it…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: 'This program is similar to that of the previous recipe, but instead of each
    thread printing its own result, they return it to `main()`. This is similar to
    how functions return a value to `main()`, only here we need to do some **casting**
    back and forth. The downside of this approach is that we won''t see the result
    until both threads are finished unless we intentionally give the first thread
    the smallest number. If the first thread has the largest number, we won''t get
    the result of the second thread until the second thread is finished, even if it
    has been completed. However, even if we don''t see the results printed right away,
    they are still being processed in two separate threads, just as before:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序与上一个配方类似，但是每个线程不是打印自己的结果，而是将结果返回给`main()`。这类似于函数将值返回给`main()`，只是这里我们需要来回进行一些**转换**。这种方法的缺点是，除非我们有意将最小的数字给第一个线程，否则在两个线程都完成之前我们看不到结果。如果第一个线程有最大的数字，那么在第二个线程完成之前，即使它已经完成，我们也看不到第二个线程的结果。然而，即使我们看不到结果立即打印出来，它们仍然在两个独立的线程中进行处理，就像以前一样：
- en: 'The code is long, so it''s split up into several steps. Write the code in a
    single file called `second-threaded.c`. As usual, we start with the headers file,
    the function prototypes, and the beginning of the `main()` function. Notice that
    we have an extra header file here, called `stdint.h`. This is for the `uintptr_t`
    type, which we''ll cast the returned value to. This is safer than casting to an
    `int`, since this is guaranteed to be of the same size as the pointer we''re casting
    from. We also create two void pointers (`prime1Return` and `prime2Return`) that
    we''ll save the return values in. Apart from these changes, the rest of the code
    is the same:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码很长，因此被分成了几个步骤。将代码写在名为`second-threaded.c`的单个文件中。和往常一样，我们从头文件、函数原型和`main()`函数的开头开始。请注意，这里有一个额外的头文件，名为`stdint.h`。这是为了`uintptr_t`类型，我们将把返回值转换为该类型。这比转换为`int`更安全，因为这保证与我们转换的指针大小相同。我们还创建了两个void指针（`prime1Return`和`prime2Return`），我们将保存返回值。除了这些更改，其余代码都是一样的：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the next part, we add the void pointers we created earlier as the second
    argument to `pthread_join()`, or actually the address of those variables. This
    will save the thread''s return value in these variables. Then, we check those
    return values to see whether the numbers were a prime number. But since the variable
    is a void pointer, we must first cast it to a `unitptr_t` type:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将之前创建的void指针作为`pthread_join()`的第二个参数，或者实际上是这些变量的地址。这将把线程的返回值保存在这些变量中。然后，我们检查这些返回值，看看这些数字是否是质数。但由于变量是void指针，我们必须首先将其转换为`unitptr_t`类型：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we have the functions as before. But this time, we return 0 or 1 cast
    to a void pointer (since that is what the function is declared to do, we cannot
    violate that):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们像以前一样有函数。但是这次，我们返回0或1，转换为void指针（因为函数声明的就是这样，我们不能违反）：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, let''s compile the program. We still get the same warning regarding an
    unused variable, but this is safe to ignore. We know we aren''t using it for anything:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编译程序。我们仍然会收到关于未使用变量的相同警告，但这是安全的。我们知道我们没有用它做任何事情。
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s now try the program, first with the bigger number as the first argument,
    and then with the smaller number as the first argument:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们尝试运行程序，首先使用更大的数字作为第一个参数，然后使用较小的数字作为第一个参数：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The overall basics of this program are the same as in the previous recipe. The
    difference here is that we return the result of the calculations from the threads
    to `main()`, just like a function. But since the return value of our `isprime()`
    function is a void pointer, we must also return this type. To save the return
    values, we pass the address of a variable as the second argument to `pthread_join()`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的基本原理与上一个教程中的相同。不同之处在于，我们将计算结果从线程返回到`main()`，就像一个函数一样。但由于我们`isprime()`函数的返回值是一个void指针，我们还必须返回这种类型。为了保存返回值，我们将一个变量的地址作为`pthread_join()`的第二个参数传递。
- en: Since each call to `pthread_join()` will *block* until its thread has finished,
    we won't get the result until both threads are completed (unless we give it the
    smallest number first).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每次调用`pthread_join()`都会阻塞，直到其线程完成，我们在两个线程都完成之前不会得到结果（除非我们首先给出最小的数字）。
- en: The new type we used in this recipe, `uintptr_t`, is a special type that matches
    the size of an unsigned integer pointer. Using a regular `int` will probably work
    as well, but it's not guaranteed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本教程中使用的新类型`uintptr_t`是一个特殊类型，它与无符号整数指针的大小匹配。使用常规的`int`可能也可以，但不能保证。
- en: Causing a race condition
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导致竞争条件
- en: A **race condition** is when more than one thread (or process) tries to write
    to the same variable simultaneously. Since we don't know which thread will access
    the variable first, we can't safely predict what will happen. Both threads will
    try to access it first; they will *race* to access the variable.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 竞争条件是指多个线程（或进程）同时尝试写入同一变量的情况。由于我们不知道哪个线程会首先访问该变量，我们无法安全地预测会发生什么。两个线程都会尝试首先访问它；它们会争先访问该变量。
- en: Knowing what's causing a race condition will help you avoid them, making your
    programs safer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 了解是什么导致了竞争条件将有助于避免它们，使您的程序更安全。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll only need the Makefile we wrote in the first recipe
    of this chapter, along with the GCC compiler and the Make tool.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您只需要本章第一个教程中编写的Makefile，以及GCC编译器和Make工具。
- en: How to do it…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll write a program that causes a race condition. If the
    program were to work properly, it should add 1 to the `i` variable on every run,
    ending up at 5,000,000,000\. There are five threads, and each thread adds 1 up
    to 1,000,000,000\. But since all the threads access the `i` variable simultaneously—more
    or less—it never reaches 5,000,000,000\. Each time a thread accesses it, it takes
    the current value and adds 1\. But during that time, another thread might also
    read the current value and add 1, which then overwrites the added 1 from the other
    thread. In other words, the threads are overwriting each other''s work:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将编写一个导致竞争条件的程序。如果程序能正常工作，它应该在每次运行时将1添加到`i`变量，最终达到5,000,000,000。有五个线程，每个线程都将1添加到1,000,000,000。但由于所有线程几乎同时访问`i`变量，它永远不会达到5,000,000,000。每次线程访问它时，它都会获取当前值并添加1。但在此期间，另一个线程可能也读取当前值并添加1，然后覆盖另一个线程添加的1。换句话说，线程正在覆盖彼此的工作：
- en: 'The code is broken up into several steps. Note that all code goes into a single
    file. Name the file `race.c`. We''ll start with the header files, a `i` of the
    type `long long int`. Then we write the `main()` function, which is pretty self-explanatory.
    It creates five threads with `pthread_create()` and then waits for them to finish
    with `pthread_join()`. Finally, it prints the resulting `i` variable:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码分为几个步骤。请注意，所有代码都放在一个文件中。将文件命名为`race.c`。我们将从头文件开始，`i`的类型为`long long int`。然后编写`main()`函数，这是相当简单的。它使用`pthread_create()`创建五个线程，然后使用`pthread_join()`等待它们完成。最后，它打印出结果变量`i`：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we write the `add()` function that will run inside the threads:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们编写`add()`函数，该函数将在线程内运行：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s compile the program. Once again, it''s safe to ignore the warning:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译程序。再次忽略警告是安全的：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s try out the program. We''ll run it several times. Notice that each
    time we run it, we get a different value. That''s because the timing of the threads
    can''t be predicted. But most likely, it will never reach 5,000,000,000, which
    should be the correct value. Note that the program will take several seconds to
    complete:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试运行程序。我们将运行它多次。请注意，每次运行时，我们都会得到不同的值。这是因为无法预测线程的时间。但最有可能的是，它永远不会达到5,000,000,000，这应该是正确的值。请注意，程序将需要几秒钟才能完成：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This program is rather inefficient at the moment. We''ll time the program before
    we move on using the `time` command. The time it takes to complete will be different
    on different computers. In a later recipe, *Making the mutex program more efficient*,
    we''ll make the program much more efficient:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，这个程序效率相当低。在继续使用`time`命令之前，我们将对程序进行计时。完成所需的时间在不同的计算机上会有所不同。在以后的教程中，我们将使程序更加高效，使互斥程序更加高效：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Since all the threads read and write to the same variable at the same time,
    they all undo each other's work. If they all ran in succession, like a non-threaded
    program, the result would be 5,000,000,000, which is what we want.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有线程同时读写同一变量，它们都会撤消彼此的工作。如果它们都按顺序运行，就像非线程化程序一样，结果将是5,000,000,000，这正是我们想要的。
- en: To better understand what's happening here, let's take it step by step. Note
    that this is just a rough estimation; the exact values and thread differ from
    one time to the next.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这里发生了什么，让我们一步一步地来。请注意，这只是一个粗略的估计；确切的值和线程会因时间而异。
- en: 'The first thread reads the value of `i`; let''s say it''s 1\. The second thread
    also reads `i`, which is still 1, since the first thread hasn''t incremented the
    value yet. Now the first thread increments the value to 2 and saves it to `i`.
    The second thread does the same; it also increments the value to 2 (1+1=2). Now,
    the third thread starts and reads the variable `i` as 2 and increments it to 3
    (2+1=3). The result is now 3, instead of 4\. This continues throughout the program''s
    execution, and there''s no telling what the result will be. Each time the program
    runs, the **timing** of the threads will be slightly different. The following
    diagram contains a simplified example of the problems that can arise:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个线程读取`i`的值；假设它是1。第二个线程也读取`i`，仍然是1，因为第一个线程还没有增加值。现在第一个线程将值增加到2并保存到`i`。第二个线程也这样做；它也将值增加到2（1+1=2）。现在，第三个线程开始并将变量`i`读取为2并将其增加到3（2+1=3）。结果现在是3，而不是4。这将在程序执行过程中继续进行，并且无法预测结果将会是什么。每次程序运行时，线程的**时间**都会略有不同。以下图表包含了可能出现的问题的简化示例：
- en: '![Figure 11.1 – Example of a race condition'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 - 竞争条件的示例'
- en: '](img/B13043_11_001.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B13043_11_001.jpg)'
- en: Figure 11.1 – Example of a race condition
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 - 竞争条件的示例
- en: Avoiding race conditions with mutexes
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用互斥锁避免竞争条件
- en: A **mutex** is a **locking mechanism** that prevents access to a **shared variable**
    so that no more than one thread can access it simultaneously. This prevents race
    conditions. With a mutex, we only lock the critical part of the code, for example,
    the updating of a shared variable. This will make sure that all other parts of
    the program run in parallel (if this is possible with the locking mechanism).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**互斥锁**是一种**锁定机制**，它防止对**共享变量**的访问，以便不超过一个线程可以同时访问它。这可以防止竞争条件。使用互斥锁，我们只锁定代码的关键部分，例如共享变量的更新。这将确保程序的所有其他部分可以并行运行（如果这在锁定机制中是可能的）。'
- en: However, if we are not careful when we write our programs, a mutex can slow
    down the program a lot, which we'll see in this recipe. In the next recipe, we'll
    fix this problem.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们在编写程序时不小心，互斥锁可能会大大减慢程序的速度，这将在这个食谱中看到。在下一个食谱中，我们将解决这个问题。
- en: Knowing how to use mutexes will help you overcome many of the problems associated
    with race conditions, making your programs safer and better.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用互斥锁将有助于您克服许多与竞争条件相关的问题，使您的程序更安全、更好。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order for this recipe to make sense, it's advised that you complete the previous
    recipe first. You'll also need the Makefile that we wrote in the first recipe
    of this chapter, the GCC compiler, and the Make tool.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个食谱有意义，建议您先完成上一个食谱。您还需要我们在本章第一个食谱中编写的Makefile，GCC编译器和Make工具。
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This program builds upon the previous recipe, but the complete code is shown
    here. The code is broken up into several steps. However, remember that all the
    code goes into the same file. Name the file `locking.c`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序建立在前一个食谱的基础上，但完整的代码在这里显示。代码分为几个步骤。但是，请记住所有的代码都放在同一个文件中。将文件命名为`locking.c`：
- en: 'We''ll start at the top as usual. The added code is highlighted. First, we
    create a new variable called `mutex` of the `pthread_mutex_t` type. This is the
    variable that is used for locking. We place this variable in the global area so
    that it can be reached from both `main()` and `add()`. The second added bit is
    the initialization of the mutex variable, using `pthread_mutex_init()`. `NULL`
    as the second argument means that we want the default attributes for the mutex:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像往常一样从顶部开始。添加的代码已经高亮显示。首先，我们创建一个名为`mutex`的新变量，类型为`pthread_mutex_t`。这是用于锁定的变量。我们将这个变量放在全局区域，以便从`main()`和`add()`都可以访问到。第二个添加的部分是初始化互斥变量，使用`pthread_mutex_init()`。第二个参数使用`NULL`表示我们希望互斥锁使用默认属性：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After we are done with the calculations, we destroy the `mutex` variable with
    `pthread_mutex_destroy()`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们完成计算后，我们使用`pthread_mutex_destroy()`销毁`mutex`变量：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And finally, we use the locking and unlocking mechanisms in the `add()` function.
    We lock the part where the `i` variable is updated and unlock it once the update
    is complete. That way, the variable is locked while the update is in progress
    so that no other threads can access it until the update is complete:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在`add()`函数中使用锁定和解锁机制。我们锁定更新`i`变量的部分，并在更新完成后解锁。这样，变量在更新进行中被锁定，以便其他线程在更新完成之前无法访问它：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s compile the program. As usual, we can ignore the warning regarding
    an unused variable:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编译程序。像往常一样，我们可以忽略关于未使用变量的警告：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now it''s time to run the program. Just as in the previous recipe, we''ll time
    the execution using the `time` command. This time, the calculation will be correct;
    it will end up at 5,000,000,000\. However, the program will take a long time to
    finish. On my computer, it takes well over 5 minutes to complete:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候运行程序了。就像在上一个食谱中一样，我们将使用`time`命令计时执行。这次，计算将是正确的；最终结果将是5,000,000,000。然而，程序将需要很长时间才能完成。在我的电脑上，需要超过5分钟才能完成：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s compare this result to a simple, non-threaded program that accomplishes
    the same result with the same basic algorithm. Let''s name this program `non-threaded.c`:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将这个结果与一个简单的非线程程序进行比较，它使用相同的基本算法实现相同的结果。让我们将这个程序命名为`non-threaded.c`：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s compile this program and time it. Note how much faster this program
    executes while, at the same time, attaining the same result:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译这个程序并计时。注意这个程序执行的速度有多快，同时又获得了相同的结果：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Threaded programs aren't automatically going to be faster than non-threaded
    programs. The non-threaded program that we ran in *step 7* was even faster than
    the threaded program from the previous recipe, even though that program didn't
    even use any mutexes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 线程化程序并不会自动比非线程化程序更快。我们在*步骤7*中运行的非线程化程序甚至比前一个食谱中的线程化程序更快，尽管该程序甚至没有使用任何互斥锁。
- en: So why is this, then?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么会这样呢？
- en: The threaded program we've written has several inefficiencies. We'll start by
    discussing the issues with the `race.c` program from the previous recipe. The
    reason why that program is slower than the non-threaded version is because of
    numerous small things. For example, it takes some time to start each thread (a
    small amount of time, but still). Then there's the inefficiency of updating the
    global `i` variable by only one step each time. All the threads are also accessing
    the same global variable at the same time. We have five threads, and each thread
    increments its local `j` variable by one. And each time that happens, the thread
    updates the global `i` variable. And since all of this happens 5,000,000,000 times,
    it takes a bit longer than it would have taken to run it sequentially in a single
    thread.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的多线程程序存在一些效率低下的问题。我们将从上一个示例中的`race.c`程序开始讨论问题。该程序比非多线程版本慢的原因是因为有许多小问题。例如，启动每个线程都需要一些时间（虽然很少，但仍然需要）。然后，每次仅更新全局的`i`变量一步也是低效的。所有线程同时访问同一个全局变量也是低效的。我们有五个线程，每个线程将其本地的`j`变量递增一次。每次这种情况发生时，线程都会更新全局的`i`变量。由于所有这些都发生了50亿次，所以比在单个线程中顺序运行要花费更长的时间。
- en: 'Then, in the `locking.c` program in this recipe, we added a mutex to lock the
    `i = i + 1` part. Since this ensures that only one thread can access the `i` variable
    simultaneously, it makes the entire program sequential again. Instead of all the
    threads running side by side, the following happens:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在本示例中的`locking.c`程序中，我们添加了一个互斥锁来锁定`i = i + 1`部分。由于这确保只有一个线程可以同时访问`i`变量，这使整个程序再次变成了顺序执行。而不是所有线程并行运行，以下情况发生：
- en: Run a thread.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行一个线程。
- en: Lock the `i = i + 1` part.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁定`i = i + 1`部分。
- en: Run `i = i + 1` to update `i`.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`i = i + 1`以更新`i`。
- en: Unlock `i = i + 1`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后解锁`i = i + 1`。
- en: Run the next thread.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下一个线程。
- en: Lock the `i = i + 1` part.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁定`i = i + 1`部分。
- en: Run `i = i + 1` to update `i`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`i = i + 1`以更新`i`。
- en: Unlock `i = i + 1`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后解锁`i = i + 1`。
- en: These steps will repeat over and over again 5,000,000,000 times in a row. Each
    time a thread starts takes time. Then it takes additional time to lock and unlock
    the mutex, and it also takes time to increment the `i` variable. It also takes
    time to switch to another thread and start the whole locking/unlocking process
    all over again.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将重复5,000,000,000次。每次线程启动都需要时间。然后需要额外的时间来锁定和解锁互斥锁，还需要时间来递增`i`变量。切换到另一个线程并重新开始整个锁定/解锁过程也需要时间。
- en: In the next recipe, we'll address these issues and make the program run much
    faster.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将解决这些问题，使程序运行得更快。
- en: See also
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information about mutexes, see the manual pages `man 3 pthread_mutex_init`,
    `man 3 phtread_mutex_lock`, `man 3 phthread_mutex_unlock`, and `man 3 pthread_mutex_destroy`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有关互斥锁的更多信息，请参阅手册页`man 3 pthread_mutex_init`，`man 3 phtread_mutex_lock`，`man
    3 phthread_mutex_unlock`和`man 3 pthread_mutex_destroy`。
- en: Making the mutex program more efficient
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使互斥程序更高效
- en: In the previous recipe, we saw that a threaded program isn't necessarily any
    faster than a non-threaded program. We also saw that when we introduced mutexes,
    the program got horribly slow. Much of this slowness is due to switching back
    and forth and locking and unlocking billions of times.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们看到多线程程序并不一定比非多线程程序快。我们还看到，当我们引入互斥锁时，程序变得非常慢。这种缓慢主要是由于来回切换、锁定和解锁数十亿次造成的。
- en: The solution to all of this locking and unlocking and switching back and forth
    is to lock and unlock as few times as possible. And also, to update the `i` variable
    as few times as possible and do as much work as possible in each thread.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 解决所有这些锁定、解锁和来回切换的方法是尽可能少地锁定和解锁。而且，尽可能少地更新`i`变量，并在每个线程中尽可能多地完成工作。
- en: In this recipe, we'll make our threaded program much faster and much more efficient.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将使我们的多线程程序运行得更快，更高效。
- en: Knowing how to write efficient threaded programs will help you stay away from
    many of the pitfalls when it comes to threading.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何编写高效的多线程程序将帮助您避免许多线程问题。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order for this recipe to make sense, it's advised that you complete the two
    previous recipes in this chapter. Other than that, the same requirements apply
    here; we need the Makefile, the GCC compiler, and the Make tool.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本示例有意义，建议您完成本章中的前两个示例。除此之外，这里也有相同的要求；我们需要Makefile、GCC编译器和Make工具。
- en: How to do it…
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This program builds on the previous `locking.c` program from the previous recipe.
    The only difference is the `add()` function. Therefore, only the `add()` function
    is shown here; the rest is the same as `locking.c`. The complete program can be
    downloaded from this chapter''s GitHub directory. The name of the file is `efficient.c`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序是基于上一个示例中的`locking.c`程序构建的。唯一的区别是`add()`函数。因此，这里只显示`add()`函数；其余部分与`locking.c`相同。完整的程序可以从本章的GitHub目录中下载。文件名为`efficient.c`：
- en: Make a copy of `locking.c` and name the new file `efficient.c`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`locking.c`并将新文件命名为`efficient.c`。
- en: 'Rewrite the `add()` function so that it looks like this code instead. Notice
    that we have removed the `for` loop. Instead, we increment a local `j` variable
    in a `while` loop until it reaches 1,000,000,000\. Then, we add the local `j`
    variable to the global `i` variable. This reduces the number of times we have
    to lock and unlock the mutex (from 5,000,000,000 times to only 5 times):'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`add()`函数，使其看起来像下面的代码。请注意，我们已经删除了`for`循环。相反，我们在`while`循环中递增一个本地的`j`变量，直到达到10亿。然后，我们将本地的`j`变量添加到全局的`i`变量中。这减少了我们必须锁定和解锁互斥锁的次数（从50亿次减少到5次）：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Compile the program:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s run the program and time it using the `time` command. Notice how
    much faster this program is:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行程序并使用`time`命令计时。请注意，这个程序运行得多快：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works…
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This program is much faster than both the non-threaded version and the first
    locking version. As a reminder of the execution times, the non-threaded version
    took around 10 seconds to complete; the first threaded version (`race.c`) took
    around 20 seconds to complete; the first mutex version (`locking.c`) took well
    over 5 minutes to complete. The final version (`efficient.c`) took just under
    2 seconds to complete—a huge improvement.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序比非线程化版本和第一个锁定版本都要快得多。作为执行时间的提醒，非线程化版本大约需要10秒才能完成；第一个线程化版本（`race.c`）大约需要20秒才能完成；第一个互斥版本（`locking.c`）需要超过5分钟才能完成。最终版本（`efficient.c`）只需要不到2秒就能完成——这是一个巨大的改进。
- en: There are two main reasons why this program is so much faster. First, this program
    only locks and unlocks the mutex 5 times (compared to 5,000,000,000 times in the
    previous recipe). Secondly, each thread can now complete its work (the `while`
    loop) fully before writing anything to the global variable.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序之所以快得多，有两个主要原因。首先，这个程序只锁定和解锁互斥锁5次（与上一个示例中的5,000,000,000次相比）。其次，每个线程现在可以在向全局变量写入任何内容之前完全完成其工作（`while`循环）。
- en: Simply put, each thread can now do its work without any interruptions, making
    it truly threaded. Only when the threads have completed their work will they write
    their result to the global variable.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，每个线程现在可以在没有任何中断的情况下完成其工作，使其真正成为线程化。只有当线程完成其工作后，它们才会将结果写入全局变量。
- en: Using condition variables
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用条件变量
- en: With `main()` using a condition variable that it has finished and then joins
    with that thread.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`使用一个条件变量来表示它已经完成，然后与该线程连接。'
- en: Knowing how to use condition variables will help you make your threaded programs
    more flexible.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用条件变量将有助于使您的线程程序更加灵活。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In order for this recipe to make sense, it's advised that you have completed
    the *Reading return values from threads* recipe first. You'll also need the GCC
    compiler, the Makefile we wrote in the *Writing your first threaded program* recipe,
    and the Make tool.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个示例有意义，建议您先完成*从线程中读取返回值*示例。您还需要GCC编译器，我们在*编写您的第一个线程化程序*示例中编写的Makefile以及Make工具。
- en: How to do it…
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we'll rewrite the prime number program from the *Reading return
    values from threads* recipe to use condition variables. The complete program will
    be shown here, but we will only discuss the added parts for this recipe.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将从*从线程中读取返回值*示例中重新编写素数程序，以使用条件变量。完整的程序将在这里显示，但我们只讨论了这个示例的新增部分。
- en: 'Since the code is long, it has been broken up into several steps. Save the
    code in a file called `cond-var.c`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于代码很长，它已经被分成了几个步骤。将代码保存在一个名为`cond-var.c`的文件中：
- en: 'We''ll start at the top as usual. Here we have added three new variables, a
    mutex that we name `lock`, a condition variable that we name `ready`, and a thread
    ID for the prime thread, which we name `primeid`. The `primeid` variable will
    be used to send the thread ID from the thread that has finished:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像往常一样从顶部开始。在这里，我们添加了三个新变量，一个我们称为`lock`的互斥锁，一个我们称为`ready`的条件变量，以及一个用于素数线程的线程ID，我们称为`primeid`。`primeid`变量将用于从已完成的线程发送线程ID：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then we must initialize both the **mutex** and the **condition variable**:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们必须初始化**互斥锁**和**条件变量**：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After that, we check the number of arguments, just as before. If the argument
    count is correct, we start the threads with `pthread_create()`, also as before:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们检查参数的数量，就像以前一样。如果参数计数正确，我们就用`pthread_create()`启动线程，也和以前一样：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now comes the interesting stuff. We''ll start by locking the mutex so that
    the `primeid` variable is protected. Then, we wait for the signal from the condition
    variable using `pthread_cond_wait()`. This will release the mutex so that the
    threads can write to `primeid`. Note that we also loop the `pthread_cond_wait()`
    call in a `while` loop. We do this because we only want to wait for the signal
    if `primeid` is still 0\. Since `pthread_cond_wait()` will block, it won''t use
    any CPU cycles. When we get the signal, we move down to the `if` statement. This
    checks which thread it was that finished and joins it. Then we go back and start
    again using the `for` loop. Each time an `if` or `else` statement has completed—when
    a thread has joined—the `primeid` variable is reset to 0\. This will make the
    next iteration wait again with `pthread_cond_wait()`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是有趣的部分。我们将从锁定互斥锁开始，以保护`primeid`变量。然后，我们使用`pthread_cond_wait()`等待条件变量的信号。这将释放互斥锁，以便线程可以写入`primeid`。请注意，我们还在`while`循环中循环`pthread_cond_wait()`调用。我们这样做是因为我们只想在`primeid`仍然为0时等待信号。由于`pthread_cond_wait()`将阻塞，它不会使用任何CPU周期。当我们收到信号时，我们移动到`if`语句。这将检查哪个线程已经完成并加入它。然后我们回去并使用`for`循环重新开始。每当`if`或`else`语句完成时——当一个线程已经加入时——`primeid`变量将被重置为0。这将使下一次迭代再次等待`pthread_cond_wait()`：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next up, we have the `isprime()` function. Here we have some new lines. Once
    the function is done calculating the number, we lock the mutex to protect the
    `primeid` variable. Then we set the `primeid` variable to the thread''s ID. Then,
    we signal the condition variable (`ready`) and release the mutex lock. This will
    wake up the `main()` function since it''s now waiting with `pthread_cond_wait()`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有`isprime()`函数。这里有一些新的行。一旦函数计算完数字，我们就锁定互斥锁以保护`primeid`变量。然后我们将`primeid`变量设置为线程的ID。然后，我们发出条件变量（`ready`）的信号并释放互斥锁。这将唤醒`main()`函数，因为它现在正在等待`pthread_cond_wait()`：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And finally, we have the `progress()` function. Nothing has changed here:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有`progress()`函数。这里没有改变：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s compile the program:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编译程序：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s now try out the program. We''ll test it with both the smaller number
    as the first argument and then as the second argument. Either way, the fastest
    number to compute will be displayed instantly, without having to wait for the
    other thread to join:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们尝试一下这个程序。我们将用较小的数字作为第一个参数和第二个参数来测试它。无论如何，最快的计算数字都将立即显示出来，而不需要等待其他线程加入：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we waited in the `while` loop with `pthread_cond_wait()`, we called it
    with both the condition variable (`ready`) and the mutex (`lock`). That way, it
    knows which mutex to release and which signal to wait for. It's when we wait that
    the mutex is released.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`while`循环中使用`pthread_cond_wait()`等待时，我们同时使用条件变量（`ready`）和互斥锁（`lock`）进行调用。这样，它就知道释放哪个互斥锁，等待哪个信号。就是在等待时释放互斥锁。
- en: During the waiting, the other threads can write to the `primeid` variable. The
    other threads will first lock the variable with the mutex before writing to it.
    Once they have written to the variable, they signal the condition variable and
    release the mutex. This wakes up the `main()` function, which is currently waiting
    with `pthread_cond_wait()`. The `main()` function then checks which thread it
    was that finished and joins it with `pthread_join()`. Then, the `main()` function
    will reset the `primeid` variable to 0 and go back to waiting with `pthread_cond_wait()`
    until the next thread signals that it's finished. There are two threads we are
    waiting for, so the `for` loop in `main()` will run the loop two times.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在等待期间，其他线程可以写入`primeid`变量。其他线程在写入变量之前会先用互斥锁锁定变量。一旦他们写入变量，就会发出条件变量的信号并释放互斥锁。这会唤醒`main()`函数，它目前正在使用`pthread_cond_wait()`等待。`main()`函数然后检查哪个线程完成了，并使用`pthread_join()`加入它。然后，`main()`函数将`primeid`变量重置为0，并使用`pthread_cond_wait()`再次等待，直到下一个线程发出完成的信号。我们正在等待两个线程，所以`main()`中的`for`循环将运行两次。
- en: Each thread gets its own thread ID using `pthread_self()`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都使用`pthread_self()`获得自己的线程ID。
- en: See also
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Refer to the following manual pages for more information regarding condition
    variables:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有关条件变量的更多信息，请参阅以下手册页面。
- en: '`man 3 pthread_cond_init()`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 3 pthread_cond_init()`'
- en: '`man 3 pthread_cond_wait()`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 3 pthread_cond_wait()`'
- en: '`man 3 pthread_cond_signal()`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 3 pthread_cond_signal()`'
