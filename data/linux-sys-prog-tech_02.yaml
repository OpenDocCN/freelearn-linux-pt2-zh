- en: '*Chapter 2*: Making Your Programs Easy to Script'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：使您的程序易于脚本化'
- en: Linux and other **Unix** systems have strong **scripting** support. The whole
    idea of Unix, from the very beginning, was to make a system easy to develop on.
    One of these features is to take the output of one program and make it the input
    of another program—hence building new tools with existing programs. We should
    always keep this in mind when creating programs for Linux. The Unix philosophy
    is to make small programs that do one thing only—and do it well. By having many
    small programs that do only one thing, we can freely choose how to combine them.
    And by combining small programs, we can write shell scripts—a common task in Unix
    and Linux.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Linux和其他**Unix**系统具有强大的**脚本**支持。Unix的整个理念，从一开始就是使系统易于开发。其中一个特性是将一个程序的输出作为另一个程序的输入——因此利用现有程序构建新工具。在为Linux创建程序时，我们应该始终牢记这一点。Unix哲学是制作只做一件事情的小程序——并且做得很好。通过拥有许多只做一件事情的小程序，我们可以自由选择如何组合它们。通过组合小程序，我们可以编写shell脚本——这是Unix和Linux中的常见任务。
- en: This chapter will teach us how to make programs that are easy to script and
    easy to interact with other programs. That way, other people will find them much
    more useful. It's even likely they will find new ways of using our programs that
    we haven't even thought of, making the programs more popular and easier to use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将教会我们如何制作易于脚本化和易于与其他程序交互的程序。这样，其他人会发现它们更有用。甚至可能会发现我们甚至没有想到的使用我们的程序的新方法，使程序更受欢迎和易于使用。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下示例：
- en: Return values and how to read them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值及其读取方法
- en: Exiting a program with a relevant return value
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相关的返回值退出程序
- en: Redirecting stdin, stdout, and stderr
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向stdin、stdout和stderr
- en: Connecting programs using pipes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道连接程序
- en: Writing to stdout and stderr
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入stdout和stderr
- en: Reading from stdin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从stdin读取
- en: Writing a pipe-friendly program
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个友好的管道程序
- en: Redirecting the result to file
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果重定向到文件
- en: Reading environment variables
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取环境变量
- en: Let's get started!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All you need for this chapter is a Linux computer with GCC and Make installed,
    preferably via one of the meta-packages or group installs mentioned in [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the Necessary Tools
    and Writing Our First Linux Programs*. It's also preferable if you use the *Bash
    shell* for optimal compatibility. Most of the examples will work with other shells
    as well, but there's no guarantee that everything will work the same way on every
    possible shell out there. You can check which shell you are using by running `echo
    $SHELL` in your terminal. If you are using Bash, it will say `/bin/bash`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所需的仅为安装有GCC和Make的Linux计算机，最好是通过[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中提到的元包或组安装之一安装。最好使用*Bash
    shell*以获得最佳兼容性。大多数示例也适用于其他shell，但不能保证在所有可能的shell上都能正常工作。您可以通过在终端中运行`echo $SHELL`来检查您正在使用哪种shell。如果您使用的是Bash，它会显示`/bin/bash`。
- en: You can download all the code for this chapter from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch2](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch2](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch2)下载本章的所有代码。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3u5VItw](https://bit.ly/3u5VItw)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接，观看代码演示视频：[https://bit.ly/3u5VItw](https://bit.ly/3u5VItw)
- en: Return values and how to read them
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值及其读取方法
- en: '`return`. It''s that same `return` statement we use to return a value from
    `main()` to the shell. The original Unix operating system and the C programming
    language came around at the same time and from the same place. As soon as the
    C language was completed in the early 1970s, Unix was rewritten in C. Previously,
    it was written in assembler only. And hence, C and Unix fit together tightly.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`。这就是我们用来从`main()`返回值到shell的`return`语句。最初的Unix操作系统和C编程语言同时出现并且来自同一个地方。C语言在20世纪70年代初完成后，Unix就被重写成了C。以前，它只是用汇编语言编写的。因此，C和Unix紧密结合在一起。'
- en: The reason why return values are so crucial in Linux is that we can build shell
    scripts. Those shell scripts use other programs and, hopefully, our programs,
    as its parts. For the shell script to be able to check whether a program has succeeded
    or not, it reads the return value of that program.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中返回值如此重要的原因是我们可以构建shell脚本。这些shell脚本使用其他程序，希望也包括我们的程序，作为其部分。为了能够检查程序是否成功，shell脚本会读取该程序的返回值。
- en: In this recipe, we will write a program that tells the user if a file or directory
    exists or not.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个程序，告诉用户文件或目录是否存在。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It's recommended that you use Bash for this recipe. I can't guarantee compatibility
    with other shells.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您在此示例中使用Bash。我不能保证与其他shell的兼容性。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will write a small **shell script** that demonstrates the
    purpose of the return values, how to read them, and how to interpret them. Let''s
    get started:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个小的**shell脚本**，演示返回值的目的，如何读取它们以及如何解释它们。让我们开始吧：
- en: 'Before we write the code, we must investigate what return values the program
    uses that we will use in our script. Execute the following commands, and make
    a note of the return values we get. The `test` command is a small utility that
    tests certain conditions. In this example, we''ll use it to determine if a file
    or directory exists. The `-e` option stands for *exists*. The `test` command doesn''t
    give us any output; it just exits with a return value:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写代码之前，我们必须调查程序使用的返回值，这些返回值将在我们的脚本中使用。执行以下命令，并记录我们得到的返回值。`test`命令是一个测试特定条件的小型实用程序。在这个示例中，我们将使用它来确定文件或目录是否存在。`-e`选项代表*存在*。`test`命令不会给我们任何输出；它只是以一个返回值退出：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now that we know what return values the `test` program gives us (0 when the
    file or directory exists, otherwise 1), we can move on and write our script. Write
    the following code in a file and save it as `exist.sh`. You can also download
    it from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/exist.sh](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/exist.sh).
    The shell script uses the `test` command to determine whether the specified file
    or directory exists:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道`test`程序给我们什么返回值（文件或目录存在时为0，否则为1），我们可以继续编写我们的脚本。在文件中写入以下代码，并将其保存为`exist.sh`。您还可以从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/exist.sh](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/exist.sh)下载。这个shell脚本使用`test`命令来确定指定的文件或目录是否存在：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, you need to make it *executable* with the following command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您需要使用以下命令使其*可执行*：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, it''s time to try out our script. We try it with directories that do exist
    and with those that don''t. We also check the exit code after each run:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候尝试我们的脚本了。我们尝试存在的目录和不存在的目录。我们还在每次运行后检查退出代码：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we know that it''s working and leaving the correct exit codes, we
    can write `echo` to print a text stating whether the file or directory exists:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道它正在工作并且离开了正确的退出代码，我们可以编写`echo`来打印一条文本，说明文件或目录是否存在：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also write a more complicated one-liner—one that takes advantage of
    the unique error code 3 we assigned to "file not found" in our script. Note that
    you shouldn''t type `>` at the start of the second line. This character is automatically
    inserted by the shell when you end the first line with a backslash to indicate
    the continuation of a long line:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以编写一个更复杂的一行命令，利用我们在脚本中分配给“文件未找到”的独特错误代码3。请注意，您不应在第二行开头键入`>`。当您用反斜杠结束第一行以指示长行的继续时，shell会自动插入此字符：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `test` program is a small utility designed to test files and directories,
    compare values, and so on. In our case, we used it to test if the specified file
    or directory exists (`-e` for exist).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`程序是一个小型实用程序，用于测试文件和目录，比较值等。在我们的情况下，我们用它来测试指定的文件或目录是否存在（`-e`表示存在）。'
- en: The `test` program doesn't print anything; it just exits in silence. It does,
    however, leave a return value. It is that return value that we check with the
    `$?` variable. It's also the very same variable we check in the script's `if`
    statements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`程序不会打印任何内容；它只是默默退出。但是，它会留下一个返回值。我们使用`$?`变量来检查该返回值。这也是我们在脚本的`if`语句中检查的相同变量。'
- en: There are some other special variables in the script that we used. The first
    one was `$#`, which contains the number of `argc` in C. At the very start of the
    script, we compared if `$#` is *not equal* to 1 (`-ne` stands for *not equal*).
    If `$#` is not equal to 1, an error message is printed and the script aborts with
    code 1.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中还有一些我们使用的特殊变量。第一个是`$#`，它包含C中的`argc`数量。在脚本的开头，我们比较了`$#`是否*不等于*1（`-ne`表示*不等于*）。如果`$#`不等于1，则打印错误消息，并且脚本以代码1中止。
- en: The reason for putting `$#` inside quotes is just a safety mechanism. If, in
    some unforeseen event, `$#` were to contain spaces, we still want the content
    to be evaluated as a single value, not two. The same thing goes for the quotes
    around the other variables in the script.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将`$#`放在引号中的原因只是一种安全机制。如果在某种意外事件中，`$#`包含空格，我们仍希望内容被评估为单个值，而不是两个值。脚本中其他变量周围的引号也是同样的道理。
- en: The next special variable is `$0`. This variable contains argument 0, which
    is the name of the program, just as with `argv[0]` in C, as we saw *in* [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*, Getting the Necessary Tools
    and Writing Our First Linux Programs*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个特殊变量是`$0`。此变量包含参数0，即程序的名称，就像我们在*第1章*中看到的C中的`argv[0]`一样，获取必要的工具并编写我们的第一个Linux程序。
- en: The first argument to the program is stored in `$1`, as shown in the `test`
    case. The first argument in our case is the supplied filename or directory that
    we want to test.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的第一个参数存储在`$1`中，就像`test`案例中所示的那样。在我们的情况下，第一个参数是我们要测试的提供的文件名或目录。
- en: Like our C programs, we want our scripts to exit with a relevant return value
    (or `exit` to leave the script and set a return value. In case the user doesn't
    supply precisely one argument, we exit with code 1, a general error code. And
    if the script is executed as it should, and the file or directory exists, we exit
    with code 0\. If the script is executed as it should, but the file or directory
    doesn't exist, we exit with code 3, which isn't reserved for a particular use,
    but still indicates an error (all *non-zero* codes are error codes). This way,
    other scripts can fetch the return value of our script and act upon it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的C程序一样，我们希望我们的脚本以相关的返回值退出（或使用`exit`离开脚本并设置返回值）。如果用户没有提供精确的一个参数，我们以代码1退出，这是一个一般的错误代码。如果脚本按预期执行，并且文件或目录存在，我们以代码0退出。如果脚本按预期执行，但文件或目录不存在，我们以代码3退出，这并没有为特定用途保留，但仍然表示错误（所有*非零*代码都是错误代码）。这样，其他脚本可以获取我们的脚本的返回值并对其进行操作。
- en: 'In *Step 5*, we did just that—act upon the exit code from our script with the
    following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们就是这样—使用以下命令对我们的脚本的退出代码进行操作：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`&&` means "and". We can read the whole line as an `if` statement. If `exist.sh`
    is true—that is, exit code 0—then execute the `echo` command. If the `exit` code
    is anything other than 0, then the `echo` command is never executed.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`表示“和”。我们可以将整行读作`if`语句。如果`exist.sh`为真，即退出代码为0，则执行`echo`命令。如果退出代码不为0，则`echo`命令永远不会被执行。'
- en: In *Step 6*, we redirected all the output from the script to `/dev/null` and
    then used a complete `if` statement to check for error code 3\. If error code
    3 is encountered, we print a message with `echo`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们将脚本的所有输出重定向到`/dev/null`，然后使用完整的`if`语句来检查错误代码3。如果遇到错误代码3，我们使用`echo`打印一条消息。
- en: There's more…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are a lot more tests and comparisons we can do with the `test` program.
    They are all listed in the manual; that is, `man 1 test`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`test`程序做更多的测试和比较。它们都列在手册中；也就是说，`man 1 test`。
- en: If you are unfamiliar with Bash and shell scripting, there is a lot of useful
    information in the manual page, `man 1 bash`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Bash和shell脚本不熟悉，在手册页`man 1 bash`中有很多有用的信息。
- en: 'The opposite of `&&` is `||` and is pronounced "or." So, the opposite of what
    we did in this recipe would be as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`的反义是`||`，发音是“或”。因此，我们在这个示例中所做的相反操作如下：'
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'If you want to dig deep into the world of Bash and shell scripting, there is
    an excellent guide at *The Linux Documentation Project*: https://tldp.org/LDP/Bash-Beginners-Guide/html/index.html.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解Bash和shell脚本的世界，在*Linux文档项目*有一个很好的指南：https://tldp.org/LDP/Bash-Beginners-Guide/html/index.html。
- en: Exiting a program with a relevant return value
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用相关的返回值退出程序
- en: In this recipe, we'll learn how to exit a C program with a relevant `return`
    fits together with the system from a broader perspective. We will also learn what
    some common return values mean.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用相关的`return`退出C程序，以及从更广泛的角度来看系统是如何配合的。我们还将学习一些常见的返回值的含义。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we only need the GCC compiler and the Make tool.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们只需要GCC编译器和Make工具。
- en: How to do it…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will write two different versions of a program here to show you two different
    methods of exiting. Let''s get started:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里编写两个不同版本的程序，以展示两种不同的退出方法。让我们开始吧：
- en: 'We''ll start by writing the first version using `return`, which we have seen
    previously. But this time, we will use it to return from `main()` and eventually
    the `functions_ver1.c`. All the return statements are highlighted in the following
    code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先编写使用`return`的第一个版本，这是我们之前见过的。但这一次，我们将用它从`main()`和最终`functions_ver1.c`中返回。以下代码中所有的返回语句都被突出显示：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, **compile** it:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，**编译**它：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, run it. Try to follow along and see which functions call and return to
    which other functions:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后运行它。试着跟着看，看哪些函数调用并返回到哪些其他函数：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Check the return value:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查返回值：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we rewrite the preceding program to use `exit()` inside the functions
    instead. What will happen then is that as soon as `exit()` is called, the program
    will `exit()` is called inside another function, that function will not return
    to `main()` first. Save the following program in a new file as `functions_ver2.c`.
    All the `return` and `exit` statements are highlighted in the following code:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将重写前面的程序，使用`exit()`来代替函数内部的`return`。那么当`exit()`被调用时，程序将立即退出。如果`exit()`在另一个函数中被调用，那个函数将不会首先返回到`main()`。将以下程序保存在一个新文件中，命名为`functions_ver2.c`。以下代码中所有的`return`和`exit`语句都被突出显示：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, compile this version:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译这个版本：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, run it and see what happens (and compare the output from the previous
    program):'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后运行它，看看会发生什么（并比较前一个程序的输出）：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, check the return value:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，检查返回值：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Notice that in C, 0 is regarded as *false* or error, while anything else is
    considered to be *true* (or correct). This is the opposite of the return values
    to the shell. This can be a bit confusing at first. However, as far as the shell
    is concerned, 0 is "all ok," while anything else indicates an error.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在C中，0被视为*false*或错误，而其他任何值都被视为*true*（或正确）。这与shell的返回值相反。这一点起初可能有点令人困惑。然而，就shell而言，0表示“一切正常”，而其他任何值表示错误。
- en: The difference between the two versions is how the functions and the entire
    program returns. In the first version, each function returns to the calling function—in
    the order they were called. In the second version, each function exits with the
    `exit()` function. This means that the program will exit directly and return the
    specified value to the shell. The second version isn't good practice; it's much
    better to return to the calling function. If someone else were to use your function
    in another program, and it suddenly exits the entire program, that would be a
    big surprise. That's not usually how we do it. However, I wanted to demonstrate
    the difference between `exit()` and `return` here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 两个版本之间的区别在于函数和整个程序的返回方式。在第一个版本中，每个函数都返回到调用函数中——按照它们被调用的顺序。在第二个版本中，每个函数都使用`exit()`函数退出。这意味着程序将直接退出并将指定的值返回给shell。第二个版本不是一个好的做法；最好是返回到调用函数。如果其他人在另一个程序中使用你的函数，而它突然退出整个程序，那将是一个大惊喜。通常我们不是这样做的。但是，我想在这里演示`exit()`和`return`之间的区别。
- en: I also wanted to demonstrate another point. Just as a function returns to its
    calling function with `return`, a program returns to its parent process (usually
    the shell) in the same way. So, in a way, programs in Linux are treated as functions
    in a program.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想演示另一点。就像函数用`return`返回到它的调用函数一样，程序也以同样的方式返回到它的父进程（通常是shell）。因此，在Linux中，程序就像是程序中的函数一样对待。
- en: 'The following diagram shows how Bash calls the program (the upper arrow), which
    then starts in `main()`, which then calls the next function (the arrows to the
    right), and so on. The arrows returning on the left show how each function returns
    to the calling function, and then finally to Bash:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了Bash如何调用程序（上箭头），然后程序在`main()`中启动，然后调用下一个函数（右箭头），依此类推。返回到左边的箭头显示了每个函数如何返回到调用函数，最终返回到Bash：
- en: '![](img/Figure_2.1_B13043.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_2.1_B13043.jpg)'
- en: Figure 2.1 – Calling and returning
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - 调用和返回
- en: There's more…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are a lot more return codes we can use. The most common ones are the
    ones we''ve seen here; `0` for *ok* and `1` for *error*. However, all other codes
    except `0` mean some form of error. Code `1` is a general error, while the other
    error codes are more specific. There isn''t exactly a standard, but there are
    some commonly used codes. Some of the most common codes are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更多的返回代码。最常见的是我们在这里看到的`0`表示*ok*，`1`表示*error*。然而，除了`0`之外的所有其他代码都表示某种形式的错误。代码`1`是一般错误，而其他错误代码更具体。虽然没有确切的标准，但有一些常用的代码。以下是一些最常见的代码：
- en: '![](img/Figure_2.2_B13043.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_2.2_B13043.jpg)'
- en: Figure 2.2 – Common error codes in Linux and other UNIX-like systems
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 - Linux和其他类UNIX系统中的常见错误代码
- en: Except for these codes, there are some additional ones listed at the end of
    `/usr/include/sysexit.h`. The codes listed in that file range from `64` to `78`
    and address errors such as data format error, service unavailable, **I/O** errors,
    and more.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些代码，还有一些其他代码列在`/usr/include/sysexit.h`的末尾。该文件中列出的代码范围从`64`到`78`，涉及数据格式错误、服务不可用、I/O错误等错误。
- en: Redirecting stdin, stdout, and stderr
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向stdin、stdout和stderr
- en: In this recipe, we will learn how to **redirect** *standard input*, *standard
    output*, and *standard error* to and from files. Redirecting data to and from
    files is one of the basic principles of Linux and other Unix systems.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何将标准输入、标准输出和标准错误重定向到文件中。将数据重定向到文件是Linux和其他Unix系统的基本原则之一。
- en: '**stdin** is the shorthand word for **standard input**. **stdout** and **stderr**
    are the shorthand words for **standard output** and **standard error**, respectively.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**stdin**是**标准输入**的简写。**stdout**和**stderr**分别是**标准输出**和**标准错误**的简写。'
- en: Getting ready
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: It's best if we use the Bash shell for this recipe for compatibility purposes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最好使用Bash shell进行此操作，以确保兼容性。
- en: How to do it…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To get the hang of redirections, we will be performing a bunch of experiments
    here. We are really going to twist and turn the redirections and see stdout, stderr,
    and stdin operate in all kinds of ways. Let''s get started:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉重定向，我们将在这里进行一系列实验。我们将扭转重定向，看到stdout、stderr和stdin以各种方式运行。让我们开始吧：
- en: 'Let''s start by saving a list of the files and directories in the top root
    directory. We can do this by redirecting standard output (stdout) from the `ls`
    command into a file:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从保存顶级根目录中的文件和目录列表开始。我们可以通过将`ls`命令的标准输出（stdout）重定向到一个文件中来实现这一点：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, take a look at the file with `cat`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用`cat`命令查看文件：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s try the `wc` command to count lines, words, and characters. Remember
    to press *Ctrl + D* when you have finished typing in the message:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试`wc`命令来计算行数、单词数和字符数。记得在输入消息后按下*Ctrl + D*：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we know how `wc` works, we can redirect its input to come from a file
    instead—the file we created with the file listing:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道了`wc`是如何工作的，我们可以重定向它的输入来自一个文件 - 我们用文件列表创建的文件：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What about standard error? Standard error is its own output stream, separated
    from standard output. If we redirect standard output and generate an error, we
    will still see the error message on the screen. Let''s try it out:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准错误呢？标准错误是它自己的输出流，与标准输出分开。如果我们重定向标准输出并生成错误，我们仍然会在屏幕上看到错误消息。让我们试一试：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Just like standard output, we can redirect standard error. Notice that we don''t
    get any error message here:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像标准输出一样，我们也可以重定向标准错误。请注意，这里我们没有收到任何错误消息：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The error messages are saved in `errors.txt`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误消息保存在`errors.txt`中：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can even redirect standard output and standard error at the same time, to
    different files:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以同时重定向标准输出和标准错误到不同的文件中：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can also redirect standard output and error into the same file for convenience:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以将标准输出和错误重定向到同一个文件中，以方便操作：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can even redirect all three (stdin, stdout, and stderr) at the same time:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以同时重定向所有三个（stdin、stdout和stderr）：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can also write to standard error from the shell to write error messages
    of our own:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以从shell向标准错误写入自己的错误消息：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Another way of printing a message to stderr from Bash is like this:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Bash中将消息打印到stderr的另一种方法是这样的：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, this doesn''t prove that our hello message got printed to standard
    error. We can prove this by redirecting the standard output to a file. If we still
    see the error message, then it''s printed on standard error. When we do this,
    we need to wrap the first statement in parenthesis to separate it from the last
    redirect:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，这并没有证明我们的hello消息被打印到标准错误。我们可以通过将标准输出重定向到一个文件来证明这一点。如果我们仍然看到错误消息，那么它是打印在标准错误上的。当我们这样做时，我们需要将第一个语句用括号括起来，以便与最后的重定向分开：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Stdin, stdout, and stderr are represented by files in the `/dev` directory.
    This means we can even redirect stdin from a file. This experiment doesn''t do
    anything useful—we could have just typed `wc`, but it proves a point:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标准输入、标准输出和标准错误在`/dev`目录中用文件表示。这意味着我们甚至可以从文件中重定向stdin。这个实验并没有做任何有用的事情 - 我们本可以只输入`wc`，但这证明了一个观点：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'All of this means that we can even redirect a standard error message back to
    standard output:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些意味着我们甚至可以将标准错误消息重定向回标准输出：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Standard output, or stdout, is where all the normal output from programs gets
    printed. Stdout is also referred to as **file descriptor** 1.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输出，或者stdout，是程序的正常输出打印的地方。Stdout也被称为文件描述符1。
- en: Standard error, or *stderr*, is where all error messages get printed. Stderr
    is also referred to as file descriptor 2\. That is why we used `2>` when we redirected
    stderr to a file. If we wanted to, for clarity, we could have redirected *stdout*
    as `1>` instead of just `>`. But the default redirection with `>` is stdout, so
    there is no need to do this.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 标准错误，或者stderr，是所有错误消息被打印的地方。Stderr也被称为文件描述符2。这就是为什么我们在将stderr重定向到文件时使用了`2>`。如果我们愿意，为了清晰起见，我们可以将*stdout*重定向为`1>`，而不仅仅是`>`。但是，默认的重定向是stdout，所以没有必要这样做。
- en: When we redirected both stdout and stderr in *Step 9*, we used an `&` sign.
    This reads as "stdout *and* stderr".
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤9*中，当我们重定向了标准输出和标准错误时，我们使用了一个`&`符号。这意味着“标准输出*和*标准错误”。
- en: Standard input, or *stdin*, is where all input data is read from. Stdin is also
    referred to as file descriptor 0\. Stdin redirects with a `<`, but just as with
    stdout and stderr, we can also write it as `0<`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输入，或*stdin*，是所有输入数据被读取的地方。Stdin也被称为文件描述符0。Stdin可以通过`<`重定向，但就像标准输出和标准错误一样，我们也可以写成`0<`。
- en: The reason for separating the two outputs, stdout and stderr, is so that when
    we redirect the output from a program to a file, we should still be able to see
    the error message on the screen. We also don't want the file to be cluttered with
    error messages.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 分开标准输出和标准错误的原因是，当我们将程序的输出重定向到文件时，我们仍然应该能够在屏幕上看到错误消息。我们也不希望文件被错误消息淹没。
- en: Having separate outputs also makes it possible to have one file for the actual
    output, and another one as a log file for error messages. This is especially handy
    in scripts.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有单独的输出也使得可以有一个文件用于实际输出，另一个文件用作错误消息的日志文件。这在脚本中特别方便。
- en: You might have heard the phrase "*Everything in Linux is either a file or a
    process*". That saying is true. There is no other *thing* in Linux, except for
    files or processes. Our experiments with `/dev/stdout`, `/dev/stderr`, and `/dev/stdin`
    proved this. Files represent even the input and output of programs.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过短语“*Linux中的一切都是文件或进程*”。这句话是真的。在Linux中没有其他*东西*，除了文件或进程。我们对`/dev/stdout`、`/dev/stderr`和`/dev/stdin`的实验证明了这一点。文件甚至代表了程序的输入和输出。
- en: In *Step 11*, we redirected the output to the `/dev/stderr` file, which is standard
    error. The message, therefore, got printed on standard error.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤11*中，我们将输出重定向到了`/dev/stderr`文件，这是标准错误。因此，消息被打印到了标准错误。
- en: In *Step 12*, we pretty much did the same thing but without using the actual
    device file. The funny-looking `1>&2` redirection reads as "*send standard output
    to standard error*".
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤12*中，我们基本上做了同样的事情，但没有使用实际的设备文件。看起来有点奇怪的`1>&2`重定向的意思是“*将标准输出发送到标准错误*”。
- en: There's more…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Instead of using `/dev/stderr`, for example, we could have used `/dev/fd/2`,
    where `/dev/fd/1`, and stdin, which is `/dev/fd/0`. So, for example, the following
    will print the list to stderr:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用`/dev/fd/2`来代替使用`/dev/stderr`，其中`/dev/fd/1`和标准输入，即`/dev/fd/0`。因此，例如，以下命令将列表打印到标准错误：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Just like we can send standard output to standard error with `1>&2`, we can
    do the opposite with `2>&1`, which means we can send standard error to standard
    output.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以使用`1>&2`将标准输出发送到标准错误一样，我们也可以使用`2>&1`将标准错误发送到标准输出。
- en: Connecting programs using pipes
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道连接程序
- en: In this recipe, we'll learn how to use **pipes** to connect programs. When we
    write our C programs, we always want to strive to make them easy to pipe together
    with other programs. That way, our programs will be much more useful. Sometimes,
    programs that are connected with pipes are called **filters**. The reason for
    this is that, often, when we connect programs with pipes, it is to filter or transform
    some data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何使用**管道**连接程序。当我们编写C程序时，我们总是希望努力使它们易于与其他程序一起使用管道连接。这样，我们的程序将更加有用。有时，使用管道连接的程序被称为**过滤器**。原因是，通常当我们使用管道连接程序时，是为了过滤或转换一些数据。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Just as in the previous recipe, it's recommended that we use the Bash shell.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在上一个教程中一样，建议使用Bash shell。
- en: How to do it…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to explore pipes in Linux:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来探索Linux中的管道：
- en: 'We are already familiar with `wc` and `ls` from the previous recipe. Here,
    we will use them together with a pipe to count the number of files and directories
    in the root directory of the system. The pipe is the vertical line symbol:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经熟悉了上一个教程中的`wc`和`ls`。在这里，我们将它们与管道一起使用，来计算系统根目录中文件和目录的数量。管道是垂直线符号：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s make things a bit more interesting. This time, we want to list only
    **symbolic links** in the root directory (by using two programs with a pipe).
    The result will differ from system to system:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们让事情变得更有趣一点。这一次，我们想要列出根目录中的**符号链接**（使用两个程序和一个管道）。结果会因系统而异：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we only want the actual filenames, not the information about them. So,
    this time, we will add another program at the end called `awk`. In this example,
    we are telling `awk` to print the ninth field. One or more whitespaces separate
    each field:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只想要实际的文件名，而不是关于它们的信息。所以，这一次，我们将在最后添加另一个名为`awk`的程序。在这个例子中，我们告诉`awk`打印第九个字段。一个或多个空格分隔每个字段：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can add another "`sed` – `s` means *substitute*. Then, we can tell `sed`
    that we want to substitute the start of the line (`^`) with the text `This is
    a link:`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以添加另一个"`sed` - `s`意思是*替换*。然后，我们可以告诉`sed`我们想要用文本`This is a link:`替换行的开头（`^`）：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A lot of things are going on here, but don't feel discouraged if you don't get
    it all. The importance of this recipe is to demonstrate how to use a *pipe* (the
    vertical line symbol, `|`).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情正在进行，但如果你不明白所有的事情，不要感到沮丧。这个教程的重要性在于演示如何使用*管道*（垂直线符号，`|`）。
- en: 'In the very first step, we counted the number of files and directories in the
    root of the filesystem using `wc`. When we run `ls` interactively, we get a nice-looking
    list that spans the width of our terminal. The output is also most likely color-coded.
    But when we run `ls` by redirecting its output through a pipe, `ls` doesn''t have
    a real terminal to output to, so it falls back to outputting the text one file
    or directory per line, without any colors. You can try this yourself if you like
    by running the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们使用`wc`计算了文件系统根目录中的文件和目录数量。当我们交互式运行`ls`时，我们会得到一个漂亮的列表，它跨越了我们终端的宽度。输出很可能也是彩色的。但是当我们通过管道重定向`ls`的输出时，`ls`没有一个真正的终端来输出，所以它会回退到每行输出一个文件或目录的文本，而没有任何颜色。如果你愿意，你可以自己尝试一下，运行以下命令：
- en: '[PRE40]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Since `ls` it outputting one file or directory per line, we can count the number
    of lines with `wc` (the `-l` option).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ls`每行输出一个文件或目录，我们可以使用`wc`（`-l`选项）来计算行数。
- en: In the next step (*Step 2*), we used `grep` to only list links from the output
    of `ls -l`. Links in the output from `ls -l` start with the letter `l` at the
    start of the line. After that is the access rights, which for links is `rwx` for
    everyone. This is what we search for with `lrwx` with `grep`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步（*步骤2*）中，我们使用`grep`仅列出了从`ls -l`的输出中的链接。`ls -l`的输出中的链接以行首的字母`l`开头。之后是访问权限，对于链接来说是`rwx`。这就是我们用`grep`搜索的内容。
- en: Then, we only wanted the actual filenames, so we added a program called `awk`.
    The `awk` tool lets us single out a particular column or field in the output.
    We singled out the ninth column (`$9`), which is the filename.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只想要实际的文件名，所以我们添加了一个名为`awk`的程序。`awk`工具让我们单独提取输出中的特定列或字段。我们提取了第九列（`$9`），也就是文件名。
- en: By running the output from `ls` through two other tools, we created a list of
    only the links in the root directory.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`ls`的输出通过另外两个工具，我们创建了一个仅包含根目录中链接的列表。
- en: 'In *Step 3*, we added another tool, or filter as it sometimes called. This
    tool is `sed`, a *stream editor*. With this program, we can make changes to the
    text. In this case, we added the text `This is a link:` in front of every link.
    The following is a short explanation of the line:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们添加了另一个工具，或者有时称为过滤器。这个工具是`sed`，一个*流编辑器*。使用这个程序，我们可以对文本进行更改。在这种情况下，我们在每个链接前面添加了文本`This
    is a link:`。以下是该行的简短解释：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`s` means "substitute"; that is, we wish to modify some text. Inside the two
    first slashes (`/`) is the text or expressions that should match what we want
    to modify. Here, we have the beginning of the line, `^`. Then, after the second
    slash, we have the text that we want to replace the matched text with, up until
    the final slash. Here, we have the text `This is a link:`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`s`表示"替换"；也就是说，我们希望修改一些文本。在两个第一个斜杠（`/`）内是应该匹配我们想要修改的文本或表达式。这里，我们有行首`^`。然后，在第二个斜杠之后，我们有要用匹配的文本替换的文本，一直到最后一个斜杠。这里，我们有文本`This
    is a link:`。'
- en: There's more…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Beware of unnecessary piping; it''s easy to get caught up in endless piping.
    One silly—but instructive—example is this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 小心不必要的管道处理；很容易陷入无休止的管道处理中。一个愚蠢但有教育意义的例子是：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We could leave out `cat` and still get the same result:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以省略`cat`，仍然可以得到相同的结果：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The same goes for this one (which I am guilty of myself from time to time):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个（我自己有时也会犯的错误）也是一样的：
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There is no reason to pipe the previous example at all. The `grep` utility
    can take a filename argument, like so:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由对前面的示例进行管道处理。`grep`实用程序可以接受文件名参数，如下所示：
- en: '[PRE48]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: See also
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For anyone interested in the history of Unix and how far back pipes go, there
    is an exciting video from 1982 on YouTube, uploaded by AT&T: [https://www.youtube.com/watch?v=tc4ROCJYbm0](https://www.youtube.com/watch?v=tc4ROCJYbm0).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何对Unix的历史以及管道的起源感兴趣的人，YouTube上有一个令人兴奋的1982年的视频，由AT&T上传：[https://www.youtube.com/watch?v=tc4ROCJYbm0](https://www.youtube.com/watch?v=tc4ROCJYbm0)。
- en: Writing to stdout and stderr
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入stdout和stderr
- en: In this recipe, we'll learn how to print text to both *stdout* and *stderr*
    in a C program. In the two previous recipes, we learned what stdout and stderr
    are, why they exist, and how to redirect them. Now, it's our turn to write correct
    programs that output error messages on standard error, and regular messages on
    standard output.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何在C程序中将文本打印到*stdout*和*stderr*。在前两个配方中，我们学习了stdout和stderr是什么，它们为什么存在，以及如何重定向它们。现在，轮到我们编写正确的程序，在标准错误上输出错误消息，并在标准输出上输出常规消息了。
- en: How to do it…
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to learn how to write output to both stdout and stderr in
    a C program:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何在C程序中将输出写入stdout和stderr：
- en: 'Write the following code in a file called `output.c` and save it. In this program,
    we will write output using three different functions: `printf()`, `fprintf()`,
    and `dprintf()`. With `fprintf()`, we can specify a file stream such as stdout
    or stderr, while with `dprintf()`, we can specify the file descriptor (1 for stdout
    and 2 for stderr, just as we have seen previously):'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`output.c`的文件中写入以下代码并保存。在这个程序中，我们将使用三个不同的函数来写入输出：`printf()`、`fprintf()`和`dprintf()`。使用`fprintf()`，我们可以指定文件流，如stdout或stderr，而使用`dprintf()`，我们可以指定文件描述符（1表示stdout，2表示stderr，就像我们之前看到的那样）：
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Compile the program:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Run the program like you usually would:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像通常一样运行程序：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To prove that the regular messages are printed to stdout, we can send the error
    messages to `/dev/null`, a black hole in the Linux system. Doing this will only
    display the messages printed to stdout:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了证明常规消息是打印到stdout的，我们可以将错误消息发送到`/dev/null`，这是Linux系统中的一个黑洞。这样做将只显示打印到stdout的消息：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we will do the reverse; we will send the messages printed to stdout to
    `/dev/null`, showing only the error messages that are printed to stderr:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将做相反的操作；我们将把打印到stdout的消息发送到`/dev/null`，只显示打印到stderr的错误消息：
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, let''s send all messages, from both stdout and stderr, to `/dev/null`.
    This will display nothing:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将所有消息，包括stdout和stderr，发送到`/dev/null`。这将不显示任何内容：
- en: '[PRE55]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How it works…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The first example, where we used `printf()`, doesn't contain anything new or
    unique. All output printed with the regular `printf()` function is printed to
    stdout.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例中，我们使用`printf()`，没有包含任何新的或独特的内容。使用常规的`printf()`函数打印的所有输出都会打印到stdout。
- en: Then, we saw some new examples, including the two lines where we use `fprintf()`.
    That function, `fprintf()`, allows us to specify a `stdio.h`).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看到了一些新的示例，包括我们使用`fprintf()`的两行。`fprintf()`函数允许我们指定`stdio.h`）。
- en: Then, we looked at some examples of using `dprintf()`. This function allows
    us to specify a **file descriptor** to print to. We covered file descriptors in
    the previous recipes of this chapter, but we will discuss them in more depth later
    in this book. Three file descriptors are always open—0 (stdin), 1 (stdout), and
    2 (stderr)—in every program we write on Linux. Here, we printed the regular message
    to file descriptor (*fd* for short) 1, and the error message to file descriptor
    2.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看了一些使用`dprintf()`的例子。这个函数允许我们指定要打印到的**文件描述符**。我们在本章的先前示例中涵盖了文件描述符，但我们将在本书的后面更深入地讨论它们。三个文件描述符始终是打开的——0（stdin）、1（stdout）和2（stderr）——在我们在Linux上编写的每个程序中。在这里，我们将常规消息打印到文件描述符（*fd*简称）1，将错误消息打印到文件描述符2。
- en: To be correct in our code, we need to include the very first line (the `#define`
    line) for the sake of `dprintf()`. We can read all about it in the manual page
    (`man 3 dprintf`), under *Feature Test Macro Requirements*. The `_POSIX_C_SOURCE`,
    is for **POSIX** standards and compatibility. We will cover this in more depth
    later in this book.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的代码中正确，我们需要包括第一行（`#define`行）以支持`dprintf()`。我们可以在手册页（`man 3 dprintf`）中找到有关它的所有信息，包括*特性测试宏要求*。`_POSIX_C_SOURCE`是用于**POSIX**标准和兼容性。我们将在本书的后面更深入地讨论这个问题。
- en: When we tested the program, we verified that the regular messages got printed
    to standard output by redirecting the error messages to a file called `/dev/null`,
    showing only the messages printed to standard output. Then, we did the reverse
    to verify that the error messages got printed to standard error.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们测试程序时，我们验证了常规消息通过将错误消息重定向到名为`/dev/null`的文件来打印到标准输出，仅显示打印到标准输出的消息。然后，我们进行了相反的操作，以验证错误消息是否被打印到标准错误。
- en: The special file, `/dev/null`, acts as a black hole in Linux and other Unix
    systems. Everything we send to that file simply disappears. Try it out with `ls
    / &> /dev/null`, for example. No output will be displayed since everything is
    redirected to the black hole.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊文件`/dev/null`在Linux和其他Unix系统中充当黑洞。我们发送到该文件的所有内容都会消失。例如，尝试使用`ls / &> /dev/null`。不会显示任何输出，因为一切都被重定向到黑洞中。
- en: There's more…
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: I mentioned that three file streams are opened in a program, assuming it includes
    `stdio.h`, as well as three file descriptors. These three file descriptors are
    always opened, even if `stdio.h` is not included. If we were to include `unistd.h`,
    we could also use macro names for the three file descriptors.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到程序中打开了三个文件流，假设它包括`stdio.h`，以及三个文件描述符。这三个文件描述符始终是打开的，即使没有包括`stdio.h`。如果我们包括`unistd.h`，我们还可以使用三个文件描述符的宏名称。
- en: 'The following table shows these file descriptors, their macro names, and file
    streams, which are handy for future reference:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了这些文件描述符、它们的宏名称和文件流，这对以后的参考很有用：
- en: '![Figure 2.3 – File descriptors and file streams in Linux'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – Linux中的文件描述符和文件流'
- en: '](img/Figure_2.3_B13043.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_2.3_B13043.jpg)'
- en: Figure 2.3 – File descriptors and file streams in Linux
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – Linux中的文件描述符和文件流
- en: Reading from stdin
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从标准输入读取
- en: In this recipe, we'll learn how to write a program in C that reads from standard
    input. Doing so enables your programs to take input from other programs via a
    *pipe*, making them easier to use as a filter, thus making them more useful in
    the long run.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何用C语言编写一个从标准输入读取的程序。这样做可以使您的程序通过*管道*从其他程序接收输入，使它们更容易用作过滤器，从而使它们在长期内更有用。
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll need the GCC compiler and preferably the Bash shell for this recipe,
    although it should work with any shell.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要GCC编译器，最好是Bash shell来完成这个示例，尽管它应该适用于任何shell。
- en: 'To fully understand the program that we are about to write, you should look
    at an ASCII table, an example of which can be found at the following URL: [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/ascii-table.md](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/ascii-table.md).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解我们即将编写的程序，您应该查看ASCII表，可以在以下URL找到示例：[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/ascii-table.md](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/ascii-table.md)。
- en: How to do it…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we will write a program that takes single words as input, converts
    their cases (uppercase into lower and lowercase into upper), and prints the result
    to standard output. Let''s get started:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个程序，它接受单词作为输入，将它们的大小写转换（大写转换为小写，小写转换为大写），并将结果打印到标准输出。让我们开始吧：
- en: 'Write the following code into a file and save it as `case-changer.c`. In this
    program, we use `fgets()` to read characters from stdin. We then use a `for` loop
    to loop over the input, character by character. Before we start the next loop
    with the next line of input, we must zero out the arrays using `memset()`:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入文件并保存为`case-changer.c`。在这个程序中，我们使用`fgets()`从stdin读取字符。然后我们使用`for`循环逐个字符地循环输入。在我们开始下一个循环之前，我们必须使用`memset()`将数组清零：
- en: '[PRE56]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Compile the program:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE57]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Try it out by typing some words in it. Quit the program by pressing *Ctrl +
    D*:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在其中输入一些单词来尝试它。按*Ctrl + D*退出程序：
- en: '[PRE58]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, try to *pipe* some input to it, for example, the first five lines from
    `ls`:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，试着将一些输入*管道*到它，例如，从`ls`中的前五行：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s try to pipe some uppercase words into it from a manual page:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试从手册页中将一些大写单词*管道*到它中：
- en: '[PRE60]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: How it works…
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we created two character **arrays** of 20 bytes each and initialize them
    to 0.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了两个20字节的字符**数组**，并将它们初始化为0。
- en: Then, we used `fgets()`, wrapped in a `while` loop, to read characters from
    standard input. The `fgets()` function reads characters until it reaches a *newline*
    character or an `c` array, and also returned.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`fgets()`，包装在`while`循环中，从标准输入读取字符。`fgets()`函数读取字符，直到它达到一个*换行*字符或一个`c`数组，并且也返回。
- en: To read more input—that is, more than one word—we continue reading input with
    the help of the `while` loop. The `while` loop won't finish until we either press
    *Ctrl + D* or the input stream is empty.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取更多输入——也就是说，不止一个单词——我们继续使用`while`循环来读取输入。`while`循环直到我们按下*Ctrl + D*或输入流为空为止。
- en: 'The `fgets()` function returns the character read on success and `NULL` on
    error or when an EOF occurs while no characters have been read (that is, no more
    input). Let''s break down the `fgets()` function so that we can understand it
    better:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`fgets()`函数在成功时返回读取的字符，在错误或在没有读取任何字符的情况下发生EOF时返回`NULL`（也就是说，没有更多的输入）。让我们分解`fgets()`函数，以便更好地理解它：'
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The first argument, `c`, is where we store the data. In this case, it's our
    character array.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`c`是我们存储数据的地方。在这种情况下，它是我们的字符数组。
- en: The second argument, `sizeof(c)`, is the maximum size we want to read. The `fgets()`
    function is safe here; it reads one less than the size we specify. In our case,
    it will only read 19 characters, leaving room for the **null character**.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数`sizeof(c)`是我们想要读取的最大大小。`fgets()`函数在这里是安全的；它读取比我们指定的大小少一个。在我们的情况下，它只会读取19个字符，留出**空字符**的空间。
- en: The final and third argument, `stdin`, is the stream we want to read from—in
    our case, standard input.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的第三个参数`stdin`是我们想要从中读取的流——在我们的情况下是标准输入。
- en: Inside the `while` loop is where the case conversions are happening, character
    by character in the `for` loop. In the first `if` statement, we check if the current
    character is an uppercase one. If it is, then we add 32 to the character. For
    example, if the character is *A*, then it's represented by 65 in the **ASCII table**.
    When we add 32, we get 97, which is *a*. The same goes for the entire alphabet.
    It's always 32 characters apart between the uppercase and lowercase versions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环内是发生大小写转换的地方，逐个字符在`for`循环中进行。在第一个`if`语句中，我们检查当前字符是否是大写的。如果是，我们加上32个字符。例如，如果字符是*A*，那么在**ASCII表**中表示为65。当我们加上32时，我们得到97，即*a*。对于整个字母表都是这样的。大写和小写版本之间始终相差32个字符。
- en: The next `if` statement does the reverse. If the character is a lowercase one,
    we subtract 32 and get the uppercase version.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的`if`语句执行相反的操作。如果字符是小写的，我们减去32并得到大写版本。
- en: Since we are only checking characters between 65 and 90, and 97 and 122, all
    other characters are ignored.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只检查65到90和97到122之间的字符，所有其他字符都被忽略。
- en: Once we printed the result on the screen, we reset the character arrays to all
    zeros with `memset()`. If we don't do this, we will have leftover characters in
    the next run.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在屏幕上打印出结果，我们就用`memset()`将字符数组重置为全零。如果我们不这样做，下一次运行时会有剩余的字符。
- en: Using the program
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用该程序
- en: We tried the program by running it interactively and typing words into it. Each
    time we hit the *Enter* key, the word is transformed; the uppercase letters will
    become lowercase and vice versa.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过交互式运行程序并向其输入单词来尝试该程序。每次按下*Enter*键时，单词都会被转换；大写字母将变成小写，反之亦然。
- en: Then, we piped data to it from the `ls` command. That output got converted into
    uppercase letters.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从`ls`命令向其传递数据。该输出被转换为大写字母。
- en: Then, we tried to pipe it uppercase words from the manual page (the headings).
    All the headings in a manual page are uppercase and start at the beginning of
    the line. This is what we "grep" for with `egrep`, and then pipe to our `case-changer`
    program.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们尝试从手册页（标题）中将其管道化为大写单词。手册页中的所有标题都是大写的，并且从行的开头开始。这就是我们用`egrep`进行“grep”搜索的内容，然后将其管道化到我们的`case-changer`程序中。
- en: There's more…
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多内容...
- en: For more information about `fgets()`, see the manual page, `man 3 fgets`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`fgets()`的更多信息，请参阅手册页`man 3 fgets`。
- en: 'You can write a small program to print a minimum ASCII table for the letters
    *a-z* and *A-Z*. This small program also demonstrates that each character is represented
    by a number:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编写一个小程序来打印字母*a-z*和*A-Z*的最小ASCII表。这个小程序还演示了每个字符都是由一个数字表示的：
- en: ascii-table.c
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ascii-table.c
- en: '[PRE62]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Writing a pipe-friendly program
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个管道友好的程序
- en: In this recipe, we will learn how to write a program that is **pipe-friendly**.
    It will take input from standard input and output the result on standard output.
    Any error messages are going to be printed on standard error.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何编写一个**管道友好**的程序。它将从标准输入接收输入，并将结果输出到标准输出。任何错误消息都将被打印到标准错误。
- en: Getting ready
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need the GCC compiler, GNU Make, and preferably the **Bash** shell for
    this recipe.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要GCC编译器，GNU Make，最好是**Bash** shell。
- en: How to do it…
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we are going to write a program that converts miles per hour
    into kilometers per hour. As a test, we are going to *pipe* data to it from a
    text file that contains measurements from a car trial run with average speeds.
    The text file is in **miles per hour** (**mph**), but we want them in **kilometers
    per hour** (**kph**) instead. Let''s get started:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个程序，将每小时英里转换为每小时公里。作为测试，我们将从一个包含汽车试验平均速度测量的文本文件中向其*管道*数据。文本文件是以**每小时英里**（**mph**）为单位的，但我们希望将其转换为**每小时公里**（**kph**）。让我们开始吧：
- en: 'Start by creating the following text file or download it from GitHub from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/avg.txt](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/avg.txt).
    If you are creating it yourself, name it `avg.txt`. This text will be used as
    the input for a program we will write. The text simulates measurement values from
    a car trial run:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建以下文本文件，或者从GitHub下载它[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/avg.txt](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/avg.txt)。如果您自己创建，请命名为`avg.txt`。这个文本将被用作我们将要编写的程序的输入。这个文本模拟了汽车试验的测量数值：
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, create the actual program. Type in the following code and save it as `mph-to-kph.c`,
    or download it from GitHub from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/mph-to-kph.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/mph-to-kph.c).
    This program will convert miles per hour into kilometers per hour. This conversion
    is performed in the `printf()` statement:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建实际的程序。输入以下代码并将其保存为`mph-to-kph.c`，或者从GitHub上下载它：[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/mph-to-kph.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/mph-to-kph.c)。该程序将把每小时英里转换为每小时公里。这个转换是在`printf()`语句中执行的：
- en: '[PRE74]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Compile the program:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Test the program by running it interactively. Type in some miles per hour values
    and hit *Enter* after each value. The program will print out the corresponding
    value in kilometers per hour:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过交互式运行程序来测试程序。输入一些每小时英里的值，并在每个值后按*Enter*。程序将打印出相应的每小时公里值：
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, it''s time to use our program as a filter to transform the table containing
    miles per hour into kilometers per hour. But first, we must filter out only the
    mph values. We can do this with `awk`:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候将我们的程序作为过滤器使用，将包含每小时英里的表格转换为每小时公里。但首先，我们必须筛选出只有mph值。我们可以使用`awk`来实现这一点：
- en: '[PRE77]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now that we have a list of the numbers only, we can add our `mph-to-kph` program
    at the end to convert the values:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了一个仅包含数字的列表，我们可以在最后添加我们的`mph-to-kph`程序来转换数值：
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Since the last value is `nn`, a non-numeric value, which is an error in the
    measurement, we don''t want to show the error message in the output. Therefore,
    we redirect stderr to `/dev/null`. Note the parenthesis around the expression,
    before the redirect:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于最后一个值是`nn`，一个非数字值，这是测量中的错误，我们不想在输出中显示错误消息。因此，我们将stderr重定向到`/dev/null`。请注意，在重定向之前，表达式周围有括号：
- en: '[PRE79]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This is much prettier! However, we also want to add *km/h* at the end of every
    line to know what the value is. We can use `sed` to accomplish this:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样看起来漂亮多了！但是，我们还想在每一行的末尾添加*km/h*，以便知道数值是多少。我们可以使用`sed`来实现这一点：
- en: '[PRE80]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works…
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This program is similar to the one from the previous recipe. The features we
    added here check if the input data is numeric or not, and if it isn't, the program
    aborts with an error message that is printed to stderr. The regular output is
    still printed to stdout, as far as it goes without an error.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序与上一个配方中的程序类似。我们在这里添加的功能检查输入数据是否是数字，如果不是，程序将中止，并打印错误消息到stderr。正常输出仍然打印到stdout，只要没有错误发生。
- en: The program is only printing the numeric values, no other information. This
    makes it better as a filter, since the *km/h* text can be added by the user with
    other programs. That way, the program can be useful for many more scenarios that
    we haven't thought about.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序只打印数值，没有其他信息。这使得它更适合作为过滤器，因为*km/h*文本可以由用户使用其他程序添加。这样，该程序可以用于我们尚未考虑到的许多其他情况。
- en: 'The line where we check for numeric input might require some explanation:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 检查数字输入的行可能需要一些解释：
- en: '[PRE81]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `strspn()` function only reads the characters that we specified in the second
    argument to the function and then returns the number of read characters. We can
    then compare the number of characters read by `strspn()` with the entire length
    of the string, which we get with `strlen()`. If those match, we know that every
    character is either numeric, a dot, a minus, or a newline. If they don't match,
    this means an illegal character was found in the string.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`strspn()`函数只读取我们在函数的第二个参数中指定的字符，然后返回读取的字符数。然后我们可以将`strspn()`读取的字符数与我们使用`strlen()`获得的字符串的整个长度进行比较。如果它们匹配，我们就知道每个字符都是数字、句点、减号或换行符。如果它们不匹配，这意味着在字符串中找到了非法字符。'
- en: For `strspn()` and `strlen()` to work, we included `string.h`. For `atof()`
    to work, we included `stdlib.h`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`strspn()`和`strlen()`工作，我们包含了`string.h`。为了使`atof()`工作，我们包含了`stdlib.h`。
- en: Piping data to the program
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据传送到程序
- en: In *Step 5*, we selected only the third field—the mph value—using the `awk`
    program. The awk `$3` variable means field number 3\. Each field is a new word,
    separated by a space.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤5*中，我们使用`awk`程序仅选择了第三个字段——mph值。awk的`$3`变量表示第3个字段。每个字段都是一个新单词，由空格分隔。
- en: In *Step 6*, we redirected the output from the `awk` program—the mph values—into
    our `mph-to-kph` program. As a result, our program printed the km/h values on
    the screen.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6*中，我们将`awk`程序的输出——mph值——重定向到我们的`mph-to-kph`程序中。结果，我们的程序在屏幕上打印出了km/h值。
- en: In *Step 7*, we redirected the error messages to `/dev/null` so that the output
    from the program is clean.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*中，我们将错误消息重定向到`/dev/null`，以便程序的输出是干净的。
- en: 'Finally, in *Step 8*, we added the text *km/h* after the kph values in the
    output. We did this by using the `sed` program. The `sed` program can look a bit
    cryptic, so let''s break it down:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在*步骤8*中，我们在输出中添加了文本*km/h*在kph值之后。我们使用了`sed`程序来实现这一点。`sed`程序可能看起来有点神秘，所以让我们来分解一下：
- en: '[PRE82]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This `sed` script is similar to the previous ones we have seen. But this time,
    we substituted the end of the line with a `$` sign instead of the beginning with
    `^`. So, what we did here is substitute the end of the line with the text "km/h".
    Note, though, that we needed to *escape* the slash in "km/h" with a backslash.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`sed`脚本与我们之前看到的类似。但是这一次，我们用`$`符号替换了行尾，而不是用`^`替换行首。所以，我们在这里做的是用文本"km/h"替换行尾。不过，请注意，我们需要用反斜杠*转义*“km/h”中的斜杠。
- en: There's more…
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There's a lot of useful information about `strlen()` and `strspn()` in the respective
    manual pages. You can read them with `man 3 strlen` and `man 3 strspn`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`strlen()`和`strspn()`有很多有用的信息在各自的手册页中。您可以使用`man 3 strlen`和`man 3 strspn`来阅读它们。
- en: Redirecting the result to a file
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将结果重定向到文件
- en: In this recipe, we will learn how to redirect the output of a program to two
    different files. We are also going to learn some best practices when writing a
    **filter**, a program specifically made to be connected with other programs with
    a pipe.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何将程序的输出重定向到两个不同的文件。我们还将学习一些在编写**过滤器**时的最佳实践，过滤器是专门用于与其他程序通过管道连接的程序。
- en: 'The program we will build in this recipe is a new version of the program from
    the previous recipe. The `mph-to-kph` program in the previous recipe had one drawback:
    it always stopped when it found a non-numeric character. Often, when we run filters
    on long input data, we want the program to continue running, even if it has detected
    some erroneous data. This is what we are going to fix in this version.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将构建一个新版本的上一个食谱中的程序。在上一个食谱中的`mph-to-kph`程序有一个缺点：它总是在找到非数字字符时停止。通常，当我们在长输入数据上运行过滤器时，我们希望程序继续运行，即使它已经检测到一些错误的数据。这就是我们要在这个版本中修复的问题。
- en: We will keep the default behavior just as it was previously; that is, it will
    abort the program when it encounters a non-numeric value. However, we will add
    an option (`-c`) so that it can continue running the program even if a non-numeric
    value was detected. Then, it's up to the end user to decide how he or she wants
    to run it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持默认行为与之前一样；也就是说，当遇到非数字值时，它将中止程序。然而，我们将添加一个选项（`-c`），以便即使检测到非数字值，它也可以继续运行程序。然后，由最终用户决定如何运行它。
- en: Getting ready
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: All the requirements listed in the *Technical requirements* section of this
    chapter apply here (the GCC compiler, the Make tool, and the Bash shell).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的*技术要求*部分列出的所有要求都适用于这里（GCC编译器、Make工具和Bash shell）。
- en: How to do it…
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'This program will be a bit longer, but if you like, you can download it from
    GitHub at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/mph-to-kph_v2.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/mph-to-kph_v2.c).
    Since the code is a bit longer, I will be splitting it up into several steps.
    However, all of the code still goes into a single file called `mph-to-kph_v2.c`.
    Let''s get started:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序会有点长，但如果你愿意，你可以从GitHub上下载它[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/mph-to-kph_v2.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/mph-to-kph_v2.c)。由于代码有点长，我将把它分成几个步骤。不过，所有的代码仍然放在一个名为`mph-to-kph_v2.c`的单个文件中。让我们开始吧：
- en: 'Let''s start with the feature macro and the required header files. Since we
    are going to use `getopt()`, we need the `_XOPEN_SOURCE` macro, as well as the
    `unistd.h` header file:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从特征宏和所需的头文件开始。由于我们将使用`getopt()`，我们需要`_XOPEN_SOURCE`宏，以及`unistd.h`头文件：
- en: '[PRE83]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Next, we will add the function prototype for the help function. We will also
    start writing the `main()` function body:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为`help`函数添加函数原型。我们还将开始编写`main()`函数体：
- en: '[PRE84]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Then, we will add the `getopt()` function inside a `while` loop. This is similar
    to the *Writing a program that parses command-line options recipe* from [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*, Getting the Necessary Tools
    and Writing Our First Linux Programs*:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在`while`循环中添加`getopt()`函数。这类似于[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中的*编写解析命令行选项的程序食谱*，获取必要的工具并编写我们的第一个Linux程序：
- en: '[PRE85]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then, we must create another `while` loop, where we will fetch data from stdin
    with `fgets()`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们必须创建另一个`while`循环，在其中我们将使用`fgets()`从stdin获取数据：
- en: '[PRE86]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Finally, we must write the function body for the `help` function:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须为`help`函数编写函数体：
- en: '[PRE87]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Compile the program using Make:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Make编译程序：
- en: '[PRE88]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Let''s try it out, without any options, by giving it some numeric values and
    a non-numeric value. The result should be the same as what we received previously:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一下，不带任何选项，给它一些数字值和一个非数字值。结果应该与我们之前收到的相同：
- en: '[PRE89]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, let''s try it out using the `-c` option so that we can continue running
    the program even though a non-numeric value has been detected. Type some numeric
    and non-numeric values into the program:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用`-c`选项，以便即使检测到非数字值，我们也可以继续运行程序。在程序中输入一些数字和非数字值：
- en: '[PRE90]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'That worked just fine! Now, let''s add some more data to the `avg.txt` file
    and save it as `avg-with-garbage.txt`. This time, there will be more lines with
    non-numeric values. You can also download the file from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/avg-with-garbage.txt](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/avg-with-garbage.txt):'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这很好！现在，让我们向`avg.txt`文件添加一些数据，并将其保存为`avg-with-garbage.txt`。这一次，将会有更多行包含非数字值。您也可以从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/avg-with-garbage.txt](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/avg-with-garbage.txt)下载该文件：
- en: '[PRE91]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, let''s run `awk` on that file again to see only the values:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们再次在该文件上运行`awk`，只看到值：
- en: '[PRE92]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now comes the moment of truth. Let''s add the `mph-to-kph_v2` program at the
    end with the `-c` option. This should convert all the mph values into kph values
    and continue running, even though non-numeric values will be found:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是真相的时刻。让我们在最后添加`mph-to-kph_v2`程序，并使用`-c`选项。这应该将所有的mph值转换为kph值并继续运行，即使找到非数字值：
- en: '[PRE93]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'That worked! The program continued, even though there were non-numeric values.
    Since the error messages are printed to stderr and the values are printed to stdout,
    we can redirect the output to two different files. That leaves us with a clean
    output file and a separate error file:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功了！程序继续运行，即使有非数字值。由于错误消息被打印到stderr，值被打印到stdout，我们可以将输出重定向到两个不同的文件。这样我们就得到了一个干净的输出文件和一个单独的错误文件：
- en: '[PRE94]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Let''s take a look at the two files:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看这两个文件：
- en: '[PRE95]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: How it works…
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The code itself is similar to what we had in the previous recipe, except for
    the added `getopt()` and the help function. We covered `getopt()` in detail in
    [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the Necessary
    Tools and Writing Our First Linux Programs*, so there's no need to cover it again
    here.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 代码本身与我们在上一个配方中的内容类似，只是增加了`getopt()`和帮助函数。我们在[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中详细介绍了`getopt()`，因此这里没有必要再次介绍它。
- en: To continue reading data from stdin when a non-numeric value is found (while
    using the `-c` option), we use `continue` to skip one iteration of the loop. Instead
    of aborting the program, we print an error message to stderr and then move on
    to the next iteration, leaving the program running.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`-c`选项时，当发现非数字值时，我们使用`continue`从stdin继续读取数据，以跳过循环的一次迭代。我们不会中止程序，而是向stderr打印错误消息，然后继续进行下一次迭代，使程序继续运行。
- en: Also, note that we passed two arguments to the `printHelp()` function. The first
    argument is a `FILE` *pointer*. We use this to pass *stderr* or *stdout* to the
    function. Stdout and stderr are *streams*, which can be reached via their `FILE`
    pointer. This way, we can choose if the help message should be printed to stdout
    (in case the user asked for the help) or to stderr (in case there was an error).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们向`printHelp()`函数传递了两个参数。第一个参数是`FILE` *指针*。我们使用这个指针将*stderr*或*stdout*传递给函数。Stdout和stderr是*流*，可以通过它们的`FILE`指针访问。这样，我们可以选择帮助消息是应该打印到stdout（如果用户要求帮助）还是打印到stderr（如果出现错误）。
- en: The second argument is the name of the program, as we have seen already.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是程序的名称，我们已经见过了。
- en: We then compiled and tested the program. Without the `-c` option, it works just
    as it did previously.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们编译并测试了程序。没有`-c`选项，它的工作方式与以前一样。
- en: After that, we tried the program with data from a file that contains some garbage.
    That's usually how data looks; it's often not "perfect". That's why we added the
    option to continue, even though non-numeric values were found.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们尝试使用包含一些垃圾的文件中的数据运行程序。这通常是数据的外观；它通常不是“完美”的。这就是为什么我们即使找到非数字值，也添加了继续的选项。
- en: Just like in the previous recipe, we used `awk` to select only the third field
    (`print $3`) from the file.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在上一个配方中一样，我们使用`awk`从文件中选择第三个字段（`print $3`）。
- en: The exciting part is *Step 12*, where we redirected both *stderr* and *stdout*.
    We separated the two outputs into two different files. That way, we have a clean
    output file with only the km/h values. We can then use that file for further processing
    since it doesn't contain any error messages.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 令人兴奋的部分是*第12步*，我们重定向了*stderr*和*stdout*。我们将两个输出分开到两个不同的文件中。这样，我们就有了一个干净的输出文件，只包含km/h值。然后，我们可以使用该文件进行进一步处理，因为它不包含任何错误消息。
- en: We could have written the program to do all the steps for us, such as filter
    out the values from the text file, do the conversions, and then write the result
    to a new file. But that's an **anti-pattern** in Linux and Unix. Instead, we want
    to write small tools that do one thing only—and do it well. That way, the program
    can be used on other files with a different structure, or for a completely different
    purpose. We could even grab the data straight from a device or modem if we wanted
    to and pipe it into our program. The tools for extracting the correct fields from
    the file (or device) have already been created; there's no need to reinvent the
    wheel.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以编写程序来为我们执行所有步骤，例如从文本文件中过滤出值，进行转换，然后将结果写入新文件。但这在Linux和Unix中是一种**反模式**。相反，我们希望编写只做一件事情的小工具，并且做得很好。这样，该程序可以用于具有不同结构的其他文件，或者用于完全不同的目的。我们甚至可以直接从设备或调制解调器中获取数据并将其传输到我们的程序中。从文件（或设备）中提取正确字段的工具已经创建；没有必要重新发明轮子。
- en: Notice that we needed to enclose the entire command, with pipes and all, before
    redirecting the output and error messages.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要在重定向输出和错误消息之前将整个命令及其所有管道括起来。
- en: There's more…
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Eric S. Raymond has written some excellent rules to stick to when developing
    software for Linux and Unix. They can all be found in his book, *The Art of Unix
    Programming*. Two of the rules that apply to us in this recipe include the *Rule
    of Modularity*, which says that we should write simple parts that are connected
    with clean interfaces. The other rule that applies to us is the *Rule of Composition*,
    which says to write programs that will be connected to other programs.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Eric S. Raymond在为Linux和Unix开发软件时制定了一些出色的规则。这些规则都可以在他的书《Unix编程艺术》中找到。在本配方中适用于我们的规则包括*模块化规则*，该规则指出我们应该编写简单的部分，并使用清晰的接口连接它们。适用于我们的另一条规则是*组合规则*，该规则指出要编写将连接到其他程序的程序。
- en: His book is available for free online at [http://www.catb.org/~esr/writings/taoup/html/](http://www.catb.org/~esr/writings/taoup/html/).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 他的书可以在[http://www.catb.org/~esr/writings/taoup/html/](http://www.catb.org/~esr/writings/taoup/html/)免费在线阅读。
- en: Reading environment variables
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取环境变量
- en: Another way to communicate with the shell—and to configure a program—is via
    **environment variables**. By default, there are a lot of environment variables
    already set. These variables contain information on just about anything regarding
    your user and your settings. Some examples include the username, which type of
    terminal you are using, the path variable we discussed in previous recipes, your
    preferred editor, your preferred locale and language, and more.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 与shell和配置程序进行通信的另一种方法是通过**环境变量**。默认情况下，已经设置了许多环境变量。这些变量包含有关用户和设置的几乎所有信息。一些示例包括用户名，您正在使用的终端类型，我们在以前的配方中讨论过的路径变量，您首选的编辑器，首选的区域设置和语言，以及其他信息。
- en: Knowing how to read these variables will make it much easier for you to adapt
    your programs to the user's environment.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何读取这些变量将使您更容易地调整程序以适应用户的环境。
- en: In this recipe, we will write a program that reads environment variables, adapts
    its output, and prints some information about the user and the session.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将编写一个程序，该程序读取环境变量，调整其输出，并打印有关用户和会话的一些信息。
- en: Getting ready
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we can use just about any shell. Other than a shell, we'll
    need the GCC compiler.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们可以使用几乎任何shell。除了shell，我们还需要GCC编译器。
- en: How to do it…
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to write a program that reads environment variables:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤编写一个读取环境变量的程序：
- en: 'Save the following code into a file called `env-var.c`. You can also download
    the whole program from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/env-var.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/env-var.c).
    This program will read some common environment variables from your shell using
    the `getenv()` function. The strange-looking number sequences (`\033[0;31`) are
    used to color the output:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码保存到名为`env-var.c`的文件中。您还可以从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/env-var.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch2/env-var.c)下载整个程序。该程序将使用`getenv()`函数从您的shell中读取一些常见的环境变量。看起来奇怪的数字序列（`\033[0;31`）用于给输出着色：
- en: '[PRE96]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Compile the program using GCC:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用GCC编译程序：
- en: '[PRE97]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Run the program. The information that will be printed for you will differ from
    mine. The last line will also be in color if your terminal supports it. If it
    doesn''t, it will tell you that your terminal doesn''t support colors:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。将为您打印的信息与我的不同。如果您的终端支持，最后一行也将是彩色的。如果不支持，它会告诉您您的终端不支持颜色：
- en: '[PRE98]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Let''s investigate the environment variables we used by using `echo`. Make
    a note of the `$TERM` variable. The dollar sign (`$`) tells the shell that we
    want to print the `TERM` variable, not the word *TERM*:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`echo`来调查我们使用的环境变量。记下`$TERM`变量。美元符号（`$`）告诉shell我们要打印`TERM`变量，而不是单词*TERM*：
- en: '[PRE99]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'If we were to change the `$TERM` variable to a regular `xterm`, without color
    support, we would get a different output from the program:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将`$TERM`变量更改为普通的`xterm`，不支持颜色，我们将从程序中获得不同的输出：
- en: '[PRE100]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Before moving on, we should reset our terminal to the value it was before we
    changed it. This will probably be something else on your computer:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，我们应该将我们的终端重置为更改之前的值。这在您的计算机上可能是其他内容：
- en: '[PRE101]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'It''s also possible to set an environment variable temporarily for the duration
    of the program. We can do this by setting the variable and executing the program
    on the same line. Notice that when the program ends, the variable is still the
    same as it was previously. We just override the variable when the program executes:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以在程序运行期间临时设置环境变量。我们可以通过设置变量并在同一行上执行程序来实现这一点。请注意，当程序结束时，变量仍然与以前相同。当程序执行时，我们只是覆盖变量：
- en: '[PRE102]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We can also print a complete list of all the environment variables using the
    `env` command. The list will probably be several pages long. All of these variables
    can be accessed using the `getenv()` C function:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用`env`命令打印所有环境变量的完整列表。列表可能会有几页长。可以使用`getenv()` C函数访问所有这些变量：
- en: '[PRE103]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: How it works…
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We use the `getenv()` function to get the values from the shell's environment
    variables. We print these variables to the screen.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`getenv()`函数从shell的环境变量中获取值。我们将这些变量打印到屏幕上。
- en: Then, at the end of the program, we check if the current terminal has color
    support. This is usually denoted by something such as `xterm-256color`, `screen-256color`,
    and so on. We then use the `strstr()` function (from `string.h`) to check if the
    `$TERM` variable contains the `256color` substring. If it does, the terminal has
    color support, and we print a colorized message on the screen. If it doesn't,
    however, we print that the terminal doesn't have color support, without using
    any colors.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在程序结束时，我们检查当前终端是否支持颜色。这通常由诸如`xterm-256color`、`screen-256color`等表示。然后，我们使用`strstr()`函数（来自`string.h`）来检查`$TERM`变量是否包含`256color`子字符串。如果是，终端支持颜色，我们在屏幕上打印一个带颜色的消息。但是，如果不支持，我们会打印终端不支持颜色，而不使用任何颜色。
- en: All of these variables are the shell's *environment variables* and can be printed
    with the `echo` command; for example, `echo $TERM`. We can also set our own environment
    variables in the shell; for instance, `export FULLNAME=Jack-Benny`. Likewise,
    we can change existing ones by overwriting them, just as we did with the `$TERM`
    variable. We can also override them by setting them at runtime, like we did with
    `TERM=xterm ./env-var`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些变量都是shell的*环境变量*，可以使用`echo`命令打印；例如，`echo $TERM`。我们还可以在shell中设置自己的环境变量；例如，`export
    FULLNAME=Jack-Benny`。同样，我们可以通过覆盖它们来更改现有的变量，就像我们用`$TERM`变量一样。我们还可以通过在运行时设置它们来覆盖它们，就像我们用`TERM=xterm
    ./env-var`一样。
- en: Regular variables set with the `FULLNAME=Jack-Benny` syntax are only available
    to the current shell and are hence called `export` command, they become **global
    variables** or *environment variables*, a more common name, available to both
    **subshells** and child processes.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FULLNAME=Jack-Benny`语法设置的常规变量仅对当前shell可用，因此称为`export`命令，它们成为**全局变量**或*环境变量*，这是一个更常见的名称，可供**子shell**和子进程使用。
- en: There's more…
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We can also change environment variables and create new ones in a C program
    by using the `setenv()` function. However, when we do so, those variables won't
    be available in the shell that started the program. The program we run is a **child
    process** of the shell, and hence it can't change the shell's variable; that is,
    its **parent process**. But any other programs started from inside our own program
    will be able to see those variables. We will discuss parent and child processes
    in more depth later in this book.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`setenv()`函数在C程序中更改环境变量并创建新变量。但是，当我们这样做时，这些变量将不会在启动程序的shell中可用。我们运行的程序是shell的**子进程**，因此它无法更改shell的变量；也就是说，它的**父进程**。但是从我们自己的程序内部启动的任何其他程序都将能够看到这些变量。我们将在本书的后面更深入地讨论父进程和子进程。
- en: 'Here is a short example of how to use `setenv()`. The `1` in the third argument
    to `setenv()` means that we want to overwrite the variable if it already exists.
    If we change it to a `0`, it prevents overwriting:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用`setenv()`的简短示例。`setenv()`的第三个参数中的`1`表示如果变量已经存在，我们想要覆盖它。如果我们将其改为`0`，则可以防止覆盖：
- en: env-var-set.c
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: env-var-set.c
- en: '[PRE104]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'If we compile and run the program and then try to read `$FULLNAME` from the
    shell, we''ll notice that it doesn''t exist:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译并运行程序，然后尝试从shell中读取`$FULLNAME`，我们会注意到它不存在：
- en: '[PRE113]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
