- en: '*Chapter 6*: Spawning Processes and Using Job Control'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*：生成进程和使用作业控制'
- en: In this chapter, we'll learn about how processes are created on the system,
    which process is the very first one, and how all processes are related to each
    other. We'll then learn the many terms involved in processes and process management
    in Linux. After that, we'll learn how to fork new processes and what **zombies**
    and **orphans** are. At the end of this chapter, we'll learn what a **daemon**
    is and how to create one, before learning about what signals are and how to implement
    them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解系统上如何创建进程，哪个进程是第一个进程，以及所有进程如何相互关联。然后，我们将学习Linux中涉及进程和进程管理的许多术语。之后，我们将学习如何分叉新进程以及**僵尸**和**孤儿**是什么。在本章结束时，我们将学习**守护进程**是什么以及如何创建它，然后学习信号是什么以及如何实现它们。
- en: 'Knowing how processes are created on the system is key to implementing good
    daemons, dealing with security, and creating efficient programs. It will also
    give you a better understanding of the overall system. In this chapter, we will
    cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 了解系统上如何创建进程对于实现良好的守护进程、处理安全性和创建高效的程序至关重要。它还将让您更好地了解整个系统。在本章中，我们将涵盖以下示例：
- en: Exploring how processes are created
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索进程是如何创建的
- en: Using job control in Bash
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Bash中使用作业控制
- en: Controlling and terminating processes using signals
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号控制和终止进程
- en: Replacing the program in a process with `execl()`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用`execl()`替换进程中的程序
- en: Forking a process
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分叉进程
- en: Executing a new program in a forked process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分叉进程中执行新程序
- en: Starting a new process with `system()`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`system()`启动新进程
- en: Creating a zombie process
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建僵尸进程
- en: Learning about what orphans are
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解孤儿进程是什么
- en: Creating a daemon
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建守护进程
- en: Implementing a signal handler
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现信号处理程序
- en: Let's get started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you'll need the GCC compiler and Make tool. We installed these
    tools in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*, Getting
    the Necessary Tools and Writing Our First Linux Programs*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将需要GCC编译器和Make工具。我们在[*第1章*]（B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020）中安装了这些工具，获取必要的工具并编写我们的第一个Linux程序。
- en: You will also need a new program called `pstree` for this chapter. You can install
    it with your package manager. If you are using Debian or Ubuntu, you can install
    it with `sudo apt install psmisc`. If, on the other hand, you are using Fedora
    or CentOS, you can install it with `sudo dnf install psmisc`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要一个名为`pstree`的新程序来完成本章。您可以使用软件包管理器安装它。如果您使用的是Debian或Ubuntu，可以使用`sudo apt
    install psmisc`进行安装。另一方面，如果您使用的是Fedora或CentOS，可以使用`sudo dnf install psmisc`进行安装。
- en: You will also need the generic `Makefile` we wrote in [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*,
    Diving Deep into C in Linux*. The Makefile is also available on GitHub, together
    with all the code samples for this chapter, at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch6](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch6).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要我们在[*第3章*]（B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097）中编写的通用`Makefile`。Makefile也可以在GitHub上找到，本章的所有代码示例也可以在[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch6](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch6)找到。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3cxY0eQ](https://bit.ly/3cxY0eQ)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以查看代码演示视频：[https://bit.ly/3cxY0eQ](https://bit.ly/3cxY0eQ)
- en: Exploring how processes are created
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索进程是如何创建的
- en: Before we go into the details of creating processes and daemons, we need a general
    understanding of processes. The best way to get this understanding is by looking
    at the processes already running on your system, which is what we are going to
    do in this recipe.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解如何创建进程和守护进程之前，我们需要对进程有一个基本的理解。获得这种理解的最佳方法是查看系统上已经运行的进程，这就是我们将在本示例中要做的事情。
- en: Every process on the system has started its life by being *spawned*—forked—from
    another process. The very first process to be used on Unix and Linux systems has
    historically been `init` process has been replaced in modern Linux distributions
    with **systemd**. They both serve the same purpose; to start the rest of the system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 系统上的每个进程都是通过从另一个进程*生成*（forked）而开始其生命周期的。在Unix和Linux系统上使用的第一个进程历史上一直是`init`进程，现代Linux发行版已将其替换为**systemd**。它们都具有相同的目的；启动系统的其余部分。
- en: 'A typical **process tree** may look like this, where a user has logged on via
    a terminal (that is, if we skip the complexity of X Window logons):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的**进程树**可能如下所示，其中用户通过终端登录（即，如果我们跳过X Window登录的复杂性）：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The process IDs are the numbers in parenthesis. `systemd` (or `init` on some
    older systems) have a `init`, even though `systemd` is used. In this case, `init`
    is just a link to `systemd`. There are still Linux systems that use `init`, though.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 进程ID是括号中的数字。`systemd`（或一些旧系统上的`init`）有一个`init`，即使使用的是`systemd`。在这种情况下，`init`只是指向`systemd`的链接。仍然有一些使用`init`的Linux系统。
- en: Having a deep understanding of how processes **spawn** is essential when it
    comes to writing system programs. For example, when we want to create a daemon,
    we often spawn a new process. There are many other use cases where we must spawn
    processes or execute a new program from an existing process.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及编写系统程序时，深入了解进程**生成**是至关重要的。例如，当我们想要创建一个守护进程时，我们经常会生成一个新进程。还有许多其他用例，我们必须生成进程或从现有进程执行新程序。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: For this recipe, you'll need `pstree`. Installation instructions for `pstree`
    are listed in the *Technical requirements* section of this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您将需要`pstree`。`pstree`的安装说明列在本章的*技术要求*部分中。
- en: How to do it…
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will look at our system and the processes it runs. We will
    use `pstree` to get a visual representation of these processes. Let''s get started:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将查看我们的系统和它运行的进程。我们将使用`pstree`来获得这些进程的可视化表示。让我们开始吧：
- en: 'First, we need a way to get our current process ID. The `$$` environment variable
    contains the current shell''s **PID**. Please note that the PID will differ on
    every system and also from one time to another:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一种方法来获取我们当前的进程ID。`$$`环境变量包含当前shell的**PID**。请注意，PID在每个系统上以及从一次到另一次都会有所不同：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let''s look at our current process, as well as its parent processes and
    child processes, with `pstree`. The parent process is what has started the process,
    while a child process is any process under it:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用`pstree`来查看我们当前的进程，以及它的父进程和子进程。父进程是启动该进程的进程，而子进程是其下的任何进程：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The output from the `pstree` command will most likely be different on your computer.
    Instead of `tmux`, you might have `xterm`, `konsole`, `mate-terminal`, or something
    similar. The `-A` option means to print the lines using ASCII characters, the
    `-p` option means to print the PID numbers, and the `-s` option means that we
    want to show the parent processes of the selected process (which is `$$` in our
    case). In my example, `tmux` is a child process of `systemd`, `bash` is a child
    process of `tmux`, and `pstree` is a child process of `bash`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pstree`命令的输出在您的计算机上很可能会有所不同。您可能有`xterm`、`konsole`、`mate-terminal`或类似的东西，而不是`tmux`。`-A`选项表示使用ASCII字符打印行，`-p`选项表示打印PID号，`-s`选项表示我们要显示所选进程的父进程（在我们的情况下是`$$`）。在我的例子中，`tmux`是`systemd`的子进程，`bash`是`tmux`的子进程，`pstree`是`bash`的子进程。'
- en: 'A process can also have several children. For example, we can start several
    processes in Bash. Here, we will start three sleep processes. Each sleep process
    will sleep for 120 seconds. We will then print another `pstree`. In this example,
    `pstree` and the three `sleep` processes are all children of `bash`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个进程也可以有多个子进程。例如，我们可以在Bash中启动多个进程。在这里，我们将启动三个`sleep`进程。每个`sleep`进程将休眠120秒。然后我们将打印另一个`pstree`。在这个例子中，`pstree`和三个`sleep`进程都是`bash`的子进程：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At the beginning of this chapter, we provided a sample process tree that showed
    a process called `login`. That process originally started out as `getty`, a process
    that manages TTYs on the system. `getty`/`login` concept, switch over to TTY3
    with *Ctrl*+*Alt*+*F3* to activate it. Then, go back to X (often on *Ctrl*+*Alt*+*F7*
    or *Ctrl*+*Alt*+*F1*). Here, we will use `grep` with `ps` to find TTY3 and make
    a note of its PID. The `ps` program is used to find and list processes on the
    system. Then, we will log in with a user on TTY3 (*Ctrl*+*Alt*+*F3*). After that,
    we will need to go back to our X Window session (and our terminal) again and use
    `grep` to find the PID we noted from TTY3\. The program in that process has now
    been replaced with `login`. In other words, a process can swap out its program:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章的开头，我们提供了一个显示名为`login`的进程的示例进程树。该进程最初是作为管理系统TTY的进程`getty`启动的。`getty`/`login`的概念，切换到TTY3，使用*Ctrl*+*Alt*+*F3*进行激活。然后，返回到X（通常在*Ctrl*+*Alt*+*F7*或*Ctrl*+*Alt*+*F1*）。在这里，我们将使用`grep`和`ps`来查找TTY3并记录其PID。`ps`程序用于查找和列出系统上的进程。然后，我们将使用用户在TTY3上登录（*Ctrl*+*Alt*+*F3*）。之后，我们需要再次返回到我们的X
    Window会话（和我们的终端），并使用`grep`来找到我们从TTY3中记录的PID。该进程中的程序现在已被替换为`login`。换句话说，一个进程可以替换其程序：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this recipe, we learned about several important concepts regarding processes
    on Linux systems. We will need this knowledge moving forward. First off, we learned
    that all processes get spawned from an existing process. The very first process
    is `init`. On newer Linux distributions, this is a symbolic link to `systemd`.
    `systemd` then spawns several processes on the system, such as `getty`, to handle
    the terminals. When a user starts to log in on a TTY, `getty` is replaced with
    `login`, the program that handles logins. When the user finally logs in, the `login`
    process spawns a shell for the user, such as Bash. Every time the user then executes
    a program, Bash spawns a copy of itself and replaces it with the program the user
    executed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们学习了关于Linux系统上进程的几个重要概念。我们将需要这些知识继续前进。首先，我们了解到所有进程都是从现有进程中生成的。第一个进程是`init`。在较新的Linux发行版中，这是指向`systemd`的符号链接。然后，`systemd`在系统上生成几个进程，比如`getty`，来处理终端。当用户开始在TTY上登录时，`getty`会被`login`替换，这个程序处理登录。当用户最终登录时，`login`进程为用户生成一个shell，比如Bash。然后，每当用户执行一个程序时，Bash会生成一个自身的副本，并用用户执行的程序替换它。
- en: 'To clarify the process/program terminology a bit: a `getty`/`login` example.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清一下进程/程序术语：`getty`/`login`示例。
- en: The reason for using TTY3 in this recipe is that we get a *real* login process
    with `getty`/`login`, something we don't get when logging in via a X Window session
    or over SSH.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中使用TTY3的原因是，我们可以通过`getty`/`login`获得一个*真正的*登录过程，而在通过X Window会话或SSH登录时我们无法获得。
- en: A process ID is denoted as PID. A parent process ID is denoted as `1`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 进程ID表示为PID。父进程ID表示为`1`）。
- en: We also learned that a process can have several children, as with the example
    provided of the `sleep` processes. We started the `sleep` processes with an `&`
    symbol at the end. This ampersand tells the shell that we want to start the process
    in the background.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到一个进程可以有多个子进程，就像`sleep`进程的示例一样。我们在`sleep`进程的末尾使用`&`符号启动了`sleep`进程。这个&符号告诉shell我们要在后台启动该进程。
- en: There's more…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The acronym TTY comes from the fact that, back in the old days, it was an actual
    *teletype* connected to the machine. A teletype is a typewriter-looking terminal.
    You type your commands on the typewriter and read the response on the paper. For
    anyone interested in teletypes, Columbia University has some exciting pictures
    and information at [http://www.columbia.edu/cu/computinghistory/teletype.html](http://www.columbia.edu/cu/computinghistory/teletype.html).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: TTY的首字母缩写来自于过去的实际*电传打字机*连接到机器上。电传打字机是一种看起来像打字机的终端。您在打字机上输入命令，然后在纸上读取响应。对于任何对电传打字机感兴趣的人，哥伦比亚大学在[http://www.columbia.edu/cu/computinghistory/teletype.html](http://www.columbia.edu/cu/computinghistory/teletype.html)上有一些令人兴奋的图片和信息。
- en: Using job control in Bash
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Bash中使用作业控制
- en: Not only will job control give you a better understanding of foreground and
    background processes, but it will also make you more efficient when working on
    a terminal. Being able to put a process in the background frees up your terminal
    to do other tasks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 作业控制不仅能让你更好地理解前台和后台进程，还能让你在终端上工作时更加高效。能够将一个进程放到后台可以让你的终端做其他任务。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Nothing particular is required for this recipe, except for the Bash shell. Bash
    is most often the default shell, so it's likely that you already have it installed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程不需要特别的要求，除了Bash shell。Bash通常是默认的shell，所以你很可能已经安装了它。
- en: How to do it…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: 'In this recipe, we will start and stop several processes, send them to the
    background, and bring them back to the foreground. This will give us an understanding
    of background and foreground processes. Let''s get started:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将启动和停止几个进程，将它们发送到后台，并将它们带回前台。这将让我们了解后台和前台进程。让我们开始吧：
- en: 'Previously, we have seen how to start a process in the background with an ampersand
    (`&`). We will repeat that here, but we will also list the current jobs running
    and bring one of them to the foreground. The first background process we''ll start
    here is `sleep`, while the other will be a manual page:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前，我们已经看到如何使用&在后台启动一个进程。我们将在这里重复这个步骤，但我们还将列出当前正在运行的作业，并将其中一个带到前台。我们将在这里启动的第一个后台进程是`sleep`，而另一个是手册页面：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have two processes in the `jobs`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在`jobs`中有两个进程：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `sleep` process is in a running state, meaning that the seconds are ticking
    away in the program. The `man ls` command has been stopped, though. The `man`
    command is waiting for you to do something with it since it requires a terminal.
    So, right now, it doesn''t do anything. We can bring it to the foreground by using
    the `fg` command (`fg` command is the job ID from the `jobs` list:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sleep`进程处于运行状态，这意味着程序中的秒数正在减少。`man ls`命令已经停止了。`man`命令正在等待你对它做一些事情，因为它需要一个终端。所以，现在它什么也不做。我们可以使用`fg`命令（`fg`命令是`jobs`列表中的作业ID）将它带到前台：'
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Quit the manual page by hitting *Q*. `man ls` will appear on the screen.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Q*退出手册页面。`man ls`将出现在屏幕上。
- en: 'Now, bring the sleep process to the foreground with `fg 1`. It only says `sleep
    300`, nothing more. But now, the program is in the foreground. This means we can
    now stop the program by hitting *Ctrl*+*Z*:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`fg 1`将`sleep`进程带到前台。它只显示`sleep 300`，没有更多的信息。但现在，程序在前台运行。这意味着我们现在可以按下*Ctrl*+*Z*来停止程序：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With that, the program has been stopped, meaning it doesn't count down anymore.
    We can now once again bring it back to the foreground with `fg 1` and let it finish.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序已经停止，这意味着它不再倒计时。我们现在可以再次用`fg 1`将其带回前台并让它完成。
- en: 'Now that the previous process has finished, let''s start a new `sleep` process.
    This time, we can start it in the foreground (by omitting the ampersand). Then,
    we can stop the program by hitting *Ctrl*+*Z*. List the jobs and notice that the
    program is in a stopped state:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在上一个进程已经完成，让我们开始一个新的`sleep`进程。这次，我们可以在前台启动它（省略了&）。然后，我们可以按下*Ctrl*+*Z*来停止程序。列出作业并注意程序处于停止状态：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can continue running the program in the background using the `bg` command
    (`bg` stands for *background*):'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`bg`命令在后台继续运行程序（`bg`代表*background*）：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also find the PID of the program by using a command called `pgrep`.
    The name `pgrep` stands for *Process Grep*. The `-f` option lets us specify the
    complete command, including its options, so that we get the correct PID:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用一个叫做`pgrep`的命令来找到程序的PID。`pgrep`的名称代表*Process Grep*。`-f`选项允许我们指定完整的命令，包括它的选项，以便我们得到正确的PID：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we know the PID, we can kill the program using `kill`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道了PID，我们可以使用`kill`来终止程序：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also kill a program using `pkill`. Here, we will start another process
    and kill it with `pkill` instead. This command is used with the same options as
    `pgrep`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以使用`pkill`来终止一个程序。在这里，我们将启动另一个进程，并使用`pkill`来终止它。这个命令和`pgrep`使用相同的选项：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this recipe, we learned about background processes, foreground process, stopped
    and running jobs, killing processes, and much more. These are some basics concepts
    that are used in job control in Linux.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们学习了后台进程、前台进程、停止和运行的作业、终止进程等基本概念。这些是Linux作业控制中使用的一些基本概念。
- en: When we killed the process with `kill`, `kill` sent a signal to the process
    in the background. The default signal for `kill` is the `TERM` signal. `TERM`
    signal, though. The `TERM` signal is number 15\. A signal that can't be handled—that
    always kills a program—is signal 9, or the `KILL` signal. We will cover signal
    handling in more depth in the next recipe.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用`kill`杀死进程时，`kill`向后台进程发送了一个信号。`kill`的默认信号是`TERM`信号。`TERM`信号是15号信号。一个无法处理的信号——总是终止程序的信号是9号信号，或者`KILL`信号。我们将在下一个教程中更深入地介绍信号处理。
- en: Controlling and terminating processes using signals
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号来控制和终止进程
- en: Now that we know a bit more about processes, it's time to move on to signals
    and learn how we can kill and control a process using signals. In this recipe,
    we will also write our first C program, which will have a signal handler.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对进程有了一些了解，是时候转向信号并学习如何使用信号来终止和控制进程了。在这个教程中，我们还将编写我们的第一个C程序，其中将包含一个信号处理程序。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll only need what's listed in the *Technical requirements*
    section of this chapter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，你只需要本章节*技术要求*部分列出的内容。
- en: How to do it…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: 'In this recipe, we''ll explore how to control and terminate processes with
    signals. Let''s get started:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将探讨如何使用信号来控制和终止进程。让我们开始吧：
- en: 'Let''s start by listing the signals we can send to a process using the `kill`
    command. The list you get from this command is rather long, so it''s not been
    included here. The most interesting—and used—signals are the first 31:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先列出我们可以使用`kill`命令发送给进程的信号。从这个命令得到的列表相当长，所以这里没有包含。最有趣和使用的信号是前31个：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s see how some of these signals work. We can send the `STOP` signal (number
    19) to a process, which has the same effect as we saw when hitting *Ctrl*+*Z*
    in `sleep`. But here, we are sending the `STOP` signal to a background process
    directly:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看这些信号是如何工作的。我们可以向一个进程发送`STOP`信号（编号19），这与我们在`sleep`中按下*Ctrl*+*Z*看到的效果相同。但是这里，我们直接向一个后台进程发送`STOP`信号：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can continue the process again by sending it the `CONT` signal (short
    for **continue**). We can type the name of the signal instead, if we wish, instead
    of its number:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过发送`CONT`信号（**continue**的缩写）来继续进程。如果愿意，我们也可以输入信号的名称，而不是它的编号：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can kill the process by sending it the `KILL` signal (number 9):'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过发送`KILL`信号（编号9）来终止进程：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s create a small program that acts upon different signals and ignores
    (or blocks) *Ctrl*+*C*, the interrupt signal. The `USR1` and `USR2` signals are
    perfect for this. Write the following code in a file and save it as `signals.c`.
    This code has been split up into multiple steps here, but all the code goes into
    this file. To register a signal handler in a program, we can use the `sigaction()`
    system call. We need to define `_POSIX_C_SOURCE` since `sigaction()` and its friends
    aren''t included in strict C99\. We also need to include the necessary headers
    files, write the handler function prototype, and begin the `main()` function:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个根据不同信号执行操作并忽略（或阻塞）*Ctrl*+*C*（中断信号）的小程序。`USR1`和`USR2`信号非常适合这个目的。将以下代码写入一个文件并保存为`signals.c`。这里将这段代码分成了多个步骤，但所有代码都放在这个文件中。要在程序中注册信号处理程序，我们可以使用`sigaction()`系统调用。由于`sigaction()`及其相关函数不包含在严格的C99中，我们需要定义`_POSIX_C_SOURCE`。我们还需要包含必要的头文件，编写处理程序函数原型，并开始`main()`函数：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s create some variables and structures that we need. The `sigaction`
    struct that we will create, `action`, is for the `sigaction()` system call. A
    bit further down in the code, we set its member. First, we must set `sa_handler`
    to our function, which will execute when the signal is received. Second, we set
    `sa_mask` to all signals using `sigfillset()`. This will ignore all the signals
    while our signal handler is being executed, preventing it from being interrupted.
    Third, we set `sa_flags` to `SA_RESTART`, meaning any interrupted systems calls
    will be restarted:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一些我们需要的变量和结构。我们将创建的`sigaction`结构`action`是为了`sigaction()`系统调用。在代码中稍后一点，我们设置它的成员。首先，我们必须将`sa_handler`设置为我们的函数，当接收到信号时将执行该函数。其次，我们使用`sigfillset()`将`sa_mask`设置为所有信号。这将在执行我们的信号处理程序时忽略所有信号，防止它被中断。第三，我们将`sa_flags`设置为`SA_RESTART`，这意味着任何中断的系统调用将被重新启动：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, it''s time to register the signal handlers using `sigaction()`. The first
    argument to `sigaction()` is the signal we want to catch, the second argument
    is a struct for the new action that should be taken, and the third argument gives
    us the old action. If we are not interested in the old action, we set this to
    `NULL`. The actions must be a `sigaction` structs:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候使用`sigaction()`注册信号处理程序了。`sigaction()`的第一个参数是我们想要捕获的信号，第二个参数是新操作的结构，第三个参数给出了旧操作。如果我们对旧操作不感兴趣，我们将其设置为`NULL`。操作必须是`sigaction`结构：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Remember that we wanted the program to ignore *Ctrl*+*C* (the interrupt signal)?
    This can be achieved by calling `sigprocmask()` before the code that should ignore
    the signal. But first, we must create a *signal set* with all the signals it should
    ignore/block. First, we will empty the set with `sigemptyset()`, and then add
    the required signals with `sigaddset()`. The `sigaddset()` function can be called
    multiple times to add more signals. The first argument to `sigprocmask()` is the
    behavior, which is `SIG_BLOCK` here. The second argument is the signal set, while
    the third argument can be used to retrieve the old set. However, here, we will
    set it to `NULL`. After that, we start the infinite `for` loop. And after the
    loop, we unblock the signal set again. In this case, it''s not necessary since
    we will just quit the program, but in other cases, it''s advised to unblock the
    signals once we have moved past the section of code that should ignore them:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记住我们希望程序忽略*Ctrl*+*C*（中断信号）吗？这可以通过在应该忽略信号的代码之前调用`sigprocmask()`来实现。但首先，我们必须创建一个包含所有应该忽略/阻塞的信号的*信号集*。首先，我们将使用`sigemptyset()`清空集合，然后使用`sigaddset()`添加所需的信号。`sigaddset()`函数可以多次调用以添加更多的信号。`sigprocmask()`的第一个参数是行为，这里是`SIG_BLOCK`。第二个参数是信号集，而第三个参数可以用于检索旧集。但是，在这里，我们将其设置为`NULL`。之后，我们开始无限的`for`循环。循环结束后，我们再次解除信号集的阻塞。在这种情况下，这是不必要的，因为我们将退出程序，但在其他情况下，建议在我们已经过了应该忽略它们的代码部分后解除信号的阻塞：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, let''s write the function that will be executed on `SIGUSR1` and `SIGUSR2`.
    The function will print the received signal:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们编写将在`SIGUSR1`和`SIGUSR2`上执行的函数。该函数将打印接收到的信号：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s compile the program:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译程序：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the program, either in a separate terminal or in the same terminal in the
    background. Notice that we are using the signal names here with `kill`; it''s
    a bit easier than keeping track of the numbers:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序，可以在单独的终端或者在同一个终端的后台运行。请注意，我们在这里使用`kill`命令的信号名称；这比跟踪数字要容易一些：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: First, we explored the many `TERM`, `KILL`, `QUIT`, `STOP`, `HUP`, `INT`, `STOP`,
    and `CONT`, as we saw here.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们探索了许多`TERM`、`KILL`、`QUIT`、`STOP`、`HUP`、`INT`、`STOP`和`CONT`，就像我们在这里看到的那样。
- en: Then, we used the `STOP` and `CONT` signals to achieve the same effect that
    we achieved in the previous recipe; that is, to stop and continue running a background
    process. In the previous recipe, we used `bg` to continue running a process in
    the background, while to stop a process, we hit *Ctrl*+*Z*. This time, we didn't
    need to have the program open in the foreground to stop it; we just sent it the
    `STOP` signal with `kill`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`STOP`和`CONT`信号来实现与上一个示例相同的效果；也就是说，停止和继续运行后台进程。在上一个示例中，我们使用`bg`来继续在后台运行进程，而要停止进程，我们按下*Ctrl*+*Z*。这一次，我们不需要将程序打开在前台来停止它；我们只需用`kill`发送`STOP`信号。
- en: After that, we moved on and wrote a C program that catches two signals, `USR1`
    and `USR2`, and blocks the `SIGINT` signal (*Ctrl*+*C*). Depending on the signal
    we send to the program, different texts are printed. We did this by implementing
    a signal handler. A `sigaction()` function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们继续编写了一个C程序，捕获了两个信号`USR1`和`USR2`，并阻止了`SIGINT`信号（*Ctrl*+*C*）。根据我们发送给程序的信号，将打印不同的文本。我们通过实现信号处理程序来实现这一点。一个`sigaction()`函数。
- en: Before calling the `sigaction()` system call, we had to populate the `sigaction`
    structure with information about the handler function, which signals to ignore
    during the handler's execution, and which behavior it should have.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`sigaction()`系统调用之前，我们必须使用有关处理程序函数的信息填充`sigaction`结构，该结构在处理程序执行期间忽略的信号，以及它应该具有的行为。
- en: 'The signal sets, both for sigaction''s `sa_mask` and `sigprocmask()`, are created
    using the `sigset_t` type and manipulated with the following function calls (here,
    we''re assuming a `sigset_t` variable with the name `s` is being used:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 信号集，无论是sigaction的`sa_mask`还是`sigprocmask()`，都是使用`sigset_t`类型创建的，并通过以下函数调用进行操作（在这里，我们假设使用了名为`s`的`sigset_t`变量：
- en: '`sigemptyset(&s);` clears all signals from `s`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigemptyset(&s);`清除`s`中的所有信号'
- en: '`sigaddset(&s, SIGUSR1);` adds the `SIGUSR1` signal to `s`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigaddset(&s, SIGUSR1);`将`SIGUSR1`信号添加到`s`'
- en: '`sigdelset(&s, SIGUSR1);` removes the `SIGUSR` signal from `s`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigdelset(&s, SIGUSR1);`从`s`中删除`SIGUSR`信号'
- en: '`sigfillset(&s);` sets all signals in `s`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigfillset(&s);`设置`s`中的所有信号'
- en: '`sigismember(&s, SIGUSR1);` finds out if `SIGUSR1` is a member of `s` (not
    used in our example code)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sigismember(&s, SIGUSR1);`找出`SIGUSR1`是否是`s`的成员（在我们的示例代码中未使用）'
- en: To print the PID of the process when it starts, we must fetch the PID with the
    `getpid()` system call. We store the PID in a variable of the `pid_t` type, as
    we have seen previously.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要在进程启动时打印进程的PID，我们必须使用`getpid()`系统调用来获取PID。我们将PID存储在`pid_t`类型的变量中，就像我们之前看到的那样。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'There''s a lot of useful information in the manual pages for `kill`, `pkill`,
    `sigprocmask()`, and the `sigaction()` system call. I suggest you read them by
    using the following commands:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`kill`、`pkill`、`sigprocmask()`和`sigaction()`系统调用的手册页中有很多有用的信息。我建议您使用以下命令阅读它们：
- en: '`man 1 kill`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 1 kill`'
- en: '`man 1 pkill`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 1 pkill`'
- en: '`man 2 sigprocmask`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 2 sigprocmask`'
- en: '`man 2 sigaction`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 2 sigaction`'
- en: There is a much simpler system call, called `signal()`, that is also used for
    signal handling. Nowadays, that system call is more or less considered deprecated.
    But if you're interested, you can read about it in `man 2 signal`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个更简单的系统调用，称为`signal()`，也用于信号处理。如今，这个系统调用基本上被认为是不推荐使用的。但如果您感兴趣，可以在`man 2 signal`中阅读相关信息。
- en: Replacing the program in a process with execl()
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用execl()在进程中替换程序
- en: At the beginning of this chapter, we saw how `getty` gets replaced by `login`
    when a user logs in. In this recipe, we will write a small program that does exactly
    that—replaces its program with a new one. The system call for this is called `execl()`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们看到当用户登录时，`getty`被`login`替换。在这个示例中，我们将编写一个小程序，正好可以做到这一点——用新程序替换其程序。这个系统调用被称为`execl()`。
- en: Knowing how to use `execl()` enables you to write programs that execute new
    programs inside the existing process. It also enables you to start a new program
    in a spawned process. When we start a new process, we probably want to replace
    that copy with a new program. So, understanding `execl()` is paramount.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用`execl()`使您能够编写在现有进程内执行新程序的程序。它还使您能够在生成的进程中启动新程序。当我们启动一个新进程时，我们可能希望用新程序替换该副本。因此，理解`execl()`是至关重要的。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You will need to have read the first three recipes in this chapter to understand
    this one fully. The other requirements for this recipe are mentioned in the *Technical
    requirements* section of this chapter; for example, you'll need the `pstree` tool.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要阅读本章的前三个示例，才能充分理解这个示例。本示例的其他要求在本章的*技术要求*部分中提到；例如，您将需要`pstree`工具。
- en: You will also need two terminals or two terminal windows for this recipe. In
    one of these terminals, we will be running the program, while in the other terminal,
    we'll be looking at `pstree` for the process.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要两个终端或两个终端窗口。在其中一个终端中，我们将运行程序，而在另一个终端中，我们将查看`pstree`以查看进程。
- en: How to do it…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will write a small program that replaces the program running
    inside the process. Let''s get started:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个小程序，用它替换进程中正在运行的程序。让我们开始吧：
- en: 'Write the following code in a file and save it as `execdemo.c`:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中编写以下代码并将其保存为`execdemo.c`：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Compile the program using Make:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Make编译程序：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, run the program in your *current* terminal:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在*当前*终端中运行程序：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, start a *new* terminal and execute `pstree` with the PID from `execdemo`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，启动一个*新*终端，并使用`execdemo`的PID执行`pstree`：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, go back to the first terminal, where `execdemo` is running, and hit *Enter*.
    This will print the password file with `less`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到运行`execdemo`的第一个终端，并按*Enter*。这将使用`less`打印密码文件。
- en: 'Finally, go back to the second terminal—the one where you ran `pstree`. Rerun
    the same `pstree` command. Note that `execdemo` has been replaced with `less`,
    even though the PID is still the same:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，回到第二个终端——您运行`pstree`的终端。重新运行相同的`pstree`命令。请注意，即使PID仍然相同，`execdemo`已被替换为`less`：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `execl()` function executes a new program and replaces the old one in the
    same process. To make the program pause its execution so that we had time to view
    it in `pstree`, we used `getchar()`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`execl()`函数执行一个新程序，并在同一个进程中替换旧程序。为了让程序暂停执行，以便我们有时间在`pstree`中查看它，我们使用了`getchar()`。'
- en: The `execl()` function takes four mandatory arguments. The first one is the
    path to the program we want to execute. The second argument is the program's name,
    as it would be printed from `argv[0]`. Finally, the third and any following argument
    is the argument we want to pass to the program we are about to execute. To *terminate*
    this list of arguments that we want to pass to the program, we must end it with
    a pointer to `NULL`, cast as a `char`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`execl()`函数有四个必需的参数。第一个是我们想要执行的程序的路径。第二个参数是程序的名称，就像从`argv[0]`中打印出来的那样。最后，第三个和之后的参数是我们想要传递给即将执行的程序的参数。为了*终止*我们想要传递给程序的参数列表，我们必须以`NULL`的指针结束，并将其转换为`char`类型。'
- en: Another way to look at a process is to think of it as an execution environment.
    The program running inside that environment can be replaced. That's why we talk
    about processes and why we call them *Process IDs*, not Program IDs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种看待一个进程的方式是把它看作一个执行环境。在这个环境中运行的程序可以被替换。这就是为什么我们谈论进程，为什么我们称它们为*Process IDs*，而不是Program
    IDs。
- en: See also
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There are several other `exec()` functions we can use, each with their own unique
    features and characteristics. These are often referred to as the "`exec()` family."
    You can read all about them by using the `man 3 execl` command.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几个`exec()`函数可以使用，每个函数都有自己独特的特性和特点。这些通常被称为"`exec()` family"。你可以使用`man 3 execl`命令来了解它们的所有信息。
- en: Forking a process
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fork一个进程
- en: Previously, we have been saying *spawned* when a program creates a new process.
    The correct terminology is to **fork** a process. What's happening is that a process
    creates a copy of itself—it *forks*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们一直在说当一个程序创建一个新的进程时使用*spawned*。正确的术语是**fork**一个进程。发生的情况是一个进程创建了自己的一个副本——它*forks*。
- en: In the previous recipe, we learned how to execute a new program inside a process
    using `execl()`. In this recipe, we'll learn how to fork a process using `fork()`.
    The forked process—the child—is a duplicate of the calling process—the parent.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的教程中，我们学习了如何使用`execl()`在一个进程中执行一个新程序。在这个教程中，我们将学习如何使用`fork()`来fork一个进程。被fork的进程——子进程——是调用进程——父进程——的一个副本。
- en: Knowing how to fork a process enables us to create new processes on the system
    programmatically. Without being able to fork, we are limited to only a single
    process. For example, if we want to launch a new program from an existing one
    and still keep the original, we must fork.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何fork一个进程使我们能够在系统中以编程方式创建新的进程。如果不能fork，我们只能限制在一个进程中。例如，如果我们想要从一个现有的程序中启动一个新程序并保留原始程序，我们必须fork。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Just as in the previous recipes, you'll need the `pstree` tool. The *Technical
    requirements* section covers how to install it. You'll also need the GCC compiler
    and the Make tool. You'll also need two terminals; one terminal to execute the
    program and another to view a process tree with `pstree`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前的教程中一样，你需要`pstree`工具。*技术要求*部分介绍了如何安装它。你还需要GCC编译器和Make工具。你还需要两个终端；一个终端用来执行程序，另一个用来用`pstree`查看进程树。
- en: How to do it…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll use `fork()` to fork a process. We''ll also view a process
    tree so that we can see what''s going on. Let''s get started:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用`fork()`来fork一个进程。我们还将查看一个进程树，以便我们可以看到发生了什么。让我们开始吧：
- en: 'Write the following code in a program and save it as `forkdemo.c`. The `fork()`
    system call is highlighted in this code. Before we `fork()`, we print the PID
    of the process:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个程序中写下以下代码并保存为`forkdemo.c`。这段代码中突出显示了`fork()`系统调用。在我们`fork()`之前，我们打印出进程的PID：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, compile the program:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译程序：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Run the program in your *current* terminal and take note of the PID:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你*当前*的终端中运行程序并注意PID：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, in a new terminal, run `pstree` with the PID of `forkdemo`. Here, we can
    see that `forkdemo` has forked and that the PID that we got from the program before
    the fork is the parent process. The forked process is the `forkdemo` running:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在一个新的终端中，用`forkdemo`的PID运行`pstree`。在这里，我们可以看到`forkdemo`已经fork了，而我们在fork之前从程序中得到的PID是父进程。fork的进程是正在运行的`forkdemo`：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a process forks, it creates a duplicate of itself. This duplicate becomes
    a child process of the process that called `fork()`—the `fork()` returns the PID
    of the child process. Inside the child process, `0` is returned. This is why the
    parent could print the PID of the child process.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程fork时，它创建了自己的一个副本。这个副本成为调用`fork()`的进程的子进程——`fork()`返回子进程的PID。在子进程中，返回`0`。这就是为什么父进程可以打印出子进程的PID。
- en: Both processes contain the same program code, and both processes are running,
    but only the specific parts in the `if` statements get executed, depending on
    whether the process is the parent or the child.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 两个进程包含相同的程序代码，两个进程都在运行，但只有`if`语句中的特定部分会被执行，这取决于进程是父进程还是子进程。
- en: There's more…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Generally speaking, both the parent and the child are identical except for the
    PID. There are, however, some other differences; for example, CPU counters are
    reset in the child. There are other such minor differences that you can read about
    in `man 2 fork`. However, the overall program code is the same.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，父进程和子进程是相同的，除了PID。然而，还有一些其他的差异；例如，子进程中的CPU计数器会被重置。还有其他一些微小的差异，你可以在`man
    2 fork`中了解到。然而，整个程序代码是相同的。
- en: Executing a new program in a forked process
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一个forked进程中执行一个新程序
- en: In the previous recipe, we learned how to fork a process using the `fork()`
    system call. In the recipe before that, we learned how to replace the program
    in a process with `execl()`. In this recipe, we'll combine the two, `fork()` and
    `execl()`, to execute a new program in a forked process. This is what happens
    every time we run a program in Bash. Bash forks itself and executes the program
    we typed in.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学习了如何使用`fork()`系统调用分叉进程。在之前的示例中，我们学习了如何用`execl()`替换进程中的程序。在这个示例中，我们将结合这两个，`fork()`和`execl()`，在一个分叉的进程中执行一个新程序。这就是每次在Bash中运行程序时发生的事情。Bash分叉自身并执行我们输入的程序。
- en: Knowing how to use `fork()` and `execl()` enables you to write programs that
    start new programs. For example, you could write your own shell with this knowledge.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用`fork()`和`execl()`使您能够编写启动新程序的程序。例如，您可以使用这些知识编写自己的shell。
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need the `pstree` tool, the GCC compiler, and the Make
    tool. You can find installation instructions for these programs in the *Technical
    requirements* section of this chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您需要`pstree`工具、GCC编译器和Make工具。您可以在本章的*技术要求*部分找到这些程序的安装说明。
- en: How to do it…
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'In this recipe, we''ll write a program that `forks()` and executes a new program
    in the child process. Let''s get started:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个程序，`fork()`并在子进程中执行一个新程序。让我们开始吧：
- en: 'Write the following program code in a file and save it as `my-fork.c`. When
    we execute a new program inside a child process, we shall wait for the child process
    to finish. This is what we do with `waitpid()`. The `waitpid()` call also has
    another important function; to get the return status from the child process:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下程序代码，并将其保存为`my-fork.c`。当我们在子进程中执行一个新程序时，我们应该等待子进程完成。这就是我们使用`waitpid()`的方式。`waitpid()`调用还有另一个重要的功能，即从子进程获取返回状态：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Compile the program using Make:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Make编译程序：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In your current terminal, find the PID of the current shell and make a note
    of it:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前的终端中，找到当前shell的PID并做个记录：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, execute the program we compiled with `./my-fork`. This will display the
    manual page for `ls`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`./my-fork`执行我们编译的程序。这将显示`ls`的手册页。
- en: 'Start a new terminal and look at the process tree for the shell in the other
    terminal. Note that `my-fork` has forked and replaced its content with `man`,
    which has forked and replaced its content with `pager` (to display the content):'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端，查看另一个终端中shell的进程树。注意，`my-fork`已经分叉并用`man`替换了其内容，`man`又分叉并用`pager`替换了其内容（以显示内容）：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Quit the manual page in the first terminal by hitting *Q*. This will yield
    the following text. Compare the PID of the parent process and the child process
    from `pstree`. Notice that the child process is `5850`, which was the `man` command.
    It started out as a copy of `my-fork`, but then replaced its program with `man`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下*Q*退出第一个终端中的手册页。这将产生以下文本。比较`pstree`中父进程和子进程的PID。注意子进程是`5850`，这是`man`命令。它最初是`my-fork`的副本，但后来用`man`替换了其程序：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `fork()` system call is responsible for forking processes on Linux and Unix
    systems. `execl()` (or one of the other `exec()` functions) is then responsible
    for executing—and replacing its own—program with a new one. This is essentially
    how any program gets started on the system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork()`系统调用负责在Linux和Unix系统上分叉进程。然后，`execl()`（或其他`exec()`函数之一）负责执行并用新程序替换自己的程序。这基本上是系统上任何程序启动的方式。'
- en: Note that we needed to tell the parent process to wait for the child process
    with `waitpid()`. If we needed to run a program that didn't require a terminal,
    we could have done without `waitpid()`. However, we should always wait for the
    child process. If we don't, the child will end up as an **orphan**. This is something
    we will discuss in great detail later on in this chapter, in the *Learning what
    orphans are* recipe.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们需要告诉父进程使用`waitpid()`等待子进程。如果我们需要运行一个不需要终端的程序，我们可以不使用`waitpid()`。但是，我们应该始终等待子进程。如果不等待，子进程将最终成为**孤儿**。这是我们将在本章后面详细讨论的内容，在*学习孤儿是什么*这个示例中。
- en: But in this particular case, where we execute the `man` command, which requires
    a terminal, we need to wait for the child for everything to work. The `waitpid()`
    call also enables us to grab the *return status* of the child. We also prevent
    the child from becoming an orphan.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这种特殊情况下，我们执行需要终端的`man`命令，我们需要等待子进程才能让一切正常工作。`waitpid()`调用还使我们能够获取子进程的*返回状态*。我们还防止子进程变成孤儿。
- en: When we ran the program and looked at the process tree with `pstree`, we saw
    that the `my-fork` process had forked itself and replaced its program with `man`.
    We could see this because the PID of the `man` command was the same as the PID
    of the child process of `my-fork`. We also noticed that the `man` command, in
    turn, had forked itself and replaced its child with `pager`. The `pager` command
    is responsible for displaying the actual text on the screen, which is usually
    `less`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序并用`pstree`查看进程树时，我们发现`my-fork`进程已经分叉并用`man`替换了其程序。我们可以看到这一点，因为`man`命令的PID与`my-fork`的子进程的PID相同。我们还注意到`man`命令反过来又分叉并用`pager`替换了其子进程。`pager`命令负责在屏幕上显示实际文本，通常是`less`。
- en: Starting a new process with system()
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用system()启动一个新进程
- en: What we just covered regarding using `fork()`, `waitpid()`, and `execl()` to
    start a new program in a forked process is the key to understanding Linux and
    processes at a deeper level. This understanding is key to becoming an excellent
    system developer. However, there is a shortcut. Instead of manually dealing with
    forking, waiting, and executing, we can use `system()`. The `system()` function
    does all these steps for us.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论的使用`fork()`、`waitpid()`和`execl()`在分叉的进程中启动新程序的内容是理解Linux和进程更深层次的关键。这种理解是成为优秀系统开发人员的关键。但是，有一个捷径。我们可以使用`system()`来代替手动处理分叉、等待和执行。`system()`函数为我们完成所有这些步骤。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you only need what's listed in the *Technical requirements*
    section of this chapter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你只需要本章节*技术要求*部分中列出的内容。
- en: How to do it…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll rewrite the previous program—`my-fork`—using the `system()`
    function instead. You''ll notice how much shorter this program is compared to
    the previous one. Let''s get started:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`system()`函数重写前一个程序`my-fork`。你会注意到这个程序与前一个程序相比要短得多。让我们开始吧：
- en: 'Write the following code in a file and save it as `sysdemo.c`. Notice how much
    smaller (and easier) this program is. The `system()` function does all the complex
    stuff for us:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入文件并保存为`sysdemo.c`。注意这个程序有多小（和简单）。`system()`函数为我们完成了所有复杂的工作：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Compile the program:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Make a note of the shell''s PID using the `$$` variable:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`$$`变量记录shell的PID：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, run the program in the current terminal. This will display the manual
    page for the `ls` command. Leave it running:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在当前终端中运行程序。这将显示`ls`命令的手册页。让它继续运行：
- en: '[PRE45]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Start a new terminal and execute `pstree` on the PID from *step 3*. Notice
    that we have an additional process here called `sh`. This is because the `system()`
    function executes the `man` command from `sh` (the basic Bourne Shell):'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新终端中启动并对*步骤3*中的PID执行`pstree`。请注意，这里有一个额外的名为`sh`的进程。这是因为`system()`函数从`sh`（基本的Bourne
    Shell）执行`man`命令：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: How it works…
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'This program was much smaller and easier to write. However, as we saw with
    `pstree`, there is an extra process compared to the previous recipe: `sh` (shell).
    The `system()` function works by executing the `man` command from `sh`. The manual
    page (`man 3 system`) clearly states this. It executes the command we specify
    by using the following `execl()` call:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序要小得多，编写起来也更容易。然而，正如我们在`pstree`中看到的那样，与上一个示例相比，有一个额外的进程：`sh`（shell）。`system()`函数通过从`sh`执行`man`命令来工作。手册页（`man
    3 system`）清楚地说明了这一点。它通过以下`execl()`调用执行我们指定的命令：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The result is the same, though. It performs a `fork()` and then an `execl()`
    call, and it waits for the child with `waitpid()`. This is also a great example
    of a higher-level function that uses lower-level system calls.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一样的。它执行`fork()`，然后是`execl()`调用，并且使用`waitpid()`等待子进程。这也是一个使用低级系统调用的高级函数的很好的例子。
- en: Creating a zombie process
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个僵尸进程
- en: To fully understand processes in Linux, we also need to look at what a zombie
    process is. And to fully understand what this is, we need to create one ourselves.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解Linux中的进程，我们还需要看看什么是僵尸进程。为了完全理解这一点，我们需要自己创建一个。
- en: A **zombie** process is a child that has exited before the parent, and the parent
    process hasn't waited for the child's status. The name "zombie process" comes
    from the fact that the process is *undead*. The process has exited, but there
    is still an entry for it in the system process table.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸**进程是指子进程在父进程之前退出，而父进程没有等待子进程的状态。"僵尸进程"这个名字来源于这个事实，即进程是*不死的*。进程已经退出，但在系统进程表中仍然有一个条目。'
- en: Knowing what a zombie process is and how it's created will help you avoid writing
    bad programs that create zombie processes on the system.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 了解什么是僵尸进程以及它是如何创建的将有助于你避免编写在系统上创建僵尸进程的糟糕程序。
- en: Getting ready
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll only need what's listed in the *Technical requirements*
    section of this chapter.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你只需要本章节*技术要求*部分中列出的内容。
- en: How to do it…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will write a small program that creates a zombie process
    on the system. We will also view the zombie process using the `ps` command. To
    prove that we can avoid zombies by waiting for the child, we will also write a
    second version with `waitpid()`. Let''s get started:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个小程序，在系统上创建一个僵尸进程。我们还将使用`ps`命令查看僵尸进程。为了证明我们可以通过等待子进程来避免僵尸进程，我们还将使用`waitpid()`编写第二个版本。让我们开始吧：
- en: 'Write the following code in a file and name it `create-zombie.c`. This program
    is the same as the one we saw in the `forkdemo.c` file, except that the child
    exits using `exit(0)` before the parent exits. The parent sleeps for 2 minutes
    after the child has exited, without waiting for the child with `waitpid()`, thus
    creating a zombie process. The call to `exit()` is highlighted here:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入文件并命名为`create-zombie.c`。这个程序与我们在`forkdemo.c`文件中看到的程序相同，只是子进程在父进程退出之前使用`exit(0)`退出。父进程在子进程退出后睡眠2分钟，而不等待子进程使用`waitpid()`，从而创建一个僵尸进程。这里突出显示了`exit()`的调用：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Compile the program:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Run the program in the current terminal. The program (the parent process) will
    stay alive for 2 minutes. In the meantime, the child is a zombie since the parent
    didn''t wait for it or its status:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前终端中运行程序。程序（父进程）将保持活动状态2分钟。与此同时，子进程是僵尸的，因为父进程没有等待它或它的状态：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'While the program is running, open up another terminal and check out the child''s
    PID with `ps`. You get the child''s PID from the preceding output from `create-zombie`.
    Here, we can see that the process is a zombie because of its status, `Z+`, and
    the word `<defunct>` after the process name:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当程序正在运行时，打开另一个终端并使用`ps`检查子进程的PID。你可以从`create-zombie`之前的输出中得到子进程的PID。在这里，我们可以看到进程是僵尸的，因为它的状态是`Z+`，并且在进程名后面有`<defunct>`这个词：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After 2 minutes—when the parent process has finished executing—rerun the `ps`
    command with the same PID. The zombie process will now be gone:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2分钟后——当父进程执行完毕时——使用相同的PID重新运行`ps`命令。僵尸进程现在将不复存在：
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, rewrite the program so that it looks as follows. Name the new version
    `no-zombie.c`. The code that''s been added is highlighted here:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重写程序，使其如下所示。将新版本命名为`no-zombie.c`。这里突出显示了添加的代码：
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Compile this new version:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译这个新版本：
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Run the program in the current terminal. Just as before, it will create a child
    process that will exit immediately. The parent process will continue running for
    2 minutes, giving us enough time to search for the child''s PID:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前终端中运行程序。就像以前一样，它将创建一个子进程，该子进程将立即退出。父进程将继续运行2分钟，给我们足够的时间来搜索子进程的PID：
- en: '[PRE55]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'While the `no-zombie` program is running, open a new terminal and search for
    the child''s PID with `ps` and `grep`. As you will see, there is no process that
    matches the PID of the child. Hence, the child has exited correctly since the
    parent waited for its status:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当“no-zombie”程序正在运行时，在新的终端中使用“ps”和“grep”搜索子进程的PID。正如你所看到的，没有与子进程的PID匹配的进程。因此，由于父进程等待其状态，子进程已正确退出：
- en: '[PRE56]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works…
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: We always want to avoid creating zombie processes on the system, and the best
    way to do that is to wait for the child processes to finish.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们始终希望避免在系统上创建僵尸进程，而最好的方法是等待子进程完成。
- en: In *steps 1 to 5*, we wrote a program that creates a zombie process. The zombie
    process gets created by the fact that the parent didn't wait for the child with
    the `waitpid()` system call. The child does exit, but it remains in the system
    process table. When we searched for the process with `ps` and `grep`, we saw the
    child process's status as `Z+`, meaning zombie. The process doesn't exist since
    it has exited using the `exit()` system call. However, it's still in there according
    to the system process table; hence, it's undead—a zombie.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1到5*中，我们编写了一个创建僵尸进程的程序。由于父进程没有使用`waitpid()`系统调用等待子进程，因此创建了僵尸进程。子进程确实退出了，但它仍然留在系统进程表中。当我们使用“ps”和“grep”搜索进程时，我们看到子进程的状态为“Z+”，表示僵尸。该进程不存在，因为它已经使用`exit()`系统调用退出。但是，根据系统进程表，它仍然存在；因此，它是不死不活的—一个僵尸。
- en: In *steps 6 to 9*, we rewrote the program using the `waitpid()` system call
    to wait for the child. The child still exists before the parent, but this time,
    the parent gets the child's status.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤6到9*中，我们使用`waitpid()`系统调用重写了程序以等待子进程。子进程仍然在父进程之前存在，但这次父进程获得了子进程的状态。
- en: A zombie process doesn't use up any system resources since the process has terminated.
    It only resides in the system process table. However, every process on the system—including
    zombies—takes up a PID number. Since there are a finite number of PIDs available
    to the system, there's a risk of running out of PIDs if dead processes are taking
    up PID numbers.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 僵尸进程不会占用任何系统资源，因为进程已经终止。它只驻留在系统进程表中。但是，系统上的每个进程—包括僵尸进程—都占用一个PID号。由于系统可用的PID号是有限的，如果死进程占用PID号，就有耗尽PID号的风险。
- en: There's more…
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There are many details about child process and their state changes in the manual
    page for `waitpid()`. There's actually three `wait()` functions available in Linux.
    You can read about them all by using the `man 2 wait` command.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux的`waitpid()`手册页中有关于子进程及其状态变化的许多细节。实际上，在Linux中有三个可用的`wait()`函数。你可以使用`man
    2 wait`命令阅读有关它们的所有内容。
- en: Learning about what orphans are
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解孤儿的含义
- en: Understanding what orphans are in a Linux system is just as crucial as understanding
    zombies. This will give you a deeper understanding of the entire system and how
    processes get inherited by `systemd`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Linux系统中孤儿的含义就像了解僵尸一样重要。这将使你更深入地了解整个系统以及进程如何被“systemd”继承。
- en: An `systemd`, which is the first process on the system—PID `1`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一个“systemd”，它是系统上的第一个进程—PID为`1`。
- en: In this recipe, we'll write a small program that forks, thus creating a child
    process. The parent process will then exit, leaving the child as an orphan.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将编写一个小程序，该程序分叉，从而创建一个子进程。然后父进程将退出，将子进程留下来作为孤儿。
- en: Getting ready
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Everything you need for this recipe is listed in the *Technical requirements*
    section of this chapter.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的*技术要求*部分列出了本食谱所需的一切。
- en: How to do it…
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will write a short program that creates an orphan process
    that will be inherited by `systemd`. Let''s get started:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将编写一个创建孤儿进程的简短程序，该进程将由“systemd”继承。让我们开始吧：
- en: 'Write the following code in a file and save it as `orphan.c`. The program will
    create a child process that will run for 5 minutes in the background. When we
    press *Enter*, the parent process will exit. This gives us time to investigate
    the child process with `pstree` both before and after the parent has exited:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中编写以下代码并将其保存为`orphan.c`。该程序将创建一个在后台运行5分钟的子进程。当我们按下*Enter*时，父进程将退出。这给了我们时间在父进程退出之前和之后使用“pstree”调查子进程：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Compile this program:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译此程序：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run the program in the current terminal and leave the program running. Don''t
    press *Enter* just yet:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前终端中运行程序并让程序继续运行。暂时不要按*Enter*：
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, in a new terminal, run `pstree` with the PID of the child. Here, we will
    see that it looks just like it did in the previous recipes. The process has been
    forked, which has created a child process with the same content:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在一个新的终端中，使用子进程的PID运行“pstree”。在这里，我们将看到它看起来就像在之前的食谱中一样。进程已经被分叉，从而创建了一个具有相同内容的子进程：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now, it's time to end the parent process. Go back and hit *Enter* in the terminal
    where `orphan` is still running. This will end the parent process.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候结束父进程了。回到“orphan”仍在运行的终端并按下*Enter*。这将结束父进程。
- en: 'Now, run `pstree` again in the second terminal. This is the same command that
    you just ran. As you can see, the child process has now been inherited by `systemd`
    since its parent has died. After 5 minutes, the child process will exit:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在第二个终端中再次运行“pstree”。这与刚刚运行的命令相同。正如你所看到的，子进程现在已被“systemd”继承，因为其父进程已经死亡。5分钟后，子进程将退出：
- en: '[PRE61]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'There are other, more standardized tools we can use to view the `ps`. Run the
    following `ps` command to view more detailed information about the child process.
    Here, we will see a lot more information. The most important to us is the PPID,
    PID, and the **Session ID** (**SID**). We will also see the **User ID** (**UID**)
    here, which specifies who owns the process:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用其他更标准化的工具来查看“ps”。运行以下“ps”命令以查看有关子进程的更详细信息。在这里，我们将看到更多信息。对我们来说最重要的是PPID、PID和**会话ID**（**SID**）。我们还将在这里看到**用户ID**（**UID**），它指定了谁拥有该进程：
- en: '[PRE62]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works…
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Every process needs a parent process. That's the reason why `systemd` inherits
    any processes on the system that end up as orphans.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都需要一个父进程。这就是为什么`systemd`会继承系统上任何成为孤儿的进程的原因。
- en: The code inside `if (pid == 0)` continued to run for 5 minutes. That gave us
    enough time to check that the child process had been inherited by `systemd`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`if (pid == 0)`中的代码继续运行了5分钟。这给了我们足够的时间来检查子进程是否已被`systemd`继承。'
- en: In the last step, we used `ps` to view more details about the child process.
    Here, we saw the PPID, PID, PGID, and SID. Some new names have been mentioned
    here that are important to know. We already know about PPID and PID, but PGID
    and SID haven't been covered yet.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步，我们使用`ps`查看了有关子进程的更多详细信息。在这里，我们看到了PPID、PID、PGID和SID。这里提到了一些重要的新名称。我们已经知道PPID和PID，但PGID和SID还没有被介绍过。
- en: '**PGID** stands for **Process Group ID** and is a way for the system to group
    processes. The PGID for the child process is the PID of the parent process. In
    other words, this PGID was created to group the parent and child process since
    they belong together. The system sets the PGID to the PID of the parent who created
    the group. We don''t need to create these groups ourselves; that is something
    the system does for us.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**PGID**代表**进程组ID**，是系统对进程进行分组的一种方式。子进程的PGID是父进程的PID。换句话说，这个PGID是为了将父进程和子进程分组在一起而创建的。系统将PGID设置为创建该组的父进程的PID。我们不需要自己创建这些组；这是系统为我们做的事情。'
- en: '`18817`, which is the PID of the Bash shell. The same rules apply here; the
    SID number will be the same as the PID of the process that started the session.
    This session consists of my user''s shell and all the programs that I start from
    it. That way, the system can kill all the processes that belong to that session
    if I log off the system.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`18817`，这是Bash shell的PID。这里也适用相同的规则；SID号将与启动会话的进程的PID相同。这个会话包括我的用户shell和我从中启动的所有程序。这样，系统就可以在我注销系统时终止属于该会话的所有进程。'
- en: See also
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There's a lot of information you can get with `ps`. I recommend that you at
    least skim through the manual with `man 1 ps`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ps`可以获得很多信息。我建议你至少浏览一下`man 1 ps`的手册。
- en: Creating a daemon
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建守护进程
- en: A common assignment when working with system programming is to create various
    daemons. A **daemon** is a background process that runs on the system and performs
    some tasks. The SSH daemon is a great example of this. Another great example is
    the NTP daemon, which takes care of synchronizing the computer clock and sometimes
    even distributing the time to other computers.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统编程中常见的任务是创建各种守护进程。**守护进程**是在系统上运行并执行一些任务的后台进程。SSH守护进程就是一个很好的例子。另一个很好的例子是NTP守护进程，它负责同步计算机时钟，有时甚至分发时间给其他计算机。
- en: Knowing how to create a daemon will enable you to create server software; for
    example, web servers, chat servers, and more.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何创建守护进程将使您能够创建服务器软件；例如，Web服务器、聊天服务器等。
- en: In this recipe, we will create a simple daemon to demonstrate some important
    concepts.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建一个简单的守护进程来演示一些重要的概念。
- en: Getting ready
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll only need the components listed in the *Technical requirements* section
    of this chapter.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要本章节*技术要求*部分列出的组件。
- en: How to do it…
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法
- en: 'In this recipe, we''ll write a small daemon that will run in the background
    in our system. The only "work" the daemon will do is write the current date and
    time to a file. This proves that the daemon is alive and well. Let''s get started:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将编写一个在我们的系统中后台运行的小型守护进程。守护进程唯一的“工作”是将当前日期和时间写入文件。这证明了守护进程是活着的。让我们开始吧：
- en: 'The code for the daemon is rather long compared to our previous examples. Therefore,
    the code has been split into several steps. There are some new things here as
    well that we haven''t covered yet. Write the code in a file and save it as `my-daemon.c`.
    Remember that all the code in all the steps goes into this file. We''ll start
    with all the `include` files, the variables we''ll need, and our `fork()`, as
    we have seen previously. This `fork()` will be the first of two:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与我们以前的示例相比，守护进程的代码相当长。因此，代码已分成几个步骤。这里还有一些我们还没有涉及的新东西。将代码写入一个文件并将其保存为`my-daemon.c`。请记住，所有步骤中的所有代码都放入这个文件中。我们将从我们需要的所有`include`文件、我们需要的变量和我们的`fork()`开始，就像我们以前看到的那样。这个`fork()`将是两个中的第一个：
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now that we''ve forked, we want the parent to exit. Once the parent has exited,
    we will be in the child process. In the child process, we will create a new session
    with `setsid()`. Creating a new session will free the process from the controlling
    terminal:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经forked，我们希望父进程退出。一旦父进程退出，我们将处于子进程中。在子进程中，我们将使用`setsid()`创建一个新的会话。创建一个新的会话将释放进程的控制终端：
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we want to `fork()` again. This second fork will create a new process
    just as before, but since it''s a new process in an already existing session,
    it will not be a session leader, preventing it from obtaining a new controlling
    terminal. The new child process is referred to as a grandchild. Once again, we
    exit the parent process (the child process). However, before we exit the child,
    we write the PID of the grandchild to a **PID file**. This PID file is used to
    keep track of the daemon:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想再次`fork()`。这第二次fork将创建一个新的进程，就像以前一样，但由于它是一个已经存在的会话中的新进程，它不会成为会话领导者，从而阻止它获取一个新的控制终端。新的子进程被称为孙子。再一次，我们退出父进程（子进程）。然而，在退出子进程之前，我们将孙子的PID写入**PID文件**。这个PID文件用于跟踪守护进程：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, set the default mode (*umask*) to something sensible for the daemon. We
    must also change the current working directory to `/` so that the daemon won''t
    prevent a filesystem from unmounting or a directory from being deleted. Then,
    we must open the daemon file, which is what we will write our messages to. The
    messages will contain the current date and time and will let us know if everything
    is working. Normally, this would be a log file instead:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将默认模式（*umask*）设置为守护进程的合理值。我们还必须将当前工作目录更改为`/`，以便守护进程不会阻止文件系统卸载或目录被删除。然后，我们必须打开守护进程文件，这是我们将写入消息的地方。消息将包含当前日期和时间，并告诉我们一切是否正常。通常，这将是一个日志文件：
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Since the daemon will only run detached in the background, we have no use for
    stdin, stdout, and stderr, so let''s close them all. However, it''s not safe to
    leave them closed. If something in the code would open a file descriptor at a
    later time, it will get file descriptor 0, which is usually stdin. File descriptors
    are assigned in sequence. If there are no open file descriptors, the first call
    to `open()` will get descriptor `0`; the second call will get descriptor `1`.
    Another problem might be that some parts might try to write to stdout, which no
    longer exists, making the program crash. Therefore, we must reopen them all, but
    to `/dev/null` (the black hole) instead:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于守护进程只会在后台运行，我们不需要stdin、stdout和stderr，所以让我们将它们全部关闭。但是，将它们关闭是不安全的。如果代码中的某些部分稍后打开文件描述符，它将获得文件描述符0，通常是stdin。文件描述符是按顺序分配的。如果没有打开的文件描述符，第一次调用`open()`将获得描述符`0`；第二次调用将获得描述符`1`。另一个问题可能是，某些部分可能尝试写入stdout，但stdout已经不存在，这会导致程序崩溃。因此，我们必须重新打开它们全部，但是重新打开到`/dev/null`（黑洞）：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Finally, we can start the daemon''s work. This is just a `for` loop that writes
    a message to the daemon file saying the daemon is still alive. Notice that we
    must flush the file pointer after each `fprintf()` with `fflush()`. Usually, in
    Linux, things are *line buffered*, meaning only a single line is buffered before
    writing. However, since this is a file and not stdout, it''s fully buffered instead,
    meaning it buffers all data until either the buffer is full or the file stream
    is closed. Without `fflush()`, we wouldn''t see any text in the file until we
    have filled the buffer. By using `fflush()` after each `fprintf()`, we can see
    the text live in the file:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以开始守护进程的工作。这只是一个`for`循环，向守护进程文件写入一条消息，说明守护进程仍然存活。请注意，我们必须在每次`fprintf()`后使用`fflush()`刷新文件指针。通常，在Linux中，事情是*行缓冲*的，这意味着在写入之前只缓冲一行。但由于这是一个文件而不是stdout，它实际上是完全缓冲的，这意味着它会缓冲所有数据，直到缓冲区满或文件流关闭。如果没有`fflush()`，我们在填满缓冲区之前将看不到文件中的任何文本。通过在每次`fprintf()`后使用`fflush()`，我们可以在文件中实时看到文本：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, it''s time to compile the entire daemon:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候编译整个守护进程了：
- en: '[PRE69]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we can start the daemon. Since we are writing the PID file to `/var/run`,
    we need to execute the daemon as root. We won''t get any output from the daemon;
    it will silently detach from the terminal:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以启动守护进程。由于我们将PID文件写入`/var/run`，我们需要以root身份执行守护进程。我们不会从守护进程中得到任何输出；它将悄悄地与终端分离：
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now that the daemon is running, let''s check out the PID number that''s been
    written to `/var/run/my-daemon.pid`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在守护进程正在运行，让我们检查已写入`/var/run/my-daemon.pid`的PID号码：
- en: '[PRE71]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let''s investigate the daemon process using both `ps` and `pstree`. If everything
    has worked out the way it should have, it should have `systemd` as its parent,
    and it should be in its own session (SID should be the same as the process ID):'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`ps`和`pstree`来调查守护进程。如果一切都按照预期进行，它的父进程应该是`systemd`，并且它应该在自己的会话中（SID应该与进程ID相同）：
- en: '[PRE72]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let''s also take a look at the `/tmp/my-daemon-is-alive.txt` file. This file
    should contain some rows specifying the date and time, 30 seconds apart:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们还看看`/tmp/my-daemon-is-alive.txt`文件。这个文件应该包含一些指定日期和时间的行，相隔30秒：
- en: '[PRE73]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Finally, let''s kill the daemon so that it doesn''t continue to write to the
    file:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们杀死守护进程，以防止它继续写入文件：
- en: '[PRE74]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works…
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The daemon we have just written is a basic traditional daemon, but it demonstrates
    all the concepts we need to understand well. One of these new and important concepts
    is how to start a new session with `setsid()`. If we don't create a new session,
    the daemon will still be a part of the user's login session and die when the user
    logs off. But since we've created a new session for the daemon and it is inherited
    by `systemd`, it now lives on its own, unaffected by the user and process that
    started it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚编写的守护进程是一个基本的传统守护进程，但它演示了我们需要充分理解的所有概念。其中一个新的重要概念是如何使用`setsid()`启动一个新会话。如果我们不创建一个新会话，守护进程仍将是用户登录会话的一部分，并在用户注销时终止。但由于我们为守护进程创建了一个新会话，并且它被`systemd`继承，它现在独立存在，不受启动它的用户和进程的影响。
- en: The reason for forking the second time is that a session leader—which is what
    our first child after the `setsid()` call is—can acquire a new controlling terminal
    if it were to open a terminal device. When we do the second fork, that new child
    is just a member of the session that was created by the first child, not the leader,
    and hence it cannot acquire a **controlling terminal** anymore. The reason for
    avoiding a controlling terminal is that if that terminal would exit, so would
    the daemon. Forking twice when creating a daemon is often called the **double-fork**
    technique.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次分叉的原因是，会话领导者——也就是我们在`setsid()`调用后的第一个子进程——如果打开终端设备，可以获取一个新的控制终端。当我们进行第二次分叉时，新的子进程只是第一个子进程创建的会话的成员，而不是领导者，因此它不再能获取**控制终端**。避免控制终端的原因是，如果该终端退出，守护进程也会退出。在创建守护进程时进行两次分叉通常被称为**双重分叉**技术。
- en: The reason we needed to start the daemon as root is that it needs to write to
    `/var/run/`. If we were to change the directory—or skip it entirely—the daemon
    would run just fine as a regular user. However, most daemons do run as root. There
    are, however, daemons that run as regular users; for example, daemons that handle
    user-related things, such as `tmux` (a **terminal multiplexer**).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 需要以root身份启动守护进程的原因是它需要写入`/var/run/`。如果我们改变目录，或者完全跳过它，守护进程将作为普通用户正常运行。然而，大多数守护进程确实以root身份运行。然而，也有一些以普通用户身份运行的守护进程；例如，处理与用户相关的事务的守护进程，比如`tmux`（一个终端复用器）。
- en: We also changed the working directory to `/`. This is so that the daemon won't
    lock up a directory. The top root directory isn't going to be removed or unmounted,
    which makes it a safe working directory for the daemon.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将工作目录更改为`/`。这样守护进程就不会锁定目录。顶级根目录不会被删除或卸载，这使其成为守护进程的安全工作目录。
- en: There's more…
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: What we have written here is a traditional Linux/Unix daemon. These kinds of
    daemons are still used today, for example, for small and quick daemons like this
    one. However, since `systemd` came around, we no longer need to "daemonize" a
    daemon the way we just did. For example, it's advised to leave stdout and stderr
    open and send all log messages there instead. These messages will then show up
    in the *journal*. We will cover systemd and the journal in more depth in [*Chapter
    7*](B13043_07_Final_SK_ePub.xhtml#_idTextAnchor299)*, Using systemd to Handle
    Your Daemons*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里编写的是传统的Linux/Unix守护进程。这些类型的守护进程今天仍在使用，例如，用于像这样的小型和快速守护进程。然而，自从`systemd`出现以来，我们不再需要像刚才那样“使守护进程成为守护进程”。例如，建议保留stdout和stderr打开，并将所有日志消息发送到那里。然后这些消息将显示在*journal*中。我们将在[*第7章*](B13043_07_Final_SK_ePub.xhtml#_idTextAnchor299)*，使用systemd处理您的守护进程*中更深入地介绍systemd和journal。
- en: The type of daemon we have written here is called *forking* in systemd language,
    which we'll learn more about later on.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里编写的守护进程类型在systemd语言中被称为*forking*，我们以后会更多地了解它。
- en: Just like `system()` simplified things for us when executing new programs, there
    is a function called `daemon()` that can create daemons for us. This function
    will do all the heavy lifting for us, such as forking, closing and reopening the
    file descriptors, changing the working directory, and more. However, please note
    that this function doesn't use the double-fork technique we used for our daemons
    in this recipe. This fact is clearly stated under the BUGS section in the `man
    3 daemon` manual page.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`system()`在执行新程序时为我们简化了事情一样，还有一个名为`daemon()`的函数可以为我们创建守护进程。这个函数将为我们做所有繁重的工作，比如分叉、关闭和重新打开文件描述符、更改工作目录等。然而，请注意，这个函数不使用我们在本篇中用于守护进程的双重分叉技术。这一事实在`man
    3 daemon`手册页的BUGS部分中明确说明。
- en: Implementing a signal handler
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现信号处理程序
- en: In the previous recipe, we wrote a simple but functional daemon. However, there
    are some problems with it; for example, the PID file isn't removed when the daemon
    is killed. Likewise, the open file stream (`/tmp/my-daemon-is-alive.txt`) isn't
    closed when the daemon is killed. A proper daemon should clean up after itself
    when it exits.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇中，我们编写了一个简单但功能齐全的守护进程。然而，它也存在一些问题；例如，当守护进程被终止时，PID文件没有被删除。同样，当守护进程被终止时，打开的文件流（`/tmp/my-daemon-is-alive.txt`）也没有被关闭。一个合适的守护进程在退出时应该进行清理。
- en: To be able to clean up on exit, we need to implement a signal handler. The signal
    handler should then take care of all the cleanup before the daemon is terminated.
    We have already seen examples of signal handlers in this chapter, so this concept
    isn't new.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在退出时进行清理，我们需要实现一个信号处理程序。然后信号处理程序应该在守护进程终止之前处理所有的清理工作。在本章中，我们已经看到了信号处理程序的例子，所以这个概念并不新鲜。
- en: It's not only daemons that use signal handlers, though. This is a common way
    of controlling processes, especially processes that don't have a controlling terminal.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并不只有守护进程使用信号处理程序。这是一种常见的控制进程的方式，特别是那些没有控制终端的进程。
- en: Getting ready
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should read the previous recipe before reading this one so that you understand
    what the daemon does. Other than that, you'll need the programs listed in the
    *Technical requirements* section of this chapter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本篇之前，您应该先阅读上一篇，以便了解守护进程的功能。除此之外，您还需要本章*技术要求*部分列出的程序。
- en: How to do it…
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法
- en: 'In this recipe, we''ll add signal handlers to the daemon we wrote in the previous
    recipe. Since the code will be a bit longer, I have split it up into several steps.
    Remember, though, that all the code goes in the same file. Let''s get started:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇中，我们将为上一篇中编写的守护进程添加信号处理程序。由于代码会有点长，我将其分成几个步骤。不过，请记住，所有的代码都在同一个文件中。让我们开始吧：
- en: 'Write the following code in and file a name it `my-daemon-v2.c`. We''ll start
    with the `#include` files and the variables, just as we did previously. However,
    notice that this time, we have moved some of the variables to the global space.
    We have done this so that the signal handler can access them. There is no way
    to pass extra arguments to a signal handler, so this is the best way to access
    them. Here, we must also define `_POSIX_C_SOURCE` for `sigaction()`. We must also
    create a prototype for our signal handler here, called `sigHandler()`. Also, notice
    the new `sigaction` struct:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入文件并命名为`my-daemon-v2.c`。我们将从`#include`文件和变量开始，就像之前一样。但是请注意，这一次我们已经将一些变量移到了全局空间。我们这样做是为了让信号处理程序可以访问它们。没有办法向信号处理程序传递额外的参数，所以这是访问它们的最佳方式。在这里，我们还必须为`sigaction()`定义`_POSIX_C_SOURCE`。我们还必须在这里创建我们的信号处理程序的原型，称为`sigHandler()`。另外，请注意新的`sigaction`结构：
- en: '[PRE75]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Just as we did previously, we must create a new session after the first fork.
    After that, we must do the second fork to make sure it isn''t a session leader
    anymore:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像之前一样，我们必须在第一次分叉后创建一个新会话。之后，我们必须进行第二次分叉，以确保它不再是一个会话领导者：
- en: '[PRE76]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Again, as we did previously, we must change the umask, the current working
    directory, and open the daemon file with `fopen()`. Next, we must close and reopen
    stdin, stdout, and stderr:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前一样，我们必须更改umask、当前工作目录，并使用`fopen()`打开守护进程文件。接下来，我们必须关闭并重新打开stdin、stdout和stderr：
- en: '[PRE77]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, it''s finally time to prepare and register the signal handlers. This is
    exactly what we covered earlier in this chapter, only here, we are registering
    handlers for all the common exit signals, such as terminate, interrupt, quit,
    and abort. Once we have dealt with the signal handlers, we will begin the daemon''s
    work; that is, the `for` loop that will write messages to the daemon file:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，终于是时候准备并注册信号处理程序了。这正是我们在本章前面讨论过的内容，只是在这里，我们为所有常见的退出信号注册处理程序，比如终止、中断、退出和中止。一旦我们处理了信号处理程序，我们将开始守护进程的工作；也就是，将消息写入守护进程文件的`for`循环：
- en: '[PRE78]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Finally, we must implement the function for the signal handler. Here, we clean
    up after the daemon by removing the PID file before exiting. We also close the
    open file stream to the daemon file:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须实现信号处理程序的函数。在这里，我们通过在退出之前删除PID文件来清理守护进程。我们还关闭了打开的文件流到守护进程文件：
- en: '[PRE79]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Compile the new version of the daemon:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译守护进程的新版本：
- en: '[PRE80]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Start the daemon as root, just as we did previously:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以root身份启动守护进程，就像我们之前做的那样：
- en: '[PRE81]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Check out the PID in the PID file and make note of it:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看PID文件中的PID并做好记录：
- en: '[PRE82]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Check it out with `ps` to see that it''s running as it should:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ps`命令查看它是否按预期运行：
- en: '[PRE83]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Kill the daemon with the default signal, `TERM`:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用默认信号`TERM`杀死守护进程：
- en: '[PRE84]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If everything has worked out as planned, the PID file will have been removed.
    See if you can access the PID file with `cat`:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切按计划进行，PID文件将被删除。尝试使用`cat`命令访问PID文件：
- en: '[PRE85]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: How it works…
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'In this recipe, we implemented a signal handler that takes care of all the
    cleanup. It removes the PID file and closes the open file stream. To cover the
    most common "exit" signals, we registered the handler with four different signals:
    *terminate*, *interrupt*, *quit*, and *abort*. When one of these signals is received
    by the daemon, it triggers the `sigHandler()` function. This function then removes
    the PID file and closes the file stream. Finally, the function exits the entire
    daemon by calling `exit()`.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们实现了一个信号处理程序，负责所有清理工作。它会删除PID文件并关闭打开的文件流。为了处理最常见的“退出”信号，我们使用四个不同的信号注册了处理程序：*终止*、*中断*、*退出*和*中止*。当守护进程接收到其中一个信号时，它会触发`sigHandler()`函数。该函数然后会删除PID文件并关闭文件流。最后，该函数通过调用`exit()`退出整个守护进程。
- en: However, since we can't pass the filename or the file stream as an argument
    to the signal handler, we placed those variables in the global scope instead.
    This makes it possible for both `main()` and `sigHandler()` to reach them.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们无法将文件名或文件流作为参数传递给信号处理程序，我们将这些变量放在全局范围内。这样一来，`main()`和`sigHandler()`都可以访问它们。
- en: There's more…
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Remember that we had to flush the stream for the time and date to show up in
    `/tmp/my-daemon-is-alive.txt`? Since we now close the file stream once the daemon
    exits, we don't need `fflush()` anymore. The data is written to the file when
    it closes. However, then we can't see the time and date "live" while the daemon
    is running. That's why we still have `fflush()` in the code.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们之前必须刷新流才能在`/tmp/my-daemon-is-alive.txt`中显示时间和日期吗？由于现在守护进程退出时关闭文件流，我们不再需要`fflush()`。数据在关闭时被写入文件。然而，这样一来，我们就无法在守护进程运行时“实时”看到时间和日期。这就是为什么我们在代码中仍然保留了`fflush()`。
