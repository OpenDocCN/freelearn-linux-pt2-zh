- en: '*Chapter 5*: Working with File I/O and Filesystem Operations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：使用文件I/O和文件系统操作'
- en: File I/O is an important part of system programming since most programs must
    read or write data to and from files. Doing file I/O also requires the developer
    to know a thing or two about the filesystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 文件I/O是系统编程的重要部分，因为大多数程序必须从文件中读取或写入数据。进行文件I/O还要求开发人员对文件系统有所了解。
- en: Mastering file I/O and filesystem operations will make you not only a better
    programmer but also a better system administrator.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 精通文件I/O和文件系统操作不仅会使您成为更好的程序员，还会使您成为更好的系统管理员。
- en: In this chapter, we will learn about the Linux filesystem and inodes. We will
    also learn how to read and write files on the system, using both streams and file
    descriptors. We will also look at system calls to create and delete files and
    change file permissions and ownership. At the end of the chapter, we will learn
    how to fetch information about files.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Linux文件系统和inode。我们还将学习如何使用流和文件描述符在系统上读取和写入文件。我们还将查看系统调用以创建和删除文件，并更改文件权限和所有权。在本章末尾，我们将学习如何获取有关文件的信息。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Reading inode information and learning the filesystem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读inode信息并学习文件系统
- en: Creating soft links and hard links
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建软链接和硬链接
- en: Creating files and updating the timestamp
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建文件并更新时间戳
- en: Deleting files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件
- en: Getting access rights and ownership
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取访问权限和所有权
- en: Setting access rights and ownership
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置访问权限和所有权
- en: Writing to files with file descriptors
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件描述符写入文件
- en: Reading from files with file descriptors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件描述符从文件中读取
- en: Writing to files with streams
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流写入文件
- en: Reading from files with streams
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流从文件中读取
- en: Reading and writing binary data with streams
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流读取和写入二进制数据
- en: Moving around inside a file with `lseek()`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`lseek()`在文件内部移动
- en: Moving around inside a file with `fseek()`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`fseek()`在文件内部移动
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need the GCC compiler, the Make tool, and the generic
    Makefile we made in the *Writing a generic Makefile with GCC options* recipe in
    [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097), *Diving Deep into
    C in Linux*. [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting
    the Necessary Tools and Writing Our First Linux Programs*, covers installing the
    compiler and the Make tool.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要GCC编译器、Make工具以及我们在[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)中的*使用GCC选项编写通用Makefile*食谱中制作的通用Makefile。[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中有关安装编译器和Make工具的内容。
- en: 'The generic Makefile, along with all the source code examples for this chapter,
    can be downloaded from GitHub at this URL: [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的Makefile以及本章的所有源代码示例可以从GitHub的以下URL下载：[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5)。
- en: We are going to look up functions and header files in the built-in manual in
    Linux. If you are using Debian or Ubuntu, the Linux Programmer's Manual is installed
    as part of the *build-essentials* meta-package, covered in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*. You'll also
    need to install the *POSIX Programmer's Manual*, covered in the *Getting information
    about Linux and Unix-specific header files* recipe in [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097),
    *Diving Deep into C in Linux*. If you are using CentOS or Fedora, these manuals
    are most likely already installed. Otherwise, check out the recipe in [*Chapter
    3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097), *Diving Deep into C in Linux*,
    that I mentioned.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Linux的内置手册中查找函数和头文件。如果您使用的是Debian或Ubuntu，Linux程序员手册将作为*build-essentials*元包的一部分安装，该元包在[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中有所涵盖，*获取必要的工具并编写我们的第一个Linux程序*。您还需要安装*POSIX程序员手册*，该手册在[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)中的*获取有关Linux和Unix特定头文件的信息*食谱中有所涵盖，*深入研究Linux中的C语言*。如果您使用的是CentOS或Fedora，这些手册很可能已经安装。否则，请查看我提到的[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)中的食谱，*深入研究Linux中的C语言*。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3u4OuWz](https://bit.ly/3u4OuWz)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以查看代码演示视频：[https://bit.ly/3u4OuWz](https://bit.ly/3u4OuWz)
- en: Reading inode information and learning the filesystem
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阅读inode信息并学习文件系统
- en: Understanding inodes is the key to understanding the filesystem in Linux at
    a deeper level. A filename isn't the actual file in a Linux or Unix system. It's
    just a **pointer** to an **inode**. The inode has information about where the
    actual data is stored and a lot of meta data about the file, such as the file
    mode, last modification date, and owner.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 理解inode是深入了解Linux文件系统的关键。在Linux或Unix系统中，文件名并不是实际的文件，它只是指向inode的指针。inode包含有关实际数据存储位置的信息，以及有关文件的大量元数据，例如文件模式、最后修改日期和所有者。
- en: In this recipe, we'll get a general understanding of the **filesystem** and
    how inodes fit into this. We will also view inode information and learn a few
    commands for that. We will also write a small C program that reads inode information
    from a filename.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将对**文件系统**有一个一般的了解，以及inode如何适应其中。我们还将查看inode信息，并学习一些相关命令。我们还将编写一个小的C程序，从文件名中读取inode信息。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll use both commands and C programs to explore the concepts
    of inodes. Everything you need for this recipe is covered in the *Technical requirements*
    section of this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用命令和C程序来探索inode的概念。您需要的一切都在本章的*技术要求*部分中有所涵盖。
- en: How to do it…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: 'In this recipe, we''ll begin by exploring the commands that already exist on
    the system to view inode information. Then, we''ll create a small C program to
    print inode information:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将首先探索系统上已经存在的命令，以查看inode信息。然后，我们将创建一个小的C程序来打印inode信息：
- en: 'We''ll start by creating a small text file that we''ll use throughout this
    recipe:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个小的文本文件，我们将在整个配方中使用它：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s view the *inode number* for this file, along with its size, block
    count, and other information. The inode number will be different on every system
    and for every file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们查看此文件的*inode编号*，以及其大小、块计数和其他信息。每个系统和每个文件的inode编号都是不同的：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The size is in bytes and is 36 bytes. Since no special characters are used
    in the text, this will be the same as the number of characters the file contains.
    We can count the number of characters with `wc`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大小以字节为单位，为36字节。由于文本中未使用特殊字符，因此这与文件包含的字符数相同。我们可以使用`wc`来计算字符数：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s build a small program that extracts some of this information; the
    inode number, the file size, and the number of `my-stat-v1.c`. The name of the
    system call function that we''ll use to extract information has the same name
    as the command-line tool, `stat`. The system call function is highlighted in the
    code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们构建一个小程序，提取其中一些信息；inode编号、文件大小和`my-stat-v1.c`的链接数。我们将用于提取信息的系统调用函数与命令行工具`stat`具有相同的名称。代码中突出显示了系统调用函数：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now compile this program using Make and the generic `Makefile`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用Make和通用的`Makefile`编译此程序：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s try the program on `testfile1`. Compare the inode number, size, and
    number of links. These numbers should be the same as when we used the `stat` program:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`testfile1`上尝试这个程序。比较inode编号、大小和链接数。这些数字应该与我们使用`stat`程序时相同：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we don''t type an argument, we''ll get a usage message:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们不输入参数，将会得到一个使用消息：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And if we try it on a file that doesn''t exist, we''ll get an error message:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试对一个不存在的文件进行操作，将会得到一个错误消息：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'The filename of a file isn''t the data or file. The filename is just a link
    to an inode. And that inode, in turn, contains information about where on the
    filesystem the actual data is stored. As we will see in the next recipe, an inode
    can have multiple names or *links*. A filename is also called a link sometimes.
    The following figure illustrates the concepts of filenames that point to the inode,
    and the inode contains information about where the **data blocks** are stored:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的文件名并不是数据或文件。文件名只是指向inode的链接。而该inode又包含有关实际数据存储在文件系统上的位置的信息。正如我们将在下一篇文章中看到的，一个inode可以有多个名称或*链接*。有时文件名也被称为链接。下图说明了指向inode的文件名和inode包含有关**数据块**存储位置的信息的概念：
- en: '![Figure 5.1 – Inodes and filenames'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – Inodes和文件名'
- en: '](img/Figure_5.1_B13043.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B13043.jpg)'
- en: Figure 5.1 – Inodes and filenames
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – Inodes和文件名
- en: An inode also contains `stat` command.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个inode还包含`stat`命令。
- en: In *step 4*, we created a small C program that reads this metadata using a system
    call function with the same name as the command, `stat()`. The `stat()` system
    call extracts much more data than what we printed here. We will print more of
    this information throughout this chapter. All of this information is stored in
    a struct called `stat`. We find all the information we need about this struct
    in the `man 2 stat` manual page. In that manual page, we also see what data types
    the variables are (`ino_t`, `off_t`, and `nlink_t`). And then, in `man sys_types.h`,
    under **Additionally**, we find what types these are.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们创建了一个小的C程序，使用与命令相同名称的系统调用函数`stat()`读取此元数据。`stat()`系统调用提取的数据比我们在此处打印的要多得多。我们将在本章中打印更多此类信息。所有这些信息都存储在一个名为`stat`的结构体中。我们在`man
    2 stat`手册页中找到了关于此结构体的所有所需信息。在该手册页中，我们还看到了变量的数据类型（`ino_t`、`off_t`和`nlink_t`）。然后，在`man
    sys_types.h`中，我们在**另外**下找到了这些类型是什么类型。
- en: The fields we use here are `st_ino` for the inode number, `st_size` for the
    file size, and `st_nlink` for the number of links to the file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的字段是`st_ino`表示inode编号，`st_size`表示文件大小，`st_nlink`表示文件的链接数。
- en: In *step 6*, we saw that the information we extracted using our C program was
    the same as the information from the `stat` command.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，我们看到我们使用C程序提取的信息与`stat`命令的信息相同。
- en: We also implemented error handling in the program. The `stat()` function is
    wrapped in an `if` statement, checking its return value for -1\. And if an error
    does occur, we print an error message to *stderr* with the filename and the error
    message from `errno`. The program also returns the `errno` variable to the shell.
    We learned all about error handling and `errno` in [*Chapter 4*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*,
    Handling Errors in Your Programs*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在程序中实现了错误处理。`stat()`函数包装在一个`if`语句中，检查其返回值是否为-1。如果发生错误，我们将使用`stderr`打印出带有文件名和`errno`的错误消息。程序还将`errno`变量返回给shell。我们在[*第4章*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*中学习了有关错误处理和`errno`的所有内容，处理程序中的错误*。
- en: Creating soft links and hard links
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建软链接和硬链接
- en: In the previous recipe, we touched on the subject of links. In this recipe,
    we'll learn more about links and how they affect inodes. We'll also investigate
    the difference between **soft links** and **hard links**. In short, a hard link
    is a filename, and a soft link is like a shortcut to a filename.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一篇文章中，我们提到了链接的主题。在这篇文章中，我们将更多地了解链接以及它们对inode的影响。我们还将调查**软链接**和**硬链接**之间的区别。简而言之，硬链接是一个文件名，软链接就像是一个文件名的快捷方式。
- en: On top of that, we'll write two programs, one that creates a hard link and one
    that creates a soft link. We'll then use the program we created in the previous
    recipe to check the **link count**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将编写两个程序，一个创建硬链接，一个创建软链接。然后，我们将使用前一篇文章中创建的程序来检查链接计数。
- en: Getting ready
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Except for the requirements listed at the beginning of this chapter, you'll
    also need the program we created in the previous recipe, `my-stat-v1.c`. You'll
    also need the test file we created in the previous recipe, named `testfile1`.
    If you haven't created those files yet, you can also download them from GitHub
    at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章开头列出的要求，您还需要我们在上一个示例中创建的程序`my-stat-v1.c`。您还需要我们在上一个示例中创建的测试文件，名为`testfile1`。如果您还没有创建这些文件，也可以从GitHub上下载它们[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch5)。
- en: You'll also need to compile the `my-stat-v1.c` program using Make so you'll
    be able to execute it, if you haven't done so already. You compile it with `make
    my-stat-v1`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要使用Make编译`my-stat-v1.c`程序，以便能够执行它，如果您还没有这样做的话。您可以使用`make my-stat-v1`来编译它。
- en: How to do it…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will create both soft links and hard links, using both the built-in commands
    and writing simple C programs to do so:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建软链接和硬链接，使用内置命令和编写简单的C程序来完成：
- en: 'We''ll start by creating a new hard link to our test file, `testfile1`. We''ll
    name the new hard link `my-file`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个新的硬链接到我们的测试文件`testfile1`。我们将新的硬链接命名为`my-file`：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now let''s investigate this new filename. Note how the links have increased
    to `2`, but the rest is the same as for `testfile1`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们调查这个新文件名。请注意链接已增加到`2`，但其余部分与`testfile1`相同：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now compare these numbers with the `testfile1` file. They should all be the
    same:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将这些数字与`testfile1`文件进行比较。它们应该都是相同的：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s create another hard link called `another-name`. We create this link
    using the name `my-file` as the target:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建另一个名为`another-name`的硬链接。我们使用名称`my-file`作为目标创建此链接：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We''ll investigate this file as well:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也将调查这个文件：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let''s delete the `testfile1` filename:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们删除`testfile1`文件名：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have deleted the first filename we created, we''ll investigate
    the other two names:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经删除了我们创建的第一个文件名，我们将调查另外两个名称：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It''s time to create a soft link. We create a soft link called `my-soft-link`
    to the name `another-name`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候创建一个软链接了。我们创建一个名为`my-soft-link`的软链接到名称`another-name`：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A soft link is a special file type, which we can see with the `ls` command.
    Note that we get a new timestamp here. Also, note that it''s a special file, which
    can be seen by the first letter in the file mode field, the letter `l` for a link:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软链接是一种特殊的文件类型，可以使用`ls`命令查看。请注意，我们在这里得到了一个新的时间戳。还要注意，它是一个特殊文件，可以通过文件模式字段中的第一个字母`l`来看到：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now let''s check the link count of `another-name`. Note that the counter hasn''t
    increased with the soft link:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们检查`another-name`的链接计数。请注意，软链接的计数器没有增加：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It''s time to write our own program to create hard links. There exists an easy-to-use
    `link()` that we''ll use for this. Write the following code in a file and save
    it as `new-name.c`. The `link()` system call is highlighted in the code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候编写我们自己的程序来创建硬链接了。存在一个易于使用的`link()`，我们将使用它。将以下代码写入文件并保存为`new-name.c`。代码中突出显示了`link()`系统调用：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Compile the program:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a new name to our previous `my-file` file. Name the new file `third-name`.
    We also try to generate some errors to see that the program prints the correct
    error messages. Note that the inode information for `third-name` is the same as
    for `my-file`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们之前的`my-file`文件创建一个新名称。将新文件命名为`third-name`。我们还尝试生成一些错误，以查看程序是否打印了正确的错误消息。请注意，`third-name`的inode信息与`my-file`的相同：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let''s create a program that creates a soft link. There''s an easy-to-use
    system call for this as well, called `symlink()`, for `new-symlink.c`. The `symlink()`
    system call is highlighted in the code. Notice how similar all of these system
    call functions are:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们创建一个创建软链接的程序。这也有一个易于使用的系统调用，称为`symlink()`，用于`new-symlink.c`。代码中突出显示了`symlink()`系统调用。注意所有这些系统调用函数有多么相似：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Compile it:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译它：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And let''s try it out, creating a new soft link called `new-soft-link` to `third-name`.
    Also, let''s try generating some errors so we can verify that the error handling
    is working:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们试一试，创建一个新的软链接，名为`new-soft-link`，指向`third-name`。此外，让我们尝试生成一些错误，以便我们可以验证错误处理是否正常工作：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works…
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: There's a lot going on here, so let's take it from the top.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多事情，所以让我们从头开始。
- en: In steps 1 to 7, we created two new hard links to the `testfile1` file. But
    as we noticed, there's nothing special about a hard link; it's just another name
    to an inode. All filenames are hard links. A filename is just a link to an inode.
    We saw that when we deleted the `testfile1` filename. The two remaining names
    link to the same inode, and it contains the same text. There is nothing special
    about the first filename or link. There's no way to tell which of the hard links
    was created first. They are equal; they even share the same date, even though
    the other links were made at a later time. The date is for the inode, not the
    filenames.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1到7中，我们创建了两个新的硬链接到`testfile1`文件。但正如我们注意到的，硬链接没有什么特别之处；它只是inode的另一个名称。所有文件名都是硬链接。文件名只是inode的一个链接。当我们删除`testfile1`文件名时，我们看到了这一点。剩下的两个名称链接到相同的inode，并且包含相同的文本。第一个文件名或链接没有什么特别之处。无法告诉哪个硬链接是首先创建的。它们是相等的；它们甚至共享相同的日期，尽管其他链接是在稍后的时间创建的。日期是为了inode，而不是文件名。
- en: As we created and deleted hard links, we saw how the link count increased and
    decreased. This is the inode keeping count of how many links—or names—it has.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建和删除硬链接时，我们看到链接计数增加和减少。这是inode保持计算它有多少链接或名称的计数。
- en: The inode isn't deleted until the last name is deleted, that is, when the link
    counter reaches zero.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最后一个名称被删除，即链接计数达到零时，inode才会被删除。
- en: In *steps 8 to 10*, we saw that a soft link, on the other hand, is a special
    file type. A soft link doesn't count toward the inode's link counter. The file
    is denoted by an `l` at the start of the `ls -l` output. We can also see what
    file the soft link points to in the `ls -l` output. Think of a soft link as a
    shortcut.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤8到10*中，我们看到软链接，另一方面，是一种特殊的文件类型。软链接不计入inode的链接计数。文件在`ls -l`输出的开头用`l`表示。我们还可以在`ls
    -l`输出中看到软链接指向的文件。把软链接想象成一个快捷方式。
- en: In *steps 11 to 13*, we wrote a C program that creates a hard link—a new name—to
    an existing filename. Here we learned that the system calls for creating new names
    is called `link()` and takes two arguments, the target and the new name.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤11到13*中，我们编写了一个创建硬链接（现有文件的新名称）的C程序。在这里，我们了解到创建新名称的系统调用称为`link()`，并且接受两个参数，目标和新名称。
- en: In *step 13*, we witnessed an interesting property for hard links. They cannot
    span across devices. When we think about it, it makes sense. The filename can't
    remain on a device separate from the inode. If the device is removed, there might
    not be any more names pointing to the inode, making it inaccessible.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤13*中，我们见证了硬链接的一个有趣特性。它们不能跨设备。当我们考虑这一点时，这是有道理的。文件名不能保留在与inode分开的设备上。如果设备被移除，可能就没有更多的名称指向inode，使其无法访问。
- en: For the remaining steps, we wrote a C program that creates soft links to existing
    files. This system call is similar to `link()` but is instead called `symlink()`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在剩下的步骤中，我们编写了一个C程序，用于创建指向现有文件的软链接。这个系统调用类似于`link()`，但是被称为`symlink()`。
- en: There's more…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Please look at the manual pages for the system calls we covered in this recipe;
    they contain some great explanations of both hard links and soft links. The manual
    pages are `man 2 link` and `man 2 symlink`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看我们在本食谱中涵盖的系统调用的手册页面；它们包含了硬链接和软链接的一些很好的解释。手册页面是`man 2 link`和`man 2 symlink`。
- en: Creating files and updating the timestamp
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建文件和更新时间戳
- en: Now that we understand the filesystem, inodes, and hard links, we'll learn how
    to create files by writing our own version of `touch` in C. We have already started
    writing a version of `touch` in [*Chapter 4*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*,
    Handling Errors in Your Programs,* where we learned about error handling. We will
    continue using the latest version of that program, which we named `simple-touch-v7.c`.
    The real version of `touch` updates the modification and access **timestamp**
    of a file if the file exists. In this recipe, we'll add that feature to our new
    version.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了文件系统、inode和硬链接，我们将学习如何通过在C中编写我们自己的`touch`版本来创建文件。我们已经开始在[*第4章*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*，处理程序中的错误*中编写`touch`的一个版本，那里我们学习了错误处理。我们将继续使用该程序的最新版本，我们将其命名为`simple-touch-v7.c`。真正的`touch`版本会在文件存在时更新文件的修改和访问时间戳。在这个食谱中，我们将在我们的新版本中添加这个功能。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Everything you'll need for this recipe is listed in the *Technical requirements*
    section for this chapter. Although we will add on the latest version of `simple-touch`,
    we'll write the entire code in this recipe. But for complete comprehension of
    the program, it is wise to read through [*Chapter 4*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*,
    Handling Errors in Your Programs,* first.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章的*技术要求*部分中列出了此食谱所需的一切。虽然我们将添加`simple-touch`的最新版本，但我们将在本食谱中编写整个代码。但为了完全理解程序，最好先阅读[*第4章*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*，处理程序中的错误*。
- en: How to do it…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this eighth version of `simple-touch`, we will add the feature to update
    the access and modification date of a file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`simple-touch`的第八个版本中，我们将添加更新文件的访问和修改日期的功能：
- en: 'Write the following code in a file and save it as `simple-touch-v8.c`. Here
    we will use the `utime()` system call to update a file''s access and modification
    timestamps. The changes from the previous version are highlighted in the code
    (except for the added comments). Also, note how the `creat()` system call has
    moved into an `if` statement. The `creat()` system call is only called if the
    file doesn''t already exist:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码，并将其保存为`simple-touch-v8.c`。在这里，我们将使用`utime()`系统调用来更新文件的访问和修改时间戳。代码中突出显示了与上一个版本的更改（除了添加的注释）。还要注意`creat()`系统调用如何移入了一个`if`语句。只有在文件不存在时才会调用`creat()`系统调用：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Compile the program using Make:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Make编译程序：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s try it out and see how it works. We''ll try it on the filenames we created
    in the previous recipe and see how each filename gets the same timestamp since
    they all point to the same inode:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一下，看看它是如何工作的。我们将在上一个食谱中创建的文件名上尝试，并看看每个文件名如何获得相同的时间戳，因为它们都指向相同的inode：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we added the feature to update the timestamp of a file—or inode,
    as we have learned that it is.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们添加了更新文件或inode的时间戳的功能。
- en: To update the access and modification time, we use the `utime()` system call.
    The `utime()` system call takes two arguments, a filename and a timestamp. But
    if we give the function `NULL` as the second argument, it will use the current
    time and date.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新访问和修改时间，我们使用`utime()`系统调用。`utime()`系统调用接受两个参数，一个文件名和一个时间戳。但是如果我们将`NULL`作为第二个参数传递给函数，它将使用当前的时间和日期。
- en: The call to `utime()` is wrapped in an `if` statement, which checks whether
    the return value is -1\. If it is, then something is wrong, and `errno` is set
    (see [*Chapter 4*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*, Handling
    Errors in Your Programs*, for an in-depth explanation of `errno`). We then use
    `errno` to check whether it was a *File not found* error (`ENOTENT`). If the file
    doesn't exist, we create it using the `creat()` system call. The call to `creat()`
    is also wrapped in an `if` statement. If something goes wrong while creating a
    file, the program prints an error message and return the `errno` value. If the
    program managed to create the file, it continues down to `return 0`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`utime()`的语句被包裹在一个`if`语句中，检查返回值是否为-1。如果是，那么出现了问题，`errno`被设置（参见[*第4章*](B13043_04_Final_SK_ePub.xhtml#_idTextAnchor147)*，处理程序中的错误*，对`errno`的深入解释）。然后我们使用`errno`来检查是否是*文件未找到*错误（`ENOTENT`）。如果文件不存在，我们使用`creat()`系统调用来创建它。对`creat()`的调用也被包裹在一个`if`语句中。如果在创建文件时出现问题，程序将打印错误消息并返回`errno`值。如果程序成功创建了文件，它将继续执行`return
    0`。
- en: If the `errno` value from `utime()` wasn't `ENOENT`, it continues down to the
    `else` statement, prints an error message, and returns `errno`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`utime()`的`errno`值不是`ENOENT`，它将继续到`else`语句，打印错误消息，并返回`errno`。
- en: When we tried the program, we noticed that both `my-file` and `third-name` got
    an updated timestamp when we updated one of them. This is because the filenames
    are just links to the same inode. And the timestamp is metadata in the inode.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试运行程序时，我们注意到当我们更新其中一个文件时，`my-file`和`third-name`都会获得更新的时间戳。这是因为这些文件名只是指向相同inode的链接。时间戳是inode中的元数据。
- en: There's more…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There's a lot of useful information in `man 2 creat` and `man 2 utime`. If you
    are interested in learning more about time and dates in Linux, I recommend you
    read `man 2 time`, `man 3 asctime`, and `man time.h`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在`man 2 creat`和`man 2 utime`中有很多有用的信息。如果你有兴趣了解Linux中的时间和日期，我建议你阅读`man 2 time`，`man
    3 asctime`和`man time.h`。
- en: Deleting files
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文件
- en: In this recipe, we learn how to `unlink()`—comes from. This recipe will enhance
    your understanding of links and close the circle. This will improve your overall
    knowledge of Linux and its filesystem. Knowing how to delete files using the system
    call will enable you to remove files directly from within your programs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用`unlink()`函数。这个食谱将增强你对链接的理解，并闭合循环。这将提高你对Linux及其文件系统的整体知识。知道如何使用系统调用删除文件将使你能够直接从程序中删除文件。
- en: Here we will write our own version of `rm`, which we will call `remove`. After
    this recipe, we know how to create and delete files and how to make links. These
    are some of the most common filesystem operations.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写我们自己的版本的`rm`，我们将其称为`remove`。在这个食谱之后，我们知道如何创建和删除文件以及如何创建链接。这些是一些最常见的文件系统操作。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we will use the `my-stat-v1` program, which we wrote in the
    *Reading inode information and learning the filesystem* recipe. We will also continue
    experimenting on the filenames we created in the previous recipes, `my-file`,
    `another-name`, and `third-name`. Except for that, you'll need what's listed under
    *Technical requirements* for this chapter, that is, the GCC compiler, the Make
    tool, and the generic Makefile.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用我们在*读取inode信息和学习文件系统*食谱中编写的`my-stat-v1`程序。我们还将继续对我们在之前的食谱中创建的文件名进行实验，`my-file`，`another-name`和`third-name`。除此之外，你还需要本章列出的*技术要求*，即GCC编译器，Make工具和通用Makefile。
- en: How to do it…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow along here to write a simple version of `rm`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 跟着这里写一个简单版本的`rm`：
- en: 'Write the following code in a file and save it as `remove.c`. This program
    uses the `unlink()` system call to remove a file. The system call is highlighted
    in the code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入一个文件并保存为`remove.c`。这个程序使用`unlink()`系统调用来删除一个文件。代码中突出显示了系统调用：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Compile it using the **Make** tool:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Make**工具编译它：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And let''s try it out:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们试一试：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The system call to remove a file is called `unlink()`. The name comes from the
    fact that when we remove a filename, we only remove a hard link to that inode;
    hence we **unlink** a filename. If it happens to be the last filename to an inode,
    then the inode is also removed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 用于删除文件的系统调用称为`unlink()`。这个名字来自于当我们删除一个文件名时，我们只是删除了指向该inode的硬链接；因此我们**unlink**了一个文件名。如果它恰好是指向inode的最后一个文件名，那么该inode也将被删除。
- en: 'The `unlink()` system calls only takes one argument: the filename that we want
    to remove.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`unlink()`系统调用只接受一个参数：我们要删除的文件名。'
- en: Getting access rights and ownership
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取访问权限和所有权
- en: In this recipe, we'll write a program that reads the access rights and ownership
    of a file using the `stat()` system call we have seen previously in this chapter.
    We will continue to build upon the `my-stat-v1` program that we built in the first
    recipe in this chapter. Here we will add the features to show ownership and access
    rights as well. Knowing how to get the owner and access rights programmatically
    is key to working with files and directories. It will enable you to check whether
    the user has the appropriate permissions and print an error message if they haven't.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将编写一个程序，使用我们在本章中之前看到的`stat()`系统调用来读取文件的访问权限和所有权。我们将继续构建在本章第一个食谱中构建的`my-stat-v1`程序的基础上。在这里，我们将添加显示所有权和访问权限的功能。知道如何以编程方式获取所有者和访问权限对于处理文件和目录至关重要。它将使你能够检查用户是否具有适当的权限，并在他们没有权限时打印错误消息。
- en: We will also learn how access rights are interpreted in Linux and how to convert
    between numerical representation and letter representation. Understanding access
    rights in Linux is key to being a Linux system programmer. Every file and directory
    on the entire system has access rights and an owner and a group assigned to them.
    It doesn't matter whether it's a log file, a system file, or just a text file
    that a user owns. Everything has access rights.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习在Linux中如何解释访问权限以及如何在数字表示和字母表示之间进行转换。了解Linux中的访问权限对于成为Linux系统程序员至关重要。整个系统上的每个文件和目录都有访问权限以及分配给它们的所有者和组。无论是日志文件、系统文件还是用户拥有的文本文件，都有访问权限。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll only need what's listed in the *Technical requirements*
    section of this chapter.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您只需要本章*技术要求*部分中列出的内容。
- en: How to do it…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will write a new version of `my-stat-v1` in this recipe. We will write the
    entire program here, though, so you don''t need the previous version:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个示例中编写`my-stat-v1`的新版本。我们将在这里编写整个程序，因此您不需要之前的版本：
- en: 'Write the following code in a file and save it as `my-stat-v2.c`. In this version,
    we''ll pull information about the owner and the group of the file and the file
    mode. To translate the `getpwuid()`. To get the group name for a `getgrgid()`.
    The changes are highlighted in the code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码并将其保存为`my-stat-v2.c`。在这个版本中，我们将获取有关文件所有者和组以及文件模式的信息。要翻译`getpwuid()`。要获取`getgrgid()`的组名。更改在代码中突出显示：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Compile the program:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Try out the program on some different files:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一些不同的文件上尝试该程序：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this version of `my-stat`, we have added features to retrieve the file access
    mode, or actually, the **file mode**. The file's complete file mode consists of
    six octal numbers. The first two (to the left) is the file type. In this case,
    it's a regular file (10 equals a regular file). The fourth octal digit is for
    the **set-user-ID bit**, the **set-group-ID bit**, and the **sticky bit**. The
    last three octal digits are for the **access mode**.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`my-stat`版本中，我们添加了检索文件访问模式或实际上是**文件模式**的功能。文件的完整文件模式由六个八进制数字组成。前两个（左侧）是文件类型。在这种情况下，它是一个常规文件（10等于常规文件）。第四个八进制数字是**设置用户ID位**、**设置组ID位**和**粘性位**。最后三个八进制数字是**访问模式**。
- en: 'In the output from `ls -l`, all these bits are instead represented as letters.
    But when we write programs, we must set and read these as numbers. Before we move
    on, let''s examine the letter-version of the file mode, so we truly understand
    it:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ls -l`的输出中，所有这些位都代表为字母。但是当我们编写程序时，我们必须将其设置和读取为数字。在继续之前，让我们检查文件模式的字母版本，以便真正理解它：
- en: '![Figure 5.2 – File access mode'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ！[图5.2 - 文件访问模式
- en: '](img/Figure_5.2_B13043.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B13043.jpg)'
- en: Figure 5.2 – File access mode
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 - 文件访问模式
- en: The set-user-ID bit is a bit that allows a process to run as the owner of the
    binary file, even though it is executed as a different user. Setting the set-user-ID
    bit is potentially dangerous and *not* something we should set on our programs.
    One program that does use the set-user-ID bit is the `passwd` program. The `passwd`
    program must update the `/etc/passwd` and `/etc/shadow` files when a user changes
    his or her password, even though those files are owned by root. Under normal circumstances,
    we can't even read the `/etc/shadow` file as a regular user, but with the set-user-ID
    bit set on the `passwd` program, it can even write to it. If the set-user-ID bit
    is set, it's denoted by an `s` in the third place of the user's access mode.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 设置用户ID位是一个允许进程以二进制文件的所有者身份运行的位，即使它以不同的用户身份执行。设置用户ID位可能是危险的，*不*是我们应该在程序上设置的东西。使用设置用户ID位的一个程序是`passwd`程序。`passwd`程序必须在用户更改密码时更新`/etc/passwd`和`/etc/shadow`文件，即使这些文件是由root拥有的。在正常情况下，我们甚至不能以常规用户的身份读取`/etc/shadow`文件，但是通过在`passwd`程序上设置设置用户ID位，它甚至可以写入它。如果设置了设置用户ID位，则在用户的访问模式的第三个位置上用`s`表示。
- en: The set-group-ID has a similar effect. When a program is executed, and the set-group-ID
    bit is set, it is executed as that group. When the set-group-ID is set, it's denoted
    by an `s` in the third place of the group's access mode.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 设置组ID具有类似的效果。当程序被执行并且设置了组ID位时，它将作为该组执行。当设置了组ID时，它在组的访问模式的第三个位置上用`s`表示。
- en: The sticky bit was historically used to *stick* a program to the swap space
    for faster loading time. Nowadays, it's used entirely differently. Now, the name—as
    well as the meaning—has changed to *restricted deletion flag*. When a directory
    has the sticky bit set, only a file's owner, the directory owner, or the root
    user can remove a file, even if the directory is writeable by anybody. For example,
    the `/tmp` directory usually has the sticky bit set. A sticky bit is denoted by
    a `t` in the last position of the last group.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 粘性位在历史上用于将程序*粘*到交换空间，以加快加载时间。现在，它的用途完全不同。现在，名称以及含义都已更改为*受限删除标志*。当目录设置了粘性位时，只有文件的所有者、目录所有者或root用户可以删除文件，即使目录可被任何人写入。例如，`/tmp`目录通常设置了粘性位。粘性位在最后一组的最后一个位置上用`t`表示。
- en: File access mode
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件访问模式
- en: 'When we run `ls -l` on a file, we always see two names. The first name is the
    user (the owner), and the second name is the group that owns the file. Take this,
    for example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在文件上运行`ls -l`时，我们总是看到两个名称。第一个名称是用户（所有者），第二个名称是拥有文件的组。例如：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this case, `jake` is the user (owner), and `devops` is the group.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`jake`是用户（所有者），`devops`是组。
- en: The file access modes are easier to understand than the special flags we just
    covered. Take a look at *Figure 5.2*. The first three letters are the user's access
    mode (the owner of the file). This particular example has `rw-`, which means that
    the user can read and write the file but not execute it. If the user were to be
    able to execute it, that would be denoted by an `x` in the last place.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 文件访问模式比我们刚刚讨论的特殊标志更容易理解。看一下*图5.2*。前三个字母是用户的访问模式（文件的所有者）。这个特定的示例有`rw-`，这意味着用户可以读取和写入文件，但不能执行它。如果用户能够执行它，那将在最后一个位置上用`x`表示。
- en: The middle three letters are for the group access mode (the group that owns
    the file). In this case, the group can only read the file since the group is missing
    both the `w` for write and the `x` for execution.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的三个字母是组访问模式（拥有文件的组）。在这种情况下，由于组缺少写入和执行的`w`和`x`，组只能读取文件。
- en: The last three letters are for all others (not the owner and not in the owner
    group). In this case, everybody else can just read the file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的三个字母是所有其他人（不是所有者，也不在所有者组中）。在这种情况下，其他人只能读取文件。
- en: A full set of permissions would be `rwxrwxrwx`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的权限集将是`rwxrwxrwx`。
- en: Converting access modes between letters and numeric
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在字母和数字之间转换访问模式
- en: 'An **octal number** represents the file access mode. Until we get used to it,
    the easiest way to convert from letters to octal is to use a pen and paper. We
    add all the numbers together in each group where that access bit is set. If it
    is not set (a dash), then we don''t add that number. When we''re finished adding
    each group, we have the access mode:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**八进制数**表示文件访问模式。在我们习惯之前，从字母转换为八进制的最简单方法是使用纸和笔。我们在每个设置了访问位的组中将所有数字相加。如果没有设置（破折号），那么我们就不添加那个数字。当我们完成每个组的添加时，我们就得到了访问模式：'
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding octal access mode is therefore 644\. Let''s do another example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的八进制访问模式是644。让我们再举一个例子：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding access mode turns out to be 775\. Let''s take one more example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的访问模式结果是775。让我们再举一个例子：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This access mode is 600.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个访问模式是600。
- en: 'The other way around can also be done by using a pen and paper. Let''s say
    we have the access mode 750, and we want to convert that into letters:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用纸和笔来做相反的事情。假设我们有访问模式750，我们想把它转换成字母：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Hence, 750 becomes `rwxr-x---`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，750变成了`rwxr-x---`。
- en: When you have been doing it for a while, you learn the most commonly used access
    modes and don't need a pen and paper anymore.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你做了一段时间后，你会学会最常用的访问模式，不再需要纸和笔。
- en: The file mode in octal
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 八进制文件模式
- en: 'The same principle applies here as with the file access mode. Remember that
    the set-user-ID is denoted by an `s` in the user''s execute position, and the
    set-group-ID is denoted by an `s` in the group''s execute bit. A `t` character
    denotes the sticky bit in the last execute bit position (the "others"). If we
    write it in a row, we get this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件访问模式一样，这里也适用相同的原则。记住，用户ID由用户的执行位置上的`s`表示，组ID由组的执行位上的`s`表示。`t`字符表示最后一个执行位位置（“其他”）的粘性位。如果我们把它写在一行上，就会得到这样：
- en: '[PRE47]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So if only the set-user-ID bit is set, we get a 4\. If both the set-user-ID
    and set-group-ID is set, we get *4+2=6*. If only the set-group-ID bit is set,
    we get a 2\. If only the sticky bit is set, we get a 1, and so forth. And if all
    the bits are set, we get a *7 (4+2+1)*.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果只设置了用户ID位，我们得到4。如果同时设置了用户ID和组ID，我们得到*4+2=6*。如果只设置了组ID位，我们得到2。如果只设置了粘性位，我们得到1，依此类推。如果所有位都设置了，我们得到*7（4+2+1）*。
- en: These file modes are represented by a number before the file access mode. For
    example, the octal file mode `4755` has the set-user-ID bit set (the 4).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件模式由文件访问模式之前的数字表示。例如，八进制文件模式`4755`设置了用户ID位（4）。
- en: 'When we program under Linux, we can even encounter two more numbers, as we
    saw with the output from our `my-stat-v2` program. There, we had this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Linux下编程时，我们甚至可能会遇到另外两个数字，就像我们从`my-stat-v2`程序的输出中看到的那样。在那里，我们有这样的：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The two first numbers, `10` in this example, are the file type. Exactly what
    these two first numbers mean is something we''ll have to look up in the `man 7
    inode` manual page. There we have a nice table telling us what it means. I have
    made a simplified list here, showing only the first two numbers we are interested
    in and what file type it represents:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个数字，在这个例子中是`10`，是文件类型。这两个数字的确切含义是我们需要在`man 7 inode`手册页中查找的。那里有一个很好的表告诉我们它的含义。我在这里列出了一个简化的列表，只显示我们感兴趣的前两个数字以及它代表的文件类型：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: That means that our example file is a regular file (10).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的示例文件是一个普通文件（10）。
- en: 'If we add up everything we just learned and translate the file mode *100755*
    from the preceding example output from `my-stat-v2`, we get this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们把刚刚学到的所有东西加起来，并将前面示例输出的`my-stat-v2`中的文件模式*100755*转换成数字，我们得到这样：
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The file type is also denoted by a letter at the very first position (see *Figure
    5.2*). The letters are as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型也由第一个位置的字母表示（见*图5.2*）。这些字母如下：
- en: '[PRE60]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Setting access rights and ownership
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置访问权限和所有权
- en: In the previous recipe, we learned how to read the `chmod` command and the `chmod()`
    system call. We will also learn how to change the owner and group of a file, using
    both the `chown` command and the `chown()` system call.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们学习了如何读取`chmod`命令和`chmod()`系统调用。我们还将学习如何改变文件的所有者和组，使用`chown`命令和`chown()`系统调用。
- en: Knowing how to set access rights properly will help you keep your systems and
    files secure.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何正确设置访问权限将有助于保护您的系统和文件安全。
- en: Getting ready
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll only need what's listed in the *Technical requirements*
    section of this chapter. It's also a good idea to read the previous recipe to
    understand permissions in Linux. You will also need the `my-stat-v2` program from
    the previous recipe.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你只需要本章*技术要求*部分列出的内容。阅读上一个配方以理解Linux中的权限也是一个好主意。你还需要上一个配方中的`my-stat-v2`程序。
- en: How to do it…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: These steps will teach us how to change the access rights and ownership of files
    and directories.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将教会我们如何更改文件和目录的访问权限和所有权。
- en: Access rights
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问权限
- en: 'We will start by setting the access rights of a file by using the `chmod` command.
    We will then write a simple C version of the `chmod` command, using the `chmod()`
    system call:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用`chmod`命令设置文件的访问权限。然后，我们将编写`chmod`命令的简单C版本，使用`chmod()`系统调用：
- en: 'Let''s start by removing the execute permission from our `my-stat-v2` program,
    using the `chmod` command. The `-x` in the following command means *remove eXecute*:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先使用`chmod`命令从我们的`my-stat-v2`程序中删除执行权限。以下命令中的`-x`表示*删除执行*：
- en: '[PRE67]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now let''s try to execute the program. This should now fail with permission
    denied:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们尝试执行程序。这次应该因为权限被拒绝而失败：
- en: '[PRE68]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now we change it back again, but this time we set the *absolute* permission
    using octal numbers. Suitable permissions for executable files are 755, which
    translates to `rwxr-xr-x`. That, in turn, means that the user has full permissions
    and, the group can read and execute the file. The same goes for all others; they
    can read and execute it:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们再次改回来，但这次我们使用八进制数字设置*绝对*权限。可执行文件的适当权限是755，对应`rwxr-xr-x`。这意味着用户有完全权限，组可以读取和执行文件。其他所有人也一样；他们可以读取和执行它：
- en: '[PRE69]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'After this command, we can once again execute the program:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个命令之后，我们可以再次执行程序：
- en: '[PRE70]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now it''s time to write a simple version of the `chmod` command, using the
    `chmod()` system call. Write the following code in a file and save it as `my-chmod.c`.
    The `chmod()` system call takes two arguments, the path to the file or directory
    and the file permission expressed as an octal number. Before we get to the `chmod()`
    system call, we perform some checks to ensure that the permission seems reasonable
    (an octal number that is either three or four digits long). After the checks,
    we convert the number to an octal number with `strtol()`. The third argument to
    `strtol()` is the base, in this case, `8`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候编写`chmod`命令的简单版本，使用`chmod()`系统调用。将以下代码写入文件并保存为`my-chmod.c`。`chmod()`系统调用接受两个参数，文件或目录的路径和以八进制数表示的文件权限。在进行`chmod()`系统调用之前，我们进行一些检查，以确保权限看起来合理（一个三位或四位数的八进制数）。检查后，我们使用`strtol()`将数字转换为八进制数。`strtol()`的第三个参数是基数，这里是`8`：
- en: '[PRE71]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now compile the program:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译程序：
- en: '[PRE72]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Test the program using different permissions. Don''t forget to check the result
    using `ls -l`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不同的权限测试程序。不要忘记使用`ls -l`检查结果：
- en: '[PRE73]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let''s also try to set the set-user-ID bit. This set-user-ID bit (and set-group-ID
    and sticky bit) is the fourth digit in front of the access mode. A `4` here sets
    the set-user-ID bit. Note the `s` (highlighted in the following code) in the user
    field:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也尝试设置设置用户ID位。这里的设置用户ID位（以及设置组ID位和粘性位）是访问模式前面的第四位数字。这里的`4`设置了设置用户ID位。请注意用户字段中的`s`（在下面的代码中突出显示）：
- en: '[PRE74]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s try to set all bits (set-user-ID, set-group-ID, sticky bit, and all
    permissions):'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试设置所有位（设置用户ID、设置组ID、粘性位和所有权限）：
- en: '[PRE75]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'And finally, change it back to something more sensible:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将其改回更合理的东西：
- en: '[PRE76]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Ownership
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有权
- en: 'But we also need to know how to change the `chown` command or the `chown()`
    system call:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也需要知道如何改变`chown`命令或`chown()`系统调用：
- en: 'To change the owner of a file, we must be root. Regular users cannot give away
    ownership of their files. Likewise, they cannot claim ownership of someone else''s
    files. Let''s try to change the owner of `my-stat-v2` to root using the `chown`
    command:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要改变文件的所有者，我们必须是root。普通用户不能放弃对他们的文件的所有权。同样，他们也不能声明对别人的文件的所有权。让我们尝试使用`chown`命令将`my-stat-v2`的所有者更改为root：
- en: '[PRE77]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If we want to change both the owner and the group, we separate the user and
    the group using a colon. The first field is the owner, and the second field is
    the group:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要改变所有者和组，我们使用冒号分隔用户和组。第一个字段是所有者，第二个字段是组：
- en: '[PRE78]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And now it''s our turn to write a simplified version of `chown`, using the
    `chown()` system call. The `chown()` system call only takes user IDs as numerical
    values. To be able to use names instead, we must first look up the username using
    `getpwnam()`. This will give us the numerical value in the `passwd` struct, in
    the `pw_uid` field. The same goes for the group. We must get the numerical group-ID
    using its name, using the `getgrnam()`system call. Now that we know all the system
    calls, let''s write the program. Name it `my-chown.c`. This program is a bit longer,
    so I have split it up into several steps. Keep in mind that all steps should go
    into a single file (`my-chown.c`). You can also download the entire code from
    [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch5/my-chown.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch5/my-chown.c)
    if you wish. Let''s start with all the header files, the variables, and the arguments
    check:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在轮到我们编写一个简化版本的`chown`，使用`chown()`系统调用。`chown()`系统调用只接受用户ID作为数值。为了能够使用名称，我们必须首先使用`getpwnam()`查找用户名。这将在`passwd`结构中的`pw_uid`字段中给我们数值。对于组也是一样。我们必须使用`getgrnam()`系统调用使用其名称获取数值组ID。现在我们知道了所有的系统调用，让我们写程序。将其命名为`my-chown.c`。这个程序有点长，所以我把它分成了几个步骤。请记住，所有步骤都应该放在一个文件（`my-chown.c`）中。如果愿意，您也可以从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch5/my-chown.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch5/my-chown.c)下载整个代码。让我们从所有的头文件、变量和参数检查开始：
- en: '[PRE79]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Since we write the username and group as `username:group` in the argument,
    we need to extract the username part and the group part. We do this with a string
    function called `strtok()`. We only provide the first argument (the string) in
    the first call to `strtok()`. After this, we get the `user` struct and the `grp`
    struct. We also check whether the user and group exist:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将用户名和组写为`username:group`在参数中，我们需要提取用户名部分和组部分。我们使用一个名为`strtok()`的字符串函数来做到这一点。在第一次调用`strtok()`时，我们只提供第一个参数（字符串）。之后，我们得到`user`结构和`grp`结构。我们还检查用户和组是否存在：
- en: '[PRE80]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, we update the user and group of the file using the `chown()` system
    call:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`chown()`系统调用来更新文件的用户和组：
- en: '[PRE81]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let''s compile the program so that we can try it:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译程序，这样我们就可以尝试它：
- en: '[PRE82]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now we test the program on a file. Remember that we need to be root to change
    a file''s owner and group:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们在一个文件上测试程序。请记住，我们需要以root身份更改文件的所有者和组：
- en: '[PRE83]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works…
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Every file and directory on the system has access rights and an owner/group
    pair. The access rights are changed with the `chmod` command or the `chmod()`
    system call. The name is short for *change mode bits*. In the previous recipe,
    we covered how to translate access rights between the more human-readable text
    format and the numerical octal form. In this recipe, we wrote a program that changed
    the mode bits using the `chmod()` system call using the numerical form.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 系统上的每个文件和目录都有访问权限和一个所有者/组对。访问权限可以使用`chmod`命令或`chmod()`系统调用来更改。该名称是*更改模式位*的缩写。在上一个示例中，我们介绍了如何在更人类可读的文本格式和数字八进制格式之间转换访问权限。在这个示例中，我们编写了一个使用`chmod()`系统调用使用数字形式更改模式位的程序。
- en: To convert the numerical form into an octal number, we used `strtol()` with
    `8` as the third argument, which is the numeral system base. Base 8 is octal;
    base 10 is the regular decimal system we use in everyday life; base 16 is hexadecimal,
    and so on.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将数字形式转换为八进制数，我们使用`strtol()`和`8`作为第三个参数，这是数字系统的基数。基数8是八进制；基数10是我们在日常生活中使用的常规十进制系统；基数16是十六进制，依此类推。
- en: We wrote the program so that the user can choose whatever they want to set,
    whether that's only the access mode bits (three digits) or also the special bits
    such as set-user-ID, set-group-ID, and sticky bit (four digits). To determine
    the number of digits the user typed, we use `strlen()`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了程序，以便用户可以选择他们想要设置的任何内容，无论是只有访问模式位（三位数）还是特殊位，如设置用户ID、设置组ID和粘性位（四位数）。为了确定用户输入的数字位数，我们使用`strlen()`。
- en: In the next program we wrote, we used `chown()` to update the owner and group
    of a file or directory. Since we want to update the user and group using the names,
    not the numerical UID and GID, the program got more complex. The `chown()`system
    call only takes the UID and GID, not names. That means we need to look up the
    UID and GID before we can call `chown()`. To look up the UID and GID, we use `getpwnam()`
    and `getgrnam()`. Each of these functions gives us a `struct` containing all information
    available for the respective user or group. From those structs, we extract the
    UID and GID, which we then use in the call to `chown()`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个程序中，我们使用`chown()`来更新文件或目录的所有者和组。由于我们想要使用名称而不是数字UID和GID来更新用户和组，程序变得更加复杂。`chown()`系统调用只接受UID和GID，而不是名称。这意味着我们需要在调用`chown()`之前查找UID和GID。为了查找UID和GID，我们使用`getpwnam()`和`getgrnam()`。这些函数中的每一个都给我们一个包含相应用户或组的所有可用信息的`struct`。从这些结构中，我们提取UID和GID，然后在调用`chown()`时使用它们。
- en: To separate the username and group part from the command line (the colon), we
    use the `strtok()` function. In the first call to the function, we specify the
    string as the first argument (in this case, `argv[1]`) and the separator (a colon).
    In the next call to `strtok()`, we leave out the string by setting it to `NULL`,
    but we still specify the separator. The first call gives us the username and the
    second call gives us the group name.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从命令行中分离用户名和组部分（冒号），我们使用`strtok()`函数。在对函数的第一次调用中，我们将字符串指定为第一个参数（在本例中为`argv[1]`），并指定分隔符（冒号）。在对`strtok()`的下一次调用中，我们将字符串设置为`NULL`，但仍然指定分隔符。第一次调用给我们用户名，第二次调用给我们组名。
- en: After that, we check whether the username and group name exist when we call
    `getpwnam()` and `getgrnam()`. If the username or group name don't exist, the
    functions return `NULL`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，当我们调用`getpwnam()`和`getgrnam()`时，我们检查用户名和组名是否存在。如果用户名或组名不存在，函数将返回`NULL`。
- en: There's more…
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are several similar functions to `getpwnam()` and `getgrnam()`, depending
    on what information you have and what information you have. If you have the UID,
    you instead use `getpwuid()`. Likewise, if you have the GID, you use `getgrgid()`.
    There is more information—and more functions—if you read the `man 3 getpwnam`
    and `man 3 getgrnam` manual pages.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个类似的函数可以使用`getpwnam()`和`getgrnam()`，具体取决于您拥有的信息和您拥有的信息。如果您有UID，您可以使用`getpwuid()`。同样，如果您有GID，您可以使用`getgrgid()`。如果您阅读`man
    3 getpwnam`和`man 3 getgrnam`手册页面，将会有更多的信息和更多的函数。
- en: Writing to files with file descriptors
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件描述符写入文件
- en: We have already seen some uses of **file descriptors** in previous chapters,
    for example, 0, 1, and 2 (*stdin*, *stdout*, and *stderr*). But in this recipe,
    we will use file descriptors to write text to files from a program.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们已经看到了**文件描述符**的一些用法，例如0、1和2（*stdin*、*stdout*和*stderr*）。但在这个示例中，我们将使用文件描述符从程序中写入文本到文件。
- en: Knowing how to use file descriptors to write to files both gives you a deeper
    understanding of the system and enables you to do some low-level stuff.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用文件描述符来写入文件既可以让您更深入地了解系统，也可以让您做一些底层的事情。
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you only need what is listed under the *Technical requirements*
    section.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您只需要在*技术要求*部分列出的内容。
- en: How to do it…
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here we will write a small program that writes text to a file:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写一个小程序来向文件写入文本：
- en: 'Write the following code in a file and save it as `fd-write.c`. The program
    takes two arguments: a string and a filename. To write to a file using file descriptors,
    we must first open the file with the `open()` system call. The `open()` system
    call returns a file descriptor, which is an integer. We then use that file descriptor
    (the integer) with the `write()` system call. We have already seen `write()` in
    [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*, Diving Deep into
    C in Linux*. In that chapter, we used `write()` to write a small text to stdout.
    This time, we use `write()` to write a text to a file. Notice that the `open()`
    system call takes three arguments: the path to the file, which mode the file shall
    open in (in this case, create the file if it doesn''t exist, and open it in read-write
    mode), and the `0644`):'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码，并将其保存为`fd-write.c`。该程序接受两个参数：一个字符串和一个文件名。要使用文件描述符写入文件，我们必须首先使用`open()`系统调用打开文件。`open()`系统调用返回一个文件描述符，这是一个整数。然后我们使用该文件描述符（整数）与`write()`系统调用。我们已经在[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*中看到了`write()`，在那一章中，我们使用`write()`将一个小文本写入标准输出。这一次，我们使用`write()`将文本写入文件。请注意，`open()`系统调用接受三个参数：文件的路径，文件应该以哪种模式打开（在这种情况下，如果文件不存在则创建文件，并以读写模式打开），以及`0644`）：
- en: '[PRE84]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let''s compile the program:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译这个程序：
- en: '[PRE85]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And let''s try to write some text to a file. Remember that if the file already
    exists, the content will be overwritten! If the new text is smaller than the old
    content of the file, only the beginning will be overwritten. Also note that if
    the text doesn''t contain a new line, the text in the file won''t contain a new
    line either:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试向文件中写入一些文本。请记住，如果文件已经存在，内容将被覆盖！如果新文本比文件的旧内容小，那么只有开头会被覆盖。还要注意，如果文本不包含换行符，那么文件中的文本也不会包含换行符：
- en: '[PRE86]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'We can even give it input from another file if we use `xargs`, a program that
    allows us to take the output of a program and parse it as a command-line argument
    to another program. Notice that this time, `testfile1` will have a new line at
    the end. The `-0` option to `xargs` makes it ignore new lines and will instead
    use the null character to indicate the end of the argument:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以从另一个文件中输入内容，如果我们使用`xargs`，这是一个允许我们将程序的输出解析为另一个程序的命令行参数的程序。请注意，这一次，`testfile1`将在末尾有一个换行符。`xargs`的`-0`选项使其忽略换行符，而是使用空字符来表示参数的结尾：
- en: '[PRE87]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: How it works…
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `open()` system call returns a file descriptor, which we save in the `fd`
    variable. A file descriptor is just an integer, just as 0, 1, and 3 are *stdin*,
    *stdout*, and *stderr*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()`系统调用返回一个文件描述符，我们将其保存在`fd`变量中。文件描述符只是一个整数，就像0、1和3是*stdin*、*stdout*和*stderr*一样。'
- en: The second argument we give to `open()` are macros with mode bits that are put
    together using *bitwise-or*. In our case, we use both `O_CREAT` and `O_RDWR`.
    The first one, `O_CREAT`, means that if the file doesn't exist, it is created.
    The second one, `O_RDWR`, means that the file should be open for both reading
    and writing.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给`open()`的第二个参数是使用*按位或*组合在一起的模式位的宏。在我们的情况下，我们同时使用`O_CREAT`和`O_RDWR`。第一个`O_CREAT`表示如果文件不存在，则创建文件。第二个`O_RDWR`表示文件应该同时用于读取和写入。
- en: To write the string to the file, we pass the file descriptor to `write()` as
    the first argument. As the second argument, we give it `argv[2]`, which contains
    the string that we want to write to the file descriptor. The last argument is
    the size of what we want to write. In our case, we get the size of `argv[2]` with
    `strlen`, a function from `string.h` to get the length of strings.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串写入文件，我们将文件描述符作为第一个参数传递给`write()`。作为第二个参数，我们给它`argv[2]`，其中包含我们要写入文件描述符的字符串。最后一个参数是我们要写入的内容的大小。在我们的情况下，我们使用`strlen`来获取`argv[2]`的大小，这是`string.h`中的一个函数，用于获取字符串的长度。
- en: Just as in the previous recipes, we check all the system calls for `-1`. If
    they return `-1`, something has gone wrong, and we use `perror()` to print an
    error message, and then we return `1`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在以前的食谱中一样，我们检查所有系统调用是否返回`-1`。如果它们返回`-1`，则表示出现了问题，我们使用`perror()`打印错误消息，然后返回`1`。
- en: There's more…
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: When a program returns normally, all open file descriptors are closed automatically.
    But if we want to close a file descriptor explicitly, we use the `close()` system
    call with the file descriptor as its argument. In our case, we could have added
    `close(fd)` just before the return.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序正常返回时，所有打开的文件描述符都会自动关闭。但是，如果我们想显式关闭文件描述符，我们可以使用`close()`系统调用，并将文件描述符作为其参数。在我们的情况下，我们可以在返回之前添加`close(fd)`。
- en: 'There''s a lot of good information about `open()`, `close()`, and `write()`
    in the manual pages. I suggest you read them for more in-depth information. You
    can read them with the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 手册页面中有关`open()`、`close()`和`write()`的很多有用信息。我建议您阅读它们以获取更深入的信息。您可以使用以下命令阅读它们：
- en: '`man 2 open`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 2 open`'
- en: '`man 2 close`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 2 close`'
- en: '`man 2 write`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 2 write`'
- en: Reading from files with file descriptors
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件描述符从文件中读取
- en: In the previous recipe, we learned how to write to files using file descriptors.
    In this recipe, we will learn how to read from files using file descriptors. We
    will therefore write a small program that is similar to `cat`. It takes one argument—a
    filename—and prints its content to standard output.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中，我们学会了如何使用文件描述符写入文件。在这个食谱中，我们将学习如何使用文件描述符从文件中读取。因此，我们将编写一个类似于`cat`的小程序。它接受一个参数——文件名，并将其内容打印到标准输出。
- en: Knowing how to read—and use—file descriptors enables you to read not only files
    but all sorts of data that comes through a file descriptor. File descriptors are
    a universal way to read and write data in Unix and Linux.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何读取和使用文件描述符使您不仅可以读取文件，还可以读取通过文件描述符传输的各种数据。文件描述符是在Unix和Linux中读取和写入数据的通用方式。
- en: Getting ready
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The only things you'll need for this recipe are listed under the *Technical
    requirements* section of this chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱所需的唯一物品在本章的*技术要求*部分列出。
- en: How to do it…
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Reading a file using a file descriptor is similar to writing to one. Instead
    of using the `write()` system call, we will instead use the `read()` system call.
    Before we can read the content, we must figure out the size of the file first.
    We can use the `fstat()` system call for this, which gives us information about
    a file descriptor:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件描述符读取文件与写入文件类似。我们将使用`read()`系统调用，而不是使用`write()`系统调用。在我们读取内容之前，我们必须先找出文件的大小。我们可以使用`fstat()`系统调用来获取这个信息，它会给我们关于文件描述符的信息：
- en: 'Write the following code in a file and name it `fd-read.c`. Notice how we get
    the file information using `fstat()` and then read the data with `read()`. We
    still use the `open()` system call, but this time we have removed `O_CREATE` and
    changed `O_RDRW` to `O_RDONLY` to only allow reads. We will use a buffer size
    of 4,096 here so that we will be able to read some bigger files. This program
    is a bit longer, so I have split it up into several steps. All of the code in
    all of the steps goes into one file, though. First, we start by writing all the
    `include` lines, the variables, and the argument check:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入一个文件，并将其命名为`fd-read.c`。注意我们如何使用`fstat()`获取文件信息，然后使用`read()`读取数据。我们仍然使用`open()`系统调用，但这次我们已经移除了`O_CREATE`并将`O_RDRW`更改为`O_RDONLY`以只允许读取。我们将在这里使用缓冲区大小为4,096，以便能够读取一些更大的文件。这个程序有点长，所以我把它分成了几个步骤。所有步骤中的代码都放在一个文件中。首先，我们从编写所有的`include`行、变量和参数检查开始：
- en: '[PRE88]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, we write the code that opens the file descriptor using the `open()` system
    call. We add some error handling to it as well by wrapping it in an `if` statement:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们编写打开文件描述符的代码，使用`open()`系统调用。我们还添加了一些错误处理，将其包装在一个`if`语句中：
- en: '[PRE89]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, we write the code that fetches the file''s size using the `fstat()` system
    call. Here we also check whether the file''s size is bigger than `MAXSIZE`, in
    which case we set `maxread` to `MAXSIZE-1`. Otherwise, we set it to the file''s
    size. Then, we read the file using the `read()` system call. And finally, we print
    the content using `printf()`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们编写代码，使用`fstat()`系统调用获取文件的大小。在这里，我们还检查文件的大小是否大于`MAXSIZE`，如果是，我们将`maxread`设置为`MAXSIZE-1`。否则，我们将其设置为文件的大小。然后，我们使用`read()`系统调用读取文件。最后，我们使用`printf()`打印内容：
- en: '[PRE90]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Let''s compile the program:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译程序：
- en: '[PRE91]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Let''s try it on some files and see if we can read them:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试在一些文件上运行它，看看我们是否可以读取它们：
- en: '[PRE92]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: How it works…
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When we read data from a file descriptor, we must specify how many characters
    should be read. Here we must be careful not to overflow the buffer. We also don't
    want to read any more than what the file actually contains. To solve all of this,
    we first find out the file's size by using `fstat()`. That function gives us the
    same information as we saw previously in the `my-stat-v2` program when we used
    `stat()`. These two functions, `stat()` and `fstat()`, do the same thing, but
    they operate on different things. The `stat()` function operates directly on a
    file, but `fstat()` operates on a file descriptor. Since we already have a file
    descriptor open to the correct file, it makes sense to use that instead. Both
    functions save their information to a struct called `stat`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从文件描述符中读取数据时，我们必须指定要读取多少个字符。在这里，我们必须小心不要溢出缓冲区。我们也不想读取比文件实际包含的更多内容。为了解决所有这些问题，我们首先使用`fstat()`找出文件的大小。该函数给我们提供了与我们之前在`my-stat-v2`程序中使用`stat()`看到的相同的信息。这两个函数`stat()`和`fstat()`做着相同的事情，但它们作用于不同的对象。`stat()`函数直接作用于文件，而`fstat()`作用于文件描述符。由于我们已经打开了正确文件的文件描述符，因此使用它是有意义的。这两个函数都将它们的信息保存到一个名为`stat`的结构体中。
- en: To not overflow the buffer, we check which is bigger, the file size or `MAXSIZE`.
    If the file size is bigger or equal to `MAXSIZE`, we use `MAXSIZE-1` as the maximum
    number of characters to read. Otherwise, we use the file's size as the maximum.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不溢出缓冲区，我们检查文件大小和`MAXSIZE`哪个更大。如果文件大小大于或等于`MAXSIZE`，我们使用`MAXSIZE-1`作为要读取的最大字符数。否则，我们使用文件的大小作为最大值。
- en: The `read()` system call takes the same arguments as `write()`, namely a file
    descriptor, a buffer, and the size we want to read (or write in the case of `write()`).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`read()`系统调用和`write()`接受相同的参数，即文件描述符、缓冲区和要读取的大小（或者在`write()`的情况下是要写入的大小）。'
- en: Since what we read in from a file is a bunch of characters, we can print the
    entire buffer to stdout using the regular `printf()`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从文件中读取的是一堆字符，我们可以使用常规的`printf()`将整个缓冲区打印到stdout。
- en: There's more…
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you look up `man 2 fstat`, you'll notice that it's the same manual page as
    `man 2 stat`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查阅`man 2 fstat`，您会注意到它与`man 2 stat`是同一个手册页。
- en: Writing to files with streams
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件流写入文件
- en: In this recipe, we will write to files using **file streams** instead of file
    descriptors, as we did in earlier recipes.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本篇中，我们将使用**文件流**而不是文件描述符来写入文件，就像我们在之前的篇章中所做的那样。
- en: As with the previous recipes where we had already seen file descriptors 1, 2,
    and 3, and some of their system calls, we have already seen file streams too,
    such as some of the `printUsage()` functions we have created. Some of these functions
    we created took two arguments, the first one being declared as `FILE *stream`.
    The argument we provided was stderr or stdout.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前我们已经看到的文件描述符1、2和3以及它们的一些系统调用一样，我们也已经看到了文件流，比如我们创建的一些`printUsage()`函数。我们创建的一些函数接受两个参数，第一个声明为`FILE
    *stream`。我们提供的参数是stderr或stdout。
- en: But we can also use file streams to write to files, which we will do in this
    recipe.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们也可以使用文件流来写入文件，这就是本篇中要做的事情。
- en: As you probably have noticed by now, some things keep coming again and again,
    such as file descriptors and file streams.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，一些东西一遍又一遍地出现，比如文件描述符和文件流。
- en: Working with file streams instead of file descriptors has some advantages. For
    example, with file streams, we can use functions such as `fprintf()` to write
    to files. This means that there are more—and more powerful—functions to read and
    write data.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件流而不是文件描述符有一些优势。例如，使用文件流，我们可以使用`fprintf()`等函数来写入文件。这意味着有更多和更强大的函数来读写数据。
- en: Getting ready
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we only need what's listed under the *Technical requirements*
    section of this chapter.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们只需要本章节“技术要求”部分列出的内容。
- en: How to do it…
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Here we write a program that writes text to a file. The program will be similar
    to what we wrote previously using file descriptors. But this time, we will read
    the text from stdin instead of from the command line. We will also write the text
    using a file stream instead of a file descriptor:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们编写一个将文本写入文件的程序。该程序将类似于我们之前使用文件描述符编写的内容。但这次，我们将从标准输入而不是从命令行读取文本。我们还将使用文件流而不是文件描述符来写入文本：
- en: 'Write the following code in a file and name it `stream-write.c`. Notice how
    much smaller this program is even though we have added a `while` loop to read
    everything from stdin. Since we can use all functions in C that operate on streams,
    we don''t need to use any special system calls to read, write, and so on. We haven''t
    even included any special header files, except `stdio.h`, which we always include
    anyway. We write the text to the file with `fprintf()`, as we have already seen
    many times when we write to stdout or stderr:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入文件并命名为`stream-write.c`。请注意，尽管我们已经添加了一个`while`循环来从标准输入读取所有内容，但这个程序要小得多。由于我们可以使用在流上操作的所有C函数，因此我们不需要使用任何特殊的系统调用来读取、写入等。我们甚至没有包含任何特殊的头文件，除了我们总是包含的`stdio.h`。我们使用`fprintf()`将文本写入文件，就像我们在写入stdout或stderr时已经看到的那样：
- en: '[PRE93]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Let''s compile the program:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译程序：
- en: '[PRE94]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now let''s try the program, both by typing in data to it and by redirecting
    data to it using a pipe. After we have redirected the entire password file into
    a new file using our program, we check that they are the same using `diff`, which
    they should be. We also try to write to a new file in a directory, which we haven''t
    got permission to. When we press *Ctrl* + *D*, we send an **EOF** to the program,
    meaning **End Of File**, indicating no more data is to be received:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们尝试该程序，一种是通过向其输入数据，另一种是通过使用管道重定向数据。在我们使用程序将整个密码文件重定向到新文件后，我们使用`diff`检查它们是否相同，它们应该是相同的。我们还尝试向一个没有权限的目录中写入新文件。当我们按下*Ctrl*
    + *D*时，我们向程序发送**EOF**，表示不再接收更多数据：
- en: '[PRE95]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: How it works…
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: As you might have noticed, this program is much shorter and easier than the
    corresponding file descriptor version we wrote earlier in this chapter.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，尽管我们在本章的前面编写的相应文件描述符版本要添加一个`while`循环来从标准输入读取所有内容，但这个程序要比那个版本简短得多。
- en: We start by creating a pointer to a file stream using `FILE *fp`. Then we create
    a buffer that we use for each line.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个指向文件流的指针，使用`FILE *fp`。然后我们创建一个用于每行的缓冲区。
- en: Then, we open the file stream using `fopen()`. That function takes two arguments,
    the filename and the mode. Here the mode is also easier to set, just a `"w"` for
    write.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`fopen()`打开文件流。该函数需要两个参数，文件名和模式。这里的模式也更容易设置，只需使用`"w"`表示写入。
- en: After that, we use a `while` loop to loop over each input line that comes into
    stdin. On each iteration, we write the current line to the file using `fprintf()`.
    As the first argument to `fprintf()` we use the file stream pointer, just as we
    did with stderr in the `if` statement at the top of the program.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用`while`循环来循环处理来自标准输入的每一行输入。在每次迭代中，我们使用`fprintf()`将当前行写入文件。作为`fprintf()`的第一个参数，我们使用文件流指针，就像我们在程序顶部的`if`语句中使用stderr一样。
- en: Before the program returns, we close the file stream with `fclose()`. Closing
    the stream isn't strictly necessary, but it's a good thing to do, just in case.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序返回之前，我们使用`fclose()`关闭文件流。关闭流并不是严格必要的，但以防万一做这件事是件好事。
- en: See also
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There's a lot of information in `man 3 fopen` if you want to dig deeper.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想深入了解，可以在`man 3 fopen`中找到大量信息。
- en: 'For a more in-depth explanation of the difference between file descriptors
    and file streams, see the GNU libc manual: [https://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html](https://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html).'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 有关文件描述符和文件流之间区别的更深入解释，请参阅GNU libc手册：[https://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html](https://www.gnu.org/software/libc/manual/html_node/Streams-and-File-Descriptors.html)。
- en: 'Another important aspect of streams is that they are buffered. There is more
    information about streams buffering in the GNU libc manual at this URL: [https://www.gnu.org/software/libc/manual/html_node/Buffering-Concepts.html](https://www.gnu.org/software/libc/manual/html_node/Buffering-Concepts.html).'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 流的另一个重要方面是它们是有缓冲的。有关流缓冲的更多信息，请参阅GNU libc手册的以下网址：[https://www.gnu.org/software/libc/manual/html_node/Buffering-Concepts.html](https://www.gnu.org/software/libc/manual/html_node/Buffering-Concepts.html)。
- en: Reading from files with streams
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流从文件中读取
- en: Now that we know how to write to a file using streams, we will learn how to
    read a file using streams. In this recipe, we will write a similar program to
    that of the previous recipe. But this time, we will read line by line from a file
    instead and print it to stdout.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用流写入文件，我们将学习如何使用流读取文件。在这个示例中，我们将编写一个类似于上一个示例的程序。但这次，我们将逐行从文件中读取并将其打印到标准输出。
- en: Mastering both the writing and reading of streams will enable you to do many
    things in Linux.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握流的写入和读取将使您能够在Linux中做很多事情。
- en: Getting ready
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All you need for this recipe is listed under the *Technical requirements* section
    of this chapter.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需要本章节“技术要求”部分列出的内容。
- en: How to do it…
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Here we will write a program that will be very similar to the previous recipe,
    but it will read text from a file instead. The principle of the program is the
    same as the previous recipe:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写一个与上一个示例非常相似的程序，但它将从文件中读取文本。该程序的原理与上一个示例相同：
- en: 'Write the following code in a file and save it as `stream-read.c`. Notice how
    similar this program is. We have changed write mode (`"w"`) to read mode (`"r"`)
    when opening the stream with `fopen()`. In the `while` loop, we read from the
    file pointer `fp` instead of stdin. Inside the `while` loop, we print what is
    in the buffer, which is the current line:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码，并将其保存为`stream-read.c`。注意这个程序是多么相似。我们已经改变了写入模式(`"w"`)为读取模式(`"r"`)，当使用`fopen()`打开流时。在`while`循环中，我们从文件指针`fp`而不是标准输入中读取。在`while`循环中，我们打印缓冲区中的内容，也就是当前行：
- en: '[PRE96]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Compile the program:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE97]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'And now we can try the program on some files. Here I try it on the test file
    we created earlier and the Makefile:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在一些文件上尝试这个程序。这里我在之前创建的测试文件和Makefile上尝试它：
- en: '[PRE98]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: How it works…
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As you might have noticed, this program is very similar to that of the previous
    recipe. But instead of opening the file for writing (`"w"`), we instead open it
    for reading (`"r"`). The file pointer looks the same, as well as the linebuffer
    and the error handling.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，这个程序与上一个配方非常相似。但是，我们不是以写入模式(`"w"`)打开文件，而是以读取模式(`"r"`)打开文件。文件指针看起来一样，以及行缓冲区和错误处理。
- en: To read each line, we loop over the file stream using `fgets()`. As you might
    have noticed in both this and the previous recipe, we don't use `sizeof(linebuf)-1`,
    only `sizeof(linebuf)`. That is because `fgets()` only reads *one less* than the
    size we give it.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取每一行，我们使用`fgets()`循环遍历文件流。正如你可能已经注意到的，在这个和上一个配方中，我们没有使用`sizeof(linebuf)-1`，只使用了`sizeof(linebuf)`。这是因为`fgets()`只读取比我们给它的大小*少一个*。
- en: There's more…
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There are a lot of similar functions as `fgets()`. You can find all of them
    by reading the manual page for it with `man 3 fgets`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多类似的函数，比如`fgets()`。你可以通过阅读它的手册页`man 3 fgets`找到所有这些函数。
- en: Reading and writing binary data with streams
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流读取和写入二进制数据
- en: There comes a time when we must save variables or arrays in a program to a file.
    For example, if we make a stock-keeping program for a warehouse, we don't want
    to re-write the entire warehouse stocks every time we start the program. That
    would defeat the purpose of the program. With streams, it's easy to save variables
    as binary data in files for later retrieval.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要将程序中的变量或数组保存到文件中。例如，如果我们为仓库制作一个库存管理程序，我们不希望每次启动程序时都重新编写整个仓库库存。这将违背程序的初衷。使用流，可以轻松地将变量保存为二进制数据文件以供以后检索。
- en: 'In this chapter, we''ll write two small programs: one that asks the user for
    two floats, saves them in an array, and writes them to a file, and another program
    that re-reads that array.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将编写两个小程序：一个要求用户输入两个浮点数，将它们保存在一个数组中，并将它们写入文件，另一个程序重新读取该数组。
- en: Getting ready
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You only need the GCC compiler, the Make tool, and the generic Makefile for
    this recipe.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你只需要GCC编译器、Make工具和通用Makefile。
- en: How to do it…
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll write two small programs: one that writes and one that
    reads binary data. The data is an array of floats:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将编写两个小程序：一个用于写入，一个用于读取二进制数据。数据是一个浮点数数组：
- en: 'Write the following code in a file and save it as `binary-write.c`. Notice
    that we open the file in *write* mode and *binary* mode, indicated by `"wb"` as
    the second argument to `fopen()`. In binary mode, we can write variables, arrays,
    and structures to a file. The array in this program will be written to a file
    called `my-binary-file` in the current working directory. When we write binary
    data with `fwrite()`, we must specify the size of a single element (a `float`
    in this case) and how many of those elements we want to write. The second argument
    to `fwrite()` is the size of a single element and the third argument is the number
    of elements:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码，并将其保存为`binary-write.c`。注意我们以*写入*模式和*二进制*模式打开文件，这由`fopen()`的第二个参数`"wb"`表示。在二进制模式下，我们可以将变量、数组和结构写入文件。这个程序中的数组将被写入到当前工作目录中名为`my-binary-file`的文件中。当我们使用`fwrite()`写入二进制数据时，我们必须指定单个元素的大小（在这种情况下是`float`）以及我们想要写入的元素数量。`fwrite()`的第二个参数是单个元素的大小，第三个参数是元素的数量：
- en: '[PRE99]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Before moving on, let''s compile this program:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，让我们编译这个程序：
- en: '[PRE100]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Let''s try out the program and verify that it writes the binary file. Since
    it''s a binary file, we can''t read it with programs such as `more`. But we can,
    however, look at it with a program called `hexdump`:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试运行程序，并验证它是否写入了二进制文件。由于它是一个二进制文件，我们无法使用`more`等程序来读取它。但是，我们可以使用一个名为`hexdump`的程序来查看它：
- en: '[PRE101]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now it''s time to write the program that reads the array back from the file.
    Write the following code in a file and save it as `binary-ready.c`. Notice that
    we use `"rb"` here, for *read* and *binary*. The arguments to `fread()` are the
    same as `fwrite()`. Also, note that we need to create an array of the same type
    and length here. We will read the data from the binary file into that array:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候编写从文件中重新读取数组的程序了。在文件中写入以下代码，并将其保存为`binary-ready.c`。请注意，我们在这里使用了`"rb"`，表示*读取*和*二进制*。`fread()`的参数与`fwrite()`相同。另外，请注意我们需要在这里创建一个相同类型和长度的数组。我们将从二进制文件中读取数据到该数组中：
- en: '[PRE102]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, let''s compile this program:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编译这个程序：
- en: '[PRE103]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'And finally, let''s run the program. Notice that the numbers printed here are
    the same as those numbers we gave to `binary-write`:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们运行程序。请注意，这里打印的数字与我们给`binary-write`的数字相同：
- en: '[PRE104]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: How it works…
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'What''s important here is `fwrite()` and `fread()`, more specifically the sizes
    we specify:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是`fwrite()`和`fread()`，更具体地说是我们指定的大小：
- en: '[PRE105]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: First off, we have the `x` array. Next, we specify the size of a single element
    or item. In this case, we get the size by using `sizeof(float)`. Then, as the
    third argument, we specify how many of those elements or items. Instead of just
    typing a literal `2` here, we calculate the number of items by taking the full
    size of the array and dividing it by the size of a float. This is done with `sizeof(x)
    / sizeof(float)`. This gives us, in this case, 2.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有`x`数组。接下来，我们指定单个元素或项目的大小。在这种情况下，我们使用`sizeof(float)`来获取大小。然后，作为第三个参数，我们指定这些元素或项目的数量。在这里，我们不只是输入一个字面上的`2`，而是通过取数组的完整大小并除以一个浮点数的大小来计算项目的数量。这是通过`sizeof(x)
    / sizeof(float)`完成的。在这种情况下，这给了我们2。
- en: The reason why it's better to calculate the items rather than just setting a
    number is to avoid errors when updating the code in the future. If we change the
    array to 6 items in a couple of months, chances are that we'll forget to update
    the arguments to `fread()` and `fwrite()`.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 更好地计算项目而不只是设置一个数字的原因是为了避免在将来更新代码时出现错误。如果我们在几个月内将数组更改为6个项目，很可能会忘记更新`fread()`和`fwrite()`的参数。
- en: There's more…
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'If we didn''t know beforehand how many floats the array contained, we could
    have figured it out with the following lines of code. We will learn more about
    `fseek()` later in this chapter:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们事先不知道数组包含多少个浮点数，我们可以用以下代码行来计算出来。我们将在本章后面学习更多关于`fseek()`的知识：
- en: '[PRE106]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Moving around inside a file with lseek()
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`lseek()`在文件内移动
- en: In this recipe, we'll learn how to move around inside a file with `lseek()`.
    This function operates on `lseek()`, we can move around (or **seek**) freely inside
    a file descriptor. Doing so can be handy if we only want to read a specific part
    of a file or we want to go back and read some data twice and so on.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何使用`lseek()`在文件内移动。这个函数操作`lseek()`，我们可以在文件描述符内自由移动（或**寻找**）。这样做可以很方便，如果我们只想读取文件的特定部分，或者我们想返回并读取一些数据两次等。
- en: In this recipe, we will modify our previous program, called `fd-read.c`, to
    specify where we want to start reading. We also make it so that the user can specify
    how many characters should be read from that position.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将修改我们之前的程序，名为`fd-read.c`，以指定我们想要开始阅读的位置。我们还使用户可以指定从该位置读取多少个字符。
- en: Getting ready
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To easier understand this recipe, I encourage you to read the recipe named *Reading
    from files with file descriptors* in this chapter before reading this one.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易理解这个食谱，我鼓励你在阅读这个之前，先阅读本章中名为*使用文件描述符从文件中读取*的食谱。
- en: How to do it…
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'The program we will write here will read a file using file descriptors. The
    user must also set a starting position where the read should start. The user can
    also—optionally—specify how many characters to read from that position:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里编写的程序将使用文件描述符读取文件。用户还必顶一个读取应该从哪里开始的起始位置。用户还可以选择指定从该位置读取多少个字符：
- en: 'Write the following code and save it in a file called `fd-seek.c`. Notice the
    added `lseek()` before we do `read()`. We have also added an extra check (`else
    if`) to check that the user doesn''t read more than what the buffer can hold.
    We have also added a newline character in `printf()` when we print the file to
    stdout. Otherwise, there won''t be a new line when we specify how many characters
    to read, and the prompt would end up on the same line. This program is also rather
    long, so I have split it up into several steps. Keep in mind that all steps go
    into the same file. Let''s begin with the variables and check the number of arguments:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下以下代码并保存在一个名为`fd-seek.c`的文件中。注意在我们进行`read()`之前添加了`lseek()`。我们还添加了一个额外的检查（`else
    if`）来检查用户是否读取的字符数超过了缓冲区的容量。当我们将文件打印到标准输出时，在`printf()`中添加了一个换行符。否则，当我们指定要读取多少个字符时，不会有新的一行，提示符会停留在同一行上。这个程序也相当长，所以我把它分成了几个步骤。请记住，所有步骤都放在同一个文件中。让我们从变量开始并检查参数的数量：
- en: '[PRE110]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Now we open the file using the `open()` system call. Just as before, we check
    the system call for errors by wrapping it in an `if` statement:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用`open()`系统调用打开文件。就像以前一样，我们通过将其包装在`if`语句中来检查系统调用是否出错：
- en: '[PRE111]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'And now, we get the file''s size using the `fstat()` system call. Here we also
    check whether the file is bigger than `MAXSIZE`, in which case we set `maxread`
    to `MAXSIZE-1`. In `else if`, we check whether the user has provided a third argument
    (how much to read), and set `maxread` to whatever the user typed:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用`fstat()`系统调用获取文件的大小。在这里，我们还检查文件是否大于`MAXSIZE`，如果是，我们将`maxread`设置为`MAXSIZE-1`。在`else
    if`中，我们检查用户是否提供了第三个参数（要读取多少），并将`maxread`设置为用户输入的值：
- en: '[PRE112]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'And finally, we write the code to move the read position with `lseek()`. After
    that, we read the content with `read()` and print it with `printf()`:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们编写代码使用`lseek()`移动读取位置。然后，我们使用`read()`读取内容并用`printf()`打印出来：
- en: '[PRE113]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Now compile the program:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译程序：
- en: '[PRE114]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'And let''s try out the program. Here we read the password file and the generic
    Makefile in our current directory:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一下这个程序。在这里，我们读取当前目录中的密码文件和通用Makefile：
- en: '[PRE115]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: How it works…
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `lseek()` function moves the *read head* (sometimes called a *cursor*) inside
    the file descriptor to the position we specify. The cursor then remains at that
    position until we start `read()`. To only read the number of characters that we
    specify as the third argument, we take that argument and assign the value to `maxread`.
    Since `read()` doesn't read any more than `maxread` (the third argument to `read()`),
    only those characters are read. If we don't give the program a third argument,
    `maxread` is set to the file's size or `MAXSIZE`, whichever is the smallest.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`lseek()`函数将*读取头*（有时称为*光标*）移动到我们指定的位置。然后光标保持在那个位置，直到我们开始`read()`。为了只读取我们指定的第三个参数作为字符数，我们将该参数赋值给`maxread`。由于`read()`不会读取超过`maxread`（`read()`的第三个参数）的字符，只有这些字符会被读取。如果我们没有给程序第三个参数，`maxread`将设置为文件的大小或`MAXSIZE`，以较小者为准。'
- en: The third argument to `lseek()`, `SEEK_SET`, is where the cursor should be located
    in relation to the value we give as the second argument. In this case, with `SEEK_SET`,
    it means that the position should be set to whatever we specify as the second
    argument. If we wanted to move the position relative to our current position,
    we would have used `SEEK_CUR` instead. And if we wanted to move the cursor relative
    to the end of the file, we would have used `SEEK_END`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`lseek()`的第三个参数`SEEK_SET`是光标应该相对于我们给出的第二个参数的位置。在这种情况下，使用`SEEK_SET`意味着位置应该设置为我们指定的第二个参数。如果我们想要相对于当前位置移动位置，我们将使用`SEEK_CUR`。如果我们想要相对于文件末尾移动光标，我们将使用`SEEK_END`。'
- en: Moving around inside a file with fseek()
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`fseek()`在文件中移动
- en: Now that we have seen how to `lseek()`, we can see how we can do so in file
    streams with `fseek()`. In this recipe, we will write a similar program to that
    of the previous recipe, but now we will use file streams instead. There will also
    be another difference here, namely, how we specify how long we want to read. In
    the previous recipe, we specified the third argument as the number of characters
    or bytes to read. But in this recipe, we will instead specify a position, that
    is, a *from position* and a *to position*.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用`lseek()`，我们可以看看如何在文件流中使用`fseek()`。在这个示例中，我们将编写一个类似于上一个示例的程序，但现在我们将使用文件流。这里还有另一个区别，即我们如何指定要读取多长时间。在上一个示例中，我们将第三个参数指定为要读取的字符或字节数。但在这个示例中，我们将指定一个位置，即*起始位置*和*结束位置*。
- en: Getting ready
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: I advise you to read the *Reading from files with streams* recipe earlier in
    this chapter before reading this one. That will give you a better understanding
    of what's going on here.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您在阅读本章前面的*使用流从文件中读取*示例之前阅读本节。这将让您更好地理解这里发生了什么。
- en: How to do it…
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will write a program that reads a file from a given position and optionally
    to an end position. If no end position is given, the file is read to the end:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个程序，从给定位置读取文件，可选地到达结束位置。如果没有给出结束位置，则读取文件直到结束：
- en: 'Write the following code in a file and save it as `stream-seek.c`. This program
    is similar to `stream-read.c`, but with the added ability to specify the start
    position and optionally the end position. Notice that we have added `fseek()`
    to set the start position. To abort the read, when we have reached the end position,
    we use `ftell()` to tell us the current position. If the end position is reached,
    we break out of the `while` loop. Also, we no longer read entire lines but individual
    characters. We do this with `fgetc()`. We also print individual characters instead
    of an entire string (line). We do this with `putchar()`. After the loop, we print
    a newline character so that the prompt won''t end up on the same line as the output:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码，并将其保存为`stream-seek.c`。这个程序类似于`stream-read.c`，但增加了指定起始位置和可选的结束位置的能力。请注意，我们已经添加了`fseek()`来设置起始位置。为了中止读取，当我们达到结束位置时，我们使用`ftell()`告诉我们当前位置。如果到达结束位置，我们就跳出`while`循环。此外，我们不再读取整行，而是读取单个字符。我们使用`fgetc()`来实现这一点。我们还打印单个字符而不是整个字符串（行）。我们使用`putchar()`来实现这一点。循环结束后，我们打印一个换行字符，这样提示就不会出现在与输出相同的行上：
- en: '[PRE116]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Now let''s compile it:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们来编译它：
- en: '[PRE117]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'And let''s try it out on some files. We try with both possible combinations:
    only a starting position, and both start and end positions:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在一些文件上试一试。我们尝试两种可能的组合：只有起始位置，以及起始和结束位置：
- en: '[PRE118]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: How it works…
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `fseek()` function works similarly to `lseek()`, as we saw in the previous
    recipe. We specify `SEEK_SET` to tell `fseek()` to seek an absolute position,
    and as the second argument, we specify the position.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`fseek()`函数的工作方式与我们在上一个示例中看到的`lseek()`类似。我们指定`SEEK_SET`来告诉`fseek()`寻找绝对位置，并将位置指定为第二个参数。'
- en: The program is similar to `stream-read.c`, but we have changed how the program
    reads. Instead of reading the entire lines, we read individual characters. This
    is so that we can stop reading at the exact position we specify as the end position.
    That wouldn't be possible if we read line by line. Because we changed the behavior
    to read the file character by character, we have also changed how we print the
    file. Now we print each character with `putchar()` instead.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序类似于`stream-read.c`，但我们已经改变了程序的读取方式。我们不再读取整行，而是读取单个字符。这样我们就可以在指定的结束位置停止读取。如果我们逐行读取，这是不可能的。因为我们改变了按字符读取文件的行为，所以我们也改变了打印文件的方式。现在我们使用`putchar()`逐个打印每个字符。
- en: After each character, we check if we are on or above the specified end position.
    If we are, we `break` out of the loop and end the entire read.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 每个字符后，我们检查是否在指定的结束位置上或以上。如果是，我们就跳出循环并结束整个读取。
- en: There's more…
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There exists a whole family of functions related to `fseek()`. You can find
    them all by reading the `man 3 fseek` manual page.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一整套与`fseek()`相关的函数。您可以通过阅读`man 3 fseek`手册页面找到它们。
