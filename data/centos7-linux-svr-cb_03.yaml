- en: Chapter 3. Managing the System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。系统管理
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Knowing and managing background services
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解和管理后台服务
- en: Troubleshooting background services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决后台服务问题
- en: Tracking system resources with journald
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用journald跟踪系统资源
- en: Configuring journald to make it persistent
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置journald以使其持久化
- en: Managing users and their groups
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理用户及其组
- en: Scheduling tasks with cron
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用cron安排任务
- en: Synchronizing files and doing more with rsync
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用rsync同步文件并执行更多操作
- en: Maintaining backups and taking snapshots
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护备份和创建快照
- en: Monitoring important server infrastructure
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控重要的服务器基础设施
- en: Taking control with Git and Subversion
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Git和Subversion进行控制
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is a collection of recipes that provides for the need to maintain
    a performance-based server solution. From monitoring your free disk space, to
    working with system services and managing the synchronization of remote files,
    the purpose of this chapter is to show you how quickly and easily you can get
    to grips with the task of server maintenance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是一系列解决方案的集合，旨在提供基于性能的服务器维护需求。从监控可用磁盘空间，到处理系统服务和管理远程文件同步，本章的目的是展示你如何快速且轻松地掌握服务器维护任务。
- en: Knowing and managing your background services
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解和管理你的后台服务
- en: Linux system services are one of the most fundamental concepts of every Linux
    server. They are programs which run continuously in your system, waiting for external
    events to process something or do it all the time. Normally, when working with
    your server, a system user will not notice the existence of such a running service
    because it is running as a background process and is therefore not visible. There
    are many services running all the time on any Linux server. These can be a web
    server, database, FTP, SSH or printing, DHCP, or LDAP server to name a few. In
    this recipe, we will show you how to manage and work with them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 系统服务是每个Linux服务器最基本的概念之一。它们是持续在你的系统中运行的程序，等待外部事件来处理某些事务或一直执行。通常，在使用服务器时，系统用户不会注意到这些正在运行的服务，因为它们作为后台进程运行，因此不可见。任何Linux服务器上都有许多服务一直在运行。这些可以是Web服务器、数据库、FTP、SSH或打印、DHCP、或LDAP服务器等。在本操作方法中，我们将展示如何管理和处理它们。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet to facilitate the download of additional packages.
    Some commands shown here use *less* navigation in their output. Read the *Navigating
    text files with less* recipe from [Chapter 2](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 2. Configuring the System"), *Configuring the System* to learn how to
    browse them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此操作，你需要一个具有root权限的CentOS 7操作系统的安装，以及你选择的基于控制台的文本编辑器，以及连接到互联网以便下载额外的软件包。这里展示的一些命令在其输出中使用了*less*导航。请阅读[第2章](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "第2章。系统配置")，*系统配置*中的*使用less浏览文本文件*操作方法，以学习如何浏览它们。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: '`systemctl` is a program that we will use to manage all our background service
    tasks in a CentOS 7 system. Here, we will show you how to use it, taking the Apache
    web server service as an example in order to get familiar with it. For a full
    explanation of Apache, read [Chapter 12](part0098_split_000.html#2TEN41-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 12. Providing Web Services"), *Providing Web Services*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemctl`是一个程序，我们将使用它在CentOS 7系统中管理所有后台服务任务。在这里，我们将展示如何使用它，以Apache Web服务器服务为例，以便熟悉它。要全面了解Apache，请阅读[第12章](part0098_split_000.html#2TEN41-4cf34a6d07944734bb93fb0cd15cce8c
    "第12章。提供Web服务")，*提供Web服务*：'
- en: 'First, we log in as root and install the Apache web server package:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们以root身份登录并安装Apache Web服务器软件包：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next we will check Apache''s service status:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将检查Apache的服务状态：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Start the webserver service in the background and print out it''s status again:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后台启动Web服务器服务并再次打印出其状态：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, let''s print out a list of all services currently running in the background
    of your system; in this list, you should identify the `httpd` service you just
    started:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们打印出系统后台当前运行的所有服务列表；在这个列表中，你应该识别出你刚刚启动的`httpd`服务：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s make a backup of the Apache configuration file:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们备份Apache配置文件：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we will make some changes to the main Apache configuration file using
    sed:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用sed对主Apache配置文件进行一些更改：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, type the following command to stop and start the service and apply our
    changes:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入以下命令来停止和启动服务并应用我们的更改：
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let''s enable the `httpd` service to start automatically at boot time:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们启用`httpd`服务，使其在启动时自动启动：
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last command will show how to restart a service:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个命令将展示如何重启服务：
- en: '[PRE8]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we have seen, the `systemctl` utility can be used to take full control of
    your system's services. The `systemctl` is the control program for `systemd`,
    which is the system and service manager in CentOS 7 Linux. The `systemctl` command
    can be used for a variety of other tasks as well, but here we concentrate on managing
    services.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`systemctl`实用程序可用于完全控制系统的服务。`systemctl`是`systemd`的控制程序，`systemd`是CentOS
    7 Linux中的系统和服务的管理器。`systemctl`命令还可以用于其他各种任务，但在这里我们专注于管理服务。
- en: So, what have we learned from this experience?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们从这次经历中学到了什么？
- en: 'We started this recipe by logging in as root and installed the Apache web server
    package as we want to use it for showing how to manage services in general using
    the `systemctl` program. Apache or the `httpd.service`, as it is called by `systemd`,
    is just an example we will use; other important services that might be running
    in a basic server environment could be `sshd.service`, `mariadb.service`, `crond.service`,
    and so on. Afterwards, we checked httpd''s current status with the `systemctl
    status` command parameter. The output showed us two fields: **Loaded** and **Active**.
    The **Loaded** field tells us if it is currently loaded and if it will automatically
    be started at boot time; the **Active** field denotes whether the service is currently
    running or not. Next, we showed how to start a service using `systemctl`. The
    command''s exact starting syntax for services is the `systemctl start <name of
    the service>.service`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个配方开始，以root身份登录并安装了Apache Web服务器包，因为我们想用它来展示如何使用`systemctl`程序管理服务。Apache或`httpd.service`，正如`systemd`所称的，只是我们将使用的一个例子；在基本服务器环境中可能运行的其他重要服务可能是`sshd.service`、`mariadb.service`、`crond.service`等。之后，我们使用`systemctl
    status`命令参数检查了httpd的当前状态。输出显示了我们两个字段：**Loaded**和**Active**。**Loaded**字段告诉我们它是否当前已加载，以及它是否将在启动时自动启动；**Active**字段表示服务当前是否正在运行。接下来，我们展示了如何使用`systemctl`启动服务。服务的精确启动语法是`systemctl
    start <服务名称>.service`。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By starting a service, the program gets detached from the terminal by forking
    off a new process that gets moved into the background where it runs as a non-interactive
    background process. This is sometimes called **daemon**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启动一个服务，程序通过创建一个新进程并将其移动到后台，使其作为非交互式后台进程运行，从而与终端分离。这有时被称为**守护进程**。
- en: 'Next, after we started the Apache webserver daemon, we then used systemctl''s
    `status` parameter again to show how the status changes if we run it. The output
    shows us that it is currently loaded but disabled on reboot. We also see that
    it is running, along with the latest logging output from this service and other
    detailed information about the process. To get an overview of all status information
    for all services on the system, use `systemctl --type service --all`. A `systemctl`
    service must not be running all the time. Its state can also be stopped, degraded,
    maintained, and so on. Next, we used the following command to get a list of all
    currently running services on your system:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们启动了Apache Web服务器守护进程之后，我们再次使用systemctl的`status`参数来展示如果我们运行它，状态是如何变化的。输出显示该服务当前已加载但在重启时被禁用。我们还看到它正在运行，以及该服务的最新日志输出和其他关于该进程的详细信息。要获取系统上所有服务的所有状态信息的概览，请使用`systemctl
    --type service --all`。`systemctl`服务不必一直运行。它的状态也可以是停止、降级、维护等。接下来，我们使用以下命令获取系统上所有当前正在运行的服务的列表：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see here, we used the `-t` flag in order to filter only for type
    service units. As you may guess, `systemctl` can not only deal with service units,
    but also with a lot of other unit types. `systemd` units are resources `systemd`
    can manage using configuration files, and which encapsulate information about
    services, listening sockets, saved system state snapshots, mounting devices, and
    other objects that are relevant to the system. To get a list of all possible unit
    types, type `systemctl -t help`. These configuration unit files reside in special
    folders in the system, and the type they belong to can be read from the extension;
    all the service unit files have the file extension, `.service` (for example, device
    unit files have the extension, `.device`). There are two places where the system
    stores them. All the `systemd` unit files installed by the basic system during
    installation are in `/usr/lib/systemd/system`, all other services that come from
    installing packages such as Apache or for your own configurations should go to
    `/etc/systemd/system`. We can find our Apache service configuration file exactly
    at `/usr/lib/systemd/system/httpd.service`. Next, we showed the user how to stop
    a service, which is the opposite of starting it, using the syntax, `systemctl
    stop <name of the service>`. Finally, as a last step, we used systemctl's `restart`
    parameter, which just handles the stopping and starting of a service in one step
    with less typing. This is often useful if a service hangs and is unresponsive,
    and you quickly need to reset it to get it working. Before showing how to stop
    and restart a service, we did another important thing. While the Apache service
    was running, we changed its main service configuration file with the `sed` command,
    adding an `-Indexes` option that disables the directory web site file listings,
    and which is a common measure to increase the security of your web server. Since
    the Apache web server was already running and loading its configuration into memory
    during service startup, any changes to this file will never be recognized by the
    running service.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们在这里使用了`-t`标志来过滤仅显示类型服务单元。正如您可能猜到的，`systemctl`不仅可以处理服务单元，还可以处理许多其他单元类型。`systemd`单元是`systemd`可以使用配置文件管理的资源，它们封装了关于服务、监听套接字、保存的系统状态快照、挂载设备以及其他与系统相关的对象的信息。要获取所有可能的单元类型的列表，请键入`systemctl
    -t help`。这些配置单元文件位于系统中的特殊文件夹中，它们所属的类型可以从扩展名中读取；所有服务单元文件都具有文件扩展名`.service`（例如，设备单元文件具有扩展名`.device`）。系统将它们存储在两个地方。所有在安装期间由基本系统安装的`systemd`单元文件都位于`/usr/lib/systemd/system`，所有其他来自安装包（如Apache）的服务或您自己的配置应该放到`/etc/systemd/system`。我们可以在`/usr/lib/systemd/system/httpd.service`找到我们的Apache服务配置文件。接下来，我们向用户展示了如何停止服务，这是启动它的反向操作，使用语法`systemctl
    stop <服务名称>`。最后，作为最后一步，我们使用了systemctl的`restart`参数，它只需一步即可处理服务的停止和启动，减少了输入。如果服务挂起且无响应，并且您需要快速重置它以使其工作，这通常很有用。在展示如何停止和重启服务之前，我们做了另一件重要的事情。当Apache服务正在运行时，我们使用`sed`命令更改了其主要服务配置文件，添加了一个`-Indexes`选项，该选项禁用了目录网站文件列表，这是提高Web服务器安全性的常见措施。由于Apache
    Web服务器已经在运行并在服务启动期间将配置加载到内存中，因此对该文件的任何更改都不会被正在运行的服务识别。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Normally, to apply any configuration file change, running services need a full
    service restart, because configuration files will normally only be loaded during
    startup initialization.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，为了应用任何配置文件的更改，运行的服务需要进行完整的服务重启，因为配置文件通常只在启动初始化期间加载。
- en: 'Now, imagine that your web server is reachable from the Internet and at the
    moment there are a lot of people accessing your web pages or applications in parallel.
    If you restart the Apache normally, the web server will be inaccessible for a
    while (as long as it takes to restart the server) as the process will actually
    end and afterwards start all over again. All the current users would get HTML
    404 error pages if they were to request something at that moment. Also, all the
    current session information would have gone; imagine you have an online web shop
    where people use shopping carts or logging in. All this information would also
    be gone. To avoid the disruption of important services such as the Apache web
    server, some of these services have a `reload` option (but not every service has
    this feature!) that we can apply instead of the `restart` parameter. This option
    just reloads and applies the service''s configuration file, while the service
    itself stays online and does not get interrupted during execution. For Apache,
    you can use the following command-line: `systemctl reload httpd.service`. To get
    a list of all the services that have the reload functionality, use the following
    lines:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你的Web服务器可以从互联网访问，并且此刻有很多人在同时访问你的网页或应用程序。如果你正常重启Apache，Web服务器将有一段时间无法访问（直到服务器重启完成），因为进程实际上会结束，然后重新开始。所有当前用户如果在那时请求内容，都会收到HTML
    404错误页面。此外，所有当前会话信息也会丢失；想象一下，你有一个在线网店，人们使用购物车或登录。所有这些信息也会消失。为了避免重要服务（如Apache Web服务器）的中断，这些服务中的一些具有`reload`选项（但并非每个服务都有此功能！），我们可以应用此选项而不是`restart`参数。此选项只是重新加载并应用服务的配置文件，而服务本身保持在线，执行过程中不会被打断。对于Apache，你可以使用以下命令行：`systemctl
    reload httpd.service`。要获取所有具有重新加载功能的服务列表，请使用以下命令：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'So, having completed this recipe, we can say that we now know how to work with
    the basic `systemctl` parameters to manage services. It can be a very powerful
    program and can be used for much more than only starting and stopping services.
    Also, in this recipe, we have used different names that all mean the same: system
    service, background process, or daemon.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，完成这个配方后，我们可以说我们现在知道如何使用基本的`systemctl`参数来管理服务。它是一个非常强大的程序，可以用于比仅仅启动和停止服务更多的事情。此外，在这个配方中，我们使用了不同的名称，它们都意味着相同：系统服务、后台进程或守护进程。
- en: There's more...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There is another important unit type called `target`. Targets are also unit
    files and there are quite a number of them already available in your system. To
    show them, use the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种重要的单元类型叫做`目标`。目标也是单元文件，你的系统中已经有相当数量的目标可用。要显示它们，请使用以下命令：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Simply said, targets are collections of unit files such as services or other
    targets. They can be used to create runlevel-like environments, which you may
    know from earlier CentOS versions. Runlevels define which services should be loaded
    at which system state. For example, there is a graphical state, or a rescue mode
    state, and so on. To see how the common runlevels correspond to our targets, run
    the following command, which shows us all the symbolic links between them:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，目标是一系列单元文件的集合，如服务或其他目标。它们可以用来创建类似于早期CentOS版本中的运行级别环境。运行级别定义了在系统处于何种状态时应加载哪些服务。例如，有图形状态，或救援模式状态等。要查看常见的运行级别如何对应于我们的目标，可以运行以下命令，该命令显示了它们之间的所有符号链接：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Targets can be dependent on other targets; to get a nice overview of target
    dependencies, we can run the following command to show all dependencies from the
    multi-user target to all the other targets (green means active and red means inactive):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目标可以依赖于其他目标；为了获得目标依赖关系的良好概览，我们可以运行以下命令，显示从多用户目标到所有其他目标的所有依赖关系（绿色表示活跃，红色表示不活跃）：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can show the current target that we are in at the moment with:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令显示我们当前所在的目标：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also switch to another target:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以切换到另一个目标：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Troubleshooting background services
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除后台服务
- en: Often, a big part of every system administrator's work is troubleshooting the
    server when something goes wrong. This is especially true for your system's services,
    as they are constantly running and processing information all the time. Services
    can be dependent on other services and on the server's system, and there will
    be situations in your administrator's life where the system services will fail
    or refuse to start. Here, in this recipe, we will show you how to troubleshoot
    them if something goes wrong.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，系统管理员工作的大部分时间都在解决服务器出现问题时的故障。这对于系统服务尤其如此，因为它们一直在运行并处理信息。服务可能依赖于其他服务和服务器的系统，系统管理员的生活中将会遇到系统服务失败或拒绝启动的情况。在这里，在这个步骤中，我们将向你展示如果出现问题如何解决它们。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice; you should also have completed the *Knowing and managing your background
    services* recipe from this chapter, where we installed the Apache web server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个步骤，你需要一个具有root权限的CentOS 7操作系统的工作安装，以及你选择的基于控制台的文本编辑器；你还应该完成了本章中的*了解和管理你的后台服务*步骤，在那里我们安装了Apache网络服务器。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In order to show you how to troubleshoot services, we will introduce a random
    error in the Apache service''s configuration file and then show you how to troubleshoot
    and fix it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向你展示如何解决服务问题，我们将在Apache服务的配置文件中引入一个随机错误，然后向你展示如何解决和修复它：
- en: 'Log in as root and type the following command to append content to the `httpd.conf`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以root身份登录，并输入以下命令将内容追加到`httpd.conf`：
- en: '[PRE16]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, reload the `httpd` service and show its output:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，重新加载`httpd`服务并显示其输出：
- en: '[PRE17]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s revert this error line:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们撤销这个错误行：
- en: '[PRE18]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, restart the service again:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次重启服务：
- en: '[PRE19]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this fairly short recipe, we showed you how an example service will behave
    if it contains errors, and what you can do to fix it to get you started. There
    are a lot of different scenarios where something can go wrong when services malfunction,
    and it can be a big part of a system administrator's job to solve those kinds
    of problem.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个相当短的步骤中，我们向你展示了如果服务包含错误，示例服务将如何表现，以及你可以做些什么来修复它以开始。当服务出现故障时，有很多不同的场景可能会出现问题，解决这些问题可能是系统管理员工作的重要部分。
- en: So, what have we learned from this experience?
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们从这次经历中学到了什么？
- en: 'We started this recipe by introducing a line of text in the main Apache configuration
    file, which does not contain any valid configuration syntax, and therefore the
    `httpd` service cannot interpret it. Then, we used the `systemctl reload` parameter
    to reload our server''s configuration file. As said before, not all services have
    the reload option, so if your service of interest does not support this, use the
    `restart` parameter instead. Since Apache will try to reload the configuration
    file with our current changes, it will refuse to accept the new configuration
    because of the wrong syntax that we introduced. Since we are just reloading the
    configuration, the running Apache process will not be affected by this problem
    and will stay online using its original configuration. The `systemctl` parameter
    will print out the following error message, giving us a hint of what to do next:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这个步骤开始，在Apache主配置文件中引入了一行文本，该文本不包含任何有效的配置语法，因此`httpd`服务无法解释它。然后，我们使用`systemctl
    reload`参数重新加载我们服务器的配置文件。如前所述，并非所有服务都有重新加载选项，因此如果你的服务不支持这一点，请使用`restart`参数代替。由于Apache将尝试加载我们当前更改的配置文件，它将拒绝接受新的配置，因为我们在其中引入了错误的语法。由于我们只是重新加载配置，正在运行的Apache进程不会受到这个问题的影响，并将继续在线使用其原始配置。`systemctl`参数将打印出以下错误消息，给我们下一步该做什么的提示：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As suggested by the error output, the `systemctl` status parameter is a very
    powerful tool to see what's going on behind the scenes with this service, and
    to try and find out the reason for any failure (here you can also see that Apache
    is still running). If you start the `systemctl` `status` with the `-l` flag, it
    prints out an even longer version of the output, which can help you even more.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如错误输出所建议的，`systemctl`状态参数是一个非常强大的工具，可以看到服务背后的情况，并试图找出任何失败的原因（在这里你也可以看到Apache仍在运行）。如果你使用`-l`标志启动`systemctl`状态，它会打印出更长的输出版本，这可以帮助你更多。
- en: 'The output of this command shows us the exact reason for failing the configuration
    reload, so we can easily trace down the cause of the problem (the output has been
    truncated):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的输出向我们展示了配置重新加载失败的精确原因，因此我们可以轻松地追踪问题的根源（输出已被截断）：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This output is part of the complete `journald` log information. If you want
    to read more about it, please refer to the *Tracking system resources with journald*
    recipe in this chapter. So, with this very useful information from the output,
    we can easily spot the problem and redo the introduction of `ERRORLINE` using
    the `sed` command and reload the service again; this time everything will work
    fine.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出是完整的`journald`日志信息的一部分。如果你想了解更多关于它的信息，请参考本章中的*使用journald跟踪系统资源*食谱。因此，通过这个输出中非常有用的信息，我们可以轻松地发现问题，并使用`sed`命令重新引入`ERRORLINE`，然后重新加载服务；这次一切都会正常工作。
- en: So, in summary, we can say that the `systemctl status` command is a very comfortable
    command that can be tremendously helpful in finding out problems with your service.
    Most services are very sensitive to syntax errors, and sometimes it can be just
    a misplaced space character that caused the service to refuse to work. Therefore,
    system administrators must work precisely all the time.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，我们可以说`systemctl status`命令是一个非常方便的命令，在找出服务问题时非常有帮助。大多数服务对语法错误非常敏感，有时可能只是一个错位的空格字符导致服务拒绝工作。因此，系统管理员必须始终精确工作。
- en: Tracking system resources with journald
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用journald跟踪系统资源
- en: Log files contain system messages and output from services, the kernel, and
    all kinds of running applications. They can be very useful in many situations,
    for instance, to troubleshoot system problems and monitor services or other system
    resources, or doing security forensics after a breach of security. In this recipe,
    you will learn the basics of how to work with logging services using journald.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件包含系统消息和来自服务、内核以及各种运行应用程序的输出。在许多情况下，它们非常有用，例如，用于解决系统问题、监控服务或其他系统资源，或者在安全事件发生后进行安全取证。在本食谱中，你将学习如何使用journald进行日志记录服务的基本操作。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To complete this recipe, you will need a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice. Also, setting the time and date correctly is very crucial for the whole
    logging concept, so please apply the *Synchronizing the system clock with NTP
    and the chrony suite* recipe from [Chapter 2](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 2. Configuring the System"), *Configuring the System* before using this
    recipe. Also, a basic knowledge of systemd and units can be advantageous. This
    is covered in the *Knowing and managing background services* recipe in this chapter.
    Journalctl uses *less* navigation to show output; please read the *Navigating
    text files with less* recipe from [Chapter 2](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 2. Configuring the System"), *Configuring the System* if you don't know
    how to work with it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个食谱，你需要一个安装了CentOS 7操作系统的工作环境，具备root权限和一个你选择的基于控制台的文本编辑器。此外，正确设置时间和日期对于整个日志记录概念至关重要，因此请在使用本食谱之前，应用来自[第2章](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "第2章：配置系统")，*配置系统*的*使用NTP和chrony套件同步系统时钟*食谱。此外，对systemd和单元有基本了解可能会有优势。这在本书的*了解和管理后台服务*食谱中有所涉及。Journalctl使用*less*导航来显示输出；如果你不知道如何使用它，请阅读来自[第2章](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "第2章：配置系统")，*配置系统*的*使用less导航文本文件*食谱。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'On CentOS 7, we have a choice between two logging mechanisms called `rsyslog`
    and the `journald` log system, which is a component of the new `systemd` system
    manager, for viewing and managing logging information. Here, we will show you
    how to work with the `journalctl` command, which is the controlling client for
    the `journald` daemon:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS 7中，我们有两个日志记录机制可供选择，分别是`rsyslog`和`journald`日志系统，后者是新的`systemd`系统管理器的一个组件，用于查看和管理日志信息。在这里，我们将向你展示如何使用`journalctl`命令，它是`journald`守护进程的控制客户端：
- en: 'To begin, log in as root and type the following command to view the whole journal
    log:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，以root身份登录，并输入以下命令来查看整个日志：
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we want to show only the messages within a specific time frame (change
    the date accordingly):'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只想显示在特定时间范围内的消息（相应地更改日期）：
- en: '[PRE23]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Afterwards, we want to filter the log system by all messages from the sshd
    service:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们想通过所有来自sshd服务的消息来过滤日志系统：
- en: '[PRE24]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we want to show only messages with type error:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只想显示类型为错误的消息：
- en: '[PRE25]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To get the most verbose version of `journalctl`, use the `verbose` option:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取`journalctl`最详细的版本，请使用`verbose`选项：
- en: '[PRE26]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To get a *current* view on the log output, use the following command (this
    is not *less* navigation—use the key combination *Ctrl*+*C* to exit this view):'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取日志输出的*当前*视图，请使用以下命令（这不是*less*导航——使用组合键*Ctrl*+*C*退出此视图）：
- en: '[PRE27]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In CentOS 7, we can use the new `journald` logging system, which is a part of
    the `systemd` system management. It is a centralized tool that will log just about
    everything on your system including all output from the early boot over kernel
    to services and all program messages. The main advantage over other logging mechanisms
    is that you don't have to configure logging for each of your services or other
    resources, because everything is already set up for all applications that are
    controlled and running through the centralized `systemd` system.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在CentOS 7中，我们可以使用新的`journald`日志记录系统，它是`systemd`系统管理的一部分。它是一个集中式工具，将记录系统上的几乎所有内容，包括从早期启动到内核、服务以及所有程序消息的所有输出。与其他日志记录机制相比，主要优势在于您不必为每个服务或其他资源配置日志记录，因为一切都已经为通过集中式`systemd`系统控制和运行的所有应用程序设置好了。
- en: So, what have we learned from this experience?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们从这次经历中学到了什么？
- en: We began our journey by running the `journalctl` command, which when applied
    without any parameters show us the complete journal log, which includes everything
    from starting your system and capturing the first boot log entries to the latest
    system messages in the order they appeared, appending new messages to the bottom
    (chronological order). If your system has been running for a while, it can contain
    hundreds of thousands of lines of logging data, and is very impractical to work
    with in this raw form.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过运行`journalctl`命令开始了我们的旅程，该命令在不带任何参数的情况下向我们展示了完整的日志记录，包括从系统启动到最新的系统消息，按照它们出现的顺序，将新消息附加到底部（按时间顺序）。如果您的系统已经运行了一段时间，它可能包含数十万行日志数据，以这种原始形式处理非常不切实际。
- en: 'This output is constantly captured by the `journald` daemon, but is not written
    to text files as other logging systems such as `rsyslog` do it. Instead, it uses
    a structured and indexed binary file, which stores a lot of additional meta information
    such as user Id, timestamp, and so on, and which makes it easy to transform into
    all kinds of different output formats. This can be very convenient if you want
    to further process journal information by another tool. As you cannot read binary
    files, you will need the client `journalctl` for it, which is used to query the
    `journald` database. Since it is almost impossible to parse through this sheer
    amount of data manually, we then take advantage of journalctl''s rich filtering
    options. First, we used the `--since` and `--until` parameters to extract all
    log messages within a specific time frame. The syntax for specifying the time
    and date here is very flexible and understands phrases such as `yesterday` or
    `now`, but we stick with the simple date syntax, `YYYY-MM-DD HH:MM:SS`. Next,
    we used journalctl''s `-u` parameter to filter log messages for a specific unit
    type. We used it to filter messages coming from the sshd daemon service. We added
    another filter using the `--since` parameter, which tightens the result of the
    `-u` unit filter even more, outputting only sshd service results that occurred
    yesterday. The next filter we applied was using the parameter string, `-p err
    -b`, which filters the log database by priority or log level. Every log message
    can have an associated priority that determines the importance of the message.
    To find out more about different log levels, refer to the manual using the command
    line `man 3 syslog` (if this manual is not available, install it by typing `yum
    install man-pages`). Our command will print out all log messages labeled as `error`
    or above, which includes: `error`, `critical`, `alert`, or `emergency`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出由`journald`守护进程持续捕获，但不写入文本文件，如`rsyslog`等其他日志系统所做的那样。相反，它使用结构化和索引的二进制文件，存储大量额外的元信息，如用户ID、时间戳等，这使得将其转换为各种不同的输出格式变得容易。如果您想通过另一个工具进一步处理日志信息，这可能会非常方便。由于无法读取二进制文件，您将需要客户端`journalctl`来查询`journald`数据库。由于手动解析如此大量的数据几乎是不可能的，因此我们利用了journalctl丰富的过滤选项。首先，我们使用`--since`和`--until`参数提取特定时间范围内的所有日志消息。指定时间和日期的语法非常灵活，理解诸如`昨天`或`现在`之类的短语，但我们坚持使用简单的日期语法，`YYYY-MM-DD
    HH:MM:SS`。接下来，我们使用journalctl的`-u`参数过滤特定单元类型的日志消息。我们使用它来过滤来自sshd守护程序服务的消息。我们添加了另一个使用`--since`参数的过滤器，这进一步收紧了`-u`单元过滤器的结果，仅输出昨天发生的sshd服务结果。我们应用的下一个过滤器是使用参数字符串`-p
    err -b`，它按优先级或日志级别过滤日志数据库。每个日志消息都可以有一个关联的优先级，该优先级确定消息的重要性。要了解有关不同日志级别的更多信息，请参阅手册，使用命令行`man
    3 syslog`（如果此手册不可用，请键入`yum install man-pages`进行安装）。我们的命令将打印出所有标记为`错误`或以上的日志消息，包括：`错误`、`严重`、`警报`或`紧急`。
- en: Next, we used the same command parameters but added `-o verbose`, which gives
    the most verbose output of logging information. Lastly we presented the `-f` parameter
    (for follow), which will give us a *live* view of the latest log messages and
    leaves this connection open, appending any new messages to the end of the output
    when they occur. This is often useful to see how the system reacts if you are
    currently testing out settings or starting/stopping services.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用了相同的命令参数，但添加了`-o verbose`，这提供了最详细的日志信息输出。最后，我们介绍了`-f`参数（用于跟随），它将为我们提供最新的日志消息的*实时*视图，并保持此连接打开，当新消息出现时，将其附加到输出的末尾。这在测试设置或启动/停止服务时查看系统反应通常很有用。
- en: 'Summing up, one can say that, on CentOS 7, two logging systems do coexist:
    the older `rsyslog` and the newer `journald`, with the latter being your primary
    tool of choice for troubleshooting your system. But remember that on CentOS 7,
    `journald` is not a full replacement for `rsyslog` though. There are some `rsyslog`
    features that are missing in `journald`, and also there are lots of tools and
    scripts, such as log digesting tools or monitoring suites such as Nagios, that
    work exclusively with `rsyslog`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，可以说在CentOS 7上，两个日志系统并存：较旧的`rsyslog`和较新的`journald`，后者是您首选的系统故障排除工具。但请记住，在CentOS
    7上，`journald`并不是`rsyslog`的完全替代品。`journald`中缺少一些`rsyslog`的功能，而且还有许多工具和脚本，如日志摘要工具或监控套件如Nagios，它们仅与`rsyslog`配合使用。
- en: System administrators often face a big challenge troubleshooting system errors
    or unexpected server behaviors. Often, it's not easy to find the single point
    of failure by searching through massive amounts of different log file texts while
    applying regular expression searches or Linux command line kung fu. Journald provides
    a very convenient alternative by providing a powerful and well-defined centralized
    querying system to get the log file analysis done quickly and efficiently!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 系统管理员在解决系统错误或意外服务器行为时经常面临巨大挑战。通常，在应用正则表达式搜索或Linux命令行功夫时，通过搜索大量不同的日志文件文本来找到单一故障点并不容易。Journald提供了一个非常方便的替代方案，通过提供一个强大且定义良好的集中查询系统，快速高效地完成日志文件分析！
- en: Configuring journald to make it persistent
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置journald以使其持久
- en: Journald's advantages over other logging systems such as `rsyslog` is that it
    is very efficient and logs just about everything on your system automatically
    without the need to configure anything, because it is a part of the `systemd`
    suite. The main disadvantage is that all `journald` log information will get lost
    after a system's restart. Journald logging can produce huge amounts of data and
    by default all logging information is only kept in memory, which is not very practicable
    if you need to access older log information or analyze causes of system crash
    reboots. Here, in this recipe, we show you how to configure `journald` to make
    it persistent.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Journald相对于其他日志系统如`rsyslog`的优势在于，它非常高效，并且会自动记录系统上的几乎所有内容，无需进行任何配置，因为它属于`systemd`套件的一部分。主要缺点是，`journald`的所有日志信息在系统重启后都会丢失。Journald日志可以产生大量数据，并且默认情况下所有日志信息仅保存在内存中，如果你需要访问较旧的日志信息或分析系统崩溃重启的原因，这并不实用。在本教程中，我们将向你展示如何配置`journald`以使其持久。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个教程，你需要一个具有root权限的CentOS 7操作系统的最小安装，以及你选择的基于控制台的文本编辑器。
- en: How to do it...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To begin this recipe, we need to create a location that will hold our persistent
    journal database:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 开始这个教程，我们需要创建一个位置来保存我们的持久日志数据库：
- en: 'Log in as the root user and create the following directory:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以root用户身份登录并创建以下目录：
- en: '[PRE28]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, add the new directory to `journald` to use it as a storage location and
    fix permissions:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将新目录添加到`journald`中，用作存储位置并修复权限：
- en: '[PRE29]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, restart `journald`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重启`journald`：
- en: '[PRE30]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, to check whether the log survived the reboot, restart the computer
    and type the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了检查日志是否在重启后存活，重启计算机并输入以下命令：
- en: '[PRE31]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We started this recipe by creating the new directory, `/var/log/journal`. By
    default, `journald` writes its log database to `/run/log/journal`, which is a
    directory only for runtime information, and its content does not survive system
    reboots. Afterwards, we used the `systemd-tmpfiles` command to set up our new
    directory for `journald`. Finally, we restarted the `journald` server daemon to
    apply our changes to the system. To test if persistence is working, restart your
    server and afterwards use `journalctl –boot=-1`. This will show us all journal
    information from the last boot. If persistence is not working, it will print out
    the following error; otherwise it will correctly show all journal messages before
    the last boot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建新目录`/var/log/journal`开始了这个教程。默认情况下，`journald`将其日志数据库写入`/run/log/journal`，这是一个仅用于运行时信息的目录，其内容在系统重启后不会保留。之后，我们使用`systemd-tmpfiles`命令为`journald`设置新目录。最后，我们重启了`journald`服务器守护进程，以将我们的更改应用到系统。为了测试持久性是否正常工作，重启你的服务器，然后使用`journalctl
    –boot=-1`。这将向我们展示上次启动以来的所有日志信息。如果持久性没有正常工作，它会打印出以下错误；否则，它会正确显示上次启动之前的所有日志消息：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this fairly simple recipe, we have shown how to make `journald` persistent
    over system reboots. This is really useful if you need to review older log files
    from the past, which can sometimes help you find out problems, for example, the
    roots of past hardware failures.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个相当简单的教程中，我们展示了如何使`journald`在系统重启后保持持久性。如果你需要查看过去的旧日志文件，这会非常有用，有时这能帮助你找出问题，例如过去硬件故障的根源。
- en: Managing users and their groups
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户及其组
- en: In this recipe, we will learn how to manage your system's users and groups on
    CentOS 7\. Essential user and group managing skills are one of the most important
    CentOS system administrator fundamentals.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个操作中，我们将学习如何在CentOS 7上管理系统的用户和组。基本的用户和组管理技能是CentOS系统管理员最重要的基础之一。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To complete this recipe, you will need a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个操作，您需要一个具有root权限的CentOS 7操作系统的有效安装，以及您选择的基于控制台的文本编辑器。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This recipe shows you how to manage users and groups by learning how to add,
    delete, and modify them:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作向您展示了如何通过学习如何添加、删除和修改用户和组来管理它们：
- en: 'To begin this recipe, we log in as root and type the following command to get
    a list of all the users known to the system: `cat /etc/passwd`.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始这个操作，我们以root身份登录，并输入以下命令以获取系统中所有已知用户的列表：`cat /etc/passwd`。
- en: 'Now, show the root user ID (**UID**) and group ID (**GID**):'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，显示root用户的ID（**UID**）和组ID（**GID**）：
- en: '[PRE33]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, we will run the following command to add a new user to the system (exchange
    `your_new_username` with a username of your choice):'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将运行以下命令以在系统中添加一个新用户（将`your_new_username`替换为您选择的用户名）：
- en: '[PRE34]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'However, in order to complete this process, you will be expected to provide
    a suitable password. To do this, type the following command (change `your_new_username`
    with a username of choice) than enter a secure password when prompted:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，为了完成这个过程，您将被要求提供一个合适的密码。为此，输入以下命令（将`your_new_username`替换为您选择的用户名），然后在提示时输入一个安全的密码：
- en: '[PRE35]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Passwords should not be less than six characters, but should not be longer than
    sixteen characters. They should consist of alphanumeric values, and for obvious
    reasons you must avoid the use of whitespaces. Do not use a dictionary-based word
    and refrain from using a known or obvious phrase.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 密码不应少于六个字符，但也不应超过十六个字符。它们应由字母数字值组成，并且出于显而易见的原因，您必须避免使用空格。不要使用字典中的单词，并避免使用已知或明显的短语。
- en: 'Next, create a new group and give it a special name:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新组并给它一个特殊的名称：
- en: '[PRE36]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we add our new user to this new group:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将新用户添加到这个新组中：
- en: '[PRE37]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, let''s print the user ID and group IDs of our new user to see what
    has changed:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们打印出新用户的用户ID和组ID，看看发生了哪些变化：
- en: '[PRE38]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works...
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The purpose of this recipe was to create a new user and group and show how to
    connect them together.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的目的是创建一个新用户和组，并展示如何将它们连接在一起。
- en: So, what did we learn from this experience?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们从这次经历中学到了什么？
- en: First, we printed out the content of file `/etc/passwd` to show all the current
    users in the system. This list not only contains normal user-accounts that belong
    to real persons, but also accounts that are used to control and own a specific
    application or service. Then, we used the `id` command to display the unique user
    UID and GID for our existing user root. In Linux, every user can be identified
    by their UID and GID, and every file in the filesystem has specific permission
    settings that manage its access for the file owner, group owner, and the rest
    of the users. For each of those three groups, you can enable or disable read,
    write, and execute permissions using the command, `chmod` (use `man chmod` to
    learn more, and also check out `man chown`). The owner and group permissions correspond
    to a UID and GID that we can display for every file using `ls -l`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们打印出`/etc/passwd`文件的内容，以显示系统中所有当前用户。这个列表不仅包含属于真实人物的普通用户账户，还包含用于控制和拥有特定应用程序或服务的账户。然后，我们使用`id`命令来显示我们现有用户root的唯一用户UID和GID。在Linux中，每个用户都可以通过他们的UID和GID来识别，并且文件系统中的每个文件都有特定的权限设置，这些设置管理文件所有者、组所有者和其他用户的访问权限。对于这三个组中的每一个，您都可以使用`chmod`命令启用或禁用读、写和执行权限（使用`man
    chmod`了解更多信息，并查看`man chown`）。所有者和组权限对应于一个UID和GID，我们可以使用`ls -l`为每个文件显示这些信息。
- en: Next, we issued the `useradd` command that required us to supply a suitable
    name for the new user, which in turn will enable the server to establish the new
    identity with a default set of values and criteria that includes a user ID, home
    directory, primary group (GID), and also set the default shell to bash. Completing
    this process is simply a matter of confirming a suitable password. To remove a
    user, there is the opposite command, `userdel`, which works similarly but can
    be given the option `-f` to remove the home directory instead of leave it on the
    system. Next, we used the `groupadd` command, which, as the name implies, will
    create a new group and associate a new unique GID to it. Afterwards, we made our
    user in question a member of the new group that we created before using the `usermod
    -G` command. As said before, each user has exactly one unique UID and GID. The
    first group is the primary group and is mandatory; however a user can belong to
    a number of different groups, which are then called secondary groups. The primary
    group is needed when creating a new file because it will set the GID and UID of
    the user creating it. To delete a group, we can use the `groupdel` command. Finally,
    we used the `id` command again on our new user to show its UID, primary GID, and
    the new secondary GID groups we added to it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们执行了`useradd`命令，要求我们为新用户提供一个合适的名称，这将使服务器能够使用一组默认值和标准建立新身份，包括用户ID、家目录、主组（GID），并将默认shell设置为bash。完成此过程只需确认一个合适的密码。要删除用户，有相反的命令`userdel`，其工作方式类似，但可以给出`-f`选项以删除家目录而不是将其留在系统上。接下来，我们使用了`groupadd`命令，顾名思义，它将创建一个新组并为它分配一个新的唯一GID。之后，我们使用`usermod
    -G`命令将我们的用户添加到之前创建的新组中。如前所述，每个用户都有一个唯一的UID和GID。第一个组是主组，是必需的；但是，用户可以属于多个不同的组，这些组称为辅助组。创建新文件时需要主组，因为它将设置创建它的用户的GID和UID。要删除组，我们可以使用`groupdel`命令。最后，我们再次使用`id`命令查看新用户的UID、主GID以及我们添加给它的新的辅助GID组。
- en: 'You are now able to fully control your user and groups with just a few commands:
    `useradd`, `usermod`, `userdel`, `groupadd`, `groupmod`, and `groupdel`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需使用几个命令即可完全控制用户和组：`useradd`、`usermod`、`userdel`、`groupadd`、`groupmod`和`groupdel`。
- en: Scheduling tasks with cron
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cron安排任务
- en: In this recipe, we will investigate the role of server automation and the convenience
    of running specific tasks at predefined periods by introducing you to the time-based
    job scheduler known as cron. Cron allows for the automation of tasks by enabling
    the administrator to determine a predefined schedule based on any hour, any day,
    or any month. It is a standard component of the CentOS operating system, and it
    is the purpose of this recipe to introduce you to the concept of managing recurring
    tasks in order to take advantage of this invaluable tool and to make CentOS work
    for you.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将探讨服务器自动化的作用以及通过引入您到基于时间的作业调度程序cron来在预定义周期内运行特定任务的便利性。Cron允许通过使管理员能够根据任何小时、任何天或任何月确定预定义的计划来自动化任务。它是CentOS操作系统的标准组件，本食谱的目的是向您介绍管理重复任务的概念，以便利用这一宝贵工具并使CentOS为您工作。
- en: Getting ready
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with root privileges, and a console-based text editor of your
    choice. The `crontab` program uses Vim for file editing. If you do not know how
    to work with Vim, go through the tutorial shown in the recipe *Introduction to
    Vim* in [Chapter 2](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 2. Configuring the System"), *Configuring the System*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本食谱，您需要具有root权限的CentOS 7操作系统的最小安装，以及您选择的基于控制台的文本编辑器。`crontab`程序使用Vim进行文件编辑。如果您不知道如何使用Vim，请查看食谱*Vim简介*中的教程，位于[第2章](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "第 2 章。配置系统")，*配置系统*。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The purpose of this recipe is to create a script that will write the time and
    date with a few words of your choice to a text file every five minutes. This may
    seem to be a relatively simple exercise, but the intention is to show you that,
    from such simplicity, cron can be used to do so much more that will make working
    with CentOS an absolute pleasure.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的目的是创建一个脚本，该脚本将每五分钟将时间和日期以及您选择的几句话写入文本文件。这可能看起来是一个相对简单的练习，但意图是向您展示，从这种简单性出发，cron可以用于做更多的事情，这将使与CentOS一起工作成为一种绝对的乐趣。
- en: 'To begin this recipe, log in as root and create your first cron job by typing:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始这个配方，请以 root 身份登录并创建您的第一个 cron 作业，方法是输入：
- en: '[PRE39]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will now create a simple cron job that will write the date and time with
    the words `hello world` to a file located at `/root/cron-helloworld.txt` every
    five minutes. To do this, add the following line:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建一个简单的 cron 作业，该作业将日期和时间与单词 `hello world` 一起写入位于 `/root/cron-helloworld.txt`
    的文件中，每五分钟一次。为此，添加以下行：
- en: '[PRE40]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When complete, simply save the file and exit the editor. The system will now
    respond with the following message:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，只需保存文件并退出编辑器。系统现在将响应以下消息：
- en: '[PRE41]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding message informs you that the server is now creating the new `cron`
    job and will automatically activate it. You can view the output of the script
    by reviewing the file found at `/root/cron-helloworld.txt` (you have to wait 5
    minutes), or by monitoring the logfile found at `/var/log/cron` (use `tail -f
    /var/log/cron` and `Ctrl+C` to exit).
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的消息通知您，服务器现在正在创建新的 `cron` 作业，并将自动激活它。您可以通过查看位于 `/root/cron-helloworld.txt`
    的文件来查看脚本的输出（您必须等待 5 分钟），或者通过监视位于 `/var/log/cron` 的日志文件（使用 `tail -f /var/log/cron`
    和 `Ctrl+C` 退出）。
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Cron is the name of a program that enables CentOS users to execute commands
    or scripts automatically at a specified time and date. Cron's settings are kept
    in a user-specific file called `crontab`, and as we have seen in this recipe this
    file can be edited to create automated tasks as often as they are required.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Cron 是一个程序的名称，它允许 CentOS 用户在指定的时间和日期自动执行命令或脚本。Cron 的设置保存在一个名为 `crontab` 的用户特定文件中，正如我们在本配方中看到的那样，可以编辑此文件以创建所需的自动化任务。
- en: So what did we learn from this experience?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们从这次经历中学到了什么？
- en: 'The example used was very simple, but in many ways this was the purpose of
    this recipe. Crontab uses a daemon, `crond`, which runs constantly in the background
    and checks once a minute to see if any of the scheduled jobs need to be executed.
    If a task is found, then cron will execute it. To edit an existing `crontab` file
    or to create a new `crontab`, we use the `crontab -e` command. To view a list
    of current cron jobs, you can type `crontab -l`. Alternatively, to view a list
    of the current jobs for another user, you can type `crontab -u username -l`. Tasks
    or jobs are generally referred to as cron jobs, and by avoiding complication in
    our first script, it was the intention to show you that the nature of command
    construction was very simple. The formation of a cron job looks like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的示例非常简单，但在许多方面，这是这个配方的目的。Crontab 使用一个守护进程 `crond`，它一直在后台运行，并每分钟检查一次是否有任何计划的任务需要执行。如果找到任务，则
    cron 将执行它。要编辑现有的 `crontab` 文件或创建新的 `crontab`，我们使用 `crontab -e` 命令。要查看当前的 cron
    作业列表，可以键入 `crontab -l`。或者，要查看另一个用户的当前作业列表，可以键入 `crontab -u username -l`。任务或作业通常称为
    cron 作业，并且通过在我们的第一个脚本中避免复杂性，目的是向您展示命令构造的本质非常简单。cron 作业的形成如下所示：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Entries are separated by a single or tabbed space, and the allowed values are
    primarily numeric (that is, `0-59` for a minute, `0-23` for an hour, `1-31` for
    a day of the month, `1-12` for month of the year, and `0-7` for day of the week).
    However, in saying this, it is also true to say that there are more specific operators
    ( `/` , `-`) and cron-specific shortcuts (that is, `@yearly`, `@daily`, `@hourly`,
    and `@weekly`) that do allow for additional controls. For example, where the `/`
    operator is used to step through specified units, it can be read as *every*, so
    in our recipe the use of `*/5` will run the task every five minutes while the
    use of `*/1` runs the task every minute. As an addition to this, you should be
    aware that the use of this syntax will align all commands on the hour. So, with
    this in mind, the most suitable template or starting point for anyone wanting
    to write their first `cron` job is to start with a series of five asterisks followed
    by the command, like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 条目由单个或制表符分隔，允许的值主要是数字（即，`0-59` 表示分钟，`0-23` 表示小时，`1-31` 表示月份中的日期，`1-12` 表示年份中的月份，`0-7`
    表示星期几）。然而，这样说也是正确的，即存在更具体的运算符（`/`，`-`）和特定的 cron 快捷方式（即，`@yearly`，`@daily`，`@hourly`，`@weekly`），这些允许额外的控制。例如，`/`
    运算符用于逐步指定单位，可以读作 *每*，所以在我们的配方中使用 `*/5` 将使任务每五分钟运行一次，而使用 `*/1` 将使任务每分钟运行一次。此外，您应该知道，使用此语法将使所有命令与小时对齐。因此，考虑到这一点，对于任何想要编写他们的第一个
    `cron` 作业的人来说，最合适的模板或起点是开始使用一系列五个星号，然后是命令，如下所示：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, proceed to configure the minute, hour, day, month, and day-of-the-week
    values as desired. For example, if you want a particular PHP script to run at
    8 P.M. (20:00 hrs) on every weekday (Monday-Friday), it may look like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，继续配置所需的分钟、小时、日期、月份和星期值。例如，如果您希望在每个工作日（周一至周五）的晚上8点（20:00小时）运行特定的PHP脚本，它可能看起来像这样：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So, with this in mind, and by completing this recipe, you can see how cron can
    be used to manage a database backup, run a scheduled system backup, provide support
    to websites by activating scripts at predefined intervals, or run various bash
    scripts and a whole lot more.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到这一点，通过完成本食谱，您可以看到cron如何用于管理数据库备份，运行预定系统备份，通过在预定义间隔激活脚本来支持网站，或运行各种bash脚本等等。
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To delete or disable a cron job, it is simply a matter of either removing the
    instruction from an individual user''s cron file or by placing a hash (`#`) at
    the beginning of the line. Individual cron files can be found at `/var/spool/cron/<username>`,
    and the use of the hash will either disable the cron job or allow you to write
    comments. To completely remove a `crontab` file, you can also use `crontab -r`.
    For example, if you want to remove the cron job created in the main recipe, you
    can log in as root and begin by typing the command, `crontab -e`. At this point,
    you may either remove the entire line or comment it out, as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除或禁用cron作业，只需从单个用户的cron文件中删除指令，或者在行首放置一个哈希（`#`）。单个cron文件可以在`/var/spool/cron/<username>`找到，使用哈希将禁用cron作业或允许您编写注释。要完全删除`crontab`文件，您还可以使用`crontab
    -r`。例如，如果您想删除主食谱中创建的cron作业，您可以以root身份登录并开始输入命令`crontab -e`。此时，您可以删除整行或将其注释掉，如下所示：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Next, save the file. There are also some special cron directories in the filesystem
    for system-wide cron jobs that will, if you drop a script file in it, run it automatically
    at a certain time point. The folders are called `cron.daily`, `cron.hourly`, `cron.weekly`,
    and `cron.monthly` in the `/etc` directory, and their names refer to the time
    point that they are run. Just remove the script from the folder if you don't want
    to execute it anymore. Take a look at the *Monitoring important server infrastructure*
    recipe for an example.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，保存文件。在文件系统中还有一些特殊的cron目录，用于系统范围的cron作业。如果您将脚本文件放入其中，它将在特定时间点自动运行。这些目录在`/etc`目录中被称为`cron.daily`、`cron.hourly`、`cron.weekly`和`cron.monthly`，它们的名称指的是它们运行的时间点。如果您不再想执行脚本，只需将其从文件夹中删除即可。查看*监控重要服务器基础设施*的示例。
- en: Synchronizing files and doing more with rsync
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用rsync同步文件并执行更多操作
- en: '`rsync` is a program that can be used to synchronize files and directories
    across a variety of local and remote locations. It can interact with multiple
    operating systems, work over SSH, provide incremental backups, execute commands
    on a remote machine, and replace the need for the `cp` and `scp` commands. The
    `rsync` program is an invaluable asset for any system administrator who intends
    to run a server or manage a network of computers, as it not only simplifies the
    process of making backups in general, but it can be used to action a complete
    backup solution. For this reason, it is the purpose of this recipe to offer a
    suitable starting point for a small utility that will quickly become your trusted
    friend.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`rsync`是一个程序，可用于在各种本地和远程位置之间同步文件和目录。它可以与多种操作系统交互，通过SSH工作，提供增量备份，在远程机器上执行命令，并取代`cp`和`scp`命令的需求。`rsync`程序对于打算运行服务器或管理计算机网络的任何系统管理员来说都是无价之宝，因为它不仅简化了备份过程，还可以用于执行完整的备份解决方案。因此，本食谱的目的是提供一个合适的起点，以快速成为您信赖的朋友的小工具。'
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet in order to facilitate the download of additional
    packages.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本食谱，您需要具有root权限的CentOS 7操作系统的安装，您选择的基于控制台的文本编辑器以及连接到Internet以促进下载其他软件包的连接。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'During the course of this recipe, it will be assumed that you know the location
    of the source files and directories that you wish to synchronize, and that a suitable
    destination is available:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的过程中，将假定您知道要同步的源文件和目录的位置，并且有一个合适的目的地：
- en: 'To begin this recipe, log in as root and install `rsync` by typing:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始本教程，请以root身份登录并键入以下内容安装`rsync`：
- en: '[PRE46]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, create a target directory for our synchronization (change the folder name
    appropriately):'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为我们的同步创建一个目标目录（根据需要更改文件夹名称）：
- en: '[PRE47]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'To begin the synchronization process, simply repeat the following command by
    modifying the value used for `/path/to/source/files/` with something more applicable
    to your needs:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始同步过程，只需重复以下命令，通过修改用于`/path/to/source/files/`的值来满足您的需求：
- en: '[PRE48]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Having used the *Return* key to confirm the preceding instruction, your system
    will now respond with a live report of what is being copied. When this process
    has finished, you can then compare both directories to see that the contents are
    exactly the same. To do this, use the `diff` command (if both are the same, no
    output will be written):'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在确认前面的指令后，您的系统现在将响应一个实时报告，说明正在复制的内容。当这个过程完成后，您可以比较两个目录，看看内容是否完全相同。为此，请使用`diff`命令（如果两者相同，则不会写入输出）：
- en: '[PRE49]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we considered the use of `rsync` through the command line. Of
    course, this is only one of the many ways that this tool can be used, but by using
    this approach we were able to explore a handful of the features provided by this
    very valuable utility.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们考虑了通过命令行使用`rsync`。当然，这只是使用这个工具的众多方式之一，但通过这种方法，我们能够探索这个非常有价值的实用程序提供的一些功能。
- en: So, what did we learn from this experience?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们从这次经历中学到了什么？
- en: Rsync is not intended to be complicated. It is a fast and efficient file synchronization
    tool that is designed to be versatile by giving you complete access to an array
    of features on the command line. It can be used to maintain an exact copy (or
    mirror) of the `source` directory on the same machine or on a completely different
    system, and it does this by copying all the files once and then only updating
    the files that have changed the next time you run it. This can save tremendous
    bandwidth and should be your primary tool when copying data over the network.
    The use of the phrase, `--delete`, is important, as it instructs `rsync` to delete
    files on the target that do not exist in the source, while the chosen flags imply
    that `rsync` should use `-a` archive mode in order to recursively copy files and
    directories while keeping all permissions and time-based information; `–v`)verbosity
    mode so you can see what is happening; and `–z` to compress the data during the
    file transfer in order to save bandwidth and reduce the amount of time required
    to complete the entire process.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Rsync 并不是为了复杂而设计的。它是一个快速且高效的文件同步工具，旨在通过在命令行上为您提供完整的访问权限来实现多功能性。它可以用来在同一台机器上或在完全不同的系统上维护`源`目录的精确副本（或镜像），它通过一次复制所有文件，然后在下次运行时仅更新已更改的文件来实现这一点。这可以节省大量的带宽，并且应该是您在网络上复制数据时的主要工具。使用短语“--delete”很重要，因为它指示`rsync`删除目标上不存在于源中的文件，而所选标志意味着`rsync`应该使用`-a`存档模式来递归复制文件和目录，同时保持所有权限和基于时间的信息；`–v`）详细模式，以便您可以看到正在发生的事情；以及`–z`在文件传输期间压缩数据，以节省带宽并减少完成整个过程所需的时间。
- en: 'As you can see, `rsync` is very flexible and has many options that go beyond
    the purpose of this recipe, but if you want to exclude certain files you could
    always extend the original instruction by invoking the `--exclude` flag. By doing
    this, you tell `rsync` to back up an entire directory but ensure that it does
    not include a predefined pattern of files and folders. For example, if you are
    copying files from your server to a USB device and you do not want to include
    large files (such as an `.iso` image) or ZIP files, then your command may look
    similar to this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`rsync`非常灵活，并且有许多超出本教程目的的选项，但如果您想排除某些文件，您始终可以通过调用`--exclude`标志来扩展原始指令。通过这样做，您告诉`rsync`备份整个目录，但确保不包括预定义的文件和文件夹模式。例如，如果您正在将文件从服务器复制到USB设备，并且您不想包括大型文件（如`.iso`映像）或ZIP文件，那么您的命令可能与此类似：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'On a final note, there is the subject of verbosity. Verbosity is very useful,
    but a tendency to use bytes as its primary unit of measurement can be a source
    of confusion. So, in order to change this, you can invoke `rsync` with the `–h`
    (or human readable) option, as shown next:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于详细程度的话题。详细程度非常有用，但倾向于使用字节作为其主要测量单位可能会引起混淆。因此，为了改变这一点，您可以调用带有`–h`（或人类可读）选项的`rsync`，如下所示：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Maintaining backups and taking snapshots
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护备份和快照
- en: In this recipe, we will show you how to do data backups, on a regular basis,
    that will take snapshots of some of your system's directory using the `crond`
    daemon. This will run the `rsync` program at regular intervals to implement a
    fully automated backup solution.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将向您展示如何定期进行数据备份，这些备份将使用`crond`守护进程对系统的一些目录进行快照。这将定期运行`rsync`程序，以实现完全自动化的备份解决方案。
- en: Getting ready
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice. It is also advantageous if you have read the *Synchronizing files and
    doing more with rsync* and *Scheduling tasks with cron* recipes in this chapter
    to get a deeper understanding of used commands.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此配方，您需要一个具有root权限的CentOS 7操作系统的有效安装，以及您选择的基于控制台的文本编辑器。如果您阅读了本章中的*使用rsync同步文件并执行更多操作*和*使用cron安排任务*配方，以获得对所用命令的更深入理解，那将是有益的。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: It's important to install the `rsync` program on your server before proceeding
    with this recipe.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续此配方之前，在您的服务器上安装`rsync`程序非常重要。
- en: 'First, log in as root and create a directory where our backups will land:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，以root身份登录并创建一个目录，我们的备份将存放在那里：
- en: '[PRE52]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we will create the following shell script file and open it for editing:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建以下shell脚本文件并打开它进行编辑：
- en: '[PRE53]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Put in the following content, replacing `/backups` in the environment variable
    `DEST` and `SOURCE` with the one you would like to backup as well as the recipient''s
    `EMAIL`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下内容，将环境变量`DEST`和`SOURCE`中的`/backups`替换为您希望备份的目录，以及收件人的`EMAIL`：
- en: '[PRE54]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Make the script executable:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使脚本可执行：
- en: '[PRE55]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, open `crontab` using:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令打开`crontab`：
- en: '[PRE56]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, create the following entry by adding the following line to the end of
    the document, then save and close it:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过在文档末尾添加以下行来创建以下条目，然后保存并关闭它：
- en: '[PRE57]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we have created a full automatic backup solution for a single
    system directory, which will create a snapshot of the files at a certain time
    point. At the time the backup process is complete you will receive an e-mail informing
    you that a backup has been made with a brief review of the actions taken.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们为单个系统目录创建了一个完全自动化的备份解决方案，该解决方案将在某个时间点创建文件的快照。备份过程完成后，您将收到一封电子邮件，通知您已进行备份，并附有对所采取行动的简要回顾。
- en: So what did we learn from this experience?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们从这次经历中学到了什么？
- en: We started this recipe by creating a directory where our backup will be placed.
    Next we created the actual script and filled it with some commands. Line 1 defines
    the file as a bash script, lines 2-6 are variables you can modify and customize
    to fit your own needs. lines 7-8 create a path and name for the log file based
    on the date, and line 9 calls `rsync` which will synchronize all our source files
    to the target directory /backups. It uses a special `--log-file` parameter which
    writes all output to the given file. The final line (10) sends the content of
    this log file to an email address.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个目录来开始此配方，我们的备份将放置在那里。接下来，我们创建了实际的脚本并填充了一些命令。第1行将文件定义为bash脚本，第2-6行是您可以修改和自定义以满足您自己需求的变量。第7-8行根据日期创建日志文件的路径和名称，第9行调用`rsync`，它将同步所有源文件到目标目录/backups。它使用特殊的`--log-file`参数，该参数将所有输出写入给定文件。最后一行（10）将此日志文件的内容发送到电子邮件地址。
- en: 'Remember, you should customize the values as required (that is, change the
    e-mail address used, select a source directory, and choose a destination directory,
    and so on.). Before it can be used and executed by `cron`, we made it executable.
    Finally, we added this script as a cron job to run on a daily schedule at 20:30
    hours. However, as this may be some hours away, if you would like to test your
    script right now, you can execute it on the command line using the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您应该根据需要自定义值（即更改使用的电子邮件地址，选择源目录，选择目标目录等）。在它能够被`cron`使用和执行之前，我们使其可执行。最后，我们将此脚本添加为cron作业，以便在每天的20:30小时运行。但是，由于这可能需要几个小时，如果您想立即测试脚本，可以使用以下命令在命令行上执行它：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In conclusion, it will go without saying that a backup should be located on
    an external drive or on a separate partition, but having completed this introduction
    I think you will agree that `rsync` is ideally positioned in such a way that it
    will enable any server administrator to develop their own policy with regard to
    maintaining an effective backup of important data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，不言而喻，备份应该位于外部驱动器或单独的分区上，但是完成这个介绍后，我认为你会同意`rsync`处于理想的位置，它将使任何服务器管理员能够制定自己的政策，以维护重要数据的有效备份。
- en: Monitoring important server infrastructure
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控重要的服务器基础设施
- en: In this recipe, we will use a small script that will monitor the available filesystem's
    disk space periodically using cron, and if it exceeds a certain percentage threshold
    the script will send out a mail with a warning message.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将使用一个小脚本来定期监控可用文件系统的磁盘空间，如果超过某个百分比阈值，脚本将发送带有警告消息的邮件。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice. You should have read the *Scheduling tasks with cron* recipe to have a
    basic understanding of the principles behind the cron system.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个配方，你需要一个具有root权限和所选控制台文本编辑器的CentOS 7操作系统的有效安装。你应该已经阅读了*使用cron安排任务*配方，以便对cron系统的原理有一个基本的了解。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To begin this recipe, log in as root and create the following file that will
    contain our monitoring script:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始这个配方，请以root身份登录并创建以下文件，该文件将包含我们的监控脚本：
- en: '[PRE59]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, put in the following content:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请输入以下内容：
- en: '[PRE60]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, save the file and make it executable:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保存文件并使其可执行：
- en: '[PRE61]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We made this script executable and put it in the `/etc/cron.daily` directory,
    which is all we need to do to run this script automatically every day via the
    `crond` service.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使这个脚本可执行，并将其放入`/etc/cron.daily`目录中，这就是我们需要做的所有事情，以便通过`crond`服务每天自动运行这个脚本。
- en: This simple script showed us how easy it is to build monitoring scripts, and
    this can be a real alternative to installing and configuring big monitoring suites
    such as Nagios. You can use the shown script as a starting point to expand on,
    adding further resources that are important to monitor, such as CPU load, available
    RAM, and so on.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的脚本向我们展示了构建监控脚本是多么容易，这可以成为安装和配置大型监控套件（如Nagios）的真正替代方案。您可以使用所示的脚本作为起点，添加更多需要监控的重要资源，例如CPU负载、可用RAM等。
- en: We used a script that executes the Linux command `df`, which is a tool to report
    file system disk space usage. From this command's output, the script then parsed
    the `USE%` column (with the Unix tools `awk` and `cut`), which gives us the total
    disk percentage used. This number will then be compared to a threshold the user
    can set by editing the script and changing the environment variable, `THRESHOLD`.
    If the extracted percentage number is higher than our threshold, there will be
    an email sent to the email address defined with the environment variable, `EMAIL`
    (change appropriately if needed).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个执行Linux命令`df`的脚本，这是一个报告文件系统磁盘空间使用情况的工具。从这个命令的输出中，脚本然后解析了`USE%`列（使用Unix工具`awk`和`cut`），这给了我们总磁盘使用百分比。然后，这个数字将与用户可以通过编辑脚本并更改环境变量`THRESHOLD`设置的阈值进行比较。如果提取的百分比数字高于我们的阈值，将向定义了环境变量`EMAIL`的电子邮件地址发送电子邮件（如果需要，请相应更改）。
- en: Taking control with GIT and Subversion
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GIT和Subversion进行控制
- en: Document revision control systems or version control systems, as they are sometimes
    called, are used for the management of changes to documents. These systems get
    more and more important these days as modern work often connects people from around
    the globe to collaborate and work together on all kinds of documents (for example,
    software source code) making it important to manage the file changes by different
    people using revisions. In this recipe, we will show you how to use modern version
    control systems such as GIT and Subversion to manage the versioning of config
    files.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 文档修订控制系统或版本控制系统，有时也称为版本控制系统，用于管理文档的更改。随着现代工作越来越多地将来自世界各地的人们联系起来，共同合作并共同处理各种文档（例如，软件源代码），这些系统变得越来越重要，因此管理不同人使用修订版进行的文件更改变得非常重要。在本配方中，我们将向您展示如何使用现代版本控制系统，如GIT和Subversion，来管理配置文件的版本控制。
- en: Getting ready
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, and a connection to the Internet in order
    to facilitate the download of additional packages.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本教程，你需要一个具有root权限的CentOS 7操作系统的工作安装，以及一个互联网连接，以便于下载额外的软件包。
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here in this recipe, we will put the complete main Linux configuration directory,
    `/etc/`, under version control of a Git repository to keep track of all our changes
    to configuration files:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将把完整的Linux主配置目录`/etc/`置于Git仓库的版本控制之下，以跟踪我们对配置文件所做的所有更改：
- en: 'To begin, log in as root, install Git, and configure it by providing an email
    address and username (please substitute `your_username` and `your_email_address`
    with real names):'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，以root身份登录，安装Git，并通过提供电子邮件地址和用户名来配置它（请将`your_username`和`your_email_address`替换为真实姓名）：
- en: '[PRE62]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let''s create a new repository in the `/etc` directory:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`/etc`目录中创建一个新的仓库：
- en: '[PRE63]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, after we have our new repository, let''s add all the files in the `/etc/`
    directory under version control:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有了新的仓库，让我们将`/etc/`目录中的所有文件置于版本控制之下：
- en: '[PRE64]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To commit the files to the repository creating your first revision, type the
    following:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要提交文件到仓库，创建你的第一个版本，请输入以下内容：
- en: '[PRE65]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, let''s change a file:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们更改一个文件：
- en: '[PRE66]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Next, show the changes to your repository:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，展示你的仓库中的更改：
- en: '[PRE67]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we will commit these changes and create a new revision of it:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将提交这些更改并创建一个新的版本：
- en: '[PRE68]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, show all the commits so far:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，展示迄今为止的所有提交：
- en: '[PRE69]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This will output the following commits on my system (the number hashes will
    be different on yours):'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将输出我的系统上的以下提交（你的系统上的数字哈希值将不同）：
- en: '[PRE70]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Based on the output from the earlier step, we will now show all the differences
    between the two revision numbers (change the number hashes on your system based
    on the output from the earlier step):'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于前一步骤的输出，我们现在将展示两个版本号之间的所有差异（根据前一步骤的输出，在你的系统上更改数字哈希值）：
- en: '[PRE71]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To complete this recipe, we will revert our changes to the original file revision
    (the initial commit):'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完成本教程，我们将撤销我们对原始文件版本的更改（初始提交）：
- en: '[PRE72]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Here, in this recipe, we showed you how to use Git to manage changes to system
    config files in the `/etc` directory. This can be important, for example, if you
    are testing things out, so a lot of changes will be made to some configuration
    files and you will want to keep track of your changes, which is nice because you
    don't need to memorize every single step you have taken if you later have to revert
    the changes or go back to a specific revision, or compare different file versions.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们向你展示了如何使用Git来管理`/etc`目录中的系统配置文件的更改。如果你正在进行测试，这可能很重要，因为你会对某些配置文件进行大量更改，并且希望跟踪这些更改。这样做的好处是，如果你以后需要撤销更改或回退到特定版本，或者比较不同文件版本，你不需要记住你采取的每一个步骤。
- en: So, what did we learn from this experience?
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们从这次经历中学到了什么？
- en: We started by installing Git and added a username and an e-mail address to its
    configuration, which is essential for using it later in the process. Then, we
    changed to the `/etc` directory and initialized (using the `init` parameter) a
    new empty Git project there, which is called repository and keeps track of all
    the files associated to it. This command will add a hidden `.git` directory to
    it, which will contain the complete file changes and revision information. Next,
    we added all the files (using the wildcard `*` operator) from this directory,
    including all sub-directories to the next revision. A revision is like a state
    the files are in at a given time point, and is identified by a unique hash ID
    such as `8069c4a`. Then, we actually created a new revision using the commit parameter
    and supplied a meaningful message using the `-m` parameter. After we set up the
    Git repository and added all the files to it, every change to the files gets watched
    in the `/etc` directory. Next, we changed the main YUM configuration file in our
    repository by adding a random string to the end of it using the echo `>>` command.
    If we now use git's `status` parameter again, we see in the output that the Git
    system has notified that this file has been changed. We can now create a new revision
    with the changed file by using git's `commit` parameter again, using another meaningful
    message here stating that `yum.conf` has been changed. We then used the git `log`
    command. This will show us all the committed revisions with their unique `md5`
    hash string IDs. With this ID, we can fuel the git `diff` command to see all the
    file changes between two revisions. To learn more about the output format, use
    `man git-diff-files` and read its section `COMBINED DIFF FORMAT`. In our last
    step, we used the checkout command to go to a specific file revision; here we
    reverted all our changes and went back to the original file state.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先安装了 Git，并向其配置中添加了用户名和电子邮件地址，这对于后续使用至关重要。然后，我们切换到 `/etc` 目录，并在那里初始化（使用 `init`
    参数）一个新的空 Git 项目，这被称为仓库，用于跟踪与之关联的所有文件。此命令将在其中添加一个隐藏的 `.git` 目录，其中包含完整的文件更改和修订信息。接下来，我们添加了该目录中的所有文件（使用通配符
    `*` 运算符），包括所有子目录到下一个修订版。修订版就像文件在给定时间点的状态，由唯一的哈希 ID 标识，例如 `8069c4a`。然后，我们实际创建了一个新修订版，使用
    commit 参数并提供有意义的 message 使用 `-m` 参数。在我们设置 Git 仓库并将所有文件添加到其中之后，对 `/etc` 目录中文件的每次更改都会被监视。接下来，我们在仓库中修改了主
    YUM 配置文件，通过使用 echo `>>` 命令在末尾添加一个随机字符串。如果我们现在再次使用 git 的 `status` 参数，我们会在输出中看到
    Git 系统已通知该文件已被更改。我们现在可以使用 git 的 `commit` 参数再次创建一个包含更改文件的新修订版，并在此处使用另一个有意义的 message
    说明 `yum.conf` 已被更改。然后我们使用了 git `log` 命令。这将向我们展示所有已提交的修订版及其唯一的 `md5` 哈希字符串 ID。使用此
    ID，我们可以为 git `diff` 命令提供燃料，以查看两个修订版之间的所有文件更改。要了解更多输出格式，请使用 `man git-diff-files`
    并阅读其 `COMBINED DIFF FORMAT` 部分。在我们最后一步中，我们使用了 checkout 命令转到特定文件修订版；在这里，我们恢复了所有更改并返回到原始文件状态。
- en: Git is a very powerful version management tool, and in this recipe we just scratched
    the surface of what can be done with it. To learn more about Git's wonderful techniques,
    such as branching, merging, pull requests, and so on, start with the Git tutorial
    pages by typing in `man gittutorial`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是一个非常强大的版本管理工具，在本教程中我们只是浅尝辄止地了解了它的功能。要学习更多关于 Git 的精彩技巧，如分支、合并、拉取请求等，可以从输入
    `man gittutorial` 开始，阅读 Git 教程页面。
- en: There's more...
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不仅如此...
- en: 'You can also use the program Subversion to bring your `/etc` directory under
    version control. Subversion is another common document revision control system
    whose main difference from Git is that it uses a centralized server to keep track
    of the file changes. Git is distributed, meaning that everybody working on a Git
    project will have the complete repository locally on their computer. Here, we
    will show you the exact steps necessary to use Subversion instead of Git for this
    purpose:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 Subversion 程序将 `/etc` 目录置于版本控制之下。Subversion 是另一种常见的文档修订控制系统，与 Git 的主要区别在于它使用中央服务器来跟踪文件更改。Git
    是分布式的，这意味着在 Git 项目上工作的每个人都会在本地计算机上拥有完整的仓库。在这里，我们将向您展示使用 Subversion 代替 Git 所需的精确步骤：
- en: 'First, install Subversion and configure a new server directory for our `/etc`
    repository:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装 Subversion 并为我们的 `/etc` 仓库配置一个新的服务器目录：
- en: '[PRE73]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, make an in-place import of the `/etc` filesystem to our new repository:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `/etc` 文件系统就地导入到我们的新仓库中：
- en: '[PRE74]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, switch to the `/etc` directory and add all the files to a new revision:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，切换到 `/etc` 目录并将所有文件添加到一个新修订版中：
- en: '[PRE75]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, create your first commit:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建您的第一个提交：
- en: '[PRE76]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, change the `yum.conf` file:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改`yum.conf`文件：
- en: '[PRE77]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Commit your changes to a new file revision:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的更改提交到新的文件版本：
- en: '[PRE78]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, show the change log:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，展示变更日志：
- en: '[PRE79]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Show the file differences between our two commits (the first commit was the
    `/etc` import):'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示我们两个提交之间的文件差异（第一个提交是`/etc`导入）：
- en: '[PRE80]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, revert to the first revision of our `yum.conf` file:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，恢复到我们`yum.conf`文件的第一个版本：
- en: '[PRE81]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
