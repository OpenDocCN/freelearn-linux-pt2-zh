# 二、配置系统

在本章中，我们将涵盖以下主题:

*   用更少的资源浏览文本文件
*   Vim 简介
*   说正确的语言
*   将系统时钟与 NTP 和 chrony 套件同步
*   设置您的主机名并解析网络
*   成为超级用户
*   建立静态网络连接
*   自定义您的系统横幅和消息
*   引发内核

# 简介

本章是食谱的集合，涵盖了建立服务器基本需求的基本实践。对于许多人来说，构建服务器似乎是一项艰巨的任务，因此本章的目的是为您提供一种即时的方法来实现预期的目标。

# 用更少的导航文本文件

在本书中，您将经常使用使用程序较少或不太像导航的程序和工具来查看和读取文件内容或显示输出。起初，这个控件看起来有点不直观。在这里，在这个食谱中，我们将向您展示如何使用较少的控件浏览文件的基本知识。

## 做好准备

要完成此方法，您将需要具有 root 权限的 CentOS 7 操作系统的有效安装。

## 怎么做...

1.  首先，以 root 用户身份登录，并键入以下命令，打开一个导航使用较少的程序:

    ```sh
    man man

    ```

2.  导航时，按向上*和*向下*键一次上下滚动一行，*空格键*向下滚动一页， *b* 键向上滚动一页。您可以使用正斜杠键 */* 在文本中搜索，后跟搜索词，然后按*返回*进行搜索。按 *n* 跳转到下一个搜索结果。按下 *q* 键退出。*

 *## 它是如何工作的...

在这里，在这个简短的食谱中，我们向您展示了较少导航的基础知识，这对于阅读手册页是必不可少的，并且在本书中被许多其他程序用来显示文本。我们只向您展示了基本命令，还有很多需要学习的。请阅读较少的手册，了解更多关于`man less`命令的信息。

# Vim 介绍

在本食谱中，我们将为您非常简要地介绍文本编辑器 Vim，它在整本书中被用作标准文本编辑器。您也可以使用任何其他您喜欢的文本编辑器，例如 nano 或 emacs。

## 做好准备

要完成此方法，您将需要具有 root 权限的 CentOS 7 操作系统的有效安装。

## 怎么做...

我们将通过安装`vim-enhanced`包来开始这个配方，因为它包含一个教程，您可以使用它来学习如何使用 Vim:

1.  首先，以 root 用户身份登录并安装以下软件包:

    ```sh
    yum install vim-enhanced

    ```

2.  然后，键入以下命令开始 Vim 教程:

    ```sh
    vimtutor

    ```

3.  这将在 Vim 编辑器中打开 Vim 教程。导航时，按下*向上*和*向下*键，单行上下滚动。退出教程，按 *Esc* 键，然后键入`:q!`，接着按*返回*键退出。
4.  现在，您应该通读该文件，并通过课程来基本了解 Vim，学习如何编辑您的文本文档。

## 它是如何工作的...

本食谱中显示的教程应该被视为一个起点，从这里学习使用 Linux 最强大、最有效的文本编辑器的基础知识。Vim 有一个非常陡峭的学习曲线，但是在花了大约半个小时阅读 vimtutor 指南后，您应该能够毫无问题地完成所有常见的文本编辑任务，例如打开、编辑和保存文本文件。

# 说正确的语言

在本食谱中，我们将向您展示如何为整个系统和单个用户更改您的 CentOS 7 安装的语言设置。改变这一点的需求很少，但可能很重要，例如如果我们在安装过程中不小心选择了错误的语言。

## 做好准备

要完成这个配方，您需要安装一个具有 root 权限的 CentOS 7 操作系统，以及一个您选择的基于控制台的文本编辑器。您应该已经阅读了食谱较少的*导航文本文件，因为该食谱中的一些命令将使用较少的打印输出。*

## 怎么做...

如果您想更改 CentOS 7 系统的全系统语言设置，您必须调整两类设置。我们首先更改系统区域设置信息，然后更改键盘设置:

1.  首先，以 root 用户身份登录并键入以下命令，以显示控制台、图形窗口管理器(X11 布局)以及当前键盘布局的当前区域设置:

    ```sh
    localectl status

    ```

2.  接下来，要更改这些设置，我们首先需要知道该系统上所有可用的区域设置和键盘设置(两个命令都使用`less`导航):

    ```sh
    localectl list-locales
    localectl list-keymaps

    ```

3.  如果您在我们的示例中从上面的输出中选择了正确的区域设置，`de_DE.utf8`和`keymap de-mac`(根据您自己的适当需求进行更改)，您可以使用:

    ```sh
    localectl set-locale LANG=de_DE.utf8
    localectl set-keymap de-mac

    ```

    更改您的区域设置和键盘设置
4.  现在，再次使用相同的命令验证您的更改的持久性:

    ```sh
    localectl status

    ```

## 它是如何工作的...

正如我们所见，`localectl`命令是一个非常方便的工具，可以管理 CentOS 7 系统中所有重要的语言设置。

那么我们从这次经历中学到了什么呢？

我们从以 root 用户身份登录命令行开始。然后，我们运行带有参数`status`的`localectl`命令，该命令为我们提供了系统中当前语言设置的概述。这个命令的输出向我们展示了 CentOS 7 系统中的语言属性可以分为区域设置(系统区域设置)和键映射(VC 键映射和所有 X11 布局属性)设置。

Linux 上的区域设置用于设置系统的语言以及其他特定于语言的属性。这可能包括来自错误消息、日志输出、用户界面的文本，如果您使用的是 Gnome 之类的窗口管理器，甚至还有**图形用户界面** ( **GUI** )。区域设置还可以定义特定于区域的格式，如纸张大小、数字及其自然排序、货币信息等。它们还定义了字符编码，如果您选择的语言包含标准 ASCII 编码中找不到的字符，这一点可能很重要。

另一方面，键盘映射设置定义了键盘上每个键的精确布局。

接下来，要更改这些设置，我们首先使用`list-locales`参数发出`localectl`命令，检索系统上所有地区的完整列表，并使用`list-keymaps`显示系统中所有可用键盘设置的列表。从`list-locales`参数输出的区域使用非常紧凑的注释来定义语言:

```sh
Language[_Region][.Encoding][@Modificator]

```

只有`Language`部分是强制的，其余都是可选的。语言和地区的例子有:`en_US`代表英语，地区代表美国或美国英语，`es_CU`代表西班牙语，地区代表古巴或古巴西班牙语。

编码对于特殊字符很重要，例如德语元音或法语口音。这些特殊字符的记忆表示可以根据所使用的编码类型进行不同的解释。一般来说，应该使用 UTF-8，因为它能够编码几乎所有语言中的任何字符。

修改器用于更改由区域设置定义的设置。例如，如果您想要塞尔维亚塞尔维亚的拉丁文设置，则使用`sr_RS.utf8@latin`，塞尔维亚塞尔维亚通常使用西里尔文定义。这将更改为西方设置，如排序、货币信息等。

为了改变实际的区域设置，我们使用了`set-locale LANG=de_DE.utf8`参数。这里，选择编码是为了显示正确的德语元音。请注意，我们使用了`LANG`选项来为所有可用的区域设置选项设置相同的区域设置值(例如，`de_DE.utf8`)。如果您不想让所有可用选项都具有相同的区域设置值，可以对单个区域设置选项使用更细粒度的控制。请使用手册页`man 7 locale`参考地区描述(关于最小安装；在使用`yum install man-pages`命令之前，您需要安装所有的 Linux 文档手册页。您可以使用类似的语法设置这些附加选项，例如，设置时间区域设置使用:

```sh
localectl set-locale LC_TIME="de_DE.utf8"

```

接下来，我们使用`list-keymaps`参数显示了所有可用的键盘码。正如我们从运行`localectl status`中看到的，键位图可以在非图形(VC 键位图)和图形(X11 布局)设置中分离，这允许在使用 Gnome 等窗口管理器和控制台时灵活配置不同的键盘布局。使用参数`set-keymap de-mac`运行`localectl`，将当前键盘映射设置为德国苹果麦金塔键盘模式。该命令将给定的键盘类型应用于普通 VC 和 X11 键盘映射。如果您希望 X11 的映射不同于控制台的映射，请使用`localectl --no-convert set-x11-keymap cz-querty`，我们使用`cz-querty`将键盘映射代码转换为捷克的 querty 键盘模型(相应地进行更改)。

## 还有更多…

有时，单个系统用户需要不同于系统区域设置的语言设置(只能由根用户设置)，这取决于他们的区域键盘差异以及使用他们首选的人类语言与系统进行交互。只要不被本地环境变量覆盖，每个用户都可以继承系统范围的区域设置。

### 注

如果用户已经为自己定义了其他语言环境，那么更改系统范围的语言环境不一定会对用户的语言环境产生影响。

要打印任何系统用户的所有当前区域环境变量，我们可以使用命令`locale`。使用适当的变量名设置单个环境变量；例如，要将时间区域设置为美国时间，我们将使用下面的行:

```sh
export LC_TIME="en_US.UTF-8"

```

但是，最有可能的是我们希望将所有的语言环境更改为相同的值；这可以通过设置`LANG`来完成。例如，要将所有地区设置为美式英语，请使用下面的行:

```sh
export LANG="en_US.UTF-8"

```

为了测试区域设置更改的效果，我们现在可以生成一条错误消息，该消息将以`locale`命令设置的语言显示。以下是将区域设置从英语更改为德语的不同语言输出:

```sh
export LANG="en_US.UTF-8"
ls !

```

将打印以下输出:

```sh
ls: cannot access !: No such file or directory

```

现在，更改为德语区域设置:

```sh
export LANG="de_DE.UTF-8"
ls !

```

将打印以下输出:

```sh
ls: Zugriff auf ! nicht möglich: Datei oder Verzeichnis nicht gefunden

```

使用`export`命令在活动控制台中设置区域设置将无法在关闭窗口或打开新的终端会话时继续。如果您想使这些更改永久化，您可以在主目录中名为`.bashrc`的文件中设置任何区域环境变量，例如`LANG`变量，每次打开 shell 时都会读取该文件。在我们的示例中，要将区域设置永久更改为`de_DE.UTF-8`(根据您自己的需要进行更改)，请使用以下行:

```sh
echo "export LANG='de_DE.UTF-8'" >> ~/.bashrc

```

# 将系统时钟与 NTP 和 chrony 套件同步

在本食谱中，我们将学习如何使用**网络时间协议** ( **NTP** )和计时套件将系统时钟与外部时间服务器同步。从需要给文档、电子邮件和日志文件打上时间戳，到保护、运行和调试网络，或者简单地与共享设备和服务进行交互，服务器上的一切都依赖于保持准确的系统时钟，本食谱的目的是向您展示如何实现这一点。

## 做好准备

要完成此方法，您需要安装具有 root 权限的 CentOS 7 操作系统、您选择的基于控制台的文本编辑器，以及连接到互联网以方便下载其他软件包。

## 怎么做...

在这个食谱中，我们将使用`chrony`服务来管理我们的时间同步。由于 CentOS minimal 默认情况下不安装 chrony，我们将通过安装它来开始这个方法:

1.  首先，以 root 用户身份登录并安装`chrony`服务，然后启动它并验证它正在运行:

    ```sh
    yum install -y chrony
    systemctl start chronyd
    systemctl status chronyd

    ```

2.  另外，如果我们想永久使用 chrony，我们必须在服务器启动时启用它:

    ```sh
    systemctl enable chronyd

    ```

3.  接下来，我们需要检查系统是否已经通过网络使用 NTP 来同步我们的系统时钟:

    ```sh
    timedatectl  | grep "NTP synchronized"

    ```

4.  如果上一步的输出显示`NTP synchronized`为`No`，我们需要使用:

    ```sh
    timedatectl set-ntp yes

    ```

    启用它
5.  如果您再次运行该命令(从步骤 3 开始)，您应该看到它现在正在同步 NTP。
6.  chrony 的默认安装将使用可以访问原子钟的公共服务器，但是为了优化服务，我们需要做一些简单的更改来简化和优化服务器的使用时间。为此，用您最喜欢的文本编辑器打开主编年配置文件，如下所示:

    ```sh
    vi /etc/chrony.conf

    ```

7.  在文件中，向下滚动并查找包含以下内容的行:

    ```sh
    server 0.centos.pool.ntp.org iburst
    server 1.centos.pool.ntp.org iburst
    server 2.centos.pool.ntp.org iburst
    server 3.centos.pool.ntp.org iburst

    ```

8.  Replace the values shown with a list of preferred local time servers:

    ```sh
    server 0.uk.pool.ntp.org iburst
    server 1.uk.pool.ntp.org iburst
    server 2.uk.pool.ntp.org iburst
    server 3.uk.pool.ntp.org iburst

    ```

    ### 注

    访问[http://www.pool.ntp.org/](http://www.pool.ntp.org/)以获得地理上靠近您当前位置的本地服务器列表。请记住，使用三个或更多服务器将有增加 NTP 服务的准确性的趋势。

9.  当完成后，使用`sytstemctl`命令

    ```sh
    systemctl restart chronyd

    ```

    在同步服务器前保存并关闭文件
10.  要检查`config`文件中的修改是否成功，您可以使用以下命令:

    ```sh
    systemctl status chronyd

    ```

11.  要检查 chrony 是否正在处理您的系统时间同步，请使用以下命令:

    ```sh
    chronyc tracking

    ```

12.  要检查网络源是否用于同步，请使用以下命令:

    ```sh
    chronyc sources

    ```

## 它是如何工作的...

我们的 CentOS 7 操作系统的时间是根据硬件时钟在每次启动时设置的，硬件时钟是位于您计算机主板上的小电池驱动时钟。通常，这个时钟太不准确或没有设置正确，因此最好通过互联网从可靠的来源(使用实时原子时间)获取系统时间。chrony 守护进程`chronyd`通过使用 NTP 通信协议与远程服务器同步的过程来设置和维护系统时间。

那么，我们从这次经历中学到了什么？

作为第一步，我们安装了`chrony`服务，因为它在 CentOS 7 的最小安装中默认不可用。之后，我们使用`timedatectl set-ntp yes`命令启用系统时间与 NTP 的同步。

之后，我们打开主记录配置文件`/etc/chrony.conf`，展示了如何更改使用的外部时间服务器。如果您的服务器位于公司防火墙之后，并且拥有自己的 NTP 服务器基础架构，这一点特别有用。

重新启动服务后，我们学习了如何使用`chronyc`命令检查和监控我们的新配置。这是一个有用的命令行工具(c 代表客户端)，用于交互和控制一个 chrony 守护进程(本地或远程)。我们将`tracking`参数与`chronyc`一起使用，它向我们显示了当前与特定服务器的 NTP 同步过程的详细信息。如果您需要有关输出(`man chronyc`)中显示的属性的更多帮助，请参考`chronyc`命令的`man`页。

我们还在`chronyc`程序中使用了`sources`参数，它向我们展示了所使用的 NTP 时间服务器的概述。

您也可以使用旧的`date`命令来验证正确的时间同步。重要的是要认识到，同步服务器的过程可能不是瞬时的，并且这个过程可能需要一段时间才能完成。然而，您现在可以放松了，因为您完全知道如何使用 NTP 协议安装、管理和同步您的时间。

## 还有更多...

在本食谱中，我们使用`chrony`服务和 NTP 协议设置系统时间。通常，系统时间设置为 **协调世界时** ( **世界协调时**)或世界时间，这意味着它是一个全球通用的标准时间。由此，我们需要使用时区来计算我们的当地时间。要找到正确的时区，请使用以下命令(使用较少的配方读取*导航文本文件以处理输出):*

```sh
timedatectl list-timezones

```

如果你找到了正确的时区，把它写下来，用在下一个命令中；例如，如果您位于德国并且靠近柏林市，请使用以下命令:

```sh
timedatectl set-timezone Europe/Berlin

```

再次使用`timedatectl`检查您现在的当地时间是否正确:

```sh
timedatectl | grep "Local time"

```

最后，如果正确，您可以将您的硬件时钟与您的系统时间同步，使其更加精确:

```sh
hwclock --systohc

```

# 设置您的主机名并解析网络

设置主机名的过程通常与安装过程相关联。如果你需要更改它或你的服务器的**域名系统** ( **域名系统**)解析器，这个食谱将告诉你如何做。

## 做好准备

要完成此方法，您需要安装具有 root 权限的 CentOS 7 操作系统，以及您选择的基于控制台的文本编辑器。

## 怎么做...

首先，我们将以 root 用户身份访问系统，并打开以下文件来命名或重命名您当前服务器的主机名:

1.  以 root 用户身份登录，输入以下命令查看当前主机名:

    ```sh
    hostnamectl status

    ```

2.  Now, change the hostname value to your preferred name. For example, if you want to call your server `jimi`, you would type (change appropriately):

    ```sh
    hostnamectl set-hostname jimi

    ```

    ### 注

    静态主机名区分大小写，仅限于使用互联网友好的字母数字文本字符串。总长度不应超过 63 个字符，但尽量保持短得多。

3.  接下来，我们需要服务器的 IP 地址。输入以下命令进行查找(您需要在输出中识别正确的网络接口):

    ```sh
    ip addr list

    ```

4.  之后，我们将设置 **全限定域名** ( **FQDN** )，为此，我们需要打开并编辑主机文件:

    ```sh
    vi /etc/hosts

    ```

5.  Here, you should add a new line appropriate to your needs. For example, if your server's hostname was called jimi, (with an IP address of `192.168.1.100`, and a domain name of `henry.com`) your final line to append will look like this:

    ```sh
    192.168.1.100        jimi.henry.com jimi

    ```

    ### 注

    对于仅在本地网络上找到的服务器，建议使用非基于互联网的顶级地址。例如，您可以使用`.local`或`.lan`，甚至`.home`，通过使用这些引用，您将避免与典型的`.com`、`.co.uk`或`.net`域名混淆。

6.  接下来，我们将打开`resolv.conf`文件，该文件负责配置系统将使用的静态 DNS 服务器地址:

    ```sh
    vi /etc/resolv.conf

    ```

7.  用以下内容替换文件内容:

    ```sh
    # use google for dns
    nameserver 8.8.8.8
    nameserver 8.8.4.4

    ```

8.  完成后，在重新启动服务器之前保存并关闭文件，以使更改立即生效。为此，请返回您的控制台并键入:

    ```sh
    reboot

    ```

9.  成功重启后，您现在可以通过键入以下命令并等待响应来检查您的新主机名和 FQDN:

    ```sh
    hostname --fqdn

    ```

10.  要测试我们是否可以使用静态 DNS 服务器地址将域名解析为 IP 地址，请使用以下命令:

    ```sh
    ping -c 10 google.com

    ```

## 它是如何工作的...

主机名是为识别网络上的计算机而创建的唯一标签。它仅限于基于字母数字的字符，使用`hostnamectl`命令可以更改服务器的主机名。DNS 服务器用于将域名转换为 IP 地址。有几个公共 DNS 服务器可用；在后面的食谱中，我们将构建自己的 DNS 服务。

那么，我们从这次经历中学到了什么？

在配方的第一阶段，我们使用`hostnamectl`命令更改了服务器使用的当前主机名。该命令可以设置三种不同类型的主机名。将命令与`set-hostname`参数一起使用将为所有三个主机名设置相同的名称:高级`pretty`主机名，它可能包括各种特殊字符(例如`Lennart's Laptop`)、用于在引导时初始化内核主机名的静态主机名(例如`lennarts-laptop`)以及临时主机名，它是从网络配置接收的默认主机名。

接下来，我们设置服务器的 FQDN。FQDN 是主机名以及其后的域名。当您运行私有域名系统或允许外部访问您的服务器时，域名变得很重要。除了使用域名系统服务器设置之外，FQDN 还可以通过更新在`/etc/hosts`找到的主机文件来实现。

CentOS 使用此文件将主机名映射到 IP 地址，在新的、未配置的或最近安装的服务器上，通常会发现此文件不正确。为此，我们首先要用`ip addr list`找出服务器的 IP 地址。

FQDN 应该由一个短主机名和域名组成。基于这个食谱中显示的例子，我们为名为`henry`的服务器设置了 FQDN，它的 IP 地址是`192.168.1.100`，域名是`henry.com`。

保存这个文件可能会完成这个过程。但是，因为内核会在引导过程中记录主机名，所以在使用更改的设置之前，除了重新引导服务器，别无选择。

接下来，我们打开系统的`resolv.conf`文件，里面保存了系统的 DNS 服务器的 IP 地址。如果您的服务器不使用或没有任何 DNS 记录，则您的系统根本无法在任何程序中为网络目的地使用域名。在我们的例子中，我们输入了公共的谷歌域名系统服务器的 IP 地址，但是您可以使用任何您想要或必须使用的域名系统服务器(通常在合作的环境中，在防火墙后面，您必须使用内部的域名系统服务器基础设施)。在成功重启后，我们使用`hostname`命令确认了您的新设置，该命令可以根据给定的参数打印出主机名或 FQDN。

因此，总之，您可以说这个方法不仅向您展示了如何重命名服务器和解决网络问题，还向您展示了主机名和域名之间的区别:

正如我们所了解的，服务器不仅因为使用了更短、更容易记住、更快键入的基于单个单词的主机名而为人所知，它还由用句点分隔的三个值组成(例如 jimi.henry.com)。起初，这些值之间的关系可能看起来很奇怪，尤其是在许多人将它们视为单个值的情况下，但是通过完成这个食谱，您发现域名由于由解析器子系统确定而与主机名保持不同，并且只有通过将它们放在一起，您的服务器才会产生整个系统的 FQDN。

## 还有更多...

hosts 文件由 IP 地址和相应主机名的列表组成，如果您的网络包含 IP 地址未在现有 DNS 记录中列出的计算机，那么为了加快网络速度，通常建议您将它们添加到此文件中。

这可以在任何操作系统上实现，但是要在 CentOS 上实现，只需在您最喜欢的文本编辑器中打开 hosts 文件，如下所示:

```sh
vi /etc/hosts

```

现在，向下滚动到文件底部的，通过用更适合您自己需要的东西替换此处显示的域名和 IP 地址来添加以下值:

```sh
192.168.1.100    www.example1.lan
192.168.1.101    www.example2.lan
```

您甚至可以使用外部地址，例如:

```sh
83.166.169.228  www.packtpub.com
```

这种方法为您提供了在域名和 IP 地址之间创建映射的机会，而不需要使用 DNS，并且它可以应用于任何工作站或服务器。该列表不受大小限制，您甚至可以使用这种方法来阻止对某些网站的访问，只需将访问已知网站的所有请求重新指向不同的 IP 地址。例如，如果`www.website.com`的真实地址是`192.168.1.200`并且您想要限制对它的访问，那么只需对您想要阻止访问的计算机上的 hosts 文件进行以下更改:

```sh
127.0.0.1    www.website.com
```

它不是故障安全的，但在这种情况下，任何试图访问该系统上的`www.website.com`的人都会自动被发送到`127.0.0.1`，这是您的本地网络地址，因此这只会阻止访问。

完成后，请记得以通常的方式保存和关闭文件，然后再继续享受任何可用网络中更快、更安全的域名解析带来的好处。

# 建立静态网络连接

在本食谱中，我们将学习如何为新的或现有的 CentOS 服务器配置静态 IP 地址。

虽然动态分配的 IP 地址或 DHCP 预留对于大多数台式机和笔记本电脑用户来说可能很好，但如果您正在设置服务器，通常情况下您需要静态 IP 地址。从网页到电子邮件，从数据库到文件共享，一个静态的 IP 地址将成为一个永久的位置，您的服务器将从这里提供一系列的应用程序和服务，这个食谱的目的是向您展示如何轻松地实现它。

## 做好准备

要完成此方法，您需要安装具有 root 权限的 CentOS 7 操作系统和您选择的基于控制台的文本编辑器。

## 怎么做...

为了这个食谱的目的，你可以在目录`/etc/sysconfig/network-scripts/`中找到所有相关的文件。首先，您需要找出要设置为静态的网络接口的正确名称。如果您需要将多个网络接口设置为静态，请对每个设备重复此方法。

1.  为此，请以 root 用户身份登录，并键入以下命令以获取系统所有网络接口的列表:

    ```sh
    ip addr list

    ```

2.  如果你只安装了一张网卡，应该很容易就能查到它的名字；只需选择未命名的`lo`(即环回设备)。如果你有不止一个，看看不同设备的 IP 地址可以帮助你选择一个正确的。在我们的例子中，该设备被称为`enp0s3`。
3.  接下来，备份网络接口配置文件(如果您的网络接口名称不同，请相应更改`enp0s3`部分):

    ```sh
    cp /etc/sysconfig/network-scripts/ifcfg-enp0s3/etc/sysconfig/network-scripts/ifcfg-enp0s3.BAK

    ```

4.  当您准备好继续操作时，在您最喜欢的文本编辑器中键入下面显示的内容来打开以下文件:

    ```sh
    vi /etc/sysconfig/network-scripts/ifcfg-enp0s3

    ```

5.  现在，处理文件并应用以下更改:

    ```sh
    NM_CONTROLLED="no"
    BOOTPROTO=none
    DEFROUTE=yes
    PEERDNS=no
    PEERROUTES=yes
    IPV4_FAILURE_FATAL=yes

    ```

6.  现在，根据需要通过自定义`XXX.XXX.XXX.XXX`的值来添加您的 IP 信息:

    ```sh
    IPADDR=XXX.XXX.XXX.XXX
    NETMASK= XXX.XXX.XXX.XXX
    BROADCAST= XXX.XXX.XXX.XXX

    ```

7.  我们现在必须添加一个默认网关。通常，这应该是您的路由器的地址。为此，只需在文件底部添加一个新行，如下所示，并根据需要自定义该值:

    ```sh
    GATEWAY=XXX.XXX.XXX.XXX

    ```

8.  准备就绪后，保存并关闭文件，然后对任何剩余的想要静态化的以太网设备重复此步骤。执行此操作时，请记住为每个设备分配不同的 IP 地址。
9.  完成后，保存并关闭此文件，然后重新启动网络服务:

    ```sh
    systemctl restart network

    ```

## 它是如何工作的...

在本食谱中，您已经看到了将服务器的 IP 地址状态从从外部 DHCP 提供程序获得的动态值更改为您分配的静态值的相关过程。该 IP 地址现在将形成一个独特的网络位置，您将能够从该位置交付一整套服务和应用程序。这是一个永久性的修改，是的，你可以说这个过程本身是相对简单的。

那么，我们从这次经历中学到了什么？

通过识别您选择的网络接口名称并创建原始以太网配置文件的备份，我们开始制作配方，然后打开位于`/etc/sysconfig/network-scripts/ifcfg-XXX`的配置文件(其中`XXX`是您的接口名称，例如，`enp0s3`)。由于静态不再需要网络管理器的服务，我们通过将值设置为`no`来禁用`NM_CONTROLLED`。接下来，由于我们正在移动到静态 IP 地址的过程中，`BOOTPROTO`已被设置为`none`，因为我们不再使用 DHCP。为了完成配置更改，我们接着添加特定的网络值，并设置 IP 地址、网络掩码、广播和默认网关地址。

为了帮助创建静态 IP 地址，默认网关是一个非常重要的设置，因为它允许服务器通过路由器与更广阔的世界联系。

完成后，我们被要求保存并关闭文件，然后对任何剩余的以太网设备重复此步骤。完成此操作后，我们被要求重新启动网络服务，以完成此配方并使我们的更改立即生效。

# 成为超级用户

在本食谱中，我们将学习如何为指定的用户或组提供以提升的权限执行各种命令的能力。

在 CentOS Linux 上，许多文件、文件夹或命令只能由名为`root`的用户访问或执行，T0 是在 Linux 系统上可以控制一切的用户的名字。每个系统有一个根用户可能适合您的需求，但是对于那些想要更大程度的灵活性、可靠的审计跟踪以及能够向选定数量的受信任用户提供有限的管理功能的人来说，您来对了地方。本食谱的目的是向您展示如何激活和配置 **sudo** ( **超级用户执行**)命令。

## 做好准备

要完成此方法，您需要以 root 权限最低限度地安装 CentOS 7 操作系统。假设您的服务器维护着一个或多个有资格升级权限的用户(根用户除外)。如果您在安装过程中没有创建系统用户帐户，请首先应用配方[第 3 章](03.html#10DJ41-4cf34a6d07944734bb93fb0cd15cce8c "Chapter 3. Managing the System")、*管理系统*中的*管理用户及其组*。

## 怎么做...

要开始这个食谱，我们将首先用非特权用户测试`sudo`命令。

1.  首先，使用非根用户帐户登录您的系统，然后键入以下内容以验证`sudo`未启用(询问时使用您的用户帐户密码):

    ```sh
    sudo ls /var/log/audit

    ```

2.  这将使用`<username>`打印以下错误输出，T0 是您当前登录的用户:

    ```sh
    <username> is not in the sudoers file.  This incident will be reported.

    ```

3.  现在，使用以下命令注销系统用户:

    ```sh
    logout

    ```

4.  接下来，以 root 用户身份登录，并使用以下命令为非 root 用户 sudo 供电(适当更改`<username>`:

    ```sh
    usermod -G wheel <username>

    ```

5.  现在，您可以通过再次注销 root 并从步骤 1 重新登录用户，然后再次尝试来测试`sudo`是否工作:

    ```sh
    sudo ls /var/log/audit

    ```

6.  恭喜，您现在已经将一个普通用户设置为拥有 sudo 权限，并且可以查看和执行仅限于根用户的文件和目录。

## 它是如何工作的...

与一些 Linux 发行版不同，CentOS 默认不提供 sudo。相反，通常只允许根用户访问系统的受限部分。这提供了一定程度的安全性，但是对于多用户服务器来说，几乎没有灵活性，除非您简单地为这些个人提供完全的管理根访问权限。这是不可取的，因此，本食谱的目的是向您展示如何为一个或多个用户提供以提升的权限执行命令的权利。

那么，我们从这次经历中学到了什么？

我们以没有超级用户权限或 sudo 权限的普通用户帐户登录系统开始。对于这个用户，我们试图列出一个通常只允许根用户查看的目录，因此我们对其应用了`sudo`命令。它失败了，给我们的错误是我们不在 sudoers 列表中。

`sudo`命令为指定的用户或组提供了执行命令的能力，就像他们是根用户一样。所有的动作都被记录下来(在一个名为`/var/log/secure`的文件中)，所以会有所有使用的命令和参数的痕迹。

然后，我们以真正的根用户身份登录，并将一个名为 wheel 的组添加到我们想要 sudo 权限的系统用户中。这个组被用作一个特殊的管理组，它的每个成员都被自动授予 sudo 权限。

从现在开始，指定用户可以实现 sudo，以便以提升的权限执行任何命令。为此，用户需要在任何命令前键入单词`sudo`，例如，他们可以运行以下命令:

```sh
sudo yum update

```

他们将被要求确认他们的用户密码(不是根密码！)，并且在成功认证后，该程序将作为用户根执行。

最后，我们可以说有三种方法可以成为 CentOS Linux 系统的根:

首先，以真正的用户根用户身份登录系统。其次，您可以在任何正常系统用户登录时使用命令`su – root`，给出根用户的密码以永久切换到根 shell 提示符。第三，你可以给一个普通用户 sudo 权限，这样他们就可以像超级用户一样使用自己的密码执行单个命令，而则以自己的身份登录。

### 注

**sudo** ( **超级用户 do** )不应与 **su** ( **替代用户**)命令混淆，后者允许您永久切换到另一个用户，而不是像作为根用户一样只执行单个命令。

`sudo`命令为拥有大量用户的服务器提供了极大的灵活性，一个管理员不足以管理整个系统。

# 定制您的系统横幅和消息

在本食谱中，我们将学习如果用户使用 SSH 或控制台成功登录到我们的 CentOS 7 系统，或者在图形窗口管理器中打开一个新的终端窗口，如何显示欢迎消息。这通常用于向用户显示信息性消息，或者出于法律原因。

## 做好准备

要完成此方法，您将需要最低限度地安装具有 root 权限的 CentOS 7 操作系统和您选择的基于控制台的文本编辑器。

## 怎么做...

1.  首先，使用您的根用户帐户登录您的系统，并使用您最喜欢的文本编辑器创建以下新文件:

    ```sh
    vi /etc/motd

    ```

2.  接下来，我们将在这个新文件中放入以下内容:

    ```sh
    ###############################################
    # This computer system is for authorized users only.
    # All activity is logged and regularly checked.
    # Individuals using this system without authority or
    # in excess of their authority are subject to
    # having all their services revoked...
    ###############################################

    ```

3.  保存并关闭此文件。
4.  恭喜，您现在已经为用户使用 ssh 或控制台成功登录系统设置了横幅消息。

## 它是如何工作的...

出于法律原因，强烈建议计算机在允许用户登录之前显示横幅；律师建议，只有在犯罪者当时知道他打算获得的访问是未经授权的情况下，才能实施未经授权访问罪。登录横幅是实现这一点的最佳方式。除了这个原因，你还可以为用户提供有用的系统信息。

那么，我们从这次经历中学到了什么？

我们从打开代表当天消息的文件`/etc/motd`开始这个食谱；此内容将在用户登录控制台或 ssh 后显示。接下来，我们在该文件中放入一个标准的法律免责声明并保存该文件。

## 还有更多...

如我们所见，`/etc/motd`文件在用户成功登录系统后显示静态文本。如果您希望在首次建立 ssh 连接时也显示一条消息，可以使用 ssh 横幅。默认情况下，ssh 守护程序配置文件中的横幅行为是禁用的，这意味着如果用户建立 ssh 连接，将不会显示任何消息。要启用此功能，请在服务器上以 root 用户身份登录，并使用您最喜欢的文本编辑器打开`/etc/ssh/sshd_config`文件，并在文件末尾放入以下内容:

```sh
Banner /etc/ssh-banner

```

然后，创建并打开一个名为`/etc/ssh-banner`的新文件，放入一条新的自定义 ssh 问候消息。

最后，使用以下代码重新启动 ssh 守护程序:

```sh
systemctl restart sshd.service

```

下次有人与您的服务器建立 ssh 连接时，将会打印出这条新消息。

`motd`文件只能打印静态消息和一些系统信息细节，但如果用户成功登录，就不可能在其中生成真正的动态消息或使用 bash 命令。

此外，`motd`在非登录外壳中不起作用，例如当您在图形窗口管理器中打开新终端时。为了实现这一点，我们可以在`/etc/profile.d`目录中创建一个自定义脚本。如果用户登录到系统，该目录中的所有脚本都会自动执行。首先，我们删除`/etc/motd`文件中的任何内容，因为我们不想显示两个欢迎横幅。然后，我们用我们的文本编辑器打开新文件`/etc/profile.d/motd.sh`，并创建一个自定义消息，如下所示，在这里我们可以使用 bash 命令并编写小脚本(使用 back ticks 运行这个文件中的 bash shell 命令):

```sh
#!/bin/bash
echo -e "
##################################
#
# Welcome to `hostname`, you are logged in as `whoami`
# This system is running `cat /etc/redhat-release`
# kernel is `uname -r`
# Uptime is 
`uptime | sed 's/.*up ([^,]*), .*/1/'`
# Mem total `cat /proc/meminfo | grep MemTotal | awk {'print $2'}` kB
###################################"

```

# 引发内核

Linux 内核是构成操作系统核心的程序。它可以直接访问底层硬件，并使用户可以使用外壳来使用它。

在这个食谱中，我们将学习如何通过使用动态加载的内核模块来初始化内核。内核模块是设备驱动程序文件(或文件系统驱动程序文件)，它增加了对特定硬件的支持，以便我们可以访问它们。

作为系统管理员，您不会经常使用内核模块，但是如果您有设备驱动程序问题或不支持的硬件，对它们有一个基本的了解会很有帮助。

## 做好准备

要完成此方法，您需要以 root 权限最低限度地安装 CentOS 7 操作系统。

## 怎么做...

1.  首先，使用您的根用户帐户登录您的系统，并键入以下命令以显示当前加载的所有 Linux 内核模块的状态:

    ```sh
    lsmod

    ```

2.  在输出中，您将看到所有加载的设备驱动程序(模块)；让我们看看是否已经加载了一个`cdrom`和`floppy`模块:

    ```sh
    lsmod | grep "cdrom\|floppy"

    ```

3.  在大多数服务器上，会有以下输出:

    ```sh
    cdrom                  42556  1 sr_mod
    floppy                 69417  0

    ```

4.  现在，我们想展示`sr_mod` cdrom 模块的详细信息:

    ```sh
    modinfo sr_mod

    ```

5.  接下来，从内核中卸载这两个模块(只有在系统中找到并加载了模块和硬件的情况下，才能这样做；否则跳过此步骤):

    ```sh
    modprobe -r -v sr_mod floppy

    ```

6.  检查模块是否已经卸载(现在输出应该是空的):

    ```sh
    lsmod | grep "cdrom\|floppy"

    ```

7.  现在，要显示系统上所有可用内核模块的列表，请使用以下目录，您可以在其中四处查看:

    ```sh
    ls /lib/modules/$(uname -r)/kernel

    ```

8.  让我们从名为`bluetooth`的子文件夹`/lib/modules/$(uname -r)/kernel/drivers/`中选择一个模块，并验证它尚未加载(输出应为空):

    ```sh
    lsmod | grep btusb

    ```

9.  获取模块的更多信息:

    ```sh
    modinfo btusb

    ```

10.  最后，加载这个蓝牙 USB 模块:

    ```sh
    modprobe btusb

    ```

11.  再次确认现在已加载:

    ```sh
    lsmod | grep "btusb"

    ```

## 它是如何工作的...

内核模块是系统硬件与内核和操作系统通信所需的驱动程序(也是加载和启用文件系统所需的驱动程序)。它们是动态加载的，这意味着在运行时只加载驱动程序或模块，这反映了您自己定制的特定硬件。

那么，我们从这次经历中学到了什么？

我们开始使用`lsmod`命令查看系统中所有当前加载的内核模块。输出显示三列:模块名称、模块加载时占用的内存量、该模块使用的进程数以及使用它的其他模块的依赖关系列表。接下来，我们检查内核是否已经加载了`cdrom`和`floppy`模块。在输出中，我们看到`cdrom`模块依赖于`sr_mod`模块。所以，接下来我们使用`modinfo`命令来获取关于它的详细信息。在这里，我们了解到`sr_mod`是 SCSI `cdrom`驱动程序。

因为我们在第一次安装基础系统时只需要软盘和 cdrom 驱动程序，所以我们现在可以禁用这些内核模块并节省一些内存。我们用`modprobe -r`命令卸载了模块及其依赖项，并再次使用`lsmod`检查这是否成功。

接下来，我们浏览了标准内核模块目录(例如，`/lib/modules/$(uname -r)/kernel/drivers`)。`uname` substring 命令打印出当前的内核版本，这样可以确保在我们的系统上安装了多个版本的内核之后，我们总是会列出当前的内核模块。

这个内核模块目录使用子目录保持系统上所有可用模块的结构和分类。我们导航到`drivers/bluetooth`并选择了`btusb`模块。在`btusb`模块上做`modinfo`，发现是通用蓝牙 USB 驱动。最后，我们决定我们需要这个模块，所以我们再次使用`modprobe`命令加载它。

## 还有更多...

重要的是要说使用`modprobe`命令加载和卸载内核模块不是持久的；这意味着，如果您重新启动系统，您对内核模块的所有更改都将消失。要在引导时加载内核模块，请创建一个新的可执行脚本文件`/etc/sysconfig/modules/<filename>.modules`，其中`<filename>`是您选择的名称。您可以像在普通命令行中一样输入`modprobe`执行命令。下面是一个在启动时额外加载蓝牙驱动程序的例子，例如`/etc/sysconfig/modules/btusb.modules`:

```sh
#!/bin/sh
if [ ! -c /dev/input/uinput ] ; then
exec /sbin/modprobe btusb >/dev/null 2>&1
fi

```

最后，您需要通过下面的行使您的新模块文件可执行:

```sh
chmod +x /etc/sysconfig/modules/btusb.modules

```

重启后用`lsmod`重新检查您的新模块设置。

要在引导时删除内核模块，例如`sr_mod`，我们需要使用`rdblacklist`内核引导选项将模块名称列入黑名单。我们可以通过将其附加到 GRUB2 配置文件`/etc/default/grub`中的`GRUB_CMDLINE_LINUX`指令的末尾来设置该选项，因此它看起来像:

```sh
GRUB_CMDLINE_LINUX="rd.lvm.lv=centos/root rd.lvm.lv=centos/swap crashkernel=auto rhgb quiet rdblacklist=sr_mod"

```

如果需要将多个模块列入黑名单，可以像`rdblacklist=sr_mod rdblacklist=nouveau`一样多次指定`rdblacklist`选项。

接下来，使用`grub2-mkconfig`命令重新创建 GRUB2 配置(要了解更多信息，请阅读[第 1 章](01.html#E9OE1-4cf34a6d07944734bb93fb0cd15cce8c "Chapter 1. Installing CentOS")、*安装 CentOS* 中的*入门和自定义引导加载程序*食谱)。

```sh
grub2-mkconfig -o /boot/grub2/grub.cfg

```

最后我们还需要使用黑名单指令在`/etc/modprobe.d/`目录中选择一个`new.conf`文件来`blacklist`模块名称，例如:

```sh
echo "blacklist sr_mod" >> /etc/modprobe.d/blacklist.conf

```*