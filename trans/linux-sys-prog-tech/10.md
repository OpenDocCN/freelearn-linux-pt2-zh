# *第十章*:使用不同种类的 IPC

在本章中，我们将了解通过所谓的**进程间通信** ( **IPC** )在进程之间进行通信的各种方式。我们将编写使用不同类型 IPC 的各种程序，从信号和管道到 FIFOs、消息队列、共享内存和套接字。

进程有时需要交换信息，例如，在客户端和服务器程序运行在同一台计算机上的情况下。这也可能是一个分成两个过程的过程，他们需要以某种方式交流。

这种 IPC 有多种发生方式。在本章中，我们将了解一些最常见的问题。

如果你想写更多最基本的程序，了解 IPC 是必不可少的。迟早，你会有一个需要共享信息的由多个片段或多个程序组成的程序。

在本章中，我们将介绍以下食谱:

*   为 IPC 使用信号—为守护进程构建客户端
*   与管道连通
*   先进先出——在Shell中使用
*   先进先出——构建发送方
*   先进先出——构建接收器
*   消息队列—创建发件人
*   消息队列—创建接收者
*   共享内存的子代和父代之间的通信
*   在不相关的进程之间使用共享内存
*   Unix 套接字—创建服务器
*   Unix 套接字—创建客户端

我们开始吧！

# 技术要求

对于这一章，你将需要 GCC 编译器，Make 工具，以及来自 [*第 3 章*](03.html#_idTextAnchor097)*的通用 Makefile，在 Linux* 中深入 C。如果您还没有安装这些工具，请参见 [*第 1 章*](01.html#_idTextAnchor020)*获取必要的工具并编写我们的第一个 Linux 程序*，了解安装说明。

本章的所有代码示例和通用 Makefile 可从 GitHub 下载，网址为[https://GitHub . com/PacktPublishing/Linux-System-Programming-technologies/tree/master/ch10](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10)。

查看以下链接，查看《行动守则》视频:[https://bit.ly/3u3y1C0](https://bit.ly/3u3y1C0)

# 使用 IPC 的信号——为守护进程构建客户端

在这本书里，我们已经多次使用了信号。然而，当启动时，我们总是使用`kill`命令向程序发送**信号**。这一次，我们将从 [*第 6 章*](06.html#_idTextAnchor245)*生成进程和使用作业控制*编写一个控制守护进程的小客户端`my-daemon-v2`。

这是信号用于**仪表板组合仪表**的典型例子。守护进程有一个小的“客户端程序”来控制它，这样它就可以停止它，重新启动它，重新加载它的配置文件，等等。

知道如何使用 IPC 的信号是编写可以在它们之间通信的程序的坚实开端。

## 做好准备

对于这个配方，您将需要 GCC 编译器、Make 工具和通用 Makefile。您还需要来自 [*第 6 章*](06.html#_idTextAnchor245)*生成流程和使用作业控制*的`my-daemon-v2.c`文件。本章的 GitHub 目录中有该文件的副本，网址为[https://GitHub . com/PacktPublishing/Linux-系统-编程-技术/树/master/ch10](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10) 。

## 怎么做…

在本食谱中，我们将从 [*第 6 章*](06.html#_idTextAnchor245)*生成流程和使用作业控制*向守护程序添加一个小客户端程序。这个程序会向守护进程发送信号，就像`kill`命令一样。但是，这个程序只会向守护进程发送信号，没有其他进程:

1.  将以下代码写入一个文件并保存为`my-daemon-ctl.c`。这个程序有点长，所以分成了几个步骤。但是所有的代码都在同一个文件中。我们将从包含行、使用函数的原型以及我们需要的所有变量开始:

    ```sh
    #define _XOPEN_SOURCE 500
    #include <stdio.h>
    #include <sys/types.h>
    #include <signal.h>
    #include <getopt.h>
    #include <string.h>
    #include <linux/limits.h>
    void printUsage(char progname[], FILE *fp);
    int main(int argc, char *argv[])
    {
       FILE *fp;
       FILE *procfp;
       int pid, opt;
       int killit = 0;
       char procpath[PATH_MAX] = { 0 };
       char cmdline[PATH_MAX] = { 0 };
       const char pidfile[] = "/var/run/my-daemon.pid";
       const char daemonPath[] = 
          "/usr/local/sbin/my-daemon-v2";
    ```

2.  然后，我们希望能够解析命令行选项。我们将只需要两个选择；即`-h`求助，`-k`杀死守护进程。默认显示守护进程的状态:

    ```sh
       /* Parse command-line options */
       while ((opt = getopt(argc, argv, "kh")) != -1)
       {
          switch (opt)
          {
             case 'k': /* kill the daemon */
                killit = 1;
                break;
             case 'h': /* help */
                printUsage(argv[0], stdout);
                return 0;
             default: /* in case of invalid options */
                printUsage(argv[0], stderr);
                return 1;
          }
       }
    ```

3.  现在，让我们打开 **PID** 文件并阅读它。完成后，我们需要在`/proc`中组装流程的`cmdline`文件的完整路径。然后，我们必须打开该文件并从中读取完整的命令行路径:

    ```sh
       if ( (fp = fopen(pidfile, "r")) == NULL )
       {
          perror("Can't open PID-file (daemon isn't "
             "running?)");
       }
       /* read the pid (and check if we could read an 
        * integer) */
       if ( (fscanf(fp, "%d", &pid)) != 1 )
       {
          fprintf(stderr, "Can't read PID from %s\n", 
             pidfile);
          return 1;
       }
       /* build the /proc path */
       sprintf(procpath, "/proc/%d/cmdline", pid);
       /* open the /proc path */
       if ( (procfp = fopen(procpath, "r")) == NULL )
       {
          perror("Can't open /proc path"
             " (no /proc or wrong PID?)");
          return 1;
       }
       /* read the cmd line path from proc */
       fscanf(procfp, "%s", cmdline); 
    ```

4.  现在我们已经有了 PID 和完整的命令行，我们可以再次检查 PID 是否属于`/usr/local/sbin/my-daemon-v2`而不是其他进程:

    ```sh
       /* check that the PID matches the cmdline */
       if ( (strncmp(cmdline, daemonPath, PATH_MAX)) 
          != 0 )
       {
          fprintf(stderr, "PID %d doesn't belong "
             "to %s\n", pid, daemonPath);
          return 1;
       }
    ```

5.  如果我们给程序`-k`选项，我们必须将`killit`变量设置为 1。所以，在这一点上，我们必须扼杀这个过程。否则，我们只打印一条消息，声明守护进程正在运行:

    ```sh
       if ( killit == 1 )
       {
          if ( (kill(pid, SIGTERM)) == 0 )
          {
             printf("Successfully terminated " 
                "my-daemon-v2\n");
          }
          else
          {
             perror("Couldn't terminate my-daemon-v2");
             return 1;
          }        
       }
       else
       {
          printf("The daemon is running with PID %d\n", 
             pid);
       }
       return 0;
    }
    ```

6.  最后，我们为`printUsage()`函数

    ```sh
    void printUsage(char progname[], FILE *fp)
    {
       fprintf(fp, "Usage: %s [-k] [-h]\n", progname);
       fprintf(fp, "If no options are given, a status "
          "message is displayed.\n"
          "-k will terminate the daemon.\n"
          "-h will display this usage help.\n");       
    }
    ```

    创建函数
7.  现在，我们可以编译程序:

    ```sh
    $> make my-daemon-ctl
    gcc -Wall -Wextra -pedantic -std=c99    my-daemon ctl.c   -o my-daemon-ctl
    ```

8.  在我们继续之前，请确保您已经禁用并停止了第 7 章 *中守护程序的`systemd`服务，使用 systemd 来处理您的守护程序* :

    ```sh
    $> sudo systemctl disable my-daemon
    $> sudo systemctl stop my-daemon
    ```

9.  现在，编译守护进程(`my-daemon-v2.c`)如果你还没有这样做的话:

    ```sh
    $> make my-daemon-v2
    gcc -Wall -Wextra -pedantic -std=c99    my-daemon-v2.c   -o my-daemon-v2
    ```

10.  然后，手动启动守护程序(这次没有`systemd`服务):

    ```sh
    $> sudo ./my-daemon-v2
    ```

11.  现在，我们可以尝试我们的新程序来控制守护进程。注意，我们不能以普通用户的身份杀死守护进程:

    ```sh
    $> ./my-daemon-ctl 
    The daemon is running with PID 17802 and cmdline ./my-daemon-v2
    $> ./my-daemon-ctl -k
    Couldn't terminate daemon: Operation not permitted
    $> sudo ./my-daemon-ctl -k
    Successfully terminated daemon
    ```

12.  如果守护程序被杀死后我们重新运行程序，它会告诉我们没有 PID 文件，因此守护程序没有运行:

    ```sh
    $> ./my-daemon-ctl 
    Can't open PID-file (daemon isn't running?): No such file or directory
    ```

## 它是如何工作的…

由于守护进程创建了一个 PID 文件，我们可以使用该文件来获取正在运行的守护进程的 PID。守护进程在终止时会删除 PID 文件，所以如果没有 PID 文件，我们可以假设守护进程没有运行。

如果 PID 文件确实存在，首先，我们从文件中读取 PID。然后，我们使用 PID 在`/proc`文件系统中组装该 PID 的`cmdline`文件的路径。Linux 系统上的每个进程在`/proc`文件系统中都有一个目录。在每个进程的目录中，都有一个名为`cmdline`的文件。该文件包含该过程的完整命令行。例如，如果守护进程是从当前目录启动的，它包含`./my-daemon-v2`，而如果它是从`/usr/local/sbin/my-daemon-v2`启动的，它包含完整的路径。

例如，如果守护进程的 PID 为`12345`，则到达`cmdline`的完整路径为`/proc/12345/cmdline`。这就是我们用`sprintf()`组装的。

然后，我们阅读`cmdline`的内容。稍后，我们使用该文件的内容来验证 PID 是否与名为`my-daemon-v2`的进程匹配。这是一个安全措施，这样我们就不会误杀错误的流程。如果守护进程被`KILL`信号杀死，它就没有机会删除 PID 文件。如果将来另一个进程获得相同的 PID，我们将冒着杀死该进程的风险。PID 编号最终将被重复使用。

当我们有了守护进程的 PID 并验证它确实属于正确的进程时，我们将要么获得它的状态，要么杀死它，这取决于我们用`-k`选项指定的内容。

这是用于控制复杂守护进程的控制程序的数量。

## 另见

更多关于`kill()`系统调用的信息，请参见`man 2 kill`手册页。

# 与管道连通

在这个配方中，我们将创建一个程序，该程序使用**管道**在两个进程之间分叉和通信。有时候，当我们**岔开**一个流程的时候，**的家长**和**的孩子**需要一个沟通的方式。管道通常是一种简单的方法。

在编写更复杂的程序时，知道如何在父进程和子进程之间通信和交换数据是很重要的。

## 做好准备

对于这个配方，我们只需要 GCC 编译器、Make 工具和通用 Makefile。

## 怎么做…

让我们编写一个简单的分叉程序:

1.  Write the following code in a file and name it `pipe-example.c`. We'll go through the code step by step. Remember that all the code goes in the same file.

    我们将从包含行和`main()`函数开始。然后，我们将创建一个大小为 2 的整数数组。管道稍后将使用该数组。数组中的第一个整数(0)是管道读取端的文件描述符。第二个整数(1)表示管道的写入端:

    ```sh
    #define _POSIX_C_SOURCE  200809L
    #include <stdio.h>
    #include <unistd.h>
    #include <fcntl.h>
    #include <errno.h>
    #define MAX 128
    int main(void)
    {
       int pipefd[2] = { 0 };
       pid_t pid;
       char line[MAX];
    ```

2.  现在，我们将使用`pipe()`系统调用创建管道。我们将给它一个整数数组作为参数。之后，我们将使用`fork()`系统调用:

    ```sh
       if ( (pipe(pipefd)) == -1 )
       {
          perror("Can't create pipe");
          return 1;
       }   
       if ( (pid = fork()) == -1 )
       {
          perror("Can't fork");
          return 1;
       }
    ```

3.  如果我们在父进程内部，我们关闭读取端(因为我们只想从父进程写入)。然后，我们使用`dprintf()` :

    ```sh
       if (pid > 0)
       {
          /* inside the parent */
          close(pipefd[0]); /* close the read end */
          dprintf(pipefd[1], "Hello from parent");
       }
    ```

    向管道的文件描述符(写结束)写一条消息
4.  在孩子的内心，我们做相反的事情；也就是说，我们关闭管道的写端。然后，我们使用`read()`系统调用读取管道中的数据。最后，我们使用`printf()` :

    ```sh
       else
       {
          /* inside the child */
          close(pipefd[1]); /* close the write end */
          read(pipefd[0], line, MAX-1);
          printf("%s\n", line); /* print message from
                                 * the parent */
       }
       return 0;
    }
    ```

    打印消息
5.  现在，编译程序以便我们可以运行它:

    ```sh
    $> make pipe-example
    gcc -Wall -Wextra -pedantic -std=c99    pipe-example.c   -o pipe-example
    ```

6.  让我们运行程序。家长用管道向孩子发送信息`Hello from parent`。然后，是孩子在屏幕上打印了这条信息:

    ```sh
    $> ./pipe-example 
    Hello from parent
    ```

## 它是如何工作的…

`pipe()`系统调用将两个文件描述符返回到整数数组。第一个，`pipefd[0]`是管道的读端，而另一个，`pipefd[1]`是管道的写端。在家长里，我们给*写一条信息，写完*的管子。然后，在子过程中，我们从管道的*读取端*读取该数据。但是在我们进行任何读或写之前，我们会关闭在各自的过程中没有使用的管道的末端。

管道是目前比较常见的 IPC 技术之一。但是它们确实有一个缺点，那就是它们只能在相关的过程之间使用；也就是说，具有公共父级(或父级和子级)的进程。

还有另一种形式的管道可以克服这种限制:所谓的*命名管道*。命名管道的另一个名称是先进先出。这就是我们将在下一份食谱中介绍的内容。

## 另见

有关`pipe()`系统调用的更多信息，请参见`man 2 pipe`手册页。

# 先进先出–在Shell中使用

在前面的食谱中，我提到了`pipe()`系统调用有一个缺点——它只能在相关进程之间使用。但是我们可以使用另一种管道，叫做**管道**。它的另一个名字是**先进先出** ( **先进先出**)。命名管道可以在任何相关或不相关的过程之间使用。

命名管道或先进先出实际上是一种特殊的文件。`mkfifo()`函数在文件系统上创建该文件，就像任何其他文件一样。然后，我们使用该文件在进程之间读写数据。

还有一个名为`mkfifo`的命令，我们可以直接从 shell 中使用它来创建命名管道。我们可以用它在不相关的命令之间传输数据。

在命名管道的介绍中，我们将介绍`mkfifo`命令。在接下来的两个食谱中，我们将使用`mkfifo()`函数编写一个 C 程序，然后编写另一个程序来读取管道的数据。

作为用户、系统管理员和开发人员，知道如何使用命名管道将会给你带来更多的灵活性。您不再局限于仅在相关进程之间使用管道。您可以自由地在系统上的任何进程或命令之间传输数据，甚至在不同的用户之间。

## 做好准备

在这个食谱中，我们不会写任何程序，所以没有特殊要求。

## 怎么做…

在这个食谱中，我们将探索`mkfifo`命令，并学习如何使用它在不相关的进程之间传输数据:

1.  我们将从创建一个命名管道开始——一个先进先出文件。我们将在`/tmp`目录中创建它，这对于像这样的临时文件来说是很常见的。但是，您可以在任何您喜欢的地方创建它:

    ```sh
    $> mkfifo /tmp/my-fifo
    ```

2.  让我们通过使用`file`和`ls`命令来确认这确实是一个先进先出。请注意我的先进先出的当前权限模式。每个人都可以阅读。不过，这可能因你的系统而异，取决于你的`umask`。但我们应该对此保持警惕，以防我们要传输敏感数据。在这种情况下，我们可以使用`chmod`命令进行更改:

    ```sh
    $> file /tmp/my-fifo 
    /tmp/my-fifo: fifo (named pipe)
    $> ls -l /tmp/my-fifo 
    prw-r--r-- 1 jake jake 0 jan 10 20:03 /tmp/my-fifo
    ```

3.  现在，我们可以尝试向管道发送数据。由于管道是一个文件，我们将在这里使用重定向，而不是管道符号。换句话说，我们将数据重定向到管道。在这里，我们将把`uptime`命令的输出重定向到管道。一旦我们将数据重定向到管道，流程就会挂起，这很正常，因为另一端没有人接收数据。它实际上并不悬挂；它*阻挡* :

    ```sh
    $> uptime -p > /tmp/my-fifo
    ```

4.  打开一个新的终端，键入以下命令以从管道接收数据。请注意，第一个终端中的过程现在将结束:

    ```sh
    $> cat < /tmp/my-fifo 
    up 5 weeks, 6 days, 2 hours, 11 minutes
    ```

5.  我们也可以反过来做；也就是说，我们可以先打开接收端，然后将数据发送到管道。这将阻止**接收过程，直到它获得一些数据。运行以下命令设置接收端，并保持其运行:

    ```sh
    $> cat < /tmp/my-fifo
    ```** 
***   现在，我们使用相同的`uptime`命令向管道发送数据。请注意，一旦收到数据，第一个过程将结束:

    ```sh
    $> uptime -p > /tmp/my-fifo
    ```

    *   也可以从多个进程向先进先出发送数据。开辟三个新的终端。在每个终端中，键入以下命令，但第二个终端用 2 替换 1，第三个终端用 3:

    ```sh
    $> echo "Hello from terminal 1" > /tmp/my-fifo
    ```

    *   现在，打开另一个终端，输入以下命令。这将接收所有消息:

    ```sh
    $> cat < /tmp/my-fifo
    Hello from terminal 3
    Hello from terminal 1
    Hello from terminal 2
    ```** 

 **## 它是如何工作的…

先进先出只是文件系统中的一个文件，尽管是一个特殊的文件。一旦我们将数据重定向到先进先出，该过程将阻塞(或“挂起”)，直到数据在另一端被接收。

同样，如果我们首先启动接收过程，该过程将阻塞，直到它获得管道的数据。这种行为的原因是先进先出不是我们可以保存数据的常规文件。我们只能用它来重定向数据；也就是说，只是一个*管*。所以，如果我们向它发送数据，但另一端什么也没有，这个过程将一直等到另一端有人收到它。在有人连接到接收端之前，数据在管道中无处可去。

还有更多…

如果系统上有多个用户，可以尝试使用 FIFOs 向他们发送消息。这样做为我们提供了一种在用户之间复制和粘贴数据的简单方法。请注意，先进先出的权限模式必须允许其他用户读取它(如果您愿意，也可以写入它)。使用`-m`选项创建先进先出时，可以直接设置所需的权限模式。例如，`mkfifo /tmp/shared-fifo -m 666`将允许任何用户读写先进先出。

## 另见

在`man 1 mkfifo`手动页面中有一点关于`mkfifo`命令的更多信息。关于先进先出的更深入的解释，请参见`man 7 fifo`手册页。

# 先进先出–构建发送方

现在我们知道了什么是先进先出，我们将继续编写一个可以创建和使用先进先出的程序。在这个食谱中，我们将编写一个程序，创建一个 FIFO，然后向它发送一条消息。在下一个配方中，我们将编写一个接收该消息的程序。

知道如何编程使用先进先出将使您能够编写程序，直接使用先进先出在它们之间进行通信，而不需要通过Shell重定向数据。

## 做好准备

我们需要常用的工具；也就是 GCC 编译器、Make 工具和通用 Makefile。

## 怎么做…

在本食谱中，我们将编写一个程序，创建一个先进先出并向其发送一条消息:

1.  将以下代码写入一个文件并保存为`fifo-sender.c`。这段代码有点长，所以我们将在这里逐步介绍。请记住，所有代码都在同一个文件中。让我们从`#include`行开始，信号处理器的原型，以及一些全局变量:

    ```sh
    #define _XOPEN_SOURCE 700
    #include <stdio.h>
    #include <unistd.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <unistd.h>
    #include <fcntl.h>
    #include <signal.h>
    #include <stdlib.h>
    #include <errno.h>
    void cleanUp(int signum);
    int fd; /* the FIFO file descriptor */
    const char fifoname[] = "/tmp/my-2nd-fifo";
    ```

2.  现在，我们可以开始编写`main()`功能了。首先，我们将为`sigaction()`函数创建结构。然后，我们将检查用户是否提供了一条消息作为参数:

    ```sh
    int main(int argc, char *argv[])
    {
       struct sigaction action; /* for sigaction */
       if ( argc != 2 )
       {
          fprintf(stderr, "Usage: %s 'the message'\n",
             argv[0]);
          return 1;
       }
    ```

3.  现在，我们必须为所有想要捕捉的信号注册信号处理程序。我们这样做是为了在程序退出时移除先进先出。请注意这里我们也注册了`SIGPIPE`信号——更多关于这个的信息请参见*如何工作……*部分:

    ```sh
       /* prepare for sigaction and register signals
        * (for cleanup when we exit) */
       action.sa_handler = cleanUp;
       sigfillset(&action.sa_mask);
       action.sa_flags = SA_RESTART;
       sigaction(SIGTERM, &action, NULL);
       sigaction(SIGINT, &action, NULL);
       sigaction(SIGQUIT, &action, NULL);
       sigaction(SIGABRT, &action, NULL);
       sigaction(SIGPIPE, &action, NULL);
    ```

4.  现在，让我们用模式`644`创建先进先出。由于模式`644`是八进制的，我们需要在 C 代码中写成`0644`；否则，它将被解释为 644 十进制(任何在 C 中以 0 开头的数字都是八进制数)。之后，我们必须使用`open()`系统调用打开先进先出——与我们打开常规文件使用的系统调用相同:

    ```sh
       if ( (mkfifo(fifoname, 0644)) != 0 )
       {
          perror("Can't create FIFO");
          return 1;
       }
       if ( (fd = open(fifoname, O_WRONLY)) == -1)
       {
          perror("Can't open FIFO");
          return 1;
       }
    ```

5.  现在，我们必须创造一个无尽的循环。在这个循环中，我们将每秒打印一次用户提供的消息。循环结束后，我们将关闭文件描述符并删除先进先出文件。不过，在正常情况下，我们不应该达到这个水平:

    ```sh
       while(1)
       {
          dprintf(fd, "%s\n", argv[1]);
          sleep(1);
       }
       /* just in case, but we shouldn't reach this */
       close(fd);
       unlink(fifoname);
       return 0;
    }
    ```

6.  最后，我们必须创建`cleanUp()`函数，我们将其注册为信号处理程序。我们使用这个函数在程序退出前进行清理。然后，我们必须关闭文件描述符并删除先进先出文件:

    ```sh
    void cleanUp(int signum)
    {
       if (signum == SIGPIPE)
          printf("The receiver stopped receiving\n");
       else
          printf("Aborting...\n");
       if ( (close(fd)) == -1 )
          perror("Can't close file descriptor");
       if ( (unlink(fifoname)) == -1)
       {
          perror("Can't remove FIFO");
          exit(1);
       }
       exit(0);
    }
    ```

7.  我们来编译程序:

    ```sh
    $> make fifo-sender
    gcc -Wall -Wextra -pedantic -std=c99    fifo-sender.c   -o fifo-sender
    ```

8.  让我们运行程序:

    ```sh
    $> ./fifo-sender 'Hello everyone, how are you?'
    ```

9.  现在，启动另一个终端，以便我们可以使用`cat`接收消息。我们在程序中使用的文件名是`/tmp/my-2nd-fifo`。消息会每秒重复一次。几秒钟后，点击 *Ctrl* + *C* 退出`cat` :

    ```sh
    $> cat < /tmp/my-2nd-fifo 
    Hello everyone, how are you?
    Hello everyone, how are you?
    Hello everyone, how are you?
    *Ctrl**+**P* 
    ```

10.  现在，回到第一个终端。你会注意到上面写着*接收器停止接收*。
11.  在第一个终端再次启动`fifo-sender`程序。
12.  再次进入第二终端，重启`cat`程序，接收信息。保持`cat`程序运行:

    ```sh
    $> cat < /tmp/my-2nd-fifo
    ```

13.  While the cat program is running on the second terminal, go back to the first one and abort the `fifo-sender` program by hitting *Ctrl* + *C*. Notice that this time, it says *Aborting* instead:

    ```sh
    Ctrl+C
    ^CAborting...
    ```

    第二终端的`cat`程序已经退出。

## 它是如何工作的…

在这个程序中，我们注册了一个以前没有见过的额外信号:`SIGPIPE`信号。当另一端终止时——在我们的例子中是`cat`程序——我们的程序将接收到一个`SIGPIPE`信号。如果我们没有捕捉到那个信号，我们的程序就会以信号 141 退出，并且不会发生清理。从这个退出代码中，我们可以看出这是由于 141-128 = 13 的`SIGPIPE`信号；而信号 13 是`SIGPIPE`。有关保留返回值的说明，请参见 [*第 2 章*](02.html#_idTextAnchor050) 、*中的图 2.2* 。

在`cleanUp()`功能中，当接收器停止接收数据时，我们使用该信号号(`SIGPIPE`，13 的宏)打印一条特殊消息。

如果我们通过点击 *Ctrl* + *C* 来中止`fifo-sender`程序，我们会得到另一条消息；即*中止*。

`mkfifo()`功能以指定的模式为我们创建一个 FIFO 文件。这里，我们将模式指定为八进制数。C 中任何前导 0 的数都是八进制数。

由于我们使用`open()`系统调用打开了先进先出，我们得到了一个**文件描述符**作为回报。我们使用带有`dprintf()`的文件描述符将用户的消息打印到管道中。该程序的第一个论点是用户的信息。

只要 FIFO 在程序中保持打开状态，`cat`也会继续监听。这就是为什么我们可以在循环中每秒重复一次消息。

## 另见

关于`mkfifo()`功能的详细说明，请参见`man 3 mkfifo`。

有关可能信号的列表，请参见`kill -L`。

要了解更多关于`dprintf()`的信息，请参阅`man 3 dprintf`手册页。

# 先进先出–构建接收器

在前面的配方中，我们编写了一个程序，创建一个先进先出，并向其写入一条消息。我们还使用`cat`接收消息来测试它。在这个食谱中，我们将编写一个从先进先出读取的 C 程序。

从先进先出读取和从普通文件读取没什么不同，或者说，从标准文件读取。

## 做好准备

在开始这个食谱之前，最好先完成前面的食谱。我们将使用上一个配方中的程序将数据写入我们将在这个配方中接收的先进先出。

你还需要常用的工具；也就是 GCC 编译器、Make 工具和通用 Makefile。

## 怎么做…

在这个食谱中，我们将为上一个食谱中写的发送者编写一个接收程序。让我们开始吧:

1.  将以下代码写入文件，并保存为`fifo-receiver.c`。我们将打开一个文件流的先进先出，然后一个字符一个字符地循环读取，直到我们得到一个**文件结束** ( **EOF** ):

    ```sh
    #include <stdio.h>
    int main(void)
    {
        FILE *fp;
        signed char c;
        const char fifoname[] = "/tmp/my-2nd-fifo";
        if ( (fp = fopen(fifoname, "r")) == NULL )
        {
            perror("Can't open FIFO");
            return 1;
        }
        while ( (c = getc(fp)) != EOF )
            putchar(c);
        fclose(fp);
        return 0;
    }
    ```

2.  编译程序:

    ```sh
    $> make fifo-receiver
    gcc -Wall -Wextra -pedantic -std=c99    fifo-receiver.c   -o fifo-receiver
    ```

3.  从之前的配方开始`fifo-sender`，并保持运行:

    ```sh
    $> ./fifo-sender 'Hello from the sender'
    ```

4.  Open up a second terminal and run `fifo-receiver`, which we just compiled. Abort it after a couple of seconds by hitting *Ctrl* + *C*:

    ```sh
    $> ./fifo-receiver 
    Hello from the sender
    Hello from the sender
    Hello from the sender
    Ctrl+C
    ```

    `fifo-sender`也会中止，就像我们用`cat`命令接收数据一样。

## 它是如何工作的…

由于先进先出是文件系统中的一个文件，我们可以使用 C 语言中的常用函数从它那里接收数据，例如文件流、`getc()`、`putchar()`等等。

这个程序类似于第 5 章[](05.html#_idTextAnchor182)**中的`stream-read.c`程序，处理文件输入/输出和文件系统操作*，除了我们在这里逐字符阅读而不是逐行阅读。*

 *## 另见

关于`getc()`和`putchar()`的更多信息，分别参见`man 3 getc`和`man 3 putchar`手册页。

# 消息队列–创建发送者

另一种流行的 IPC 技术是**消息队列**。顾名思义，它相当于。一个进程将消息留在队列中，另一个进程读取它们。

Linux 上有两种类型的消息队列:**系统五**和 **POSIX** 。在本食谱中，我们将涵盖 POSIX 消息队列，因为这些更现代，处理起来也更简单。POSIX 消息队列都是关于使用`mq_`函数的，比如`mq_open()`、`mq_send()`等等。

了解如何使用消息队列使您能够从各种 IPC 技术中进行选择。

## 做好准备

对于这个配方，我们只需要 GCC 编译器和 Make 工具。

## 怎么做…

在这个食谱中，我们将创建发送程序。这个程序将创建一个新的消息队列和一些消息。在下一个食谱中，我们将收到这些消息:

1.  Write the following code in a file and save it as `msg-sender.c`. Since there are some new things in the code, I have broken it up into several steps. All the code goes into a single file, though, called `msg-sender.c`.

    让我们从所需的头文件开始。我们还为最大消息大小定义了一个宏。然后，我们将创建一个名为`msgattr`的`mq_attr`类型的结构。然后我们将设置它的成员；也就是说，我们将`mq_maxmsg`设置为 10，`mq_msgsize`设置为`MAX_MSG_SIZE`。第一个，`mq_maxmsg`，指定队列中的消息总数。第二个，`mq_msgsize`，指定消息的最大大小:

    ```sh
    #include <stdio.h>
    #include <mqueue.h>
    #include <fcntl.h>
    #include <sys/stat.h>
    #include <sys/types.h>
    #include <string.h>
    #define MAX_MSG_SIZE 2048
    int main(int argc, char *argv[])
    {
       int md; /* msg queue descriptor */
       /* attributes for the message queue */
       struct mq_attr msgattr;
       msgattr.mq_maxmsg = 10;
       msgattr.mq_msgsize = MAX_MSG_SIZE;
    ```

2.  我们将把作为程序的第一个参数作为消息。因此，在这里，我们将检查用户是否输入了参数:

    ```sh
       if ( argc != 2)
       {
          fprintf(stderr, "Usage: %s 'my message'\n",
             argv[0]);
          return 1;
       }
    ```

3.  Now, it's time to open and create the message queue with `mq_open()`. The first argument is the name of the queue; here, it's `/my_queue`. The second argument is the flags, which in our case are `O_CREATE` and `O_RDWR`. These are the same flags that we have seen previously, for example, with `open()`. The third argument is the permission mode; once again, this is the same as for files. The fourth and last argument is the struct we created earlier. The `mq_open()` function then returns a message queue descriptor to the `md` variable.

    然后，最后，我们使用`mq_send()`将消息发送到队列。这里，首先我们给它`md`描述符。然后，我们有了想要发送的消息，在本例中，这是程序的第一个参数。然后，作为第三个参数，我们必须指定消息的大小。最后，我们必须为消息设置优先级；在这种情况下，我们将只使用 1。它可以是任何正数(一个`unsigned int`)。

    在退出程序之前，我们要做的最后一件事是用`mq_close()`关闭消息队列描述符:

    ```sh
       md = mq_open("/my_queue", O_CREAT|O_RDWR, 0644, 
          &msgattr); 
       if ( md == -1 )
       {
          perror("Creating message queue");
          return 1;
       }
       if ( (mq_send(md, argv[1], strlen(argv[1]), 1))
          == -1 )
       {
          perror("Message queue send");
          return 1;
       }
       mq_close(md);
       return 0;
    }
    ```

4.  编制程序。请注意，我们必须链接到`rt`库，它代表**实时扩展库** :

    ```sh
    $> gcc -Wall -Wextra -pedantic -std=c99 -lrt \
    > msg-sender.c -o msg-sender
    ```

5.  现在，运行程序，向队列发送三四条消息:

    ```sh
    $> ./msg-sender "The first message to the queue"
    $> ./msg-sender "The second message"
    $> ./msg-sender "And another message"
    ```

## 它是如何工作的…

在这个食谱中，我们使用 POSIX 消息队列函数创建一个新队列，然后向它发送消息。当我们创建队列时，我们使用`msgattr`的`mq_maxmsg`成员指定该队列最多可以包含 10 条消息。

我们还使用`mq_msgsize`成员将每条消息的最大长度设置为 2，048 个字符。

当我们调用`mq_open()`时，我们将队列命名为`/my_queue`。消息队列必须以正斜杠开头。

一旦创建了队列，我们就使用`mq_send()`向它发送消息。

在这个食谱的最后，我们向队列发送了三条消息。这些消息现在正在排队等待接收。在下一个食谱中，我们将学习如何编写一个程序来接收这些消息并将其打印在屏幕上。

## 另见

在`man 7 mq_overview`手册页中有一个关于 Linux 中 POSIX 消息队列功能的很好的概述。

# 消息队列–创建接收者

在之前的食谱中，我们构建了一个程序，创建了一个名为`/my_queue`的消息队列，然后向它发送了三条消息。在这个食谱中，我们将创建一个程序来接收来自该队列的消息。

## 做好准备

在你开始这个食谱之前，你需要完成前面的食谱。否则，我们将不会收到任何消息。

你还需要 GCC 编译器和制作工具来制作这个食谱。

## 怎么做…

在本食谱中，我们将收到上一份食谱中发送的消息:

1.  将以下代码写入一个文件并保存为`msg-receiver.c`。这段代码比发送程序的代码长一点，所以它被分成几个步骤，每个步骤解释一点代码。但是请记住，所有代码都放在同一个文件中。我们将从头文件、变量、结构和名为`buffer`的字符指针开始。我们稍后将使用它来分配内存:

    ```sh
    #include <stdio.h>
    #include <mqueue.h>
    #include <fcntl.h>
    #include <sys/stat.h>
    #include <sys/types.h>
    #include <stdlib.h>
    #include <string.h>
    int main(void)
    {
       int md; /* msg queue descriptor */
       char *buffer;
       struct mq_attr msgattr;
    ```

2.  下一步是使用`mq_open()`打开消息队列。这一次，我们只需要提供两个论据；队列的名称和标志。在这种情况下，我们只想从队列中读取:

    ```sh
       md = mq_open("/my_queue", O_RDONLY);
       if (md == -1 )
       {
          perror("Open message queue");
          return 1;
       }
    ```

3.  现在，我们也希望使用`mq_getattr()`获得消息队列的属性。一旦我们有了队列的属性，我们就可以使用它的`mq_msgsize`成员来使用`calloc()`为这个大小的消息分配内存。这本书里我们之前没见过`calloc()`。第一个参数是我们想要分配内存的元素数量，而第二个参数是每个元素的大小。`calloc()`函数然后返回一个指向该内存的指针(在我们的例子中，这是`buffer` ):

    ```sh
       if ( (mq_getattr(md, &msgattr)) == -1 )
       {
          perror("Get message attribute");
          return 1;
       }
       buffer = calloc(msgattr.mq_msgsize, 
          sizeof(char));
       if (buffer == NULL)
       {
          fprintf(stderr, "Couldn't allocate memory");
          return 1;
       }
    ```

4.  Next, we will use another member of the `mq_attr` struct called `mq_curmsgs`, which contains the number of messages currently in the queue. First, we will print the number of messages. Then, we will loop over all the messages using a `for` loop. Inside the loop, first, we receive a message using `mq_receive`. Then, we print the message using `printf()`. Finally, before iterating over the next message, we reset the entire memory to NULL characters using `memset()`.

    第一个参数到`mq_receive`是描述符，第二个参数是消息要去的缓冲区，第三个参数是消息的大小，第四个参数是消息的优先级，在本例中为 NULL，意思是我们首先接收所有优先级最高的消息:

    ```sh
       printf("%ld messages in queue\n", 
          msgattr.mq_curmsgs);
       for (int i = 0; i<msgattr.mq_curmsgs; i++)
       {
          if ( (mq_receive(md, buffer, 
          msgattr.mq_msgsize, NULL)) == -1 )
          {
             perror("Message receive");
             return 1;
          }
          printf("%s\n", buffer);
          memset(buffer, '\0', msgattr.mq_msgsize);
       }
    ```

5.  最后，我们要做一些清理工作。首先，我们必须`free()`缓冲区所指向的内存。然后，在使用`mq_unlink()` :

    ```sh
       free(buffer);
       mq_close(md);
       mq_unlink("/my_queue");
       return 0;
    }
    ```

    从系统中移除队列之前，我们必须关闭`md`队列描述符
6.  现在是时间编译程序:

    ```sh
    $> gcc -Wall -Wextra -pedantic -std=c99 -lrt \
    > msg-reveiver.c -o msg-reveiver
    ```

7.  最后，让我们使用新程序接收消息:

    ```sh
    $> ./msg-reveiver 
    3 messages in queue
    The first message to the queue
    The second message
    And another message
    ```

8.  如果我们现在尝试重新运行程序，它将简单地声明不存在这样的文件或目录。这是因为我们删除了带有`mq_unlink()` :

    ```sh
    $> ./msg-reveiver 
    Open message queue: No such file or directory
    ```

    的消息队列

## 它是如何工作的…

在之前的食谱中，我们向`/my_queue`发送了三条消息。通过我们在这个食谱中创建的程序，我们收到了这些消息。

为了打开队列，我们使用了与创建队列时相同的函数；也就是`mq_open()`。但是这次——因为我们打开了一个已经存在的队列——我们只需要提供两个参数；也就是队列的名称和标志。

对`mq_`函数的每次调用都进行错误检查。如果出现错误，我们用`perror()`打印错误信息，用 1 返回Shell。

在从队列中读取实际消息之前，我们用`mq_getattr()`获取队列的属性。通过这个函数调用，我们填充了`mq_attr`结构。读取消息最重要的两个成员是`mq_msgsize`，这是队列中每个消息的最大大小，以及`mq_curmsgs`，这是当前队列中的消息数量。

我们使用`mq_msgsize`中的最大消息大小，使用`calloc()`为消息缓冲区分配内存。`calloc()`函数返回“清零”内存，而它的对应函数`malloc()`则不返回。

为了分配内存，我们需要创建一个指向我们想要的类型的指针。这是我们在节目开始时用`char *buffer`做的。`calloc()`函数有两个参数:要分配的元素数量和每个元素的大小。这里，我们希望元素的数量与`mq_msgsize`值所包含的数量相同。而且每个元素都是一个`char`，所以每个元素的大小应该是`sizeof(char)`。该函数然后返回一个指向存储器的指针，在我们的例子中，该指针被保存到`char`指针的`buffer`中。

然后，当我们接收到队列消息时，我们在循环的每次迭代中都将它们保存在这个缓冲区中。

循环遍历所有消息。我们从`mq_curmsgs`成员那里获得了消息数量。

最后，一旦我们读完了所有的消息，我们就关闭并删除了队列。

## 另见

关于`mq_attr`结构的更多信息，我建议你阅读`man 3 mq_open`手册页。

我们在本食谱和上一个食谱中介绍的每个功能都有自己的手册页；例如，`man 3 mq_send`、`man 3 mq_recevie`、`man 3 mq_getattr`等等。

如果你不熟悉`calloc()`和`malloc()`功能，我建议你阅读`man 3 calloc`。本手册页面涵盖了`malloc()`、`calloc()`、`free()`以及部分其他相关功能。

`memset()`功能也有自己的手动页面；也就是`man 3 memset`。

# 共享记忆的亲子沟通

在这个食谱中，我们将学习如何在两个相关的进程之间使用**共享内存**——父母和孩子。共享内存以各种形式存在，可以有不同的使用方式。在这本书里，我们将集中讨论 POSIX 共享内存函数。

Linux 中的共享内存可以在相关的进程之间使用，就像我们在这个食谱中将要探索的那样，但是也可以在不相关的进程之间使用**文件描述符**来共享内存。当我们以这种方式使用共享内存时，内存由`/dev/shm`目录中的一个文件支持。我们将在下一个食谱中看到这一点。

在这个食谱中，我们将使用*匿名*共享内存——没有文件支持的内存。

共享内存就是它听起来的样子——在进程之间共享的一块内存。

知道如何使用共享内存将使您能够编写更高级的程序。

## 做好准备

对于这个食谱，你只需要 GCC 编译器和 Make 工具。

## 怎么做…

在这个食谱中，我们将编写一个使用共享内存的程序。首先，在分叉之前，进程会向共享内存写入一条消息。然后，分叉后，孩子将替换共享内存中的消息。最后，父进程将再次替换共享内存的内容。让我们开始吧:

1.  将下面的代码写在一个文件中，并命名为`shm-parent-child.c`。像往常一样，我将把代码分成几个更小的步骤。但是所有的代码都在同一个文件中。首先，我们将编写所有的头文件。这里有很多。我们还将为我们的内存大小定义一个宏。然后，我们将把三条消息写成字符数组常量:

    ```sh
    #include <stdio.h>
    #include <sys/mman.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <sys/wait.h>
    #include <fcntl.h>
    #include <unistd.h>
    #include <string.h>
    #define DATASIZE 128
    int main(void)
    {
       char *addr;
       int status;
       pid_t pid;
       const char startmsg[] = "Hello, we are running";
       const char childmsg[] = "Hello from child";
       const char parentmsg[] = "New msg from parent";
    ```

2.  Now comes the exciting part—mapping the shared memory space. There's a total of six arguments we need to provide to the memory mapping function; that is, `mmap()`.

    第一个参数是内存地址，我们将它设置为空——这意味着内核将为我们处理它。

    第二个参数是内存区域的大小。

    第三个论点是内存应该具有的保护。在这里，我们将它设置为读写。

    第四个参数是我们的标志，我们将其设置为共享和匿名，这意味着它可以在进程之间共享，并且不会被文件支持。

    第五个参数是文件描述符。但是在我们的例子中，我们使用了匿名，这意味着这个内存不会被文件支持。因此，出于兼容性原因，我们将它设置为-1。

    最后一个参数是偏移量，我们将它设置为 0:

    ```sh
       addr = mmap(NULL, DATASIZE, 
          PROT_WRITE | PROT_READ, 
          MAP_SHARED | MAP_ANONYMOUS, -1, 0);
       if (addr == MAP_FAILED)
       {
          perror("Memory mapping failed");
          return 1;
       }
    ```

3.  Now that the memory is ready for us, we will copy our first message to it using `memcpy()`. The first argument to `memcpy()` is a pointer to the memory, which in our case is the `addr` character pointer. The second argument is the data or message we want to copy from, which in our case is `startmsg`. The last argument is the size of the data we want to copy, which in this case is the length of the string in `startmsg` + 1\. The `strlen()` function doesn't include the terminating null character; that's why we need to add 1.

    然后，我们打印进程的 PID 和共享内存中的消息。之后，我们叉:

    ```sh
       memcpy(addr, startmsg, strlen(startmsg) + 1);
       printf("Parent PID is %d\n", getpid());
       printf("Original message: %s\n", addr);
       if ( (pid = fork()) == -1 )
       {
          perror("Can't fork");
          return 1;
       }
    ```

4.  如果我们在子进程中，我们会将孩子的消息复制到共享内存中。如果我们在父母的过程中，我们会等待孩子。然后，我们可以将父消息复制到内存中，并打印这两条消息。最后，我们将通过取消共享内存的映射来清理。不过，这并不是严格要求的:

    ```sh
       if (pid == 0)
       {
          /* child */
          memcpy(addr, childmsg, strlen(childmsg) + 1);
       }
       else if(pid > 0)
       {
          /* parent */
          waitpid(pid, &status, 0);
          printf("Child executed with PID %d\n", pid);
          printf("Message from child: %s\n", addr);
          memcpy(addr, parentmsg, 
             strlen(parentmsg) + 1);
          printf("Parent message: %s\n", addr);
       }
       munmap(addr, DATASIZE);
       return 0;
    }
    ```

5.  把程序编译一下，这样我们就可以把它转一转了。请注意，我们这里使用的是另一个 C 标准——**GNU11**。我们这样做是因为 **C99** 标准不包含`MAP_ANONYMOUS`宏，但是 **GNU11** 包含。 **GNU11** 是带有一些额外 GNU 扩展的 **C11** 标准。另外，请注意我们链接到*实时扩展*库:

    ```sh
    $> gcc -Wall -Wextra -std=gnu11 -lrt \
    > shm-parent-child.c -o shm-parent-child
    ```

6.  现在，我们可以测试程序:

    ```sh
    $> ./shm-parent-child 
    Parent PID is 9683
    Original message: Hello, we are running
    Child executed with PID 9684
    Message from child: Hello from child
    Parent message: New msg from parent
    ```

## 它是如何工作的…

共享内存是不相关进程、相关进程和线程之间的一种常见 IPC 技术。在这个食谱中，我们看到了如何在父母和孩子之间使用共享记忆。

内存区域使用`mmap()`映射。该函数将地址返回到映射内存。如果出现错误，则返回`MAP_FAILED`宏。一旦我们映射了内存，我们就检查了`MAP_FAILED`的指针变量，并在出现错误时中止了它。

一旦我们映射了内存并获得了一个指向它的指针，我们就使用`memcpy()`向它复制数据。

最后，我们用`munmap()`取消了内存映射。这并不是绝对必要的，因为当最后一个进程存在时，它将被取消映射。然而，不这样做是一种不好的做法。你应该总是自己清理，释放所有分配的内存。

## 另见

关于和`munmap()`的更详细解释，请参见`man 2 mmap`手册页。关于`memcpy()`的详细说明，请参见`man 3 memcpy`手册页。

关于各种 C 标准和什么是 GNU 扩展的更深入的解释，见[https://gcc.gnu.org/onlinedocs/gcc/Standards.html](https://gcc.gnu.org/onlinedocs/gcc/Standards.html)。

# 在不相关的进程之间使用共享内存

在之前的食谱中，我们使用了孩子和父母之间的共享记忆。在本食谱中，我们将学习如何使用文件描述符来映射内存，以便在两个不相关的进程之间共享内存。以这种方式使用共享的内存会自动为`/dev/shm`目录中的内存创建一个底层文件，其中 **shm** 代表**共享内存**。

知道如何在不相关的进程之间使用共享内存，可以扩展您对这种 IPC 技术的使用。

## 做好准备

对于这个食谱，你只需要 GCC 编译器和 Make 工具。

## 怎么做…

首先，我们将编写一个程序，打开并创建共享内存的文件描述符，并映射内存。然后，我们将编写另一个读取内存区域的程序。我们将在这里编写和检索一个由三个浮点数组成的**数组**，而不仅仅是一条消息，就像我们在前面的食谱中所做的那样。

### 创造作家

让我们首先创建作者:

1.  The first step is to create a program that will create a shared memory and write some data to it. Write the following code in a file and save it as `write-memory.c`. As usual, the code will be broken up into several steps, but all the code goes into a single file.

    就像前面的食谱一样，我们会有一堆头文件。然后，我们将创建我们需要的所有变量。这里，我们需要一个文件描述符变量。请注意，即使我在这里称它为文件描述符，它也是内存区域的描述符。`memid`包含内存映射描述符的名称。然后，我们必须使用`shm_open()`打开并创建“文件描述符”:

    ```sh
    #include <stdio.h>
    #include <sys/mman.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    #include <unistd.h>
    #include <string.h>
    #define DATASIZE 128
    int main(void)
    {
       int fd;
       float *addr;
       const char memid[] = "/my_memory";
       const float numbers[3] = { 3.14, 2.718, 1.202};
       /* create shared memory file descriptor */
       if ( (fd = shm_open(memid, 
          O_RDWR | O_CREAT, 0600)) == -1)
       {
          perror("Can't open memory fd");
          return 1;
       }
    ```

2.  文件支持的内存最初大小为 0 字节。要将其扩展到我们的 128 字节，我们必须用`ftruncate()` :

    ```sh
       /* truncate memory to DATASIZE */
       if ( (ftruncate(fd, DATASIZE)) == -1 )
       {
          perror("Can't truncate memory");
          return 1;
       }
    ```

    截断它
3.  现在，我们必须映射内存，就像我们在之前的食谱中所做的那样。但是这一次，我们会给它`fd`文件描述符，而不是-1。我们还省略了`MAP_ANONYMOUS`部分，从而使这个内存由一个文件支持。然后，我们必须使用`memcpy()`将浮点数组复制到内存中。为了让读取程序有机会读取内存，我们必须暂停程序，用`getchar()`等待*进入*键。然后，只需要用`shm_unlink()` :

    ```sh
       /* map memory using our file descriptor */
       addr = mmap(NULL, DATASIZE, PROT_WRITE, 
          MAP_SHARED, fd, 0);
       if (addr == MAP_FAILED)
       {
          perror("Memory mapping failed");
          return 1;
       }
       /* copy data to memory */
       memcpy(addr, numbers, sizeof(numbers));
       /* wait for enter */
       printf("Hit enter when finished ");
       getchar();
       /* clean up */
       munmap(addr, DATASIZE);
       shm_unlink(memid);
       return 0;
    }
    ```

    取消内存映射，删除文件描述符和底层文件来清理即可
4.  现在，让我们编译程序:

    ```sh
    $> gcc -Wall -Wextra -std=gnu11 -lrt write-memory.c \
    > -o write-memory
    ```

### 创造读者

现在，让我们创建读者:

1.  现在，我们将编写程序，读取存储区域并打印数组的数字。编写以下程序并保存为`read-memory.c`。这个程序类似于`write-memory.c`，但是我们不是写给内存，而是从里面读取:

    ```sh
    #include <stdio.h>
    #include <sys/mman.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <fcntl.h>
    #include <unistd.h>
    #include <string.h>
    #define DATASIZE 128
    int main(void)
    {
       int fd;
       float *addr;
       const char memid[] = "/my_memory";
       float numbers[3];
       /* open memory file descriptor */
       fd = shm_open(memid, O_RDONLY, 0600);
       if (fd == -1)
       {
          perror("Can't open file descriptor");
          return 1;
       }
       /* map shared memory */
       addr = mmap(NULL, DATASIZE, PROT_READ, 
          MAP_SHARED, fd, 0);
       if (addr == MAP_FAILED)
       {
          perror("Memory mapping failed");
          return 1;
       }
       /* read the memory and print the numbers */
       memcpy(numbers, addr, sizeof(numbers));
       for (int i = 0; i<3; i++)
       {
          printf("Number %d: %.3f\n", i, numbers[i]);
       }
       return 0;
    }
    ```

2.  现在，编译这个程序:

    ```sh
    $> gcc -Wall -Wextra -std=gnu11 -lrt read-memory.c \
    > -o read-memory
    ```

### 测试一切

请遵循以下步骤:

1.  现在，是时候尝试这一切了。打开一个终端，运行我们编译的`write-memory`程序。保持程序运行:

    ```sh
    $> ./write-memory 
    Hit enter when finished
    ```

2.  打开另一个终端，在`/dev/shm` :

    ```sh
    $> ls -l /dev/shm/my_memory 
    -rw------- 1 jake jake 128 jan 18 19:19 /dev/shm/my_memory
    ```

    中检出文件
3.  现在，运行我们刚刚编译的读记忆程序。这将从共享内存中检索三个数字并将其打印在屏幕上:

    ```sh
    $> ./read-memory 
    Number 0: 3.140
    Number 1: 2.718
    Number 2: 1.202
    ```

4.  回到`write-memory`程序运行的终端，点击*进入*。这样做将清理并删除文件。完成后，让我们看看文件是否还在`/dev/shm` :

    ```sh
    ./write-memory 
    Hit enter when finished Enter
    $> ls -l /dev/shm/my_memory
    ls: cannot access '/dev/shm/my_memory': No such file or directory
    ```

## 它是如何工作的…

使用非匿名共享内存类似于我们在前面的食谱中所做的。唯一的例外是我们首先使用`shm_open()`打开一个特殊的文件描述符。您可能已经注意到，这些标志类似于常规`open()`呼叫的标志；也就是说，`O_RDWR`用于读写，`O_CREATE`用于创建文件，如果文件不存在的话。以这种方式使用`shm_open()`会在`/dev/shm`目录中创建一个名为第一个参数的文件。甚至权限模式的设置也和普通文件一样——在我们的例子中，`0600`为用户读写，对其他任何人都没有权限。

我们从`shm_open()`获得的文件描述符然后被传递给`mmap()`调用。我们还省略了`MAP_ANONYMOUS`宏对`mmap()`的调用，就像我们在前面的食谱中看到的那样。跳过`MAP_ANONYMOUS`意味着内存将不再是匿名的，这意味着它将由一个文件支持。我们使用`ls -l`检查了这个文件，发现它确实有我们给它的名称和正确的权限。

我们编写的下一个程序使用`shm_open()`打开了相同的共享内存文件描述符。`mmap()`之后，我们在内存区域循环浮点数字。

最后，一旦我们在`write-memory`程序中点击*进入*，则`/dev/shm`中的文件被`shm_unlink()`移除。

## 另见

在`man 3 shm_open`手册页有很多关于`shm_open()`和`shm_unlink()`的更多信息。

# Unix 套接字–创建服务器

**Unix 套接字**类似于和 **TCP/IP** 套接字，但它们只是本地的，由文件系统上的一个套接字文件表示。但是与 Unix 套接字一起使用的整体功能或多或少与 TCP/IP 套接字相同。Unix 套接字的完整名称是 *Unix 域套接字*。

Unix 套接字是程序在机器上进行本地通信的常见方式。

知道如何使用 Unix 套接字将使编写需要在它们之间通信的程序变得更加容易。

## 做好准备

在这个配方中，您只需要 GCC 编译器、Make 工具和通用 Makefile。

## 怎么做…

在这个食谱中，我们将编写一个充当服务器的程序。它将接收来自客户端的消息，并在每次收到消息时用“收到的消息”进行响应。当服务器或客户端退出时，它也会自行清理。让我们开始吧:

1.  Write the following code in a file and save it as `unix-server.c`. This code is a bit longer than most of our previous examples, so it's been broken up into several steps. All the code goes in the same file, though.

    这里有相当多的头文件。我们还将为我们将接受的最大消息长度定义一个宏。然后我们将为`cleanUp()`函数编写原型，该函数将用于清理文件。该功能也将用作信号处理器。然后，我们将声明一些全局变量(以便可以从`cleanUp()`到达它们):

    ```sh
    #define _XOPEN_SOURCE 700
    #include <stdio.h>
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <sys/un.h>
    #include <string.h>
    #include <unistd.h>
    #include <signal.h>
    #include <stdlib.h>
    #include <errno.h>
    #define MAXLEN 128
    void cleanUp(int signum);
    const char sockname[] = "/tmp/my_1st_socket";
    int connfd;
    int datafd;
    ```

2.  现在，是时候开始编写`main()`函数并声明一些变量了。大部分这个你现在应该都很熟悉了。我们还将在这里注册所有信号的信号处理器。新的是`sockaddr_un`结构。这将包含套接字类型和文件路径:

    ```sh
    int main(void)
    {
       int ret;
       struct sockaddr_un addr;
       char buffer[MAXLEN];
       struct sigaction action;
       /* prepare for sigaction */
       action.sa_handler = cleanUp;
       sigfillset(&action.sa_mask);
       action.sa_flags = SA_RESTART;
       /* register the signals we want to handle */
       sigaction(SIGTERM, &action, NULL);
       sigaction(SIGINT, &action, NULL);
       sigaction(SIGQUIT, &action, NULL);
       sigaction(SIGABRT, &action, NULL);
       sigaction(SIGPIPE, &action, NULL);
    ```

3.  现在我们已经有了所有的信号处理器、变量和结构，我们可以使用`socket()`函数创建一个套接字文件描述符。一旦处理完毕，我们将设置连接类型(属于*家族*类型)和套接字文件的路径。然后我们会调用`bind()`，它会为我们绑定插座以便我们使用:

    ```sh
       /* create socket file descriptor */
       connfd = socket(AF_UNIX, SOCK_SEQPACKET, 0);
       if ( connfd == -1 )
       {
          perror("Create socket failed");
          return 1;
       }
       /* set address family and socket path */
       addr.sun_family = AF_UNIX;
       strcpy(addr.sun_path, sockname);
       /* bind the socket (we must cast our sockaddr_un
        * to sockaddr) */
       if ( (bind(connfd, (const struct sockaddr*)&addr, 
          sizeof(struct sockaddr_un))) == -1 )
       {
          perror("Binding socket failed");
          return 1;
       }
    ```

4.  现在，我们将通过调用`listen()`为连接准备套接字文件描述符。第一个参数是套接字文件描述符，而第二个参数是我们想要的积压的缓冲区大小。完成后，我们将接受使用`accept()`的连接。这将为我们提供一个新的套接字**文件描述符**(我们称之为`datafd`)，我们将在发送和接收数据时使用它。一旦连接被接受，我们可以打印*客户端连接到本地终端:

    ```sh
       /* prepare for accepting connections */
       if ( (listen(connfd, 20)) == -1 )
       {
          perror("Listen error");
          return 1;
       }
       /* accept connection and create new file desc */
       datafd = accept(connfd, NULL, NULL);
       if (datafd == -1 )
       {
          perror("Accept error");
          return 1;
       }
       printf("Client connected\n");
    ```* 
5.  现在，我们将开始程序的主循环。在外循环中，当我们收到一条消息时，我们将只写一条确认消息。在内部循环中，我们将从新的套接字文件描述符中读取数据，保存在`buffer`中，然后在我们的终端上打印出来。如果`read()`返回-1，则说明出了问题，我们必须突破内循环读取下一行。如果`read()`返回 0，则客户端已断开，我们必须运行`cleanUp()`并退出:

    ```sh
       while(1) /* main loop */
       {
          while(1) /* receive message, line by line */
          {
             ret = read(datafd, buffer, MAXLEN);
             if ( ret == -1 )
             {
                perror("Error reading line");
                cleanUp(1);
             }
             else if ( ret == 0 )
             {
                printf("Client disconnected\n");
                cleanUp(1);
             }
             else
             {
                printf("Message: %s\n", buffer);
                break;
             }
          }
       /* write a confirmation message */
       write(datafd, "Message received\n", 18);
       }
       return 0;
    }
    ```

6.  最后，我们必须为`cleanUp()`功能创建身体:

    ```sh
    void cleanUp(int signum)
    {
       printf("Quitting and cleaning up\n");
       close(connfd);
       close(datafd);
       unlink(sockname);
       exit(0);
    }
    ```

7.  现在，编译程序。这一次，我们将在`cleanUp()`函数中收到 GCC 关于一个未使用变量`signum`的警告。这是因为我们从未在`cleanUp()`中使用过`signum`变量，所以我们可以放心地忽略这个警告:

    ```sh
    $> make unix-server
    gcc -Wall -Wextra -pedantic -std=c99    unix-server.c   -o unix-server
    unix-server.c: In function 'cleanUp':
    unix-server.c:94:18: warning: unused parameter 'signum' [-Wunused-parameter]
     void cleanUp(int signum)
                  ~~~~^~~~~~
    ```

8.  运行程序。既然我们没有客户，它暂时不会说或做任何事情。然而，它确实创建了套接字文件。保持程序原样:

    ```sh
    $> ./unix-server
    ```

9.  打开一个新的终端，查看插座文件。在这里，我们可以看到它是一个套接字文件:

    ```sh
    $> ls -l /tmp/my_1st_socket 
    srwxr-xr-x 1 jake jake 0 jan 19 18:35 /tmp/my_1st_socket
    $> file /tmp/my_1st_socket 
    /tmp/my_1st_socket: socket
    ```

10.  现在，回到运行服务器程序的终端，用 *Ctrl* + *C* 中止。然后，看看文件是否还在(不应该在):

    ```sh
    ./unix-server
    Ctrl+C
    Quitting and cleaning up
    $> file /tmp/my_1st_socket 
    /tmp/my_1st_socket: cannot open `/tmp/my_1st_socket' (No such file or directory)
    ```

## 它是如何工作的…

`sockaddr_un`结构是一种用于 Unix 域套接字的特殊结构。还有一个叫做`sockaddr_in`的用于 TCP/IP 套接字。`_un`结尾代表 Unix 插座，`_in`代表互联网家庭插座。

我们用来创建套接字文件描述符的`socket()`函数有三个参数:地址族(`AF_UNIX`)、类型(`SOCK_SEQPACKET`，提供双向通信)和协议。我们将协议指定为 0，因为没有套接字可供选择。

还有一个一般结构叫做`sockaddr`。当我们传递我们的`sockaddr_un`结构作为`bind()`的参数时，我们需要将其类型转换为`sockaddr`，通用类型，因为这正是函数所期望的——更准确地说，是一个`sockaddr`指针。我们为`bind()`提供的最后一个参数是结构的大小；也就是`sockaddr_un`。

一旦我们创建了套接字并将其与`bind()`绑定，我们就为与`listen()`的传入连接做好了准备。

最后，我们接受了与`accept()`的传入连接。这给了我们一个新的套接字文件描述符，然后我们用它来发送和接收消息。

## 另见

手册页中有一些关于我们在这个食谱中使用的功能的更深入的信息。我建议你把它们都检查一下:

*   `man 2 socket`
*   `man 2 bind`
*   `man 2 listen`
*   `man 2 accept`

# Unix 套接字–创建客户端

在前面的配方中，我们创建了一个 Unix 域套接字服务器。在本食谱中，我们将为该套接字创建一个客户端，然后在客户端和服务器之间进行通信。

在这个食谱中，我们将看到如何使用套接字在服务器和客户端之间进行通信。知道如何通过套接字进行通信对于使用套接字至关重要。

## 做好准备

在做这个食谱之前，你应该已经完成了之前的食谱；否则，您将没有服务器可以交谈。

您还需要 GCC 编译器、Make 工具和这个配方的通用 Makefile。

## 怎么做…

在这个配方中，我们将为服务器编写一个客户端，我们在前面的配方中已经编写过了。一旦它们连接，客户端就可以向服务器发送消息，服务器会以*收到的消息*进行响应。让我们开始吧:

1.  将以下代码写入一个文件并保存为`unix-client.c`。因为这段代码也有点长，所以分成了几个步骤。不过，所有代码都在`unix-client.c`文件中。这个程序的前半部分类似于服务器，除了我们有两个缓冲器而不是一个，并且没有信号处理:

    ```sh
    #define _XOPEN_SOURCE 700
    #include <stdio.h>
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <sys/un.h>
    #include <string.h>
    #include <unistd.h>
    #include <signal.h>
    #include <stdlib.h>
    #include <errno.h>
    #define MAXLEN 128
    int main(void)
    {
       const char sockname[] = "/tmp/my_1st_socket";
       int fd;
       struct sockaddr_un addr;
       char sendbuffer[MAXLEN];
       char recvbuffer[MAXLEN];
       /* create socket file descriptor */
       fd = socket(AF_UNIX, SOCK_SEQPACKET, 0);
       if ( fd == -1 )
       {
          perror("Create socket failed");
          return 1;
       }
       /* set address family and socket path */
       addr.sun_family = AF_UNIX;
       strcpy(addr.sun_path, sockname);
    ```

2.  现在，我们将使用`connect()`来启动与服务器的连接，而不是使用`bind()`、`listen()`和`accept()`。`connect()`函数采用与`bind()` :

    ```sh
       /* connect to the server */
       if ( (connect(fd, (const struct sockaddr*) &addr, 
          sizeof(struct sockaddr_un))) == -1 )
       {
          perror("Can't connect");
          fprintf(stderr, "The server is down?\n");
          return 1;
       }
    ```

    相同的参数
3.  现在我们已经连接到服务器，我们可以使用`write()`通过套接字文件描述符发送消息。这里，我们将使用`fgets()`将来自用户的消息读取到一个缓冲区，将一个**换行符**转换为一个**空字符**，然后将该缓冲区写入一个文件描述符:

    ```sh
       while(1) /* main loop */
       {
          /* send message to server */
          printf("Message to send: ");
          fgets(sendbuffer, sizeof(sendbuffer), stdin);
          sendbuffer[strcspn(sendbuffer, "\n")] = '\0';
          if ( (write(fd, sendbuffer, 
             strlen(sendbuffer) + 1)) == -1 )
          {
             perror("Couldn't write");
             break;
          }
          /* read response from server */
          if ( (read(fd, recvbuffer, MAXLEN)) == -1 )
          {
             perror("Can't read");
             return 1;
          }
          printf("Server said: %s\n", recvbuffer);
       }
       return 0;
    }
    ```

4.  编译程序:

    ```sh
    $> make unix-client
    gcc -Wall -Wextra -pedantic -std=c99    unix-client.c   -o unix-client
    ```

5.  我们现在试试运行程序。服务器还没启动就不行了:

    ```sh
    $> ./unix-client 
    Can't connect: No such file or directory
    The server is down?
    ```

6.  在单独的终端中启动服务器并保持运行:

    ```sh
    $> ./unix-server
    ```

7.  Go back to the terminal with the client and rerun it:

    ```sh
    $> ./unix-client 
    Message to send:
    ```

    您现在应该会在服务器中看到一条消息，称*客户端已连接*。

8.  在客户端程序中写一些消息。你应该在点击*进入*的同时看到它们出现在服务器中。几条信息后，点击*Ctrl*+*C*:T0
9.  用服务器将切换到终端。你应该会看到类似这样的东西:

    ```sh
    Client connected
    Message: Hello, how are you?
    Message: Testing 123
    Client disconnected
    Quitting and cleaning up
    ```

## 它是如何工作的…

在前面的食谱中，我们写了一个套接字服务器。在这个食谱中，我们编写了一个使用`connect()`系统调用连接到该服务器的客户端。该系统调用采用与`bind()`相同的参数。一旦建立了连接，服务器和客户端都可以使用`write()`和`read()`读写套接字文件描述符(双向通信)。

因此，本质上，一旦建立了连接，使用文件描述符读写文件并没有什么不同。

## 另见

更多关于`connect()`系统调用的信息，请参见`man 2 connect`手册页。***