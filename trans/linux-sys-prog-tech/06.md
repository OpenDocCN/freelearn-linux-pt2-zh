# 六、生成进程和使用作业控制

在本章中，我们将学习如何在系统上创建进程，哪个进程是第一个进程，以及所有进程如何相互关联。然后我们将学习 Linux 中进程和进程管理中涉及的许多术语。之后，我们将学习如何分叉新进程以及**僵尸**和**孤儿**是什么。在本章的最后，我们将学习什么是**守护进程**以及如何创建一个，然后学习什么是信号以及如何实现它们。

了解进程是如何在系统上创建的，这是实现好的守护程序、处理安全性和创建高效程序的关键。它还会让你更好地了解整个系统。在本章中，我们将介绍以下食谱:

*   探索进程是如何创建的
*   在 Bash 中使用作业控制
*   使用信号控制和终止过程
*   用`execl()`替换进程中的程序
*   形成一个过程
*   在分叉进程中执行新程序
*   用`system()`开始新的过程
*   创建僵尸进程
*   了解什么是孤儿
*   创建守护进程
*   实现信号处理器

我们开始吧！

# 技术要求

在本章中，您将需要 GCC 编译器和 Make 工具。我们在 [*第 1 章*](01.html#_idTextAnchor020) *中安装了这些工具，获取必要的工具并编写我们的第一个 Linux 程序*。

本章还需要一个名为`pstree`的新程序。您可以使用软件包管理器安装它。如果你用的是 Debian 或者 Ubuntu，可以用`sudo apt install psmisc`安装。另一方面，如果你使用的是 Fedora 或 CentOS，你可以用`sudo dnf install psmisc`安装。

你还需要我们在 [*第三章*](03.html#_idTextAnchor097) *中写的通用`Makefile`，在 Linux* 中深入 C。Makefile 也可以在 GitHub 上找到，连同本章的所有代码示例，网址为[。](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch6)

查看以下链接，查看《行动守则》视频:[https://bit.ly/3cxY0eQ](https://bit.ly/3cxY0eQ)

# 探索进程是如何创建的

在我们进入创建进程和守护进程的细节之前，我们需要对进程有一个大致的了解。获得这种理解的最好方法是查看已经在您的系统上运行的进程，这就是我们在本食谱中要做的。

系统中的每一个进程都是从另一个进程派生出的(分叉)开始了它的生命。第一个在 Unix 和 Linux 系统上使用的进程在历史上是 **init** 。在现代 Linux 发行版中，`init`进程已经被**系统和**所取代。它们都服务于同一个目的；启动系统的其余部分。

典型的**进程树**可能是这样的，用户通过终端登录(也就是说，如果我们跳过 X Window 登录的复杂性):

```sh
|- systemd (1)
  \- login (6384)
    \- bash (6669)
      \- more testfile.txt (7184)
```

进程标识是括号中的数字。`systemd`(或某些旧系统上的`init`)的**进程 ID** ( **PID** )为 1。请注意，在一些 Linux 系统上，您仍然可以看到名称`init`，即使使用了`systemd`。在这种情况下，`init`只是`systemd`的一个链接。不过，仍然有使用`init`的 Linux 系统。

在编写系统程序时，深刻理解进程**如何产生**是必不可少的。例如，当我们想要创建一个守护进程时，我们通常会产生一个新的进程。还有许多其他的用例，在这些用例中，我们必须从现有的进程中产生进程或者执行一个新的程序。

## 做好准备

这个食谱，你需要`pstree`。`pstree`的安装说明列于本章的*技术要求*部分。

## 怎么做…

在这个食谱中，我们将看看我们的系统和它运行的过程。我们将使用`pstree`来获得这些过程的可视化表示。让我们开始吧:

1.  首先，我们需要一种方法来获取我们当前的进程标识。`$$`环境变量包含当前 shell 的 **PID** 。请注意，每个系统的 PID 会有所不同，而且每次也会有所不同:

    ```sh
    $> echo $$
    18817
    ```

2.  现在，让我们用`pstree`来看看我们当前的进程，以及它的父进程和子进程。父进程是启动该进程的进程，而子进程是其下的任何进程:

    ```sh
    $> pstree -A -p -s $$
    systemd(1)---tmux (4050)---bash(18817)---pstree(18845)
    ```

3.  `pstree`命令的输出很可能在您的计算机上有所不同。除了`tmux`，你可能还有`xterm`、`konsole`、`mate-terminal`或者类似的东西。`-A`选项表示用 ASCII 字符打印行，`-p`选项表示打印 PID 号，`-s`选项表示我们要显示所选进程的父进程(在我们的例子中是`$$`)。在我的例子中，`tmux`是`systemd`的子进程，`bash`是`tmux`的子进程，`pstree`是`bash`的子进程。
4.  一个过程也可以生几个孩子。例如，我们可以在 Bash 中启动几个进程。在这里，我们将开始三个睡眠过程。每个睡眠过程将睡眠 120 秒。然后我们将打印另一个`pstree`。在本例中，`pstree`和三个`sleep`进程都是`bash` :

    ```sh
    $> sleep 120 &
    [1] 21902
    $> sleep 120 &
    [2] 21907
    $> sleep 120 &
    [3] 21913
    $> pstree -A -p -s $$
    systemd(1)---tmux (4050)---bash(18817)-+-pstree(21919)
                                           |-sleep(21902)
                                           |-sleep(21907)
                                           `-sleep(21913)
    ```

    的子进程
5.  At the beginning of this chapter, we provided a sample process tree that showed a process called `login`. That process originally started out as `getty`, a process that manages TTYs on the system. **TTY** stands for *Teletype*. Normally, a Linux computer has seven TTYs you can switch between by using the sequence *Ctrl*+*Alt*+*F1*, *Ctrl*+*Alt*+*F2*, and so on, all the way up to *Ctrl*+*Alt*+*F7*.

    为了演示`getty` / `login`的概念，用*Ctrl*+*Alt*+*F3*切换到 TTY3 来激活它。然后，回到 X(经常在*Ctrl*+*Alt*+*F7*或*Ctrl*+*Alt*+*F1*)。在这里，我们将使用`grep`和`ps`找到 TT3，并记下它的 PID。`ps`程序用于在系统上查找和列出进程。然后，我们将在 TTY3 上以用户身份登录(*Ctrl*+*Alt*+*F3*)。之后，我们将需要再次回到我们的 X Window 会话(和我们的终端)，并使用`grep`找到我们在 TTY3 中记录的 PID。该过程中的程序现已被`login`取代。换句话说，一个进程可以换出它的程序:

    ```sh
    Ctrl+Alt+F3
    login: 
    Ctrl+Alt+F7
    $> ps ax | grep tty3
    9124 tty3     Ss+    0:00 /sbin/agetty -o -p -- \u --
    noclear tty3 linux
    Ctrl+Alt+F3
    login: jake
    Password: 
    $> 
    Ctrl+Alt+F7
    $> ps ax | grep 9124
    9124 tty3     Ss     0:00 /bin/login -p –
    ```

## 它是如何工作的…

在这个食谱中，我们了解了关于 Linux 系统上进程的几个重要概念。我们将需要这些知识继续前进。首先，我们了解到所有进程都是从现有进程衍生而来的。第一个过程是`init`。在较新的 Linux 发行版上，这是到`systemd`的符号链接。`systemd`然后在系统上产生几个进程，比如`getty`，来处理终端。当用户开始登录 TTY 时，`getty`被处理登录的程序`login`所取代。当用户最终登录时，`login`进程为用户生成一个 shell，比如 Bash。每当用户执行一个程序时，Bash 都会生成一个自己的副本，并用用户执行的程序替换它。

稍微澄清一下过程/程序术语:一个**过程**运行**程序代码**。我们经常把一个*运行程序*叫做一个*进程*，没错。但是，过程中的程序代码可以换出，就像我们在`getty` / `login`例子中看到的那样。

在这个食谱中使用 TTY3 的原因是，我们通过`getty` / `login`获得了一个*真实的*登录过程，这是我们通过 X Window 会话或通过 SSH 登录时所没有的。

进程标识为，表示为工艺进程图。父进程标识表示为 **PPID** 。系统上的每个进程都有一个父进程(除了第一个进程， **systemd** ，其 PID 为`1`)。

我们还了解到一个进程可以有几个子进程，如`sleep`进程的例子。我们在最后用一个`&`符号开始了`sleep`过程。这个&符号告诉 shell 我们想在后台启动这个过程。

## 还有更多…

首字母缩略词“TTY”来源于这样一个事实:在过去，它是一个与机器相连的实际的“T0”电传打字机。电传打字机是一种看起来像打字机的终端。你在打字机上输入命令，然后阅读纸上的回应。对于任何对电传打字机感兴趣的人来说，哥伦比亚大学在 http://www.columbia.edu/cu/computinghistory/teletype.html有一些令人兴奋的图片和信息。

# 在 Bash 中使用作业控制

作业控制不仅能让你更好地理解前台和后台进程，还能让你在终端上工作时更有效率。能够将一个进程放在后台可以让你的终端腾出时间去做其他的任务。

## 做好准备

除了 Bash Shell，这个食谱不需要什么特别的东西。Bash 通常是默认的 shell，所以很可能您已经安装了它。

## 怎么做…

在这个食谱中，我们将启动和停止几个进程，将它们发送到后台，并将其带回前台。这将使我们了解背景和前景过程。让我们开始吧:

1.  之前我们已经看到了如何在后台用一个&符号(`&`)开始一个进程。我们将在这里重复，但我们也将列出当前正在运行的作业，并将其中一个带到前台。我们将在这里开始的第一个后台进程是`sleep`，而另一个将是手动页面:

    ```sh
    $> sleep 300 &
    [1] 30200
    $> man ls &
    [2] 30210
    ```

2.  现在我们在**后台**有了两个进程，我们用`jobs` :

    ```sh
    $> jobs
    [1]-  Running                 sleep 300 &
    [2]+  Stopped                 man ls
    ```

    列出来
3.  `sleep`进程处于运行状态，意味着程序中的秒在滴答作响。但是`man ls`命令已经停止。`man`命令正等着你用它做些什么，因为它需要一个终端。所以，现在，它没有任何作用。我们可以使用`fg`命令将其带到前台( **fg** 代表**前台**)。您给`fg`命令的参数是来自`jobs`列表的作业标识:

    ```sh
    $> fg 2
    ```

4.  点击 *Q* 退出手动页面。`man ls`会出现在屏幕上。
5.  现在，用`fg 1`将睡眠过程带到前台。上面只写了`sleep 300`，仅此而已。但现在，这个项目处于前台。这意味着我们现在可以通过点击 *Ctrl* + *Z* :

    ```sh
    sleep 300
    Ctrl+Z
    [1]+  Stopped                 sleep 300
    ```

    来停止程序
6.  就这样，程序被停止了，这意味着它不再倒计时了。我们现在可以再次用`fg 1`把它带回到前台，让它结束。
7.  既然前面的进程已经完成，那就开始新的`sleep`进程吧。这一次，我们可以在前台开始(省略&符号)。然后点击 *Ctrl* + *Z* 即可停止程序。列出作业并注意程序处于停止状态:

    ```sh
    $> sleep 300
    Ctrl+Z
    [1]+  Stopped                 sleep 300
    $> jobs
    [1]+  Stopped                 sleep 300
    ```

8.  现在，我们可以使用`bg`命令继续在后台运行程序(`bg`代表*后台* ):

    ```sh
    $> bg 1
    [1]+ sleep 300 &
    $> jobs
    [1]+  Running                 sleep 300 &
    ```

9.  我们也可以通过使用名为`pgrep`的命令找到程序的 PID。名称`pgrep`代表*工艺 Grep* 。`-f`选项允许我们指定完整的命令，包括其选项，以便我们获得正确的 PID:

    ```sh
    $> pgrep -f "sleep 300"
    4822
    ```

10.  既然知道了 PID，就可以用`kill` :

    ```sh
    $> kill 4822
    $> Enter
    [1]+  Terminated              sleep 300
    ```

    杀死程序了
11.  我们也可以使用`pkill`杀死一个程序。在这里，我们将开始另一个过程，并改为用`pkill`杀死它。该命令与`pgrep` :

    ```sh
    $> sleep 300 &
    [1] 6526
    $> pkill -f "sleep 300"
    [1]+  Terminated              sleep 300
    ```

    选项一起使用

## 它是如何工作的…

在这个食谱中，我们了解了后台进程、前台进程、停止和运行作业、终止进程等等。这些是在 Linux 作业控制中使用的一些基本概念。

当我们用`kill`杀死进程时，`kill`在后台向进程发出信号。`kill`的默认信号是`TERM`信号。**术语**代表**终止**。不过，程序可以选择如何对`TERM`信号采取行动。`TERM`信号为15 号。一个不能被处理的信号——总是杀死一个程序——是信号 9，或`KILL`信号。我们将在下一个食谱中更深入地介绍信号处理。

# 使用信号控制和终止过程

现在我们对过程有了更多的了解，是时候转向信号，学习我们如何利用信号杀死和控制一个过程了。在这个食谱中，我们还将编写我们的第一个 C 程序，它将有一个信号处理器。

## 做好准备

对于这个食谱，你只需要本章*技术要求*部分列出的内容。

## 怎么做…

在本食谱中，我们将探索如何用信号控制和终止进程。让我们开始吧:

1.  让我们首先列出我们可以使用`kill`命令发送给进程的信号。从这个命令得到的列表相当长，所以这里没有包括它。最有趣的——也是最常用的——信号是前 31 个:

    ```sh
    $> kill -L
    ```

2.  让我们看看这些信号是如何工作的。我们可以将`STOP`信号(19 号)发送给一个进程，效果和我们在`sleep`中点击 *Ctrl* + *Z* 时看到的一样。但是在这里，我们直接向后台进程发送`STOP`信号:

    ```sh
    $> sleep 120 &
    [1] 16392
    $> kill -19 16392
     [1]+  Stopped                 sleep 120
    $> jobs
    [1]+  Stopped                 sleep 120
    ```

3.  现在，我们可以通过向其发送`CONT`信号(简称**继续**)来再次继续该过程。如果我们愿意，我们可以输入信号的名称，而不是它的号码:

    ```sh
    $> kill -CONT 16392
    $> jobs
    [1]+  Running                 sleep 120 &
    ```

4.  现在，我们可以通过向进程发送`KILL`信号(数字 9):

    ```sh
    $> kill -9 16392
    $> Enter
    [1]+  Killed                  sleep 120
    ```

    来终止进程
5.  现在，让我们创建一个小程序，它对不同的信号起作用，并忽略(或阻止) *Ctrl* + *C* ，中断信号。`USR1`和`USR2`信号非常适合这种情况。将以下代码写入一个文件并保存为`signals.c`。这段代码在这里被分成了多个步骤，但是所有的代码都进入了这个文件。要在程序中注册信号处理程序，我们可以使用`sigaction()`系统调用。我们需要定义`_POSIX_C_SOURCE`，因为`sigaction()`和它的朋友不包括在严格的 C99 中。我们还需要包含必要的头文件，编写处理函数原型，并开始`main()`函数:

    ```sh
    #define _POSIX_C_SOURCE 200809L
    #include <stdio.h>
    #include <sys/types.h>
    #include <signal.h>
    #include <unistd.h>
    void sigHandler(int sig);
    int main(void)
    {
    ```

6.  现在，让我们创建一些我们需要的变量和结构。我们将创建的`sigaction`结构`action`用于`sigaction()`系统调用。在代码再往下一点，我们设置了它的成员。首先，我们必须将`sa_handler`设置为我们的功能，当收到信号时将执行。其次，我们使用`sigfillset()`将`sa_mask`设置为所有信号。这将忽略所有信号，同时我们的信号处理器正在执行，防止它被中断。第三，我们将`sa_flags`设置为`SA_RESTART`，这意味着任何中断的系统调用都将重新启动:

    ```sh
        pid_t pid; /* to store our pid in */
        pid = getpid(); /* get the pid */
        struct sigaction action; /* for sigaction */
        sigset_t set; /* signals we want to ignore */
        printf("Program running with PID %d\n", pid);
        /* prepare sigaction() */
        action.sa_handler = sigHandler;
        sigfillset(&action.sa_mask);
        action.sa_flags = SA_RESTART;
    ```

7.  现在，是时候使用`sigaction()`注册信号处理器了。`sigaction()`的第一个参数是我们想要捕捉的信号，第二个参数是应该采取的新动作的结构，第三个参数给出了旧动作。如果我们对旧动作不感兴趣，我们将其设置为`NULL`。动作必须是`sigaction`结构:

    ```sh
        /* register two signal handlers, one for USR1
           and one for USR2 */
        sigaction(SIGUSR1, &action, NULL);
        sigaction(SIGUSR2, &action, NULL);
    ```

8.  还记得我们希望程序忽略 *Ctrl* + *C* (中断信号)吗？这可以通过在应该忽略信号的代码之前调用`sigprocmask()`来实现。但是首先，我们必须创建一个*信号集*，其中包含所有它应该忽略/阻止的信号。首先用`sigemptyset()`清空集合，然后用`sigaddset()`添加需要的信号。`sigaddset()`功能可以多次调用，增加更多信号。`sigprocmask()`的第一个论点是行为，这里是`SIG_BLOCK`。第二个参数是信号集，而第三个参数可用于检索旧集。但是，在这里，我们将它设置为`NULL`。之后，我们开始无限`for`循环。循环之后，我们再次解除信号集的阻塞。在这种情况下，没有必要，因为我们只是退出程序，但在其他情况下，一旦我们越过了应该忽略它们的代码部分，建议解除对信号的阻塞:

    ```sh
        /* create a "signal set" for sigprocmask() */
        sigemptyset(&set);
        sigaddset(&set, SIGINT);
        /* block SIGINT and run an infinite loop */
        sigprocmask(SIG_BLOCK, &set, NULL);
        /* infinite loop to keep the program running */
        for (;;)
        {
            sleep(10);
        }
        sigprocmask(SIG_UNBLOCK, &set, NULL);
        return 0;
    }
    ```

9.  最后，让我们写下将在`SIGUSR1`和`SIGUSR2`上执行的功能。该功能将打印接收到的信号:

    ```sh
    void sigHandler(int sig)
    {
        if (sig == SIGUSR1)
        {
            printf("Received USR1 signal\n");
        }
        else if (sig == SIGUSR2)
        {
            printf("Received USR2 signal\n");
        }
    }
    ```

10.  让我们编译程序:

    ```sh
    $> make signals
    gcc -Wall -Wextra -pedantic -std=c99    signals.c   -o
     signals
    ```

11.  在单独的终端或后台的同一终端运行程序。请注意我们在这里使用的信号名称带有`kill`；这比记录数字容易一点:

    ```sh
    $> ./signals &
    [1] 25831
    $> Program running with PID 25831
    $> kill -USR1 25831
    Received USR1 signal
    $> kill -USR1 25831
    Received USR1 signal
    $> kill -USR2 25831
    $> kill -USR2 25831
    Received USR2 signal
    $> Ctrl+C
    ^C
    $> kill -USR1 25831
    Received USR1 signal
    $> kill -TERM 25831
    $> ENTER 
    [1]+  Terminated              ./signals
    ```

## 它是如何工作的…

首先，我们探索了 Linux 系统中可用的许多**信号**，其中前 31 个令人感兴趣并被广泛使用。最常见的有`TERM`、`KILL`、`QUIT`、`STOP`、`HUP`、`INT`、`STOP`和`CONT`，正如我们在这里看到的。

然后，我们使用`STOP`和`CONT`信号来实现与我们在前一个食谱中实现的相同的效果；即停止并继续运行后台进程。在之前的菜谱中，我们使用`bg`在后台继续运行一个进程，而要停止一个进程，我们点击 *Ctrl* + *Z* 。这一次，我们不需要在前台打开程序来停止它；我们刚刚用`kill`给它发送了`STOP`信号。

之后，我们继续写了一个 C 程序，捕捉两个信号，`USR1`和`USR2`，屏蔽`SIGINT`信号( *Ctrl* + *C* )。根据我们发送给程序的信号，会打印不同的文本。我们通过实现一个信号处理器做到了这一点。一个**信号处理器**是我们自己编写的一个函数，就像其他任何函数一样。然后，我们用`sigaction()`函数将该函数注册为信号处理器。

在调用`sigaction()`系统调用之前，我们必须用关于处理函数的信息填充`sigaction`结构，在处理函数执行过程中要忽略哪些信号，以及它应该有哪些行为。

sigaction 的`sa_mask`和`sigprocmask()`信号集都是使用`sigset_t`类型创建的，并通过以下函数调用进行操作(这里，我们假设使用了名为`s`的`sigset_t`变量:

*   `sigemptyset(&s);`清除来自`s`的所有信号
*   `sigaddset(&s, SIGUSR1);`将`SIGUSR1`信号加到`s`
*   `sigdelset(&s, SIGUSR1);`从`s`移除`SIGUSR`信号
*   `sigfillset(&s);`设置`s`中的所有信号
*   `sigismember(&s, SIGUSR1);`查明`SIGUSR1`是否是`s`的成员(在我们的示例代码中未使用)

要在进程启动时打印进程的 PID，我们必须用`getpid()`系统调用获取 PID。如前所述，我们将 PID 存储在`pid_t`类型的变量中。

## 另见

在`kill`、`pkill`、`sigprocmask()`和`sigaction()`系统调用的手册页中有很多有用的信息。我建议您使用以下命令阅读它们:

*   `man 1 kill`
*   `man 1 pkill`
*   `man 2 sigprocmask`
*   `man 2 sigaction`

还有一个更简单的系统调用，叫做`signal()`，也用于信号处理。如今，这种系统调用或多或少被认为是不可取的。但是如果你感兴趣的话，可以在`man 2 signal`里面了解一下。

# 用 execl()替换进程中的程序

在本章的开头，我们看到了当用户登录时`getty`是如何被`login`取代的。在这个食谱中，我们将编写一个小程序来实现这一点——用一个新程序替换它的程序。系统对此的称呼是`execl()`。

知道如何使用`execl()`使您能够编写在现有进程内执行新程序的程序。它还使您能够在衍生过程中启动一个新程序。当我们开始一个新的过程时，我们可能想用一个新的程序替换那个副本。所以，了解`execl()`是至关重要的。

## 做好准备

你需要阅读本章的前三个食谱才能完全理解这一个。本章*技术要求*部分提到了该配方的其他要求；例如，您将需要`pstree`工具。

您还需要两个终端或两个终端窗口来制作这个食谱。在其中一个终端中，我们将运行程序，而在另一个终端中，我们将查看`pstree`以了解过程。

## 怎么做…

在这个食谱中，我们将编写一个小程序，替换进程内部运行的程序。让我们开始吧:

1.  将以下代码写入文件并保存为`execdemo.c` :

    ```sh
    #include <stdio.h>
    #include <unistd.h>
    #include <errno.h>
    #include <sys/types.h>
    int main(void)
    {
       printf("My PID is %d\n", getpid());
       printf("Hit enter to continue ");
       getchar(); /* wait for enter key */
       printf("Executing /usr/bin/less...\n");
       /* execute less using execl and error check it */
       if ( execl("/usr/bin/less", "less", 
          "/etc/passwd", (char*)NULL) == -1 )
       {
          perror("Can't execute program");
          return 1;
       }
       return 0;
    }
    ```

2.  使用 Make:

    ```sh
    $> make execdemo
    gcc -Wall -Wextra -pedantic -std=c99    execdemo.c   -o execdemo
    ```

    编译程序
3.  现在，在您当前的*终端中运行该程序:

    ```sh
    $> ./execdemo
    My PID is 920
    Hit enter to continue
    ```* 
**   现在，启动一个*新的*终端，用`execdemo` :

    ```sh
    $> pstree -A -p -s 920
    systemd(1)---tmux(4050)---bash(18817)---execdemo(920)
    ```

    的 PID 执行`pstree`*   现在，回到第一个终端，`execdemo`正在运行，点击*进入*。这会用`less`打印密码文件。*   最后，回到第二个终端——你运行`pstree`的那个终端。重新运行相同的`pstree`命令。注意`execdemo`已经被`less`取代，虽然 PID 还是一样:

    ```sh
    $> pstree -A -p -s 920
    systemd(1)---tmux(4050)---bash(18817)---less(920)
    ```* 

 *## 它是如何工作的…

`execl()`功能执行一个新程序，并在同一过程中替换旧程序。为了让程序暂停执行以便我们有时间在`pstree`中查看，我们使用了`getchar()`。

`execl()`函数接受四个强制参数。第一个是我们要执行的程序的路径。第二个参数是程序的名称，因为它将从`argv[0]`打印。最后，第三个参数以及后面的任何参数都是我们要传递给将要执行的程序的参数。要让*终止*这个我们想传递给程序的参数列表，我们必须用指向`NULL`的指针来结束它，将其转换为`char`。

另一种看待进程的方式是将其视为一个执行环境。在该环境中运行的程序可以被替换。这就是为什么我们谈论进程，为什么我们称之为*进程标识*，而不是程序标识。

## 另见

我们还可以使用其他几个`exec()`功能，每个都有自己独特的功能和特点。这些通常被称为“`exec()`家族。”您可以使用`man 3 execl`命令阅读所有关于它们的内容。

# 分叉进程

之前我们一直说*衍生*当一个程序创建一个新的进程。正确的术语是**叉**一个进程。正在发生的是一个过程创造了它自己的一个副本——它*分叉*。

在之前的食谱中，我们学习了如何使用`execl()`在进程中执行新程序。在本食谱中，我们将学习如何使用`fork()`分叉进程。分叉进程(子进程)是调用进程(父进程)的副本。

知道如何分叉一个进程使我们能够以编程方式在系统上创建新的进程。由于无法分叉，我们只能执行一个进程。例如，如果我们想从一个现有的程序启动一个新的程序，但仍然保持原来的程序，我们必须分叉。

## 做好准备

就像之前的食谱一样，你需要`pstree`工具。*技术要求*部分介绍了如何安装。您还需要 GCC 编译器和 Make 工具。你还需要两个终端；一个终端执行程序，另一个终端用`pstree`查看工艺树。

## 怎么做…

在这个食谱中，我们将使用`fork()`来分叉一个过程。我们还将查看一个进程树，这样我们就可以看到发生了什么。让我们开始吧:

1.  在程序中编写以下代码并保存为`forkdemo.c`。`fork()`系统调用在该代码中突出显示。在我们`fork()`之前，我们打印进程的 PID:

    ```sh
    #include <stdio.h>
    #include <sys/types.h>
    #include <unistd.h>
    int main(void)
    {
       pid_t pid;
       printf("My PID is %d\n", getpid());
       /* fork, save the PID, and check for errors */
       if ( (pid = fork()) == -1 )
       { 
          perror("Can't fork");
          return 1;
       }
       if (pid == 0)
       {
          /* if pid is 0 we are in the child process */
          printf("Hello from the child process!\n");
          sleep(120);
       }

       else if(pid > 0)
       {
          /* if pid is greater than 0 we are in 
           * the parent */
          printf("Hello from the parent process! "
             "My child has PID %d\n", pid);
          sleep(120);
       }
       else
       {
          fprintf(stderr, "Something went wrong "
             "forking\n");
          return 1;
       }
       return 0;
    }
    ```

2.  现在，编译程序:

    ```sh
    $> make forkdemo
    gcc -Wall -Wextra -pedantic -std=c99    forkdemo.c   
    -o forkdemo
    ```

3.  在您当前的*终端运行程序，并记下 PID:

    ```sh
    $> ./forkdemo 
    My PID is 21764
    Hello from the parent process! My child has PID 21765
    Hello from the child process!
    ```* 
**   现在，在一个新的终端中，用`forkdemo`的 PID 运行`pstree`。在这里，我们可以看到`forkdemo`已经分叉，我们在分叉之前从程序中得到的 PID 是父进程。分叉的过程就是**子过程**，孩子的 PID 和家长告诉我们的一致。另外，注意现在有两个`forkdemo`运行副本:

    ```sh
    $> pstree -A -p -s 21764
    systemd(1)---tmux(4050)---bash(18817)---
    forkdemo(21764)---forkdemo(21765)
    ```* 

 *## 它是如何工作的…

当一个进程分叉时，它会创建一个自身的副本。该副本成为名为`fork()`-父进程的进程的子进程。子进程与父进程相同，只是它有一个新的 PID。在父进程内部，`fork()`返回子进程的 PID。在子进程中，`0`被返回。这就是为什么父进程可以打印子进程的 PID。

两个进程包含相同的程序代码，两个进程都在运行，但只有`if`语句中的特定部分得到执行，这取决于进程是父进程还是子进程。

## 还有更多…

一般来说，除了 PID，父母和孩子都是一样的。然而，还有一些其他的区别；例如，在子进程中重置 CPU 计数器。你可以在`man 2 fork`中读到其他这样的细微差别。但是，整体程序代码是一样的。

# 在分叉进程中执行新程序

在前面的食谱中，我们学习了如何使用`fork()`系统调用来分叉一个进程。在此之前的食谱中，我们学习了如何用`execl()`替换进程中的程序。在这个食谱中，我们将结合两个，`fork()`和`execl()`，以分叉的过程执行一个新的程序。这是我们每次在 Bash 中运行程序时都会发生的事情。Bash 分叉并执行我们键入的程序。

知道如何使用`fork()`和`execl()`可以让你编写启动新程序的程序。例如，您可以用这些知识编写自己的 shell。

## 做好准备

对于这个食谱，你将需要`pstree`工具、GCC 编译器和 Make 工具。您可以在本章的*技术要求*部分找到这些程序的安装说明。

## 怎么做…

在这个食谱中，我们将编写一个程序`forks()`并在子进程中执行一个新的程序。让我们开始吧:

1.  将以下程序代码写入文件，保存为`my-fork.c`。当我们在子进程中执行一个新程序时，我们将等待子进程完成。这就是我们用`waitpid()`做的。`waitpid()`这个称呼还有另一个重要的功能；要从子进程获取退货状态:

    ```sh
    #include <stdio.h>
    #include <unistd.h>
    #include <sys/types.h>
    #include <string.h>
    #include <sys/wait.h>
    int main(void)
    {
       pid_t pid;
       int status;
       /* Get and print my own pid, then fork
          and check for errors */
       printf("My PID is %d\n", getpid());
       if ( (pid = fork()) == -1 )
       {
          perror("Can't fork");
          return 1;
       }
       if (pid == 0)
       {
          /* If pid is 0 we are in the child process,
             from here we execute 'man ls' */
          if ( execl("/usr/bin/man", "man", "ls",
             (char*)NULL) == -1 )
          {
             perror("Can't exec");
             return 1;
          }
       }
       else if(pid > 0)
       {
          /* In the parent we must wait for the child
             to exit with waitpid(). Afterward, the
             child exit status is written to 'status' */
          waitpid(pid, &status, 0);
          printf("Child executed with PID %d\n", pid);
          printf("Its return status was %d\n", status);
          printf("Its return status was %d\n", status);
       }
       else
       {
          fprintf(stderr, "Something went wrong "
             "forking\n");
          return 1;
       }
       return 0;
    }
    ```

2.  使用 Make:

    ```sh
    $> make my-fork
    gcc -Wall -Wextra -pedantic -std=c99    my-fork.c   -o
    my-fork
    ```

    编译程序
3.  在你当前的终端中，找到当前 shell 的 PID 并做好记录:

    ```sh
    $> echo $$
    18817
    ```

4.  现在，执行我们用`./my-fork`编译的程序。这将显示`ls`的手动页面。
5.  启动一个新终端，查看另一个终端中Shell的进程树。注意`my-fork`已经分叉并用`man`替换其内容，而`man`已经分叉并用`pager`替换其内容(显示内容):

    ```sh
    $> pstree -A -p -s 18817
    systemd(1)---tmux(4050)---bash(18817)---my-fork(5849)-
    --man(5850)---pager(5861)
    ```

6.  点击 *Q* 退出第一终端的手动页面。这将产生以下文本。从`pstree`开始比较父进程和子进程的 PID。请注意，子进程是`5850`，这是`man`命令。它最初是`my-fork`的复制品，但后来用`man` :

    ```sh
    My PID is 5849
    Child executed with PID 5850
    Its return status was 0
    ```

    取代了它的程序

## 它是如何工作的…

`fork()`系统调用是负责在 Linux 和 Unix 系统上分叉进程。`execl()`(或其他`exec()`功能之一)然后负责执行——并用新的程序替换它自己的程序。这是任何程序在系统上启动的基本方式。

注意，我们需要用`waitpid()`告诉父进程等待子进程。如果我们需要运行一个不需要终端的程序，没有`waitpid()`我们也能做到。但是，我们应该始终等待孩子的过程。如果我们不这样做，孩子最终会成为**孤儿**。这是我们将在本章后面的*学习什么是孤儿*食谱中详细讨论的内容。

但是在这种特殊的情况下，我们执行`man`命令，这需要一个终端，我们需要等待孩子的一切工作。`waitpid()`呼叫还能让我们抓取孩子的*返回状态*。我们也防止孩子成为孤儿。

当我们运行程序并用`pstree`查看进程树时，我们看到`my-fork`进程已经用分叉，并用`man`替换了它的程序。我们可以看到这一点，因为`man`命令的 PID 与`my-fork`子进程的 PID 相同。我们还注意到`man`命令依次分叉，并用`pager`替换了它的子命令。`pager`命令负责在屏幕上显示实际文本，通常为`less`。

# 用系统()启动新进程

我们刚刚介绍的关于使用`fork()`、`waitpid()`和`execl()`在分叉进程中启动一个新程序是更深层次理解 Linux 和进程的关键。这种理解是成为优秀系统开发人员的关键。然而，有一条捷径。我们可以使用`system()`，而不是手动处理分叉、等待和执行。`system()`功能为我们完成所有这些步骤。

## 做好准备

对于这个食谱，你只需要本章*技术要求*部分列出的内容。

## 怎么做…

在这个食谱中，我们将使用`system()`函数来重写之前的程序— `my-fork`。你会注意到这个程序与前一个相比要短得多。让我们开始吧:

1.  将以下代码写入一个文件并保存为`sysdemo.c`。注意这个程序有多小(多简单)。`system()`功能为我们完成所有复杂的工作:

    ```sh
    #include <stdio.h>
    #include <stdlib.h>
    int main(void)
    {
       if ( (system("man ls")) == -1 )
       {
          fprintf(stderr, "Error forking or reading "
             "status\n");
          return 1;
       }
       return 0;
    }
    ```

2.  编译程序:

    ```sh
    $> make sysdemo
    gcc -Wall -Wextra -pedantic -std=c99    sysdemo.c   -o
    sysdemo
    ```

3.  使用`$$`变量

    ```sh
    $> echo $$
    957
    ```

    记下Shell的 PID
4.  现在，在当前终端运行程序。这将显示`ls`命令的手动页面。让它运行:

    ```sh
    $> ./sysdemo
    ```

5.  启动一个新的终端，从*步骤 3* 开始在 PID 上执行`pstree`。请注意，我们这里有一个额外的过程，称为`sh`。这是因为`system()`功能执行来自`sh`(基本伯恩Shell):

    ```sh
    $> pstree -A -p -s 957
    systemd(1)---tmux(4050)---bash(957)---sysdemo(28274)--
    -sh(28275)---man(28276)---pager(28287)
    ```

    的`man`命令

## 它是如何工作的…

这个程序小得多，也更容易写。然而，正如我们在`pstree`中看到的，与之前的配方相比，还有一个额外的过程:`sh`(Shell)。`system()`功能通过执行来自`sh`的`man`命令来工作。手册页(`man 3 system`)明确说明了这一点。它通过以下`execl()`调用执行我们指定的命令:

```sh
execl("/bin/sh", "sh", "-c", command, (char *) 0);
```

然而，结果是一样的。它执行一个`fork()`然后一个`execl()`呼叫，它和`waitpid()`一起等待孩子。这也是使用低级系统调用的高级函数的一个很好的例子。

# 创建僵尸进程

为了完全理解 Linux 中的进程，我们还需要看看什么是僵尸进程。为了完全理解这是什么，我们需要自己创造一个。

一个**僵尸**进程是一个先于父进程退出的子进程，父进程没有等待子进程的状态。“僵尸进程”这个名字来源于这个进程是*不死*的事实。进程已经退出，但是在系统进程表中仍然有一个条目。

了解什么是僵尸进程以及它是如何创建的将有助于您避免编写在系统上创建僵尸进程的坏程序。

## 做好准备

对于这个食谱，你只需要本章*技术要求*部分列出的内容。

## 怎么做…

在这个食谱中，我们将编写一个小程序，在系统上创建一个僵尸进程。我们还将使用`ps`命令查看僵尸进程。为了证明我们可以通过等待孩子来避免僵尸，我们还会用`waitpid()`写第二个版本。让我们开始吧:

1.  将下面的代码写在一个文件中，并命名为`create-zombie.c`。该程序与我们在`forkdemo.c`文件中看到的程序相同，只是孩子在家长退出之前使用`exit(0)`退出。孩子退出后，家长睡 2 分钟，不用等孩子有`waitpid()`，这样就形成了一个僵尸过程。此处突出显示了对`exit()`的调用:

    ```sh
    #include <stdio.h>
    #include <sys/types.h>
    #include <unistd.h>
    #include <stdlib.h>
    int main(void)
    {
       pid_t pid;
       printf("My PID is %d\n", getpid());
       /* fork, save the PID, and check for errors */
       if ( (pid = fork()) == -1 )
       {
          perror("Can't fork");
          return 1;
       }
       if (pid == 0)
       {
          /* if pid is 0 we are in the child process */
          printf("Hello and goodbye from the child!\n");
     exit(0);
          /* if pid is greater than 0 we are in 
           * the parent */
          printf("Hello from the parent process! "
             "My child had PID %d\n", pid);
          sleep(120);
       }
       else 
       {
          fprintf(stderr, "Something went wrong "
             "forking\n");
          return 1;
       }
       return 0;
    }
    ```

2.  编译程序:

    ```sh
    $> make create-zombie
    gcc -Wall -Wextra -pedantic -std=c99    create-
    zombie.c   -o create-zombie
    ```

3.  在当前终端运行程序。程序(父进程)将存活 2 分钟。在此期间，孩子是僵尸，因为父母没有等待它或它的状态:

    ```sh
    $> ./create-zombie
    My PID is 2429
    Hello from the parent process! My child had PID 2430
    Hello and goodbye from the child!
    ```

4.  当程序运行时，打开另一个终端，用`ps`查看孩子的 PID。您可以从`create-zombie`的前面输出中获得孩子的 PID。在这里，我们可以看到进程是一个僵尸，因为它的状态，`Z+`，以及进程名称后面的单词【T3:

    ```sh
    $> ps a | grep 2430
      2430 pts/18   Z+     0:00 [create-zombie] <defunct>
      2824 pts/34   S+     0:00 grep 2430
    ```

5.  2 分钟后，当父进程完成执行时，用相同的 PID 重新运行`ps`命令。僵尸进程现在将消失:

    ```sh
    $> ps a | grep 2430
      3364 pts/34   S+     0:00 grep 2430
    ```

6.  现在，重写程序，使其如下所示。命名新版本`no-zombie.c`。添加的代码在此处突出显示:

    ```sh
    #include <stdio.h>
    #include <sys/types.h>
    #include <unistd.h>
    #include <stdlib.h>
    #include <sys/wait.h>
    int main(void)
    {
       pid_t pid;
     int status;
       printf("My PID is %d\n", getpid());
       /* fork, save the PID, and check for errors */
       if ( (pid = fork()) == -1 )
       {
          perror("Can't fork");
          return 1;
       }
       if (pid == 0)
       {
          /* if pid is 0 we are in the child process */
          printf("Hello and goodbye from the child!\n");
          exit(0);
       }
       else if(pid > 0)
       {
          /* if pid is greater than 0 we are in 
           * the parent */
          printf("Hello from the parent process! "
             "My child had PID %d\n", pid);
     waitpid(pid, &status, 0); /* wait for child */
          sleep(120);
       }
       else
       {
          fprintf(stderr, "Something went wrong "
             "forking\n");
          return 1;
       }
       return 0;
    }
    ```

7.  编译这个新版本:

    ```sh
    $> make no-zombie
    gcc -Wall -Wextra -pedantic -std=c99    no-zombie.c  
    -o no-zombie
    ```

8.  在当前终端运行程序。就像以前一样，它将创建一个将立即退出的子进程。父进程将继续运行 2 分钟，给我们足够的时间搜索孩子的 PID:

    ```sh
    $> ./no-zombie
    My PID is 22101
    Hello from the parent process! My child had PID 22102
    Hello and goodbye from the child!
    ```

9.  当`no-zombie`程序运行时，打开一个新的终端，用`ps`和`grep`搜索孩子的 PID。正如您将看到的，没有与子进程的 PID 相匹配的进程。因此，孩子已经正确退出，因为父母等待其状态:

    ```sh
    $> ps a | grep 22102
    22221 pts/34   S+     0:00 grep 22102
    ```

## 它是如何工作的…

我们总是希望避免在系统上创建僵尸进程，最好的方法是等待子进程完成。

在*步骤 1 到 5* 中，我们编写了一个程序，创建了一个僵尸进程。僵尸进程是由于父进程没有用`waitpid()`系统调用等待子进程而创建的。子进程确实退出了，但它仍保留在系统进程表中。当我们搜索带有`ps`和`grep`的进程时，我们看到子进程的状态为`Z+`，意思是僵尸。该进程不存在，因为它已经使用`exit()`系统调用退出。然而，根据系统进程表，它仍然在那里；因此，它是不死的——僵尸。

在*步骤 6 到 9* 中，我们使用`waitpid()`系统调用重写了程序来等待孩子。子代仍然存在于父代之前，但这一次，父代获得了子代的状态。

僵尸进程不会耗尽任何系统资源，因为该进程已经终止。它只存在于系统进程表中。然而，系统上的每个进程——包括僵尸——都占用一个 PID 号。由于系统可用的 PID 数量有限，如果死进程占用 PID 数量，就有用完 PID 的风险。

## 还有更多…

`waitpid()`的手动页面中有很多关于子进程及其状态变化的详细信息。Linux 中实际上有三个`wait()`功能。您可以使用`man 2 wait`命令阅读所有这些内容。

# 了解什么是孤儿

理解 Linux 系统中的孤儿和理解僵尸一样重要。这将使对整个系统以及进程如何被`systemd`继承有更深入的了解。

**孤儿**是父母双亡的孩子。然而，正如我们在本章中所学的，每个进程都需要一个父进程。所以，即使是孤儿也需要父母的过程。为了解决这个困境，每个孤儿都被`systemd`继承，这是系统上的第一个进程——PID`1`。

在这个食谱中，我们将编写一个分叉的小程序，从而创建一个子进程。然后，父进程将退出，让子进程成为孤儿。

## 做好准备

本章*技术要求*部分列出了此配方所需的一切。

## 怎么做…

在这个食谱中，我们将编写一个简短的程序，创建一个孤儿进程，该进程将由`systemd`继承。让我们开始吧:

1.  将以下代码写入一个文件并保存为`orphan.c`。该程序将创建一个在后台运行 5 分钟的子进程。当我们按下*进入*时，父进程将退出。这给了我们时间来研究父母离开前后`pstree`的子进程:

    ```sh
    #include <stdio.h>
    #include <sys/types.h>
    #include <unistd.h>
    #include <stdlib.h>
    int main(void)
    {
       pid_t pid;
       printf("Parent PID is %d\n", getpid());
       /* fork, save the PID, and check for errors */
       if ( (pid = fork()) == -1 )
       {
          perror("Can't fork");
          return 1;
       }
       if (pid == 0)
       {
          /* if pid is 0 we are in the child process */
          printf("I am the child and will run for "
             "5 minutes\n");
          sleep(300);
          exit(0);
       }
       else if(pid > 0)
       {
          /* if pid is greater than 0 we are in 
           * the parent */
          printf("My child has PID %d\n" 
             "I, the parent, will exit when you "
             "press enter\n", pid);
          getchar();
          return 0;
       }
       else
       {
          fprintf(stderr, "Something went wrong "
             "forking\n");
          return 1;
       }
       return 0;
    }
    ```

2.  编译本程序:

    ```sh
    $> make orphan
    gcc -Wall -Wextra -pedantic -std=c99    orphan.c   -o
     orphan
    ```

3.  在当前终端运行程序，并保持程序运行。暂时不要按*进入*:

    ```sh
    $> ./orphan
    My PID is 13893
    My child has PID 13894
    I, the parent, will exit when you press enter
    I am the child and will run for 2 minutes
    ```

4.  现在，在新的终端中，用孩子的 PID 运行`pstree`。在这里，我们会看到它看起来就像它在以前的食谱。进程已经分叉，创建了一个子进程，内容相同:

    ```sh
    $> pstree -A -p -s 13894
    systemd(1)---tmux(4050)---bash(18817)---orphan(13893)-
    --orphan(13894)
    ```

5.  现在，是时候结束父进程了。回到`orphan`还在运行的终端，点击*进入*。这将结束父进程。
6.  现在，在第二个终端再次运行`pstree`。这与您刚才运行的命令相同。可以看到，子进程自从父进程死亡后，现在已经被`systemd`继承了。5 分钟后，子进程将退出:

    ```sh
    $> pstree -A -p -s 13894
    systemd(1)---orphan(13894)
    ```

7.  我们还可以使用其他更多的标准化工具来查看**父进程标识** ( **PPID** )。其中之一就是`ps`。运行以下`ps`命令至查看子进程的更多详细信息。在这里，我们将看到更多的信息。对我们来说最重要的是 PPID、PID 和**会话标识** ( **SID** )。我们还会在这里看到的**用户 ID** ( **UID** )，指定进程的所有者:

    ```sh
    $> ps jp 13894
    PPID PID PGID  SID   TTY  TPGID STAT UID TIME COMMAND
    1  13894 13893 18817 pts/18 18817 S 1000 0:00 ./orphan
    ```

## 它是如何工作的…

每个进程都需要一个父进程。这就是为什么`systemd`会继承系统上任何最终成为孤儿的进程。

`if (pid == 0)`里面的代码继续运行 5 分钟。这给了我们足够的时间来检查子进程是否被`systemd`继承。

在最后一步中，我们使用`ps`查看子进程的更多细节。在这里，我们看到了 PPID、PID、PGID 和 SID。这里提到了一些重要的新名字。我们已经知道了 PPID 和 PID，但是还没有涉及到 PGID 和 SID。

**PGID** 代表**进程组 ID** ，是系统对进程进行分组的一种方式。子进程的 PGID 是父进程的 PID。换句话说，创建这个 PGID 是为了将父进程和子进程分组，因为它们属于同一个组。系统将 PGID 设置为创建组的父代的 PID。我们不需要自己创造这些群体；这是系统为我们做的事情。

**SID** 代表**会话 ID** ，这也是系统分组进程的一种方式。然而，SID 组通常更大，包含更多的进程——通常是一个完整的“会话”，因此得名。这个组的 SID 是`18817`，是 Bash shell 的 PID。相同的规则适用于此；SID 号将与启动会话的进程的 PID 相同。这个会话由我的用户Shell和我从中启动的所有程序组成。这样，如果我注销系统，系统可以终止属于该会话的所有进程。

## 另见

你可以通过`ps`获得很多信息。我建议你至少用`man 1 ps`浏览一下手册。

# 创建守护进程

使用系统编程时，一个常见的任务是创建各种守护程序。一个**守护进程**是一个后台进程，运行在系统上并执行一些任务。SSH 守护程序就是一个很好的例子。另一个很好的例子是 NTP 守护程序，它负责同步计算机时钟，有时甚至将时间分配给其他计算机。

知道如何创建守护进程将使您能够创建服务器软件；例如，网络服务器、聊天服务器等等。

在这个食谱中，我们将创建一个简单的守护进程来演示一些重要的概念。

## 做好准备

您只需要本章*技术要求*部分列出的组件。

## 怎么做…

在这个食谱中，我们将编写一个小的后台程序，它将在我们的系统中后台运行。守护进程唯一要做的“工作”是将当前日期和时间写入文件。这证明守护进程是活的，并且运行良好。让我们开始吧:

1.  与我们之前的例子相比，守护进程的代码相当长。因此，代码被分成了几个步骤。这里还有一些我们还没有涉及到的新东西。将代码写入文件，保存为`my-daemon.c`。请记住，所有步骤中的所有代码都放在这个文件中。我们将从所有的`include`文件、我们需要的变量和我们的`fork()`开始，正如我们之前看到的。这`fork()`将是两个中的第一个:

    ```sh
    #include <stdio.h>
    #include <unistd.h>
    #include <stdlib.h>
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <time.h>
    #include <fcntl.h>
    int main(void)
    {
       pid_t pid;
       FILE *fp;
       time_t now; /* for the current time */
       const char pidfile[] = "/var/run/my-daemon.pid";
       const char daemonfile[] = 
          "/tmp/my-daemon-is-alive.txt";
       if ( (pid = fork()) == -1 )
       {
          perror("Can't fork");
          return 1;
       }
    ```

2.  现在我们已经分叉了，我们希望父母退出。一旦家长退出，我们将进入子进程。在子进程中，我们将用`setsid()`创建一个新的会话。创建新会话将从控制终端释放进程:

    ```sh
       else if ( (pid != 0) )
       {
          exit(0);
       }
       /* the parent process has exited, so this is the
        * child. create a new session to lose the 
        * controlling terminal */
       setsid();
    ```

3.  现在，我们又要`fork()`了。第二个分叉将像以前一样创建一个新的进程，但是由于它是一个已经存在的会话中的新进程，它将不是一个会话领导者，从而阻止它获得一个新的控制终端。新的子进程被称为孙子。我们再次退出父进程(子进程)。然而，在我们退出孩子之前，我们将孙子的 PID 写入一个 **PID 文件**。这个 PID 文件用于跟踪守护进程:

    ```sh
       /* fork again, creating a grandchild, 
        * the actual daemon */
       if ( (pid = fork()) == -1 )
       {
          perror("Can't fork");
          return 1;
       }
       /* the child process which will exit */
       else if ( pid > 0 )
       {
          /* open pid-file for writing and error 
           * check it */
          if ( (fp = fopen(pidfile, "w")) == NULL )
          {
             perror("Can't open file for writing");
             return 1;
          }
          /* write pid to file */
          fprintf(fp, "%d\n", pid); 
          fclose(fp); /* close the file pointer */
          exit(0);
       }
    ```

4.  现在，将默认模式( *umask* )设置为对守护进程合理的模式。我们还必须将当前工作目录更改为`/`，这样守护程序就不会阻止文件系统卸载或目录删除。然后，我们必须打开守护程序文件，这是我们将向其写入消息的地方。这些消息将包含当前的日期和时间，并让我们知道是否一切正常。通常，这应该是一个日志文件:

    ```sh
       umask(022); /* set the umask to something ok */
       chdir("/"); /* change working directory to / */
       /* open the "daemonfile" for writing */
       if ( (fp = fopen(daemonfile, "w")) == NULL )
       {
          perror("Can't open daemonfile");
          return 1;
       }
    ```

5.  因为守护进程只会在后台独立运行，所以我们不需要 stdin、stdout 和 stderr，所以让我们关闭它们。然而，让它们关闭是不安全的。如果代码中的某个东西稍后打开一个文件描述符，它会得到文件描述符 0，通常是 stdin。文件描述符是按顺序分配的。如果没有打开的文件描述符，第一次调用`open()`会得到描述符`0`；第二次调用将得到描述符`1`。另一个问题可能是某些部分可能试图写入不再存在的 stdout，从而导致程序崩溃。因此，我们必须将它们全部重新打开，但要改为`/dev/null`(黑洞):

    ```sh
       /* from here, we don't need stdin, stdout or, 
        * stderr anymore, so let's close them all, 
        * then re-open them to /dev/null */
       close(STDIN_FILENO);
       close(STDOUT_FILENO);
       close(STDERR_FILENO);
       open("/dev/null", O_RDONLY); /* 0 = stdin */
       open("/dev/null", O_WRONLY); /* 1 = stdout */
       open("/dev/null", O_RDWR); /* 2 = stderr */
    ```

6.  最后，我们可以开始守护进程的工作。这只是一个`for`循环，它向守护进程文件写入一条消息，表示守护进程仍然存在。请注意，我们必须在每个`fprintf()`之后用`fflush()`刷新文件指针。通常在 Linux 中，东西都是*行缓冲*，意思是写之前只缓冲一行。但是，由于这是文件，而不是 stdout，因此它会被完全缓冲，这意味着它会缓冲所有数据，直到缓冲区已满或文件流关闭。没有`fflush()`，我们不会在文件中看到任何文本，直到我们填充了缓冲区。通过在每个`fprintf()`之后使用`fflush()`，我们可以看到文件中的文本直播:

    ```sh
       /* here we start the daemons "work" */
       for (;;)
       {
          /* get the current time and write it to the
             "daemonfile" that we opened above */
          time(&now);
          fprintf(fp, "Daemon alive at %s", 
             ctime(&now));
          fflush(fp); /* flush the stream */
          sleep(30);
       }
       return 0;
    }
    ```

7.  现在，是时候编译整个守护进程了:

    ```sh
    $> make my-daemon
    gcc -Wall -Wextra -pedantic -std=c99    my-daemon.c  
    -o my-daemon
    ```

8.  现在，我们可以启动守护进程。由于我们正在将 PID 文件写入`/var/run`，我们需要以 root 用户身份执行守护进程。我们不会从守护进程获得任何输出；它将无声地脱离终端:

    ```sh
    $> sudo ./my-daemon
    ```

9.  现在守护进程正在运行，让我们检查一下已经写入`/var/run/my-daemon.pid` :

    ```sh
    $> cat /var/run/my-daemon.pid 
    5508
    ```

    的 PID 号
10.  让我们使用`ps`和`pstree`来研究守护进程。如果一切都按照它应该有的方式进行，它应该有`systemd`作为它的父级，并且它应该在它自己的会话中(SID 应该与进程 ID 相同):

    ```sh
    $> ps jp 5508
    PPID PID PGID SID TTY TPGID STAT UID TIME COMMAND
    1   5508 5508 5508?   -1    Ss    0  0:00 ./my-daemon
    $> pstree -A -p -s 5508
    systemd(1)---my-daemon(5508)
    ```

11.  我们也来看看`/tmp/my-daemon-is-alive.txt`文件。该文件应包含一些指定日期和时间的行，间隔 30 秒:

    ```sh
    $> cat /tmp/my-daemon-is-alive.txt 
    Daemon alive at Sun Nov 22 23:25:45 2020
    Daemon alive at Sun Nov 22 23:26:15 2020
    Daemon alive at Sun Nov 22 23:26:45 2020
    Daemon alive at Sun Nov 22 23:27:15 2020
    Daemon alive at Sun Nov 22 23:27:45 2020
    Daemon alive at Sun Nov 22 23:28:15 2020
    Daemon alive at Sun Nov 22 23:28:45 2020
    ```

12.  最后，让我们杀死守护进程，这样它就不会继续写入文件:

    ```sh
    $> sudo kill 5508
    ```

## 它是如何工作的…

我们刚刚编写的守护进程是一个基本的传统守护进程，但是它展示了我们需要很好理解的所有概念。这些新的重要概念之一是如何用`setsid()`开始新的会话。如果我们不创建新的会话，守护进程将仍然是用户登录会话的一部分，并在用户注销时死亡。但是由于我们已经为守护进程创建了一个新的会话，并且它被`systemd`继承，它现在独立存在，不受启动它的用户和进程的影响。

第二次分叉的原因是会话领导者——也就是我们在`setsid()`调用后的第一个孩子——可以获得一个新的控制终端，如果它要打开一个终端设备的话。当我们做第二个分叉时，新的子节点只是由第一个子节点创建的会话的成员，而不是领导者，因此它不能再获得**控制终端**。避免控制终端的原因是如果该终端退出，守护进程也会退出。创建守护进程时分叉两次通常被称为**双分叉**技术。

我们需要以 root 身份启动守护进程的原因是它需要写入`/var/run/`。如果我们要更改目录——或者完全跳过它——守护进程将作为普通用户正常运行。但是，大多数守护程序确实以 root 用户身份运行。然而，有一些守护进程作为的普通用户运行；例如，处理用户相关事务的守护程序，如`tmux`(一个**终端多路复用器**)。

我们也把工作目录改成了`/`。这样守护进程就不会锁定一个目录。顶部根目录不会被删除或卸载，这使得它成为守护进程的安全工作目录。

## 还有更多…

我们在这里写的是一个传统的 Linux/Unix 守护进程。这些类型的守护进程至今仍在使用，例如，像这样的小型快速守护进程。然而，自从`systemd`出现后，我们不再需要像刚才那样“监视”一个守护进程。例如，建议保持 stdout 和 stderr 打开，并在那里发送所有日志消息。这些信息将会出现在*杂志*上。我们将在 [*第 7 章*](07.html#_idTextAnchor299) *中更深入地介绍 systemd 和日志，使用 systemd 来处理您的守护进程*。

我们在这里编写的守护进程类型在 systemd 语言中被称为*分叉*，我们将在后面详细了解。

就像`system()`在执行新程序时为我们简化了事情一样，有一个叫做`daemon()`的函数可以为我们创建守护进程。这个函数将为我们完成所有繁重的工作，例如分叉、关闭和重新打开文件描述符、更改工作目录等等。但是，请注意，这个函数没有使用我们在这个配方中为守护进程使用的双分叉技术。这一事实在`man 3 daemon`手册页的 BUGS 一节中有明确说明。

# 实现信号处理器

在前面的食谱中，我们编写了一个简单但功能强大的守护进程。但是有一些问题；例如，当守护进程被终止时，PID 文件不会被删除。同样，当守护程序被杀死时，打开的文件流(`/tmp/my-daemon-is-alive.txt`)不会关闭。一个合适的守护进程应该在退出时自行清理。

为了能够在退出时清理，我们需要实现一个信号处理程序。然后，信号处理程序应该在守护进程终止之前处理所有的清理工作。我们已经在本章中看到了信号处理程序的例子，所以这个概念并不新鲜。

然而，使用信号处理程序的不仅仅是守护进程。这是控制进程的常见方式，尤其是没有控制终端的进程。

## 做好准备

在阅读这个食谱之前，你应该先阅读前面的食谱，这样你就能理解守护进程的作用了。除此之外，您还需要本章*技术要求*部分列出的程序。

## 怎么做…

在这个配方中，我们将在前面的配方中编写的守护进程中添加信号处理程序。由于代码会稍长一些，所以我将其分成了几个步骤。但是请记住，所有的代码都在同一个文件中。让我们开始吧:

1.  在中写入以下代码，并将其命名为`my-daemon-v2.c`。我们将从`#include`文件和变量开始，就像以前一样。但是，请注意，这一次，我们将一些变量移到了全局空间。我们这样做是为了让信号处理器能够访问它们。没有办法将额外的参数传递给信号处理程序，所以这是访问它们的最佳方式。在这里，我们还必须为`sigaction()`定义`_POSIX_C_SOURCE`。我们还必须为我们的信号处理器创建一个原型，叫做`sigHandler()`。另外，请注意新的`sigaction`结构:

    ```sh
    #include <sys/types.h>
    #include <sys/stat.h>
    #include <time.h>
    #include <fcntl.h>
    #include <signal.h>
    void sigHandler(int sig);
    /* moved these variables to the global scope
       since they need to be access/deleted/closed
       from the signal handler */
    FILE *fp;
    const char pidfile[] = "/var/run/my-daemon.pid";
    int main(void)
    {
       pid_t pid;
       time_t now; /* for the current time */
       struct sigaction action; /* for sigaction */
       const char daemonfile[] = 
          "/tmp/my-daemon-is-alive.txt";
       if ( (pid = fork()) == -1 )
       {
          perror("Can't fork");
          return 1;
       }
       else if ( (pid != 0) )
       {
          exit(0);
       }
    ```

2.  正如我们之前所做的，我们必须在第一个分叉之后创建一个新的会话。之后，我们必须做第二个分叉，以确保它不再是会话头:

    ```sh
       /* the parent process has exited, which makes 
        * the rest of the code the child process */
       setsid(); /* create a new session to lose the 
                    controlling terminal */

       /* fork again, creating a grandchild, the 
        * actual daemon */
       if ( (pid = fork()) == -1 )
       {
          perror("Can't fork");
          return 1;
       }
       /* the child process which will exit */
       else if ( pid > 0 )
       {
          /* open pid-file for writing and check it */
          if ( (fp = fopen(pidfile, "w")) == NULL )
          {
             perror("Can't open file for writing");
             return 1;
          }
          /* write pid to file */
          fprintf(fp, "%d\n", pid); 
          fclose(fp); /* close the file pointer */
          exit(0);
       }
    ```

3.  同样，正如我们之前所做的，我们必须更改 umask，即当前的工作目录，并用`fopen()`打开守护程序文件。接下来，我们必须关闭并重新打开 stdin、stdout 和 stderr:

    ```sh
       umask(022); /* set the umask to something ok */
       chdir("/"); /* change working directory to / */
       /* open the "daemonfile" for writing */
       if ( (fp = fopen(daemonfile, "w")) == NULL )
       {
          perror("Can't open daemonfile");
          return 1;
       }
       /* from here, we don't need stdin, stdout or, 
        * stderr anymore, so let's close them all, 
        * then re-open them to /dev/null */
       close(STDIN_FILENO);
       close(STDOUT_FILENO);
       close(STDERR_FILENO);
       open("/dev/null", O_RDONLY); /* 0 = stdin */
       open("/dev/null", O_WRONLY); /* 1 = stdout */
       open("/dev/null", O_RDWR); /* 2 = stderr */
    ```

4.  现在，终于到了准备和注册信号处理器的时候了。这正是我们在本章前面介绍的内容，只是在这里，我们正在为所有常见退出信号注册处理程序，例如终止、中断、退出和中止。一旦我们处理了信号处理程序，我们将开始守护进程的工作；也就是将消息写入守护程序文件的`for`循环:

    ```sh
    /* prepare for sigaction */
       action.sa_handler = sigHandler;
       sigfillset(&action.sa_mask);
       action.sa_flags = SA_RESTART;
       /* register the signals we want to handle */
       sigaction(SIGTERM, &action, NULL);
       sigaction(SIGINT, &action, NULL);
       sigaction(SIGQUIT, &action, NULL);
       sigaction(SIGABRT, &action, NULL);
       /* here we start the daemons "work" */
       for (;;)
       {
          /* get the current time and write it to the
             "daemonfile" that we opened above */
          time(&now);
          fprintf(fp, "Daemon alive at %s", 
             ctime(&now));
          fflush(fp); /* flush the stream */
          sleep(30);
       }
       return 0;
    }
    ```

5.  最后，我们必须实现信号处理器的功能。在这里，我们通过在退出之前移除 PID 文件来清理守护程序。我们还关闭守护程序文件的打开文件流:

    ```sh
    void sigHandler(int sig)
    {
        int status = 0;
        if ( sig == SIGTERM || sig == SIGINT 
            || sig == SIGQUIT 
            || sig == SIGABRT )
        {
            /* remove the pid-file */
            if ( (unlink(pidfile)) == -1 )
                status = 1;
            if ( (fclose(fp)) == EOF )
                status = 1;
            exit(status); /* exit with the status set*/
        }
        else /* some other signal */
        {
            exit(1);
        }
    }
    ```

6.  编译守护进程的新版本:

    ```sh
    $> make my-daemon-v2
    gcc -Wall -Wextra -pedantic -std=c99    my-daemon-v2.c
    -o my-daemon-v2
    ```

7.  以 root 用户身份启动守护程序，就像我们之前所做的那样:

    ```sh
    $> sudo ./my-daemon-v2 
    ```

8.  检查 PID 文件中的 PID 并记录下来:

    ```sh
    $> cat /var/run/my-daemon.pid 
    22845
    ```

9.  用`ps`检查看它是否正常运行:

    ```sh
    $> ps jp 22845
      PPID   PID  PGID   SID TTY TPGID STAT UID TIME
    COMMAND
        1 22845 22845 22845 ?      -1 Ss     0 0:00 ./my
    daemon-v2
    ```

10.  用默认信号`TERM` :

    ```sh
    $> sudo kill 22845
    ```

    杀死守护进程
11.  如果一切都按计划进行，PID 文件将被删除。看看能不能用`cat` :

    ```sh
    $> cat /var/run/my-daemon.pid 
    cat: /var/run/my-daemon.pid: No such file or directory
    ```

    访问 PID 文件

## 它是如何工作的…

在这个食谱中，我们实现了一个信号处理器，负责所有的清理工作。它删除 PID 文件并关闭打开的文件流。为了覆盖最常见的“退出”信号，我们用四种不同的信号注册了处理程序:*终止*、*中断*、*退出*、*中止*。当守护进程接收到其中一个信号时，它会触发`sigHandler()`功能。然后，该函数删除 PID 文件并关闭文件流。最后，该函数通过调用`exit()`退出整个守护进程。

但是，因为我们不能将文件名或文件流作为参数传递给信号处理程序，所以我们将这些变量放在全局范围内。这使得`main()`和`sigHandler()`都有可能到达它们。

## 还有更多…

还记得我们为了在`/tmp/my-daemon-is-alive.txt`中出现的时间和日期必须冲洗溪流吗？由于现在一旦守护进程退出，我们就关闭文件流，因此不再需要`fflush()`。当文件关闭时，数据被写入文件。然而，当守护进程运行时，我们看不到“实时”的时间和日期。这就是为什么我们在代码中仍然有`fflush()`。**