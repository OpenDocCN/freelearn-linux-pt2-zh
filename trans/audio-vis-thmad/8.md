# 8.ThMAD 模块参考

在 ThMAD 中，模块是可视化的构建块。在本章中，我们提供了一个完整的模块参考，描述了每个模块的功能和参数。根据其结构，它还描述了您可以使用该软件做什么。浏览并彻底阅读这一章会帮助你获得一些印象和新的想法。模块类别名称和模块名称与 GUI 和实现代码密切相关，重点放在 GUI 上，因此您可以使用 GUI 轻松地进行自己的实验。

所有模块都有零个或多个表示各种类型数据的输出锚点，以及零个或多个表示各种类型数据的输入锚点。一些模块有副作用，例如，它们存储了一些东西或者做了一些没有在输出数据中反映出来的事情。数据类型有:

*   `int`:整数。
*   `float`:浮点数。
*   `double`:双精度浮点型。ThMAD 中的所有浮点数都是单精度浮点类型，因此尽管定义了这种双精度类型，但并未使用。
*   `float3`:三个浮点数的向量。例如，3D 坐标。
*   `float4`:四个浮点数的向量。例如，红色、绿色、蓝色、阿尔法颜色值。
*   `quaternion`:也是四个浮点数的向量，但是有四元数计算规则。四元数准确地表示了 3D 旋转操作。
*   `string`:一串字符。
*   一个 4x4 的浮动矩阵。矩阵用于描述空间操作，如旋转、缩放和平移。
*   `float_array`:可变数量浮点值的数组。
*   `float3_array`:可变数量的 float3 向量的数组。
*   `quaternion_array`:可变数量的四元数数据的数组。
*   指向一个资源文件，可能是一个模块可以读写的图片或者一些文本文件。
*   `enum`:一个枚举。在必须从固定集合中选择字符串值的地方使用。枚举也用于一次性操作，如重置或触发某些东西。
*   `sequence`:8192 个浮点值的数组。由需要对指定的浮点值进行一些开发的模块使用，通常是在时域中。与`float_array`的不同之处在于 ThMAD Artiste GUI 中有一个特殊的图形编辑器。
*   `render`:代表可提取项目的内部队列。
*   `texture`:表示图形硬件内部彩色点的位图。
*   `mesh`:定义 3D 物体表面的点的集合。可以表示面，即具有相连边的二维表面原子，但情况不一定如此。
*   `bitmap`:CPU 托管下的若干色点，表示不直接由图形硬件处理。仅由合适的渲染器模块发送到图形硬件。
*   `particlesystem`:可能大量相等或相似的 3D 对象。内部处理，仅通过发送到图形硬件的渲染器。
*   `segment_mesh`:一种特殊形式的边不相连的网格。通常在进一步处理之前转化为网格。

在本章的模块参考表中，所有结核控制锚规格将被写成:

*   `Parameter-Name : Parameter-Type`

其中参数名不包含空格或连字符。表中较长的名字会在下划线处断开，所以如果您看到类似于`gamma_ correction:float`的内容。实际指的是`gamma_correction:float`。

每个模块属于一个类别，这将通过每个模块在模块列表器和模块浏览器中的位置来反映。模块类别如下:

*   屏幕:图形硬件的输出。
*   位图:驻留在主内存中并由 CPU 处理的彩色像素存储。
*   虚拟模块:模块通常传递不变的值。例如，如果您想要控制一个同时连接到多个输入锚点的浮点值，请使用此选项。这个类别实际上只包含各种其他类别的虚拟对象的别名。
*   数学:类似运算符的数学运算，所有输入和输出类型都相同，函数的输入和输出类型不同。在这里你还可以找到振荡器。
*   网格:包含定义 3D 对象的曲面或曲面部分的点的集合，无论这些点是连接的还是未连接的。
*   Particlesystems:可能有大量相同或相似的 3D 对象。用于雨、雾和许多特殊效果。
*   渲染器:将不同种类的输入转换成可以直接连接到屏幕的输出锚点。还包含改变其他模块的渲染器输出的模块。
*   选择器:用于从某种数据类型的集合中获取单个元素或元素的子范围。
*   声音:处理声音输入。
*   String:处理字符串。
*   系统:系统相关模块的集合，如时间、系统状态或文件选择器相关模块。
*   纹理:处理驻留在图形硬件上的位图。使用纹理代替位图会产生巨大的性能提升。纹理对于反向传播像素数据也很重要，即，将子管道输出反馈给其输入成分之一。
*   宏:可重用的子管道。

## 屏幕

这实际上包含了一个单一的内置模块`screen0`，是图形输出所必须的。任何模块最终都必须以某种方式连接到屏幕；否则，它不会被激活。因此，它是可视化设置的管道或管道组中的最后一个模块，负责监视器上的可视化输出。

### 屏幕

输出到图形硬件、图形卡和显示器。见表 [8-1](#Tab1) 。

表 8-1。

The screen0 module

<colgroup><col> <col> <col></colgroup> 
| `screen0` | 屏幕 |
| --- | --- |
| 在…里 | `screen:render` | 这里，任何可视化管道都必须连接到。如果这是不相连的，什么也看不见。如果有几个管道连接到这个锚点，那么呈现顺序可能非常重要。要更改 ThMAD Artiste GUI 中的顺序，请双击锚点并拖动锚点连接符。 |
|   | `gamma_correction:float` | 伽马校正。默认为 1.0。伽马校正源于人类对视觉亮度的感知是非线性的这一事实，并且源于自身显示非线性行为的旧阴极射线管。通常，大于 1 的灰度系数会使阴影变暗，小于 1 的灰度系数会使阴影变亮。 |
| 在外 | 没有人 | 将渲染到图形硬件。 |

## 位图

位图是存在于 ThMAD 中的图像，而不是存在于图形硬件中的图像，所以在它们被上传到图形硬件之前，可以对它们执行操作。

### 过滤

位图过滤器都涉及两个位图，并且都具有相同的结构。路径是位图→滤镜，然后见表 [8-2](#Tab2) 。

表 8-2。

Bitmap filter modules

<colgroup><col> <col> <col> <col></colgroup> 
| 动态分配的名称 |   |
| --- | --- |
| 在…里 | `bmp1:complex` | 第一个位图 |
|   |   | `in1:bitmap` | 位图锚点；需要连接到位图生成器 |
|   | `bitm1_ofs: float3` | 这是混合发生前应用的位图像素坐标的偏移量。第三个坐标被忽略 |
| `bmp2:complex` | 第二个位图 |
|   | `in2:bitmap` | 位图锚点；需要连接到位图生成器 |
|   | `bitm2_ofs: float3` | 这是混合发生前应用的位图像素坐标的偏移量。第三个坐标被忽略 |
|   | `bitm2_ opacity: float` | 定义一个混合因子，值从[0；1].为 0 时，输出将为 B1。值为 1 时，输出将是混合结果。所有其他值线性插值。 |
| `target_size: float3` | 输出位图大小。第三个坐标被忽略。 |
| `set_target_ size:enum` | 使用此选项将大小设置为正方形，例如:8x8、16x16、32x32、64x64、128x128、256x256、512x512、1024x1024 和 2048x2048。 |
| `blend_type: enum` | 混合类型-确定进行混合时要应用的公式。本章列出了可用的模式。请注意，所有不同的位图过滤器将只是在这个锚点使用不同的设置。 |
| `bitmap_type: enum` | `integer`或`float`之一。未使用。 |
| 在外 | `bitmap:bitmap` | 输出位图。您可以在这里添加更多的过滤器，或者将它发送到任何需要位图作为输入的模块。 |

表 [8-3](#Tab3) 中列出了所有可用的混合模式。如果给定样本图像，我们使用![A457467_1_En_8_Figa_HTML.jpg](A457467_1_En_8_Figa_HTML.jpg)透明)，和![A457467_1_En_8_Figb_HTML.jpg](A457467_1_En_8_Figb_HTML.jpg)作为位图 B1(在边缘的白色部分作为位图 B2(一个`ALPHA`通道被添加，但读取 1.0)。

表 8-3。

Bitmap filter blending modes

<colgroup><col> <col> <col></colgroup> 
| 过滤器模块的名称 | 相应的“blend_type”锚点设置 | 描述 |
| --- | --- | --- |
| `bitm_blend_add` | `BLEND_ADD` | For each RGBA value, add B1 and B2.![A457467_1_En_8_Figc_HTML.jpg](A457467_1_En_8_Figc_HTML.jpg)Clamp to max. 1.0\. Blending the images will yield the image shown here. The white color on top-left comes from the `ALPHA` there not applied before doing the blending! So even though `ALPHA` is 0 there, the hidden RGB values (white here) will be taken into account! |
| `bitm_blend_ average` | `BLEND_ AVERAGE` | For each RGBA value, take the average (B1+B2) / 2.![A457467_1_En_8_Figd_HTML.jpg](A457467_1_En_8_Figd_HTML.jpg) |
| `bitm_blend_ color_` `burn` | `BLEND_ COLOR_ BURN` | For each RGBA value, divide![A457467_1_En_8_Fige_HTML.jpg](A457467_1_En_8_Fige_HTML.jpg)inverted B1 by B2, invert the result, and clamp to [0.0;1.0]. Burns in the color of B2 to B1\. The result for the sample images is shown here; the darker B1, the more its color is used. |
| `bitm_blend_ color_dodge` | `BLEND_ COLOR_ DODGE` | For each RGBA value, divides B1 by![A457467_1_En_8_Figf_HTML.jpg](A457467_1_En_8_Figf_HTML.jpg)inverted B2\. The brighter B2, the more it affects the color of the result. No part of B1 will be darkened in the result. |
| `bitm_blend_ darken` | `BLEND_ DARKEN` | For each RGBA value, take the smaller of B1, B2.![A457467_1_En_8_Figg_HTML.jpg](A457467_1_En_8_Figg_HTML.jpg) |
| `bitm_blend_` `difference` | `BLEND_ DIFFERENCE` | For each RGBA value, take the![A457467_1_En_8_Figh_HTML.jpg](A457467_1_En_8_Figh_HTML.jpg)absolute difference &#124; B1 – B2 &#124;. In our example, we will only get `ALPHA` values where B1 has an ALPHA ≠ 1.0, i.e., in its surroundings. With B2’s `ALPHA` not 1.0 everywhere, you get more interesting results. |
| `bitm_blend_ exclusion` | `BLEND_ EXCLUSION` | 每个 RGBA 值的公式为:B1+B2-2 B1 B2 |
| `bitm_blend_ glow` | `BLEND_ GLOW` | For each of the RGBA values, take the square of B2 and divide by the inverse of B1\. The square will emphasize lighter parts of B2, but for darker parts the light parts of B1 gain influence.![A457467_1_En_8_Figi_HTML.jpg](A457467_1_En_8_Figi_HTML.jpg) |
| `bitm_blend_ hard_light` | `BLEND_ HARD_LIGHT` | Same as `BLEND_OVERLAY,` but with B1 and B2 exchanged.![A457467_1_En_8_Figj_HTML.jpg](A457467_1_En_8_Figj_HTML.jpg) |
| `bitm_blend_ hard_mix` | `BLEND_ HARD_MIX` | For each RGBA value, where B1 is darker than B2 is lighter, set 0\. Otherwise, set 1.![A457467_1_En_8_Figk_HTML.jpg](A457467_1_En_8_Figk_HTML.jpg) |
| `bitm_blend_` `lighten` | `BLEND_ LIGHTEN` | For each RGBA channel, take the bigger of B1, B2.![A457467_1_En_8_Figl_HTML.jpg](A457467_1_En_8_Figl_HTML.jpg) |
| `bitm_blend_ linear_burn` | `BLEND_ LINEAR_ BURN` | 同`BLEND_SUBTRACT`。 |
| `bitm_blend_ linear_dodge` | `BLEND_ LINEAR_ DODGE` | 同`BLEND_ADD`。 |
| `bitm_blend_ linear_light` | `BLEND_ LINEAR_ LIGHT` | For each RGBA value, if B1 < 0.5, do a linear burn with 2 ∙ B1 and B2; otherwise, a linear dodge with 2 ∙ (1.0 – B1) and B2.![A457467_1_En_8_Figm_HTML.jpg](A457467_1_En_8_Figm_HTML.jpg) |
| `bitm_blend_` `multiply` | `BLEND_ MULTIPLY` | For each RGBA value, take B1 ∙ B2.![A457467_1_En_8_Fign_HTML.jpg](A457467_1_En_8_Fign_HTML.jpg)Because of the multiplication, where parts of both B1 and B2 are dark, the result will be even darker. |
| `bitm_blend_ negation` | `BLEND_ NEGATION` | 对于每个 RGBA 值，取以下值的倒数:(1.0–B1)-B2 的绝对值 |
| `bitm_blend_ normal` | `BLEND_ NORMAL` | For each RGBA value, mix B2 to B1 according to the `bitm2_opacity` anchor value. Following 0.0, 0.5 and 1.0:![A457467_1_En_8_Figo_HTML.jpg](A457467_1_En_8_Figo_HTML.jpg) |
| `bitm_blend_ overlay` | `BLEND_ OVERLAY` | For each RGBA value, where B2 < 0.5, take twice the multiplied value, 2∙B1∙B2\. Otherwise, take the inverse of twice the inverse multiplied value, 1.0 – 2∙(1.0 – B1)∙(1.0 - B2).![A457467_1_En_8_Figp_HTML.jpg](A457467_1_En_8_Figp_HTML.jpg) |
| `bitm_blend_` `phoenix` | `BLEND_ PHOENIX` | For each RGBA value, take the lower of B1, B2, and add the inverse of the higher of B1, B2.![A457467_1_En_8_Figq_HTML.jpg](A457467_1_En_8_Figq_HTML.jpg) |
| `bitm_blend_ pin_light` | `BLEND_ PIN_LIGHT` | For each RGBA value, if a < 0.5, do a blend darken of 2∙B1 and B2; otherwise, do a blend lighten of 2 ∙ (1.0 – B1) and B2![A457467_1_En_8_Figr_HTML.jpg](A457467_1_En_8_Figr_HTML.jpg) |
| `bitm_blend_ reflect` | `BLEND_ REFLECT` | Same as `BLEND_GLOW`, but with B1 and B2 exchanged. The sample shows some artifacts because of the division.![A457467_1_En_8_Figs_HTML.jpg](A457467_1_En_8_Figs_HTML.jpg) |
| `bitm_blend_ screen` | `BLEND_ SCREEN` | Same as blend multiply, but take the inverses of B1 and B2, and from the result take the inverse again. Where a normal multiply intensifies dark regions in both bitmaps, this mode intensifies light regions in both bitmaps.![A457467_1_En_8_Figt_HTML.jpg](A457467_1_En_8_Figt_HTML.jpg) |
| `bitm_blend_ soft_` `light` | `BLEND_ SOFT_LIGHT` | A softened version of `BLEND_HARD_LIGHT`.![A457467_1_En_8_Figu_HTML.jpg](A457467_1_En_8_Figu_HTML.jpg) |
| `bitm_blend_ subtract` | `BLEND_ SUBTRACT` | Like addition, but lets RGBA values refer to 0.5 as a zero point. You can thus achieve a subtraction if values are below 0.5\. Clamps the result to min. 0.0.![A457467_1_En_8_Figv_HTML.jpg](A457467_1_En_8_Figv_HTML.jpg) |
| `bitm_blend_ vivid_light` | `BLEND_ VIVID_LIGHT` | For each RGBA value, if B1 < 0.5, take a color burn of 2 ∙ B1 and B2; otherwise take a color dodge of 2 ∙ (1.0 – B1) and B2.![A457467_1_En_8_Figw_HTML.jpg](A457467_1_En_8_Figw_HTML.jpg) |

这两个图像都是 png，并以`WHITE`作为指定的背景色。请注意，所有混合滤镜都独立处理红色、绿色、蓝色和 ALPHA 颜色分量，并且它们都是逐个像素地起作用，不会混合不同的像素。

生成的位图将作为纹理发送到图形硬件，作用于顶点颜色全为白色的四边形。

请注意，B1 和 B2 可以使用相同的位图来混合图像本身。

### 发电机

位图生成器用作生成位图的来源，无需加载外部图像文件。路径是位图→生成器，然后见表 [8-4](#Tab4) 到 [8-9](#Tab9) 。

表 8-9。

The subplasma module

<colgroup><col> <col> <col></colgroup> 
| `subplasma` | 产生随机等离子体。与`plasma`模块相比，少了很多人为因素 |
| --- | --- |
| 在…里 | `rand_seed:float` | 更改整数部分，创建另一个形状的子等离子体 |
| `size:enum` | 位图大小，以下之一:8x8、16x16、32x32、64x64、128x128、256x256、512x512 或 1024x1024 |
| `amplitude: enum` | 定义亚质的颗粒。越高越好。可用值为 2、4、8、16、32、64、128、256 和 512 |
| `color:float4` | 亚原生质的颜色 |
| 在外 | `bitmap:bitmap` | 结果位图 |

表 8-8。

The solid module

<colgroup><col> <col> <col></colgroup> 
| `solid` | 为每个像素生成相同颜色的单色位图。您可以将它用于位图着色的过滤器 |
| --- | --- |
| 在…里 | `color:float4` | 颜色 |
| `size:enum` | 位图大小:8x8、16x16、32x32、64x64、128x128、256x256、512x512、1024x1024 或 2048x2048 之一 |
| 在外 | `bitmap:bitmap` | 结果位图 |

表 8-7。

The plasma module

<colgroup><col> <col> <col></colgroup> 
| `plasma` | 产生确定的、非随机的规则等离子体。颜色值通过以下的线性函数计算:sin(x 的线性函数)∙sin(y 的线性函数) |
| --- | --- |
| 在…里 | 设置 |   |
|   | `col_amp: float4` | 外部线性函数的颜色分量乘数 |
| `col_ofs:float4` | 外部线性函数的颜色分量加法 |
| `period: complex` | 包含颜色分量的`float3`锚点，用于`sin()`项中线性函数的乘数(每个 float3 的第三个分量未使用，因为我们只需要 x 和 y 坐标) |
| `ofs:complex` | 包含颜色分量的 float3 锚点，用于在`sin()`项中添加线性函数(每个`float3`的第三个分量未使用，因为我们只需要 x 和 y 坐标) |
| `size:enum` | 位图大小，为以下之一:8x8、16x16、32x32、64x64、128x128、256x256、512x512 或 1024x1024。 |
| 在外 | `bitmap:bitmap` | 结果位图 |

表 8-6。

The perlin_noise module

<colgroup><col> <col> <col></colgroup> 
| `perlin_noise` | 柏林噪波位图 |
| --- | --- |
| 在…里 | `perlin_options` |   |
|   | `rand_seed: float` | 随着整数部分的变化，创建另一个形状的噪声。 |
| `perlin_ strength:float` | 噪音的强度。 |
| `size:enum` | 8×8、16×16、32×32、64×64、128×128、256×256、512×512、1024×1024 或 2048×2048 之一。定义位图的像素大小。 |
| `octave:enum` | 噪音的模糊。越高，越不模糊。值的范围从 1 到 16。 |
| `frequency: enum` | 定义纹理。值的范围从 1 到 8-。 |
| `bitmap_type: enum` | `integer`或`float`之一。未使用。 |
| `blob_settings` |   |
| `enable_blob: enum` | 设置为`yes`或`no`，是否融合成一个 blob。 |
| `arms:float` | 如果要制作星星或花朵，请将值设置为> 0。 |
|   | `attenuation: float` | 控制形状的清晰度。越少越模糊。 |
| `star_flower: float` | 控制中心部分的密度。如果> 0，则使靠近中心的手臂变细(对于花)。 |
| `angle: float` | 使用它来旋转形状(只有当它有手臂时才有意义)。 |
| `color:float4` | 噪波的颜色。 |
| `alpha:enum` | 设置为`yes`或`no`，如果`yes`使用`ALPHA`通道进行密度转换；否则`ALPHA`已经在这里申请了。在后一种情况下，位图将到处都有`ALPHA` = 1.0。 |
| 在外 | `bitmap:bitmap` | 生成的位图。 |

表 8-5。

The concentric_circles module

<colgroup><col> <col> <col> <col></colgroup> 
| `concentric_circles` | 创建同心圆 |
| --- | --- |
| 在…里 | 设置 |   |
|   | `frequency: float` | 控制要生成的圆的密度 |
|   | `attenuation: float` | 控制形状的清晰度。越少，越模糊 |
|   | `color:float4` | 定义颜色 |
|   | `alpha:enum` | 设置为`yes`或`no`。如果是`yes`，使用`ALPHA`通道进行密度过渡；否则`ALPHA`已经在这里申请了。在后一种情况下，位图将到处都有`ALPHA` = 1.0。 |

表 8-4。

The blob module

<colgroup><col> <col> <col></colgroup> 
| `blob` | 生成一个斑点 |
| --- | --- |
| 在…里 | 设置 |   |
| `arms:float` | 如果要制作星星或花朵，请将值设置为> 0。值 0 表示:没有手臂。 |
| `attenuation: float` | 控制形状的清晰度。越少越模糊。 |
| `star_flower: float` | 控制中心部分的密度。如果> 0，则使靠近中心的手臂变细(对于花)。 |
| `angle:float` | 使用它来旋转形状(只有当它有手臂时才有意义)。 |
| `color:float4` | 定义斑点的颜色。 |
| `alpha:enum` | 设置为`yes`或`no`。如果是`yes`，使用`ALPHA`通道进行密度过渡；否则`ALPHA`已经在这里申请了。在后一种情况下，位图各处的`ALPHA` = 1.0。 |
| `size:enum` | 8×8、16×16、32×32、64×64、128×128、256×256、512×512、1024×1024 或 2048×2048 之一。定义位图的像素大小。 |
| 在外 | `bitmap:bitmap` | 生成的位图。 |

### 装载机

从文件中加载位图。路径是位图→加载器。然后参见表 [8-10](#Tab10) 至 [8-12](#Tab12) 。

表 8-12。

The png_bitm_load module

<colgroup><col> <col> <col></colgroup> 
| `png_bitm_load` | 将 PNG 文件作为位图加载。该文件必须在`/home/[USER]/thmad/` `[VERSION]/data/resources`文件夹内。 |
| --- | --- |
| 在…里 | `Filename: resource` | 指向 resources 文件夹中的文件。 |
|   | `reload:enum` | 操作枚举。点击`yes`告诉 ThMAD 重新加载文件。 |
| 在外 | `bitmap:bitmap` | 输出位图 |
| `texture:texture` | 加载后作为纹理发送到图形硬件 |

表 8-11。

The jpeg_bitm_load_alpha module

<colgroup><col> <col> <col></colgroup> 
| `jpeg_bitm_load_alpha` | 加载两个 JPG 文件。第二个定义了`ALPHA`通道。两个文件都必须在`/home/[USER]/thmad/ [VERSION]/data/resources`文件夹中 |
| --- | --- |
| 在…里 | `filename_rgb: resource` | RGB 数据 |
| `filename_ alpha:resource` | `ALPHA`数据；使用灰度值位图指定`ALPHA`值 |
| 在外 | `bitmap:bitmap` | 输出位图 |
| `texture:``text`T2】 | 加载后直接作为纹理发送到图形硬件 |

表 8-10。

The jpeg_bitm_load module

<colgroup><col> <col> <col></colgroup> 
| `jpeg_bitm_load` | 将 JPG 文件作为位图加载。该文件必须在`/home/[USER]/thmad/` `[VERSION]/data/resources`文件夹内 |
| --- | --- |
| 在…里 | `filename: resource` | 指向 resources 文件夹中的文件。 |
| 在外 | `bitmap:bitmap` | 输出位图。 |
| `texture:texture` | 加载后直接将纹理发送到图形硬件。 |

### 修饰语

位图的修改。路径是位图→修改器→添加噪波。参见表 [8-13](#Tab13) 。

表 8-13。

The add_noise module

<colgroup><col> <col> <col></colgroup> 
| `add_noise` | 给位图添加噪波。请注意，这是一个开销很大的操作，因为位图需要经常重新计算 |
| --- | --- |
| 在…里 | `bitmap_in:bitmap` | 输入位图 |
| `time_rate:float` | 应用噪波的时间间隔(毫秒)。 |
| `noise_amount: float` | 加多少噪点:1.0 最大量，0.0 无 |
| 在外 | `bitmap:bitmap` | 输出位图 |

## 仿制品

虚拟对象要么什么都不做，要么传递值而不改变它们。它们用于技术原因或多路复用控制器。例如，模块 A 和 B 需要一个浮动输入，并且您希望相应的锚只受到手动更改，即使用 GUI，此外还要同步。它们应该总是接收相同的控制器值。没有假人，你得一个接一个地换。为了避免这种单调的工作，你可以用一个假人，把它连接到 A 和 B 上；见图 [8-1](#Fig1) 。

![A457467_1_En_8_Fig1_HTML.jpg](A457467_1_En_8_Fig1_HTML.jpg)

图 8-1。

Using dummies to simplify manual controlling On the left side of the figure, you need to adjust two controllers if you want to synchronize the input. Using the dummy shown on the right allows you to do it in one step.

虚拟模型位于模块层次结构的不同位置——`Dummies`模块部分为来自不同模块部分的虚拟模型提供别名；见表 [8-14](#Tab14) 。

表 8-14。

Dummy module aliases

<colgroup><col> <col> <col></colgroup> 
| 名字 | 描述 | 是的别名 |
| --- | --- | --- |
| `float_dummy` | 多路复用浮点值 | 数学→假人→浮点 _ 假人 |
| `float3_dummy` | 复用 float3 向量 | 数学→假人→浮点 3 _ 假人 |
| `float4_dummy` | 复用一个 float4 向量，主要是颜色值 | 数学→假人→浮点 4 _ 假人 |
| `quaternion_dummy` | 复用一个四元数 | 数学→假人→四元数 _ 假人 |
| `mesh_dummy` | 多路复用器 a 网格输入 | 网格→假人→网格 _ 假人 |
| `texture_dummy` | 多路复用器纹理输入 | 纹理→假人→纹理 _ 假人 |

## 数学模块

数学模块对于控制其他模块很重要。它们不产生任何图形输出。

### 累加器

累加器累加输入值，也就是说，它们保存一个内部值，该值通过提供的输入值每帧更新一次。每个的初始值是运算的中性元素，对于加法为 0.0，或者是具有 0.0 值元素的数组，对于四元数乘法(0.0；0.0;0.0;1.0).

如果使用了一个`reset:enum`输入锚，这意味着将其值设置为`ok`会将累加器重置为初始状态。该锚点将在下一帧自动停用，因此如果您想重复该动作，您必须再次将其设置为`ok`。

路径是数学→算术→累加器，然后见表 [8-15](#Tab15) 。

表 8-15。

Accumulator modules

<colgroup><col> <col> <col> <col></colgroup> 
| 名字 | 类型 | 参数名称 | 描述 |
| --- | --- | --- | --- |
| `float_ accumulator` | 浮动→浮动 | 浮点输入→结果浮点 | 每帧将输入值添加到累加器中。 |
| `float_``accumulator_`T2】 | 浮动→浮动 | 浮点 _ 输入，极限 _ 下限，极限 _ 上限→结果 _ 浮点 | 每帧将输入值添加到累加器中。如果累加器值超过其中一个限值，它将被箝位到相应的限值。 |
| `float3_ accumulator` | 浮动 3 →浮动 3 | 浮点 3 _ 输入→结果 _ 浮点 3 | 每帧将输入 float3 值按分量添加到累加器。 |
| `float4_ accumulator` | 浮动 4 →浮动 4 | 浮点 4 _ 输入→结果 _ 浮点 4 | 每帧将输入 float4 值按分量添加到累加器。 |
| `quat_ rotation_ accum_` `2d` | 浮点 x 浮点→四元数 | 参数 x，参数 y →结果 quat | 在 ThMAD 中，四元数由(x，y，z；w)，这意味着它的特殊实数部分位于数组的末尾。`param_x`和`param_y`构建乘数四元数(0，x，0；1) resp。(0，0，y；1)对于每一帧要应用的第一和第二乘法或旋转:accum = accum ∙ (0，x，0；1) accum = accum ∙ (0，0，y；1)由于四元数的特殊性质，这种形式的乘法可以描述任何旋转。 |

### 算术

这一类是关于基本的算术运算。

#### 一元运算符

所有类型都相同的 in → out 运算。

在布尔运算符的情况下，输入和输出是映射的浮点数。[-0.5 内的一个输入；0.5]表示`FALSE`，输入小于-0.5 或大于+0.5 表示`TRUE`，输出 1.0 表示`TRUE`，输出 0.0 表示`FALSE`。路径是数学→算术→一元。然后表 [8-16](#Tab16) 给出一个概述。

表 8-16。

Unary operators

<colgroup><col> <col> <col> <col></colgroup> 
| 名字 | 类型 | 参数名称 | 描述 |
| --- | --- | --- | --- |
| `cos` | `float` | 浮点输入→结果浮点 | 余弦函数 out = cos(in) |
| `sin` | `float` | 浮点输入→结果浮点 | 正弦函数 out = sin(in) |
| `tan` | `float` | 浮点输入→结果浮点 | 正切函数 out = tan(in) |
| `acos` | `float` | 浮点输入→结果浮点 | 反余弦函数 out = arccos(in) |
| `atan` | `float` | 浮点输入→结果浮点 | 反正切函数 out = arctan(in) |
| `abs` | `float` | 浮点输入→结果浮点 | 绝对值，去掉符号 out = abs(in) |
| `not` | `float` | a →结果 _ 浮点 | 布尔 NOT out = not(in) |
| `derivative` | `float` | 浮点输入→结果浮点 | 导数函数 out = in - last_in 由于模块将每 1/60 秒调用一次，这意味着这是时间的近似导数，1/60d/dt |
| `ifinside` | `float` | float_in→ result_float 参数:低，高 val_inside，val_outside | 检查输入是否在范围[low；高]，如果是，则输出`val_inside`。否则输出`val_outside`。 |
| `vector_ normalize` | `float3` | param1 →结果 _ 浮点 3 | 规格化 float3 向量，即在保持方向不变的情况下将其长度更改为 1.0:v→v/&#124; &#124; v &#124; &#124; |

#### 二元运算符

所有类型都相同的操作 in1 ○ in2 → out。路径是数学→算术→二进制→ * → *。

表 [8-17](#Tab17) 给出列表；注意，在布尔值的情况下，输入和输出是映射的浮点型:在[-0.5；0.5]表示`FALSE`，输入小于-0.5 或大于+0.5 表示`TRUE`，输出 1.0 表示`TRUE`，输出 0.0 表示`FALSE`。

表 8-17。

Binary operators

<colgroup><col> <col> <col> <col></colgroup> 
| 名字 | 类型 | 参数名称 | 描述 |
| --- | --- | --- | --- |
| `mod` | `float` | param1 参数 2 →模式 | 除模 out = in1 - int(in1 / in2) ∙ in2 其中 int()去除小数部分 |
| `add` | `float` | param1 参数 2 →总计 | 加法 out = in1 + in2 |
| `sub` | `float` | param1 param2 → diff | 减法 out = in1 - in2 |
| `mult` | `float` | param1 参数 2 → mult | 乘法输出= in1 ∙ in2 |
| `div` | `float` | param1 参数 2 → div | 除法 out = in1 / in2 |
| `max` | `float` | param1 参数 2 →最大值 | 最大 out = in1 > in2？输入 1:否则:输入 2 |
| `min` | `float` | param1 参数 2 → min | 最小 out = in1 < in2？输入 1:否则:输入 2 |
| `pow` | `float` | param1 参数 2 → pow | 电源输出= 1 ^输入 2 |
| `round` | `float` | param1 参数 2 →圆形 | rounded out = round0(in1/in2)∙in2 其中 round 0()给出最接近的整数(正数向上一半，负数向下一半)示例:in1 = 25.6382，in2 = 100 → 25.64 示例:in1 = 25.635，in2 = 100 → 25.64 示例:in1 = -25.635，in2 = 100 → -25.64 |
| `floor` | `float` | param1 参数 2 →楼板 | 给出调整后的 floor out = floor0( in1 / in2 ) ∙ in2，其中 floor0()给出下一个较小的整数示例:in1 = 25.6382，in2 = 100 → 25.63 |
| `ceil` | `float` | 参数 1 参数 2 → ceil | 给出缩放后的 ceil out = ceil0( in1 / in2 ) ∙ in2，其中 ceil0()给出下一个较大的整数示例:in1 = 25.6312，in2 = 100 → 25.64 |
| `and` | `float` `(boolean)` | 参数 1 参数 2 →和 | 布尔 AND out = in1 && in2 0，0 → 01，0 → 00，1 → 0 1，1 → 1 |
| `or` | `float` `(boolean)` | param1 参数 2 →或 | 布尔 OR out = in1 &#124;&#124; in2 0，0 → 01，0 → 10，1 → 1 1，1 → 1 |
| `nand` | `float` `(boolean)` | param1 param2 → nand | 布尔 NAND out = not(in1 && in2) 0，0 → 11，0 → 10，1 → 1 1，1 → 0 |
| `xor` | `float` `(boolean)` | param1 参数 2 → xor | 布尔 XOR out =(in1 &#124; &#124; in2)& & not(in1 & & in2)0，0 → 01，0 → 10，1 → 1 1，1 → 1 |
| `nor` | `float (boolean)` | param1 参数 2 → nor | 布尔 NOR out = not(in1 &#124;&#124; in2) 0，0 → 11，0 → 00，1 → 0 1，1 → 0 |
| `float4_ add` | `float4` | 参数 1 参数 2 →结果 | 两个 float4 值的分量相加 out<sub>I</sub>= in1<sub>I</sub>+in2<sub>I</sub> |
| `quat_mul` | `quaternion` | 参数 1 参数 2 →结果 | 四元数乘法 out = in1⇟；如果把它看作是空间中的一次旋转，那么乘法就代表了两次连续的旋转。 |
| `vector_ add` | `float3` | 参数 1 参数 2 →结果 _ 浮点 3 | 向量加法 out<sub>I</sub>= in1<sub>I</sub>+in2<sub>I</sub> |
| `vector_ cross_ product` | `float3` | 参数 1 参数 2 →结果 _ 浮点 3 | 向量叉积 out = in1 x in2 |
| `vector_ from_ points` | `float3` | 参数 1 参数 2 →结果 _ 浮点 3 | 从 A 点到 b 点的向量，本质上是它们的位置向量的减法 out<sub>I</sub>= in2<sub>I</sub>-in1<sub>I</sub> |

#### 三元运算符

所有类型都相同的操作 in1 ○ in2 ○ in3 → out。路径是数学→算术→三进制→浮点→乘法 _ 加法。只有一个，如表 [8-18](#Tab18) 所示。

表 8-18。

Ternary Operators

<colgroup><col> <col> <col> <col></colgroup> 
| 名字 | 类型 | 参数名称 | 描述 |
| --- | --- | --- | --- |
| `mult_` `add` | `float` | float _ in first _ mult then _ add→result _ float | 先乘后加=(float _ in∙first _ mult)+then _ add |

#### 功能

函数具有一种或多种类型的一个或多个输入值，以及可能不同类型的一个或多个输出值。路径是数学→算术→函数。见表 [8-19](#Tab19) 至 [8-26](#Tab26) 。

Table 8-26.

<colgroup><col> <col> <col></colgroup> 
| `float3_rotate_by_quat` | 让点向量以四元数定义的旋转绕中心点旋转 |
| --- | --- |
| 在…里 | `point:float3` | 我们要旋转的(位置)向量 |
| `center:float3` | 围绕这个中心点旋转 |
| 在外 | `result_float3: float3` | 旋转的结果 |

Table 8-25.

<colgroup><col> <col> <col></colgroup> 
| `vector_mul_float` | 将向量乘以标量 out<sub>I</sub>= in1<sub>I</sub>∏in2 |
| --- | --- |
| 在…里 | `param1:float3` | 要缩放的向量 |
| `param2:float` | 标量乘数 |
| 在外 | `result_float3: float3` | 乘法运算的结果 |

Table 8-24.

<colgroup><col> <col> <col></colgroup> 
| `vector_dot_product` | 矢量点积 out =σ<sub>I</sub>in1<sub>I</sub>∙in2<sub>I</sub> |
| --- | --- |
| 在…里 | `param1:float3` | 第一向量 |
| `param2:float3` | 第二向量 |
| 在外 | `result_float: float` | 点积 |

Table 8-23.

<colgroup><col> <col> <col></colgroup> 
| `vector_add_float` | 给每个向量分量加一个浮点数 out <sub>i</sub> = in1 <sub>i</sub> + in2 |
| --- | --- |
| 在…里 | `param1:float3` | 矢量 |
|   | `param2:float` | 添加到每个组件的单个标量 |
| 在外 | `result_float3:float3` | 结果向量 |

Table 8-22.

<colgroup><col> <col> <col></colgroup> 
| `axis_angle_to_quaternion` | 将绕轴旋转一个角度转换为四元数表示 |
| --- | --- |
| 在…里 | `axis:float3` | 轴心 |
| `angle:float` | 围绕轴的旋转角度 |
| 在外 | `Result: quaternion` | 表示相同操作的四元数 |

Table 8-21.

<colgroup><col> <col> <col></colgroup> 
| `quaternion_to_axis_angle` | 将表示四元数的旋转转换为描述同一旋转的轴和角度值 |
| --- | --- |
| 在…里 | `source_ quaternion: quaternion` | 输入四元数 |
| 在外 | `result_axis: float3` | 输出轴 |
| `result_``angle`T2】 | 围绕输出轴的旋转角度 |

Table 8-20.

<colgroup><col> <col> <col></colgroup> 
| `float4_mul_float` | 将一个`float4`的所有分量与另一个给定的浮点数相乘 |
| --- | --- |
| 在…里 | `param1:float4` | `float4`值 |
|   | `param2:float` | `float`被乘数 |
| 在外 | `result_float4: float4` | 新的`float4`值:(`param1` <sub>i</sub> ∙ `param2`) |

Table 8-19.

<colgroup><col> <col> <col></colgroup> 
| `compare` | 比较两个值，如果检查相等，则比较模糊 |
| --- | --- |
| 在…里 | `float_a:float` | 第一次浮动。 |
| `float_b:float` | 第二次浮动。 |
| `operator:enum` | `equals, larger_than`或`smaller_than`之一。 |
| 在外 | `result:float` | 对于`equals`:如果 abs(a-b) < 0.00001 将返回 1.0，否则为`larger_than`0.0:如果 a > b 将返回 1.0，否则为`smaller_than:`0.0 如果 a < b 将返回 1.0，否则为 0.0 |

### 排列

数组相关函数。路径是数学→数组。见表 [8-27](#Tab27) 至 [8-29](#Tab29) 。

Table 8-29.

<colgroup><col> <col> <col></colgroup> 
| `float_array_average` | 计算给定数组的平均值 |
| --- | --- |
| 在…里 | `float_in: float_array` | 该阵列 |
| `start:float` | 数组内部的开始索引 |
| `end:float` | 数组内的结束索引 |
| 在外 | `result_float: float` | 平均值。如果 start 和/或 en 索引是分数，则在边缘处，将考虑相邻成员的加权值 |

Table 8-28.

<colgroup><col> <col> <col></colgroup> 
| `float_array_pick` | 从 float_array 中选取一个值 |
| --- | --- |
| 在…里 | `float_in: float_array` | 要从中获取值的数组 |
| `which:float` | 索引。如果索引超出界限，将再次返回最后一个返回的值。 |
| 在外 | `result_float: float` | 选取的值。 |

Table 8-27.

<colgroup><col> <col> <col></colgroup> 
| `float_array_memory_ buffer` | 可变大小的缓冲区。根据模式添加输入值 |
| --- | --- |
| 在…里 | `float_in:float` | 下一帧要添加的下一个值。 |
| `size:enum` | 缓冲区的大小。2、4、8、16、32、64、128、256、512、1024、2048 或 4096 中的一个。 |
| `mode:enum` | 如果`rewind`，从左侧数组边界开始添加，然后每一步增加一个位置。超过最大值时，再次从左边界开始。如果`shift`，开始左加，当超过最大值时，将整个数组左移，从此只在右边界加。如果`insert_right`，总是左移并且总是在右边的数组边界相加。 |
| `ema:float` | 可用于平滑输入值。0.0 表示不平滑，0.9 表示正常，0.99 表示缓慢平滑。您不希望该值≥ 1.0。 |
| 在外 | `result_array: float_array` | 当前缓冲区。 |
| `cur_index:float` | 将被添加的下一个浮点数的索引。 |

### 颜色

颜色是一个四维值，或称`float4`，包括以下内容:

*   `RED`
*   `GREEN`
*   `BLUE`
*   `ALPHA`、不透明度或反透明度

所有值都在[0.0；1.0].

路径是数学→颜色。对颜色特别有用的功能如表 [8-30](#Tab30) 和 [8-31](#Tab31) 所示。

Table 8-31.

<colgroup><col> <col> <col></colgroup> 
| 转换器→ f4_hsl_to_f4_rgb | 将 HSL+A 颜色从 HSL 颜色空间转换为 RGBA 浮点 4 |
| --- | --- |
| 在…里 | `hsl:float4` | 色调、饱和度、亮度、Alpha |
| 在外 | `result_float4: float4` | RGBA 的颜色 |

Table 8-30.

<colgroup><col> <col> <col></colgroup> 
| 转换器→ 4f_hsv_to_f4_rgb | 将 HSV+A 颜色从 HSV 空间转换为 RGBA 浮点 4 |
| --- | --- |
| 在…里 | `h:float` | 色彩 |
| `s:float` | 浸透 |
| `v:float` | 价值 |
| `a:float` | 希腊字母的第一个字母 |
| 在外 | `result_float4: float4` | RGBA 的颜色 |

### 转换器

从一种数据类型到另一种数据类型的各种转换器。颜色类型的转换器不在这里；在本章的后面找到它们。路径是数学→转换器。见表 [8-32](#Tab32) 至 [8-39](#Tab39) 。

Table 8-39.

<colgroup><col> <col> <col></colgroup> 
| `matrix_to_quaternion` | 将合适的矩阵转换为相应的四元数 |
| --- | --- |
| 在…里 | `source_matrix: matrix` | 4x4 矩阵 |
| 在外 | `result_quat: quaternion` | 输出四元数 |

Table 8-38.

<colgroup><col> <col> <col></colgroup> 
| `4float_to_quaternion` | 给定四元数的构成元素，构造四元数 |
| --- | --- |
| 在…里 | `param1:float` | I 值= ThMAD 中的 x |
| `param2:float` | j 值= ThMAD 中的 y |
| `param3:float` | k 值= z(单位:ThMAD) |
| `param4:float` | ThMAD 中的实部= w |
| 在外 | `result_quat: quaternion` | 输出四元数 |

Table 8-37.

<colgroup><col> <col> <col></colgroup> 
| `quaternion_to_4float` | 膨胀四元数 |
| --- | --- |
| 在…里 | `in_quat: quaternion` | 输入四元数 |
| 在外 | `param1:float` | I 值= ThMAD 中的 x |
| `param2:float` | j 值= ThMAD 中的 y |
| `param3:float` | k 值= z(单位:ThMAD) |
| `param4:float` | ThMAD 中的实部= w |

Table 8-36.

<colgroup><col> <col> <col></colgroup> 
| `float4_to_4float` | 增加一个`float4`值 |
| --- | --- |
| 在…里 | `in_float4:float4` | 输入`float4` |
| 在外 | `param1:float` | 第一次浮动 |
| `param2:float` | 第二次浮动 |
| `param3:float` | 第三次浮动 |
| `param4:float` | 第四次浮动 |

Table 8-35.

<colgroup><col> <col> <col></colgroup> 
| `float3_to_float` | 增加一个`float3`值 |
| --- | --- |
| 在…里 | `float3_in:float3` | 输入`float3` |
| 在外 | `a:float` | 第一次浮动 |
|   | `b:float` | 第二次浮动 |
|   | `c:float` | 第三次浮动 |

Table 8-34.

<colgroup><col> <col> <col></colgroup> 
| `4float_to_float4` | 给定其组成部分，构造一个 float4 |
| --- | --- |
| 在…里 | `floata:float` | 第一次浮动 |
| `floatb:float` | 第二次浮动 |
| `floatc:float` | 第三次浮动 |
| `floatd:float` | 第四次浮动 |
| 在外 | `result_float4: float4` | `float4`输出(`floata; floatb; floatc; floatd`) |

Table 8-33.

<colgroup><col> <col> <col></colgroup> 
| `3float_to_float3` | 给定其成分，构造一个`float3` |
| --- | --- |
| 在…里 | `floata:float` | 第一次浮动 |
| `floatb:float` | 第二次浮动 |
| `floatc:float` | 第三次浮动 |
| 在外 | `result_float3: float3` | `float3 output (floata; floatb; floatc)` |

Table 8-32.

<colgroup><col> <col> <col></colgroup> 
| 浮点到浮点 3 | 将单个输入浮点多路复用到浮点 3 的所有组件 |
| --- | --- |
| 在…里 | `param1:float` | 输入 |
| 在外 | `result_float3: float3` | 答`float3 (param1;param1;param1)` |

### 仿制品

由于模块能够为每个锚点提供不止一个输出数据流，因此以一个控制器同时控制几个组件的方式多路传输值，为所有组件提供相同的值可能会有所帮助。这就是假人的用途。路径是数学→假人。见表 [8-40](#Tab40) 至 [8-43](#Tab43) 。

Table 8-43.

<colgroup><col> <col> <col></colgroup> 
| `quaternion_dummy` | 多路复用器单输入四元数 |
| --- | --- |
| 在…里 | `quat_in: quaternion` | 输入 |
| 在外 | `out_quat: quaternion` | 将输入复制到输出。这里可以连接其他几个模块。 |

Table 8-42.

<colgroup><col> <col> <col></colgroup> 
| `float4_dummy` | 多路复用单输入浮点 4 |
| --- | --- |
| 在…里 | `float4_in:float4` | 输入 |
| 在外 | `out_float4: float4` | 将输入复制到输出。这里可以连接其他几个模块。 |

Table 8-41.

<colgroup><col> <col> <col></colgroup> 
| `float3_dummy` | 多路复用单输入浮点 3 |
| --- | --- |
| 在…里 | `float3_in:float3` | 输入 |
| 在外 | `out_float3: float3` | 将输入复制到输出。其他几个模块可以连接到。 |

Table 8-40.

<colgroup><col> <col> <col></colgroup> 
| `float_dummy` | 多路复用器单输入浮点 |
| --- | --- |
| 在…里 | `float_in:float` | 输入 |
| 在外 | `result_float: float` | 将输入复制到输出。其他几个模块可以连接到。 |

### 插入文字

不同类型值之间的插值。路径是数学→插值。见表 [8-44](#Tab44) 至 [8-49](#Tab49) 。

Table 8-49.

<colgroup><col> <col> <col></colgroup> 
| `quat_slerp_3p` | 根据 pos 参数是小于还是大于 0.5，在三个四元数之间进行线性插值，从第一个到第二个或从第二个到第三个 |
| --- | --- |
| 在…里 | `quat_a: quaternion` | 第一个值 |
| `quat_b: quaternion` | 第二个值 |
| `quat_c: quaternion` | 第三个价值 |
| `pos:float` | 位置，范围是[0.0；1.0] |
| 在外 | `result_quat: quaternion` | `pos < 0.5: quat_a + 2 ∙ pos ∙ (quat_b - quat_a)`插值:`pos ≥ 0.5: quat_b + 2 ∙ (pos-0.5) ∙ (quat_c - quat_b)` |

Table 8-48.

<colgroup><col> <col> <col></colgroup> 
| `quat_slerp_2p` | 在两个四元数之间线性插值。你用它来平滑旋转 |
| --- | --- |
| 在…里 | `quat_a: quaternion` | 第一个值 |
| `quat_b: quaternion` | 第二个值 |
| `pos:float` | 位置，范围是[0.0；1.0] |
| 在外 | `result_quat: quaternion` | `quat_a + pos ∙ (quat_b - quat_a)`插值 |

Table 8-47.

<colgroup><col> <col> <col></colgroup> 
| `float_smoothe` r | 从内部存储的值逐渐变化到给定的最终值。假设内部值为 5.0，最终值为 1.0，然后以递减的步长将内部值从 5.0 平滑地更改为 1.0 |
| --- | --- |
| 在…里 | `value_in:float` | 要更改的结束值 |
| `speed:float` | 速度 |
| 在外 | `result_float: float` | 当前发展的内在价值 |

Table 8-46.

<colgroup><col> <col> <col></colgroup> 
| `float4_interpolate` | 在两个锚点值之间线性插值 |
| --- | --- |
| 在…里 | `float4_in_a: float4` | 第一个值 |
|   | `float4_in_b: float4` | 第二个值 |
|   | `pos:float` | 位置，范围是[0.0；1.0] |
| 在外 | `result_float4: float4` | `float3_in_a + pos ∙ (float3_in_b - float3_in_a)`插值 |

Table 8-45.

<colgroup><col> <col> <col></colgroup> 
| `float3_interpolate` | 在两个锚点值之间线性插值。 |
| --- | --- |
| 在…里 | `float3_in_a: float3` | 第一个值 |
| `float3_in_b: float3` | 第二个值 |
| `pos:float` | 位置，范围是[0.0；1.0] |
| 在外 | `result_float3: float3` | `float3_in_a + pos ∙ (float3_in_b - float3_in_a)`插值 |

Table 8-44.

<colgroup><col> <col> <col></colgroup> 
| `float_interpolate` | 在两个锚点值之间线性插值 |
| --- | --- |
| 在…里 | `float_in_a:float` | 第一个值 |
| `float_in_b:float` | 第二个值 |
| `pos:float` | 位置，范围是[0.0；1.0] |
| 在外 | `result_float: float` | `float_in_a + pos ∙ (float_in_b - float_in_a)`插值 |

### 限制器

浮点值的限制器。路径是数学→限制器。参见表 [8-50](#Tab50) 和 [8-51](#Tab51) 。

Table 8-51.

<colgroup><col> <col> <col></colgroup> 
| `float_clamp` | 将值限制在一个范围内 |
| --- | --- |
| 在…里 | `value:float` | 输入浮动 |
| `low:float` | 下限 |
| `high:float` | 上限 |
| 在外 | `result_float: float` | 箝位值:低≤值≤最大值→值值< low → low value >高→高 |

Table 8-50.

<colgroup><col> <col> <col></colgroup> 
| `float_limiter` | 限制最大值或最小值 |
| --- | --- |
| 在…里 | `value_in:float` | 输入浮动 |
| `limit_value: float` | 在哪里设置限制 |
| `type:enum` | 最大值、最小值之一。是设置上限还是下限。 |
| 在外 | `result_float: float` | 极限值:类型=最大值→结果=最小值(值，极限值)类型=最小值→结果=最大值(值，极限值) |

### 振荡器

给定某个频率 f，振荡器产生周期性重复出现的浮点值。更正式地说，function(t+n 1/f)= function(t)，n = 0，+/- 1，+/- 2，…

#### 浮点序列器

`float_sequencer`允许从给定的序列中重复产生浮点数。路径是数学→振荡器→浮点 _ 序列器。

使用图形`float_sequence`控制器从艺术家 GUI 内部定义序列。根据所选择的类型，这些值无条件重复或被触发；见表 [8-52](#Tab52) 。

表 8-52。

Sequencer types

<colgroup><col> <col></colgroup> 
| `Type` | 描述 |
| --- | --- |
| `oscillating` | 无条件无休止地重复。 |
| `trigger` | 仅在触发器从:trigger < 0 → trigger > 0 开始变化时启动并运行一次。在序列结束时，发出最后一个值时停止。当相同的触发器 trigger < 0 → trigger > 0 再次触发时再次启动。 |
| `trigger_pingpong` | 与 trigger 相同，但是当 trigger 一次又一次地被触发时，交替地以正向和反向顺序运行序列。 |
| `trigger_` `sync` | 与 trigger_pingpong 相同，但当触发 trigger < 0 → trigger > 0 时运行正向序列，当 trigger > 0 → trigger < 0 时运行反向序列 |

锚如表 [8-53](#Tab53) 所示。

Table 8-53.

<colgroup><col> <col> <col></colgroup> 
| `float_sequencer` | 浮点定序器 |
| --- | --- |
| 在…里 | `float_sequence: sequence` | 浮动序列。 |
|   | `length:float` | 一个序列运行所需的秒数。 |
| `options:complex` |   |
| `behavior: enum` | 振荡器行为，`oscillating, trigger`、`trigger_pingpong`、`trigger_sync`之一。 |
| `time_source: enum` | 时间(隐藏输入参数)源。以下之一:`operating_system`:将使用操作系统的定时器—`sequence`:将使用时序定时器，即可以忽略时序间隙 |
| `trigger:float` | 触发值。未用于行为=振荡。 |
| `drive_type: enum` | 时间(隐藏输入参数)模式。其中之一:`time_internal_relative`:传递自引擎启动后渲染工作所经过的时间。`external`:使用`drive`参数。 |
| `drive:float` | 当`external`用作`drive_type`时的时间参数。所以你可以用你自己的时间观念。 |
| `Out` | `float:float` | 振荡器值，序列之一 |

#### 内部 _ 范围

路径是数学→振荡器→ inside_range 见表 [8-54](#Tab54) 。

Table 8-54.

<colgroup><col> <col> <col></colgroup> 
| `inside_range` | 指出一个数字是否在某个范围内 |
| --- | --- |
| 在…里 | `sound_in:float` | 输入浮动 |
| `range_low:float` | 下限 |
| `range_high:float` | 上限 |
| `randomness: float` | 指定`random_beat`锚点的随机性。0 表示永不开火，100 表示永远开火。 |
| 在外 | `every_beat:float` | 一旦进入范围，发射一帧脉冲`1.0` |
| `random_beat: float` | 与`every_beat`相同，但只以一定的概率开火 |
| `in_range:float` | 1.0 当我们在范围内时。否则 0.0。 |

这不是严格意义上的振荡器，而是输入数据的聚合器。由于输入数据显示周期性成分，例如音乐，对于连接到其输出的成分来说，它看起来像振荡器，因此它位于振荡器部分。

这个伪振荡器对于声音节拍检测是有用的。它会在某种程度上消除不重要的副作用。更详细地说，它的作用如下:给定数字 a <sub>1</sub> ，a <sub>2</sub> ，a <sub>3</sub> ，a <sub>4</sub> ，…和一个范围[r <sub>1</sub> ，r <sub>2</sub> ]的输入，模块的`in_range`输出锚对于该范围内的所有数字都将是 1.0:a<sub>I</sub>8712【r<sub>1</sub>例如，参见图 [8-2](#Fig2) 。

![A457467_1_En_8_Fig2_HTML.jpg](A457467_1_En_8_Fig2_HTML.jpg)

图 8-2。

In-range pseudo-oscillator, in-range output The white line denotes the input signal, green is the range, and the violet line is the `in_range` output.

此外，每当`in_range`输出从 0.0 变为 1.0 时，输出锚`every_beat`触发单个脉冲。作为后者的变体，当`in_range`输出从 0.0 变为 1.0 时，输出锚`random_beat`将随机发射单脉冲。“随机性”输入参数描述了速率:仅当 0 到 100 之间的某个随机数位于[0；随机性]，那个脉冲就会被激发。所以这种随机脉冲的概率将是“随机性”的百分之一。图 [8-3](#Fig3) 中显示了一个`every_beat`输出的例子。

![A457467_1_En_8_Fig3_HTML.jpg](A457467_1_En_8_Fig3_HTML.jpg)

图 8-3。

In-range pseudo-oscillator, beat output The white line denotes the input signal, green is the range, and the violet line is the `every_beat` output.

#### 振荡器

这取决于类型:噪声、正弦、saw、方形、三角形或二次振荡器。路径是数学→振荡器→振荡器。

详细来说，如果`freq`是频率 f，`amp`是幅度，`ofs`是偏移量；见表 [8-55](#Tab55) 。

表 8-55。

The oscillator module’s types

<colgroup><col> <col> <col></colgroup> 
| 名字 | 类型 | 描述 |
| --- | --- | --- |
| 噪音 | 噪音 | 将从内部创建一个随机值[-1；+1] ∙ amp + ofs 每频率秒 |
| --- | --- | --- |
| 犯罪 | 正弦 | For f = 1:![A457467_1_En_8_Figx_HTML.jpg](A457467_1_En_8_Figx_HTML.jpg)`ofs` will add to the values. NOTE: this is not mathematically sin(t), but sin(t ∙2π), so we have a full cycle each t → t + 1 |
| 看见 | 看见 | For f = 1:![A457467_1_En_8_Figy_HTML.jpg](A457467_1_En_8_Figy_HTML.jpg)`ofs` will add to the values |
| 平方 | 平方 | For f = 1:![A457467_1_En_8_Figz_HTML.jpg](A457467_1_En_8_Figz_HTML.jpg)`ofs` will add to the values |
| 三角 | 三角 | For f = 1:![A457467_1_En_8_Figaa_HTML.jpg](A457467_1_En_8_Figaa_HTML.jpg)`ofs` will add to the values |
| 二次的 | 半抛物线重复出现 | For f = 1:![A457467_1_En_8_Figab_HTML.jpg](A457467_1_En_8_Figab_HTML.jpg)`ofs` will add to the values |

此外，参数`phase`将添加到时间中，这意味着水平移动曲线。这不经常使用，保留默认值 0。如果不需要，就不必关心它。所有参数见表 [8-56](#Tab56) 。

Table 8-56.

<colgroup><col> <col> <col> <col></colgroup> 
| 振荡器 | 振荡器 |
| --- | --- |
| 在…里 | `osc:complex` |   |
|   | `osc_type: enum` | 振荡器类型；`noise, sin, saw, square, triangle`或`quadratic`之一。 |
|   | `freq:float` | 频率单位为 1/s |
|   | `amp:float` | 振幅；振荡器将在[-amp；+amp] + ofs |
|   | `ofs:float` | 偏移；振荡器将在[-amp；+amp] + ofs |
|   | `phase.float` | 向时间参数添加一个值 |
| `options:complex` |   |
|   | `time_source: enum` | 时间源(隐藏的输入参数)。以下之一:`operating_system`:将使用操作系统的定时器—`sequence`:将使用时序定时器，即可以减去时序间隙 |
|   | `drive_type: enum` | 时间模式(隐藏输入参数)。其中之一:`time_internal_absolute`:自引擎启动后经过的绝对时间—`time_internal_relative`:自引擎启动后经过的渲染工作时间。T2:使用参数 T3。 |
|   | `drive:float` | 当`external`用作`drive_type`时的时间参数。所以你可以有自己的时间观念。 |
| 在外 | `float:float` | 振荡器值，总是在[-amp；+amp] + ofs |

#### 脉冲振荡器

重复提供形状和长度可调的脉冲。请注意，只有当触发器被激活时，它才会开始产生输出。路径是数学→振荡器→脉冲振荡器。可能的形状如表 [8-57](#Tab57) 所示。

表 8-57。

Pulse types

<colgroup><col> <col></colgroup> 
| 三角 | 

![A457467_1_En_8_Figac_HTML.jpg](A457467_1_En_8_Figac_HTML.jpg)

 |
| --- | --- |
| 平方 | ![A457467_1_En_8_Figad_HTML.jpg](A457467_1_En_8_Figad_HTML.jpg) |
| 余弦 | ![A457467_1_En_8_Figae_HTML.jpg](A457467_1_En_8_Figae_HTML.jpg) |
| 高斯 | ![A457467_1_En_8_Figaf_HTML.jpg](A457467_1_En_8_Figaf_HTML.jpg) |

参数见表 [8-58](#Tab58) 。

![A457467_1_En_8_Fig4_HTML.jpg](A457467_1_En_8_Fig4_HTML.jpg)

图 8-4。

Pulse oscillator of type “triangle” with enveloped input signal Table 8-58.

<colgroup><col> <col> <col> <col></colgroup> 
| 脉冲振荡器 |   |
| --- | --- |
| 在…里 | `in_signal:float` | 默认值为 1.0。您可以使用该值让脉冲包络输入信号，参见图 [8-4](#Fig4) 。 |
| `trigger:float` | 默认为 0.0。脉冲振荡器将仅在触发器> 0 时运行。 |
| `osc:complex` |   |
|   | `freq:float` | 脉冲频率，单位为 1/秒。 |
|   | `pulse_type: enum` | 脉冲类型。`triangle, square, cosine`或`gauss`之一。 |
|   | `pulse_width: float` | 以秒为单位的脉冲宽度。对于三角形、正方形和余弦形，宽度是明显的。对于高斯型，宽度为-3σ到 3σ(在你喜欢的搜索引擎中搜索“正态分布”)。 |
|   | `time_source: enum` | 时间(隐藏输入参数)源。以下之一:`operating_system`:将使用操作系统的定时器—`sequence`:将使用时序定时器，即可以减去时序间隙 |
| 在外 | `result1float` | 振荡器值，总是在[0；in_signal] |

## 网状物

网格是定义 3D 对象的表面或面的点的集合。

### 仿制品

虚拟对象只是将它们的网格输入转发到输出。如果您需要一个网格来与宏内部进行通信，并且您有几个消费者，这将非常有用。路径是网格→假人→网格 _ 假人。参见表 [8-59](#Tab59) 。

Table 8-59.

<colgroup><col> <col> <col></colgroup> 
| `mesh_dummy` | 只需将其网格输入传递给输出 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| 在外 | `mesh_out:mesh` | 输出网格 |

### 发电机

生成器产生像素数据。路径是网格→生成器。见表 [8-60](#Tab60) 至 [8-63](#Tab63) 。

Table 8-63.

<colgroup><col> <col> <col></colgroup> 
| xtra→kalida _ mesh | 像双曲碗一样的网格 |
| --- | --- |
| 在…里 | `Hemispheric: float` | 碗的形状。0.0 是平的，1.0 就像半个球，超过 1.0 会进一步挤压 |
| 在外 | `mesh_out: mesh` | 输出网格 |

Table 8-62.

<colgroup><col> <col> <col></colgroup> 
| `ribbon` | 随着时间的推移，扭曲的 3D 丝带会发生变化 |
| --- | --- |
| 在…里 | `spatial` |   |
|   | `start_point: float3` | 丝带开始的地方 |
| `end_point: float3` | 丝带的终点 |
| `up_vector: float3` | 偏斜的向上向量 |
| `shape` |   |
| `width:float` | 色带宽度 |
| `skew_amp: float` | 偏斜幅度 |
| `time_amp: float` | 形状变化幅度 |
| `time_source: enum` | `sequence`或`real`之一。如果`sequence`，取顺序时间(需要手动启动)。如果`real`，取 ThMAD 启动后的实际时间。 |
|   | `segm_count: float` | 绘制功能区的线段数 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-61.

<colgroup><col> <col> <col></colgroup> 
| `ocean_tunnel` | 类别特效。使用模块`ocean`中的海洋模拟，但是将计算的坐标映射到一个管上 |
| --- | --- |
| 在…里 | `time_spec:float` | 机芯的时间比例系数 |
| 在外 | 网格:网格 | 输出网格 |

Table 8-60.

<colgroup><col> <col> <col></colgroup> 
| `ocean` | x-z 平面中的海洋(y=0) |
| --- | --- |
| 在…里 | `time_speed: float` | 表面运动的时间标度 |
| `lambda:float` | 控制波速 |
| `wind_speed_x: float` | 模拟风速 x 坐标 |
|   | `wind_speed_y: float` | 模拟风速 y 坐标 |
| `normals_only: enum` | 设置为`yes`或`no`。如果是`yes`，使用稍微不同的算法，忽略 x-z 扭曲。 |
| 在外 | `mesh:mesh` | 输出网格 |

### 进口商

导入 Cal3D 或 Blender 文件。路径是网状→进口商。见表 [8-64](#Tab64) 和 [8-65](#Tab65) 。

Table 8-65.

<colgroup><col> <col> <col></colgroup> 
| `obj_importer` | 进口搅拌机*。obj 文件(Blender 是一个工业级 3D 创作程序) |
| --- | --- |
| 在…里 | `filename:resource` | *。要导入的 obj 文件。示例/网格资源文件夹包含一些示例 |
| `preserve_uv_ coords:enum` | 设置为`NO`或`YES`，是否也从文件中读取纹理 uv 坐标 |
| `center_``object`T2】 | 设置为`NO`或“是”,是否将对象置于原点中心(使用质心算法) |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-64.

<colgroup><col> <col> <col></colgroup> 
| `cal3d_importer` | 导入一个`cal3d`项目。一个例子是在`examples/dolphin`的示例文件夹中的状态 |
| --- | --- |
| 在…里 | `filename:resource` | 指向一个 Cal3D *。cfg 文件 |
|   | `use_thread:enum` | 设置为`yes`或`no`。是否在后台生成网格 |
| `transforms: complex` |   |
| `pre_rotation: quaternion` | 描述加载时的预旋转。 |
| `pre_rotation_ center:float` | 预旋转的中心 |
| `rotation:` | 导入后的循环 |
|   | `quaternion` |   |
| `rotation_center: float3` | 旋转的中心 |
| `post_rot_ translate:float3` | 导入后翻译 |
| `bones:complex` | 允许修改 Cal3D 模型的各种参数 |
| 在外 | `mesh:mesh` | 输出网格 |
| `bones_bounding_ box:mesh` | 骨骼边界框 |
| `absolutes:complex` | “骨骼”输入锚点的输出副本 |

### 修改器:颜色

网格顶点颜色相关模块。路径是网格→修改器→颜色。见表 [8-66](#Tab66) 。

Table 8-66.

<colgroup><col> <col> <col></colgroup> 
| `mesh_colorfield` | 根据颜色字段设置顶点的颜色。给定一个向量 A→B，所有的顶点都被投影到这个向量上，这个位置描述了插值 RGBA 颜色渐变中的位置。如果超出限制，将应用模数(重复) |
| --- | --- |
| 在…里 | `mesh_in: mesh` | 输入网格 |
| `start_pos:float3` | 色域的开始位置 |
| `color_from:float4` | 开始位置的颜色 |
| `end_pos:float3` | 色域的结束位置 |
| `color_to:float4` | 结束位置的颜色 |
| 在外 | `mesh_out:mesh` | 输出网格 |

### 修改器:转换器

转换网格数据。路径是网格→修改器→转换器→网格 _ 到 _ 浮点 3 _ 数组。见表 [8-67](#Tab67) 。

Table 8-67.

<colgroup><col> <col> <col></colgroup> 
| `mesh_to_float3_arrays` | 将网格转化为相应的 float3 数组。由于没有模块有`float3_array`输入，这个模块目前没有多大用处 |
| --- | --- |
| 在…里 | `mesh_in: mesh` | 输入网格 |
| 在外 | `vertices: float3_array` | 网格的顶点 |
| `vertex_normals: float3_array` | 顶点法线 |
|   | `face_normals: float3_array` | 面法线 |
|   | `face_centers: float3_arrays` | 面部居中 |

### 修改器:变形器

改变网格坐标的模块。路径是网格→修改器→变形器。见表 [8-68](#Tab68) 至 [8-74](#Tab74) 。

Table 8-74.

<colgroup><col> <col></colgroup> 
| `mesh_vortex` | 该模块目前正在建设中，尚未投入使用 |

Table 8-73.

<colgroup><col> <col></colgroup> 
| `mesh_vertex_move` | 该模块目前正在建设中，尚未投入使用 |

Table 8-72.

<colgroup><col> <col> <col></colgroup> 
| `mesh_rain_down` | 模拟粒子落下或下落 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格。 |
| `start:float` | 控制效果的开始(开始> 0)和效果的大小(爆炸和降雨速度)。 |
| `floor_level:float` | y 轴上停止下雨的地方。 |
| `explosion_ factor:float` | x-z 平面上粒子(输入网格的分离部分)的爆炸。默认值为 1.0(无爆炸)，较高的值会增加爆炸幅度。 |
| `landing_` | 着陆，这是运动的最后阶段 |
| `fluffiness:` | 沿着 y 轴，可以根据这个来调整 |
| `float` | 输入参数。默认值为 0.0，这意味着 |
| 关闭，较高的值会降低`floor_level` |
| 基于每粒子的参数，由 |
| 每个粒子的大小。 |
| 在外 | `mesh_out: mesh` | 输出网格 |

Table 8-71.

<colgroup><col> <col> <col></colgroup> 
| `mesh_normal_ randistort` | 随机扭曲顶点坐标和/或顶点法线。如果只是扭曲法线，你可以添加有趣的灯光效果，因为法线控制灯光反射 |
| --- | --- |
| 在…里 | `mesh_in_mesh` | 输入网格 |
|   | `distortion_ factor:float3` | x、y 和 z 维度上的随机失真因子 |
| `distort_ normals:enum` | 设置为`no`或`yes`，是否扭曲法线(严重影响光反射率) |
| `distort_ vertices:enum` | 设置为`no`或`yes`，是否扭曲顶点坐标。 |
| `vertex_ distortion_ factor:float` | 如果法线和顶点都扭曲了，使用它来控制顶点扭曲的相对量 |
| 在外 | `mesh_out: mesh` | 输出网格 |

Table 8-70.

<colgroup><col> <col> <col></colgroup> 
| `mesh_noise` | 向顶点坐标添加噪波。法线，纹理坐标和面的分配保持不变 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `noise:amount: float3` | 每个方向的噪声量 |
| 在外 | `mesh_out: mesh` | 输出网格 |

Table 8-69.

<colgroup><col> <col></colgroup> 
| `mesh_inflate` | 该模块目前正在建设中，尚未投入使用 |

Table 8-68.

<colgroup><col> <col> <col></colgroup> 
| `mesh_explode` | 分解网格。打破网格成分的边界，让它们散开 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `start:float` | 一个爆炸触发器。一旦设定为大于 0 的值，爆炸就会开始。该参数的值控制爆炸粒子的速度。越高越快。一旦设置为< 0，则使用未爆炸的网格重新开始 |
| `explosion_ factor:float` | 一个乘以爆炸速度的因子(可以将`start`设置为 1.0，只让这个参数控制速度) |
| `velocity_ deceleration:float` | 控制爆炸后爆炸粒子变慢的数量。 |
| `use_weights: enum` | 设置为`no`或`yes`。如果`yes`，每个粒子在爆炸后的重量是从它的空间范围计算出来的，而这个重量会影响粒子爆炸的速度。 |
| `weight_power:float` | 如果启用，控制权重的影响。如果大于 1，小粒子的重量差异就不那么重要了。 |
| 在外 | `mesh_out:mesh` | 输出网格。 |

至于`mesh_rain_down`模块，给定一个输入网格，这个变形器将解耦它的所有部分，并开始分解和沿着 y 轴移动它们，一直到某个楼层。因此，它从云中出来时就像下雨一样。

如果需要不同方向的运动，可以在输入前使用网格→修改器→变换→ mesh_rotate_quat 中的旋转模块，在输出后使用另一个`mesh_rotate_quat`旋转回来。模块`mesh_rotate_quat`使用四元数来指定旋转。如果您喜欢轴-角度-旋转符号，您可以使用转换器模块数学→算术→四元数→轴 _ 角度 _ 到 _ 四元数。例如，参见图 [8-5](#Fig5) 。

![A457467_1_En_8_Fig5_HTML.jpg](A457467_1_En_8_Fig5_HTML.jpg)

图 8-5。

The mesh_rain_down module with rotation transformation

### 修改器:辅助对象

网格的辅助模块。路径是网格→修改器→辅助对象。见表 [8-75](#Tab75) 和 [8-76](#Tab76) 。

Table 8-76.

<colgroup><col> <col> <col></colgroup> 
| `mesh_compute_tangents_ vertex_color_array` | 计算顶点的切线并将它们存储在颜色数组中。可以在着色器中使用 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| 在外 | `mesh_out:mesh` | 输出网格 |

Table 8-75.

<colgroup><col> <col></colgroup> 
| `mesh_compute_tangents` | 该模块目前正在建设中，尚未投入使用 |

### 修改器:拾取器

用于从网格中提取值。路径是网格→修改器→拾取器。见表 [8-77](#Tab77) 和 [8-78](#Tab78) 。

Table 8-78.

<colgroup><col> <col> <col> <col></colgroup> 
| `mesh_vertex_picker` | 获取某个网格顶点的完整数据 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `id:float` | 整数部分表示网格顶点 ID (0，1，2，…) |
| 在外 | `vertex:float3` | 顶点坐标 |
| `normal:float3` | 顶点处的法向量 |
| `color:float4` | 顶点处的颜色 |
| `texcoords:float3` | 该顶点的纹理坐标 |
| `passthru:mesh` | 输出网格。请注意，您必须将它连接到结果承载渲染子管道，模块才能工作。只是把它放在网格生产者和预期的网格消费者之间(像渲染器) |
| `sizes:complex` | 网格阵列大小 |
|   | `vertices_size: float` | 顶点数 |
|   | `normals_size: float` | 顶点法线的数量 |
|   | `colors_size: float` | 顶点颜色的数量 |
|   | `faces_size: float` | 面数 |

Table 8-77.

<colgroup><col> <col> <col></colgroup> 
| `mesh_attach_picker` | 给定两个顶点 ID，返回 ID1 的坐标和一个旋转四元数，该旋转四元数描述了沿 ID1 的法线和 ID2-ID1 水平方向观察所需的旋转 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `id_a:float` | 整数部分指向顶点 A (0，1，2，…) |
| `id_b:float` | 整数部分指向顶点 B (0，1，2，…) |
| 在外 | `position:float3` | 顶点 A 的坐标 |
| `rotation: quaternion` | 由 A 处的法线定义的旋转向量，以及从 A 到 B 的向量 |

`mesh_attach_picker`和`mesh_vertex_picker`模块都可以用来让可视化扫描网格的顶点，并根据它获得的坐标做事情。注意，如果你不打算使用旋转四元数，使用`mesh_attach_picker`你不必指定第二个顶点 ID。

### 修改器:变换

用于修改顶点数据。路径是网格→修改器→变换。见表 [8-79](#Tab79) 至 [8-85](#Tab85) 。

Table 8-85.

<colgroup><col> <col> <col></colgroup> 
| `mesh_translate_ edge_wraparound` | 对顶点进行平移，但在某些限制坐标值处环绕 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
|   | `translation: float3` | 翻译 |
| `edge_min: float3` | 定义 x、y 和 z 值，如果边坐标小于该值，则会发生坐标方向的环绕 |
|   | `edge_max: float3` | 定义 x、y 和 z 值，如果边坐标大于，则在这些值处会发生坐标方向的环绕 |
| 在外 | `mesh_out: mesh` | 输出网格 |

Table 8-84.

<colgroup><col> <col> <col></colgroup> 
| `mesh_translate` | 平移网格 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `translation: float3` | 平移向量 |
| 在外 | `out_mesh: mesh` | 输出网格 |

Table 8-83.

<colgroup><col> <col> <col></colgroup> 
| `mesh_scale` | 执行缩放 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `scale:float3` | 每个维度的比例因子 |
| 在外 | `mesh_out: mesh` | 输出网格 |

Table 8-82.

<colgroup><col> <col> <col></colgroup> 
| `mesh_rotate_quat_ around_vertex` | 围绕网格的一个顶点旋转网格。之后额外翻译 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `quat_in: quaternion` | 描述旋转的四元数 |
|   | `vertex_rot_id: float` | 整数部分指向将围绕其执行旋转的顶点。值为 0，1，2，… |
| `offset_pos: float3` | 旋转后的附加平移 |
| 在外 | `out_mesh: mesh` | 输出网格 |

Table 8-81.

<colgroup><col> <col> <col></colgroup> 
| `mesh_rotate_quat` | 通过旋转四元数旋转网格 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `quat_in: quaternion` | 旋转四元数(如果您需要用轴角旋转来控制它，请使用模块数学→算术→函数→轴角到四元数) |
| `invert_rotation: enum` | 设置为`no`或`yes`，是否反转旋转 |
| 在外 | `mesh_out:out` | 输出网格 |

Table 8-80.

<colgroup><col> <col> <col></colgroup> 
| `mesh_norm_scale` | 缩放和移动网格，使其所有顶点都位于[0；1].大小关系保持不变(最大跨度将为[0；1]) |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| 在外 | `mesh_out: mesh` | 输出网格 |

Table 8-79.

<colgroup><col> <col> <col></colgroup> 
| `mesh_mirror` | 镜像网格 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `axis:enum` | 要镜像哪个轴，x、y 或 z 中的一个。 |
| 在外 | `mesh_out: mesh` | 输出网格 |

### 微粒

二维粒子系统相关的简单网格。路径是网格→粒子。见表 [8-86](#Tab86) 至 [8-88](#Tab88) 。

Table 8-88.

<colgroup><col> <col></colgroup> 
| `mesh_star` | 该模块目前正在建设中，尚未投入使用 |

Table 8-87.

<colgroup><col> <col> <col></colgroup> 
| `mesh_rays` | 随机扇形三角形从(0，0，0)开始，直到某个大小限制 |
| --- | --- |
| 在…里 | `num_rays:float` | 光线的数量 |
| `center_color: float4` | 要分配的中心颜色 |
| `options / limit_ray_size` | 如果< 0，使最大光线大小为 1.0。否则使用此处给出的限制。 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-86.

<colgroup><col> <col> <col></colgroup> 
| `mesh_disc` | 圆盘或圆环。如果与基本网格渲染器一起使用，请注意纹理分布在整个周长上。如果不希望这样，您可以尝试使用`use_tex_center`参数 |
| --- | --- |
| 在…里 | `num_segments: float` | 沿周长生成的线段数 |
| `diameter:float` | 洞的直径。如果你想要一个圆盘而不是一个圆环，把这个值设为 0 |
| `border_width: float` | 戒指的宽度。如果直径为零，则为圆盘的半径。 |
| `use_tex_center: enum` | 设置为`no`或`yes`。如果`yes`，不要将纹理扩展到整个周边，而是只使用中心部分，这使得纹理被有效地一维使用。 |
| 在外 | `mesh:mesh` | 输出网格 |

### 日轮

mesh → segmesh 下的 Segmesh 模块目前正在构建中，没有功能。

### 固体

使用网格生成三维实体。路径是网格→实体。见表 [8-89](#Tab89) 至 [8-102](#Tab102) 。

Table 8-102.

<colgroup><col> <col> <col></colgroup> 
| `plane_uv_distort` | 维度为[-1 的 x-y 平面；-1] → [1;1]在 z=0 处，由序列控制器扭曲纹理坐标 |
| --- | --- |
| 在…里 | `x_res:float` | 该数字的整数部分是 x 方向的分辨率 |
| `y_res:float` | 该数字的整数部分是 y 方向的分辨率 |
| `distortion: complex` |   |
| `x_shape: sequence` | 描述沿 x 轴的扭曲。如果将序列内的所有值都设定为 0.5，则不会发生失真。低于 0.5 的数字表示负失真，高于 0.5 的数字表示正失真 |
| `x_shape_ multiplier:float` | 应用于 x 失真值的乘数 |
| `z_shape: sequence` | 描述了沿 y 轴的扭曲(不要被名字迷惑；这是错误的，但出于向后兼容的考虑，仍保留原样) |
| `z_shape_ multiplier:float` | 应用于 y 失真值的乘数 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-101.

<colgroup><col> <col> <col></colgroup> 
| `metaballs` | 显示变形球。这是一个等电位面的物理模拟。功能，但目前有缺陷，显示一些工件 |
| --- | --- |
| 在…里 | `grid_size:float` | 该决议 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-100.

<colgroup><col> <col> <col></colgroup> 
| `mesh_torus_knot` | 圆环结。这是一个位于环面上的纽结，可能有许多圈 |
| --- | --- |
| 在…里 | `num_sectors:float` | 周长方向的扇区数 |
| `num_stacks:float` | 沿其长度的分段数 |
| `p:float` | p 参数化 |
| `q:float` | q 参数化 |
| `phi_offset:float` | 角度偏移 |
| `size` |   |
| `size_shape_x: sequence` | 沿长度的第一个径向分量的大小 |
| `size_shape_x_ multiplier:float` | 应用于`size_shape_x`序列的因子 |
| `size_shape_y: sequence` | 第二径向分量沿长度的大小 |
| `size_shape_y_ multiplier:float` | 应用于`size_shape_y`序列的因子 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-99.

<colgroup><col> <col> <col></colgroup> 
| `mesh_super_banana` | 一种柔韧的，可能是香蕉形的网状物。请注意，您必须先设置形状，然后才能看到任何内容 |
| --- | --- |
| 在…里 | `num_sectors:float` | 周长方向的扇区数 |
|   | `num_stacks:float` | 沿其长度方向的堆叠数量 |
| `shape:complex` |   |
| `x_shape:` | 沿着一个径向维度的序列 |
|   | `sequence` |   |
| `x_shape_ multiplier:float` | x 形状的乘数 |
| `y_shape: sequence` | 沿着另一个径向维度的序列 |
| `y_shape_ multiplier:float` | y 形的乘数 |
| `z_shape: sequence` | 沿长度维度的序列 |
| `z_shape_ multiplier:float` | z 形的倍增器 |
| `size:complex` |   |
| `size_shape_x: sequence` | 沿长度尺寸的一个半径的大小形状 |
| `size_shape_x_ multiplier:float` | 沿长度尺寸的一个半径的大小形状的乘数 |
| `size_shape_y: sequence` | 沿长度尺寸的其他半径的大小形状 |
| `size_shape_y_ multiplier:float` | 沿长度尺寸的另一个半径的大小形状的乘数 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-98.

<colgroup><col> <col> <col></colgroup> 
| `mesh_sphere_ octahedron` | 具有更规则细分的球体。从一个八面体(三角形的 8 个面)开始，反复细分它的每个部分(从一个三角形中产生四个三角形)，将每个新点投影到球体上(只需将其拉伸到所需立方体的半径) |
| --- | --- |
| 在…里 | `subdivision_level: float` | 细分的迭代次数。小心不要把它弄得太大，否则它会碎的。大于 9 的值将被忽略，并被固定为 9。 |
| `max_ normalization_ level: float` | 法线重算可以被配置为在某个级别停止，如果光线照射在表面上，这会使表面变得更加凹凸不平。 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-97.

<colgroup><col> <col> <col></colgroup> 
| `mesh_sphere_ icosahedron` | 具有更规则细分的球体。从一个二十面体(三角形的 20 个面)开始，反复细分它的每个部分(从一个三角形中产生四个三角形)，将每个新点投影到球体上(只需将其拉伸到所需立方体的半径) |
| --- | --- |
| 在…里 | `subdivision_level: float` | 细分的迭代次数。小心不要把它弄得太大，否则它会碎的。缺省值是 6，这在很多情况下都适用。大于 7 的值将被忽略，并被固定为 7。 |
| `max_ normalization_ level: float` | 法线重新计算可以被配置为在某个级别停止，如果光线照射到表面上，这将使表面更加凹凸不平。 |
| `initial_ico_scale: float` | 在开始细分之前，缩放原始二十面体。这些点不会被投影到球体上。目前有点问题，因为它显示文物。 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-96.

<colgroup><col> <col> <col></colgroup> 
| `mesh_sphere` | 一个球体。使用非常基本的用于地球仪的简单细分算法 |
| --- | --- |
| 在…里 | `num_sectors:float` | 经度部分的数量 |
| `num_stacks:float` | 纬度部分的数量 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-95.

<colgroup><col> <col> <col></colgroup> 
| `mesh_solid_supershape` | 通过结合幂和正弦函数的复杂形状 |
| --- | --- |
| 在…里 | `x:` `complex` | 算法的 x 和 y 维度目前都在这里处理 |
|   | `x_num_ segments:float` | 要生成的段数。生成的顶点总数是这个的平方 |
| `x_start:float` | 算法的角度 |
|   | `x_stop:float` | 算法的角度 |
| `y_start:float` | 算法的角度 |
| `y_stop:float` | 算法的角度 |
| `x_a:float` | 比例因子 |
| `x_b:float` | 比例因子 |
| `x_n1:float` | 权力之争 |
| `x_n2:float` | 权力之争 |
| `x_n3:float` | 权力之争 |
| `x_m:float` | 算法中的角度因子 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-94.

<colgroup><col> <col> <col> <col></colgroup> 
| `mesh_planes` | 许多平行的平面 |
| --- | --- |
| 在…里 | `num_planes:float` | 飞机数量 |
| `space_between: float` | 相邻平面之间的距离 |
| `diameter:float` | 平面的尺寸是 2 x 直径乘以 2 x 直径 |
| `normals:float3` | 指定每个平面的空间方向。“法线”垂直于一个平面 |
| `colors:complex` |   |
|   | `color_a:float4` | 每个平面在顶点 1 着色 |
|   | `color_b:float4` | 每个平面在顶点 2 着色 |
|   | `color_c:float4` | 每个平面在顶点 3 着色 |
|   | `color_d:float4` | 每个平面在顶点 4 着色 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-93.

<colgroup><col> <col> <col></colgroup> 
| `mesh_grid` | 由小四边形组成的二次网格。中心将在(0；0;0 ),网格的大小将是 1×1 |
| --- | --- |
| 在…里 | `power_of_two_ size:float` | 2 的幂是每边四边形的数量。所以如果这是 4，我们每边都有 2^4 = 16，总共是 16x16 = 256。 |
| `plane:enum` | `xy`、`xz`、`yz`之一。网格的方向。 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-92.

<colgroup><col> <col> <col></colgroup> 
| `mesh_cylinder` | 圆柱体 |
| --- | --- |
| 在…里 | `start:float3` | 基地的中心 |
| `end:float3` | 顶部的中心 |
| `radius:float` | 半径 |
| `segments:float` | 分段的数量 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-91.

<colgroup><col> <col> <col></colgroup> 
| `mesh_cone` | 来了 |
| --- | --- |
| 在…里 | `base:float3` | 圆锥体底部的中心 |
| `peak:float3` | 圆锥的顶点 |
| `radius:float` | 底部的半径 |
| `segments:float` | 分段的数量 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-90.

<colgroup><col> <col> <col></colgroup> 
| `mesh_box` | 由六个正方形面组成的盒子。线性尺寸总是[-0.5；0.5] |
| --- | --- |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-89.

<colgroup><col> <col> <col></colgroup> 
| `mesh_arrow` | 一支箭 |
| --- | --- |
| 在…里 | `start:float3` | 起动位置 |
| `end:float3` | 端位置 |
| `radius:float` | 身体的半径 |
| `segments:float` | 分段的数量 |
|   | `head_size:float` | 头部占全长的比例 |
| 在外 | `mesh:mesh` | 输出网格 |

### 纹理

这些模块用于网格的纹理坐标操作。路径是网格→纹理。参见表 [8-103](#Tab103) 和 [8-104](#Tab104) 。

Table 8-104.

<colgroup><col> <col> <col> <col></colgroup> 
| `mesh_tex_sequ_distort` | 使用序列来描述纹理坐标失真 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `spatial:complex` |   |
|   | `scale_u:float` | 一个附加的纹理 u 坐标比例因子 |
|   | `scale_v:float` | 附加的纹理 v 坐标比例因子 |
|   | `translate_u: float` | 额外的纹理 u 坐标平移 |
|   | `translate_v: float` | 额外的纹理 v 坐标平移 |
| `distortion: complex` |   |
|   | `u_shape: sequence` | 描述纹理 u 坐标失真 |
|   | `v_shape: sequence` | 描述纹理 v 坐标失真 |
| 在外 | `mesh_out: mesh` | 输出网格 |

Table 8-103.

<colgroup><col> <col> <col></colgroup> 
| `mesh_tex_bitmap_ distort` | 使用位图来描述纹理坐标失真 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `bitmap:bitmap` | 位图。只使用红色和绿色。红色表示纹理的 U 向变形，绿色表示 V 向变形。值为 0.5 表示没有扭曲 |
| `intensity:float` | 控制效果的整体强度 |
| `spatial:complex` | 附加失真参数 |
| `u_off:float` | 纹理 u 坐标偏移 |
| `v_off:float` | 纹理 v 坐标偏移 |
| `u_scale:float` | 纹理 u 坐标比例因子 |
| `v_scale:float` | 纹理 v 坐标比例因子 |
| 在外 | `mesh_out: mesh` | 输出网格 |

### 头顶

通过算法定义网格。路径是网格→顶点。见表 [8-105](#Tab105) 至 [8-109](#Tab109) 。

Table 8-109.

<colgroup><col> <col> <col></colgroup> 
| `ribbon_vertices` | 扭曲的丝带。随着时间的推移而改变。类似于网格→生成器→ ribbon，但是不会创建面，所以`mesh_basic_render`模块不能处理它 |
| --- | --- |
| 在…里 | `start_point:float3` | 起点 |
|   | `end_point:float3` | 终点 |
| `up_vector:float3` | 向上矢量定义了它的运动方式 |
| `num_segments: float` | 分段的数量 |
| `particle_scale: float` | 会影响颜色。如果将此值更改为小于 1.0 的值，颜色将从黑色变为白色或灰色 |
| `width:float` | 控制功能区的宽度 |
|   | `skew_amp:float` | 偏斜幅度 |
| `time_amp:float` | 扭曲的时间尺度 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-108.

<colgroup><col> <col> <col></colgroup> 
| `random_vertices` | 生成随机顶点 |
| --- | --- |
| 在…里 | `rand_seed:float` | 随机种子。如果您需要不同的发行版，请进行更改 |
| `num_points: float` | 点数 |
| `scaling:float3` | 一次缩放 |
| `distrib:enum` | 分布:`box`:盒子内均匀`sphere`:球体表面均匀`bowl`:球体内部均匀`gauss`:3D 高斯`gauss2d`:2D 高斯，z = 0 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-107.

<colgroup><col> <col> <col></colgroup> 
| 修改器→网格 _ 顶点 _ 距离 _ 排序 | 从输入网格中，获取顶点，并根据到给定点的距离对它们进行排序(最远的先排序)。输出不包含颜色或面孔；没有纹理坐标！所以`mesh_basic_render`模块不能处理它 |
| --- | --- |
| 在…里 | mesh_in:网格 | 输入网格。不会被改变。 |
| 距离 _ 至:浮动 3 | 测量距离的起点 |
| 在外 | mesh_out:网格 | 输出网格。没有颜色、法线或面；只有顶点。 |
| original _ ids:float _ 数组 | 排序后输入网格的 id。 |

Table 8-106.

<colgroup><col> <col> <col></colgroup> 
| `lightning_vertices` | 等离子球效应 |
| --- | --- |
| 在…里 | `rand_seed:float` | 一些随机的种子。为不同的形状更改此值。通常你想把它发送到一个`mesh_dot_render`模块进行渲染，因为这个模块没有生成法线或面。 |
| `lifetime:float` | 如果希望模拟不那么紧张，请增加该值 |
| `length:float` | 雷击的时间长度 |
| `mesh_a:mesh` | 输入网格。从这里开始的顶点被用作闪电的起点。这里的法线用于撞击的主要方向 |
| `num_points: float` | 闪电顶点的数量 |
| `scaling:float3` | 使用它来控制效果的尺寸 |
| `sub_divide:float` | 为雷击每个部分生成许多点。如果使用点渲染器，增加该值是有意义的 |
| 在外 | `mesh:mesh` | 输出网格 |

Table 8-105.

<colgroup><col> <col> <col></colgroup> 
| `bspline_vertices` | 获取输入网格的顶点，并使用它们来填充 B 样条线管道。注意，输出网格不包含任何法线或面，所以`mesh_basic_render`模块不能处理它 |
| --- | --- |
| 在…里 | `source:mesh` | 输入网格 |
| `density:float` | 密度:为每个顶点对生成的点数 |
| 在外 | `mesh:mesh` | 输出网格 |

### 字母 X

一些特殊的网格生成器和修改器。路径是 Mesh → Xtra。见表 [8-110](#Tab110) 至 [8-112](#Tab112) 。

表 8-112。

<colgroup><col> <col> <col></colgroup> 
| `thorn` | 生成彩色刺 |
| --- | --- |
| 在外 | `mesh_result:mesh` | 输出网格 |

Table 8-111.

<colgroup><col> <col> <col></colgroup> 
| `planeworld` | 与网格结合使用→顶点→ `random_vertices`作为输入，创建一个具有完整网格属性的复杂结:顶点、颜色、纹理坐标、面 |
| --- | --- |
| 在…里 | `bspline_vertices_ mesh:mesh` | 输入网格。这里你不必使用`bspline_vertices`模块的输出！b 样条是在内部计算的。 |
| 在外 | `mesh_result:mesh` | 输出网格 |

Table 8-110.

<colgroup><col> <col> <col></colgroup> 
| `cloud_plane` | 一架彩色云飞机 |
| --- | --- |
| 在外 | `mesh_out:mesh` | 输出网格 |

## 粒子系统

粒子系统处理许多小尺寸的物体。它们以某种方式弥补了状态内部循环结构的缺失。

### 分形

分形是具有一些特殊的、与分形相关的数学性质的几何对象或对象集合。这里的一个模块使用迭代函数系统算法来产生分形。路径是粒子系统→分形。参见表 [8-113](#Tab113) 。

Table 8-113.

<colgroup><col> <col> <col></colgroup> 
| `ifs_modifier` | 根据迭代函数系统(IFS)连续改变粒子的坐标。这是 x → f(x) → f(f(x)) → f(f(f(x)))等等。这里的函数 f 是两个仿射映射的随机混合 |
| --- | --- |
| 在…里 | `in_particlesystem: particlesystem` | 输入粒子系统 |
| `change_probab: float` | 如果希望每帧(1/60 秒)仅更改粒子的特定部分，请将此值设定为小于 1.0 的值。) |
| `change_random: enum` | 这是一个触发器。选择`go`，一个随机的 IFS 参数集将被生成并使用。请注意，只有一小部分随机生成的集合会产生可用的结果 |
| `save_params: enum` | 将当前参数设置保存到`/home/[USER]/thmad/ [VERSION]/data/resources/ifs`中的文件的触发器，以便在将来的状态中使用。 |
| `load_params: resource` | 加载先前保存的参数集。这个锚的值是不持久的，所以它是一次性的设置动作。当然，这里获得的参数将被持久化。 |
| `ifs:complex` | 当前参数集:两个仿射变换。该算法以相等的概率在它们之间随机切换 |
| `sys1:complex` | 第一个系统。![$$ \left(\begin{array}{cccc}a11& a12& a13& at1\\ {}a21& a22& a23& at2\\ {}a31& a32& a33& at3\\ {}0& 0& 0& 1\end{array}\right) $$](A457467_1_En_8_Chapter_IEq1.gif) |
| `sys2:complex` | 第二系统![$$ \left(\begin{array}{cccc}b11& b12& b13& bt1\\ {}b21& b22& b23& bt2\\ {}b31& b32& b33& bt3\\ {}0& 0& 0& 1\end{array}\right) $$](A457467_1_En_8_Chapter_IEq2.gif) |
| 在外 | `particlesystem: particlesystem` | 输出粒子系统 |

### 发电机

发电机产生粒子。路径是粒子系统→发电机。见表 [8-114](#Tab114) 至 [8-116](#Tab116) 。

Table 8-116.

<colgroup><col> <col> <col> <col> <col></colgroup> 
| `particles_mesh_spray` | 类似于`basic_spray_emitter`，但是使用一个网格作为粒子的运动原点 |
| --- | --- |
| 在…里 | `num_particles:float` | 粒子的总数 |
|   | `particles_per_ second:float` | 如果不设置为-1，该数字指定粒子死亡后每秒钟复活的最大粒子数。 |
|   | `mesh_properties: complex` | 网格属性仅在粒子出生或复活时适用 |
|   |   | `pick_type:enum` | `sequential`或`random`之一。如何 |
|   |   |   | 从网格中选择顶点作为粒子运动的原点。 |
|   |   | `center:float3` | 所有粒子共有的平移向量 |
|   |   | `spread:fload3` | 添加到粒子最终位置时，应用于输入顶点位置坐标的乘数 |
|   |   | `random_ deviation:float3` | 指定计算粒子位置时的随机性 |
|   | `spatial:complex` |   |
|   |   | `speed_type: enum` | 如何计算速度:其中之一:`random_balanced`:对于每个坐标，速度将从内部`rnd[-0.5;0.5]`∙`speed_*`∙`speed_mult``directional`:取`speed_mult`∙`speed_*``mesh_beam`:取`speed_mult` `origin_to_vertex + add_vector`其中`rnd[a;b]`指定 a 和 b 之间的一个随机数，`origin_to_vertex`是从原点到顶点的归一化向量。 |
|   |   | `speed_multiplier: float` | 速度乘数(`speed_mult`) |
|   |   | `speed_random_ value:float` | 随机值的乘数[-0.5；0.5]添加到`speed_mult` |   |
|   |   | `speed:complex` | 这指定粒子发射时开始运动的速度。其解释方式由`speed_type`、`speed_multiplier`和`speed_random_value`指定 |   |
|   |   |   | `speed_x:float` |   |
|   |   |   | `speed_y:float` |   |
|   |   |   | `speed_z:float` |   |
|   |   | `add_vector: float3` | `add_vector`仅适用于 speed_type = `mesh_beam` |   |
|   |   | `size:complex` | 每个粒子的尺寸计算:`size = size_base +` `rnd[-0.5;0.5]` ∙ `random_weight` |   |
|   |   |   | `particle_size_ base:float` |   |
|   |   |   | `particle_size_ random_ weight:float` | 其中`rnd[a;b]`指定 a 和 b 之间的一个随机数。 |   |
|   | `appearance: complex` |   |   |
|   |   | `color:float4` | 粒子颜色 |   |
|   |   | `time:complex` | 每个粒子的寿命:`lifetime = lifetime_base + rnd[-0.5;0.5]` ∙ `random_weight`其中`rnd[a;b]`指定 a 和 b 之间的一个随机数 |   |
|   |   |   | `particle_ lifetime_base: float` |   |
|   |   |   | `particle_ lifetime_ random_ weight:float` |   |
|   |   | `time_source: enum` | 从哪里花时间。`real`或`sequencer`之一。对于简单的状态，使用`real` |   |
| 在外 | `particlesystem: particlesystem` | 输出粒子系统 |   |

Table 8-115.

<colgroup><col> <col> <col> <col> <col></colgroup> 
| `bitmap_to_particlesystem` | 使用位图像素作为运动原点和颜色的粒子系统 |
| --- | --- |
| 在…里 | `bitmap_in:bitmap` | 输入位图 |
|   | `particles_per_ second:float` | 如果不设置为-1，该数字指定粒子死亡后每秒钟复活的最大粒子数。 |
| `spatial:complex` |   |
|   | `bitmap_size:float` | 从坐标原点的角度看，位图的大小 |
|   | `bitmap_normal: float3` | 法线，指定位图在空间中的方向 |
|   | `bitmap_ upvector:float3` | 围绕法线向量旋转位图 |
|   | `bitmap_position: float3` | 位图中心的位置 |
|   | `speed:complex` | 这指定粒子发射时开始运动的速度 |
|   |   | `speed_x:float` |
|   |   | `speed_y:float` |
|   |   | `speed_z:float` |
|   | `speed_type: enum` | 速度参数的应用方式。如果`random_balanced`，例如速度-x 将从[-速度 _ x/2；speed_x/2]。如果`directional`，将按规定取速度 |
|   | `size:complex` | 每个粒子的尺寸计算:`size = size_base +` `rnd[-0.5;0.5]` ∙ `random_weight` |
|   |   | `particle_size_ base:float` |
|   |   |   | `particle_size_ random_ weight:float` | 其中 rnd[a-；b]指定 a 和 b 之间的一个随机数。 |
|   | `time_source: enum` | 从哪里花时间。`real`或`sequencer`之一。对于简单的状态，使用`real`。 |
|   | `particle_ rotation_dir: quaternion` | 如果启用了粒子旋转，请使用该选项来指定旋转。 |
|   | `enable_rotation` | 是否启用旋转:`true`或`false`之一 |
| `appearance: complex` |   |
|   | `color:float4` | 颜色 |
|   | `time:complex` | 每个粒子的寿命:`lifetime = lifetime_base + rnd[-0.5;0.5]` ∙ `random_weight`其中`rnd[a;b]`指定 a 和 b 之间的一个随机数 |
|   |   | `particle_ lifetime_base: float` |
|   |   | `particle_ lifetime_ random_ weight: float` |
| 在外 | `particlesystem: particlesystem` | 输出粒子系统 |

Table 8-114.

<colgroup><col> <col> <col> <col> <col></colgroup> 
| `basic_spray_emitter` | 在空间中的给定点创建粒子。粒子的数量不会随后改变——被认为是死的粒子仍然留在内存中，并且可能随后在这一点上再次开始存活 |
| --- | --- |
| 在…里 | `num_particles: float` | 粒子的总数 |
|   | `particles_per_ second:float` | 如果不设置为-1，该数字指定粒子死亡后每秒钟复活的最大粒子数。 |
|   | `spatial:complex` |   |
|   |   | `emitter_ position:float3` | 粒子开始存在的空间位置。 |
|   |   | `speed:complex` | 这指定粒子发射时开始运动的速度 |
|   |   |   | `speed_x:float` |   |
|   |   |   | `speed_y:float` |   |
|   |   |   | `speed_z:float` |   |
|   |   | `speed_type: enum` | 速度参数的应用方式。如果`random_balanced`，例如速度-x 将从[-速度 _ x/2；speed_x/2]。如果`directional`，将按规定取速度 |
|   |   | `size:complex` | 每个粒子的尺寸计算:`size = size_base +` `rnd[-0.5;0.5]` ∙ `random_weight`其中`rnd[a-;b]`指定 a 和 b 之间的一个随机数 |
|   |   |   | `particle_size_ base:float` |   |
|   |   |   | `particle_size_ random_ weight:float` |   |
|   |   | `time_source: enum` | 从哪里花时间。`real`或`sequencer`之一 |
|   |   | `particle_ rotation_dir: quaternion` | 如果启用了粒子旋转，请使用该选项来指定旋转。 |
|   |   | `enable_rotation: enum` | 是否启用旋转:`true`或`false`之一 |
|   | `appearance: complex` |   |
|   |   | `color:float4` | 颜色 |
|   |   | `time:complex` | 每个粒子的寿命:`lifetime = lifetime_base + rnd[-0.5;0.5]` ∙ `random_weight`其中`rnd[a;b]`指定一个随机数 |
|   |   |   | `particle_ lifetime_base: float` |   |
|   |   |   | `particle_ lifetime_ random_ weight: float` | 在 a 和 b 之间。 |
| 在外 | `particlesystem: particlesystem` | 输出粒子系统 |

### 修饰语

修改器告诉粒子在发射后的行为，除了在发射点指定给它们的速度。路径是粒子系统→修改器。见表 [8-117](#Tab117) 至 [8-122](#Tab122) 。

Table 8-122.

<colgroup><col> <col> <col></colgroup> 
| `size_noise` | 随机改变粒子的大小，增加或增加一个数字 |
| --- | --- |
| 在…里 | `in_particlesystem: particlesystem` | 输入粒子系统 |
| `strength:float` | 变动量 |
| `size_type:enum` | `multiply`或`add`之一 |
| 在外 | `particlesystem: particlesystem` | 输出粒子系统 |

Table 8-121.

<colgroup><col> <col> <col></colgroup> 
| `size_mult` | 改变粒子的大小，增加或增加一个数字 |
| --- | --- |
| 在…里 | `in_particlesystem: particlesystem` | 输入粒子系统 |
| `strength:float` | 变动量 |
| `size_type:enum` | `multiply`或`add`之一 |
| 在外 | `particlesystem: particlesystem` | 输出粒子系统 |

Table 8-120.

<colgroup><col> <col></colgroup> 
| `particle_fluid_deformer` | 该模块目前正在建设中，尚未投入使用 |

Table 8-119.

<colgroup><col> <col> <col> <col> <col></colgroup> 
| `floor` | 模拟地板，粒子在地板上停止运动或反弹 |
| --- | --- |
| `In` | `in_particlesystem: particlesystem` | 输入粒子系统 |
|   | `axis:complex` |   |
|   | `x:complex` |   |
|   |   | `x_floor:enum` | `no`或`yes`之一。是否启用 x = floor-x 处的楼层 |
|   |   | `x_bounce: enum` | `no`或`yes`之一。是否在碰到地板时启用弹跳。 |
|   |   | `x_loss:float` | 只有在弹跳时，在弹跳时经历的速度损失 |
|   | `y:complex` |   |
|   |   | `y_floor:enum` | `no`或`yes`之一。是否启用 y = floor-y 处的楼层 |
|   |   | `y_bounce: enum` | `no`或`yes`之一。是否在碰到地板时启用弹跳。 |
|   |   | `y_loss:float` | 只有在弹跳时，在弹跳时经历的速度损失 |
|   | `z:complex` |   |
|   |   | `z_floor:enum` | `no`或`yes`之一。是否启用 z = floor-z 处的楼层 |
|   |   | `z_bounce: enum` | `no`或`yes`之一。是否在碰到地板时启用弹跳。 |
|   |   | `z_loss:float` | 只有在弹跳时，在弹跳时经历的速度损失 |
|   | `refraction:enum` | `no`或`yes`之一。如果`yes`，也启用了反弹，启用折射，这意味着粒子会在或多或少随机的方向反弹 |
|   | `refraction_ amount:float3` | 如果启用折射，折射量将发生在每个维度上 |
| `floor:float3` | 楼层 x、楼层 y 和楼层 z 值 |
| 在外 | 粒子系统:粒子系统 | 输出粒子系统 |

Table 8-118.

<colgroup><col> <col> <col></colgroup> 
| `basic_wind_deformer` | 应用风 |
| --- | --- |
| 在…里 | `in_particlesystem: particlesystem` | 输入粒子系统 |
| `wind:float3` | 风速 |
| 在外 | `particlesystem: particlesystem` | 输出粒子系统 |

Table 8-117.

<colgroup><col> <col> <col></colgroup> 
| `basic_gravity` | 增加重力和摩擦力 |
| --- | --- |
| `In` | `in_particlesystem: particlesystem` | 输入粒子系统 |
|   | `basic_parameters: complex` |   |
|   | `center:float3` | 重心 |
| `amount:float3` | 重力的每个坐标的乘数。将一个或两个设置为零可以模拟重力，就像径向或平面重心一样 |
| `friction:float3` | 摩擦力会像空气中的粒子一样限制最终速度 |
| `time_source: enum` | 从哪里花时间，是`sequencer`还是`real` |
| `mass_calculations: complex` |   |
| `mass_type: enum` | 个体:将每个粒子的尺寸作为其质量-均匀:而不是使用`uniform_mass`参数 |
| `uniform_mass: float` | 如果 mass_type = `uniform`，这将是每个粒子的质量 |
| 在外 | `particlesystem: particlesystem` | 输出粒子系统 |

## 渲染器

一旦数据流到达管道中的渲染器，我们就进入了 OpenGL 对象世界。这意味着在渲染步骤之后，我们将得到点、线、多边形、四边形和其他图形元素，它们最终将在屏幕上产生输出。

本节描述了渲染数据的修改步骤，如方向、渲染模式等。也就是说，这里也解释了具有渲染器输入和渲染器输出锚点的模块。

根据渲染器渲染什么或对渲染对象做什么，渲染器被分为几个部分。

### 基础

基本渲染器。路径是渲染器→基本。见表 [8-123](#Tab123) 至 [8-127](#Tab127) 。

Table 8-127.

<colgroup><col> <col> <col> <col></colgroup> 
| `textured_triangle` | 有纹理的三角形 |
| --- | --- |
| 在…里 | `spatial:complex` |   |
|   |   | `position_a:float3` | 定位角 A |
|   |   | `position_b:float3` | 定位角 B |
|   |   | `position_c:float3` | 定位角 C |
|   |   | `tex_coord_a: float3` | 纹理坐标角 A |
|   |   | `tex_coord_b: float3` | 纹理坐标角 B |
|   |   | `tex_coord_c: float3` | 纹理坐标角 C |
|   | `color:complex` |   |
|   |   | `global_alpha: float` | 阿尔法乘数。仅应用于颜色倍增器的 ALPHA 组件，这样的存在只是为了方便。 |
|   |   | `color_multiplier: float4` | 作为应用于所有颜色的乘数。如上所述，其阿尔法分量首先乘以`global_alpha` |
|   |   | `color_a:float4` | 颜色角 A |
|   |   | `color_b:float4` | 颜色角 B |
|   |   | `color_c:float4` | 颜色角 C |
|   | `texture_in:texture` | 输入纹理 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-126.

<colgroup><col> <col> <col> <col></colgroup> 
| `textured_rectangle` | 重要渲染器；。在屏幕上绘制带有纹理的矩形 |
| --- | --- |
| 在…里 | `spatial:complex` |   |
|   |   | `position:float3` | 矩形中心的位置。 |
|   |   | `size:float` | 尺寸倍增器。如果这是 1.0，大小将是 2x2，因为坐标在[-1；-1]x[1；1] |
|   |   | `angle:float` | 绕 z 轴的旋转角度 |
|   |   | `x_aspect_ratio: float` | 如果你想应用一个长宽比，在这里放一个不等于 1.0 的东西 |
|   |   | `tex_coord_a: float3` | 左下角的纹理坐标。这里的第三个坐标没有使用 |
|   |   | `tex_coord_b: float3` | 右上角的纹理坐标。这里的第三个坐标没有使用 |
|   |   | `facing_camera: enum` | `no`或`yes`之一。如果是`yes`，使用 OpenGL 的一个特殊功能，旋转被忽略，矩形被绘制成面向镜头。 |
|   | `color:complex` |   |
|   |   | `global_alpha: float` | 阿尔法乘数。仅应用于颜色倍增器的`ALPHA`组件，这样的存在只是为了方便。 |
|   |   | `color_multiplier: float4` | 作为应用于所有颜色的乘数。如上所述，其阿尔法分量首先乘以`global_alpha` |
|   |   | `color_center: float4` | 中心颜色 |
|   |   | `color_a:float4` | 左下角颜色 |
|   |   | `color_b:float4` | 左上角颜色 |
|   |   | `color_c:float4` | 右上角颜色 |
|   |   | `color_d:float4` | 右下角颜色 |
|   | `texture_in:texture` | 输入纹理 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-125.

<colgroup><col> <col> <col> <col></colgroup> 
| `render_line` | 在屏幕上绘制一条线 |
| --- | --- |
| 在…里 | `spatial:complex` |   |
|   | `point_a:float3` | 起点 |
|   | `point_b:float3` | 端点 |
|   | `color_a:float4` | 开始颜色 |
|   | `color_b:float4` | 结束颜色。介于两者之间的颜色在 RGBA 颜色空间中进行线性插值。 |
|   | `width:float` | 宽度。请注意，根据您的硬件，可能会有一个上限 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-124.

<colgroup><col> <col> <col> <col></colgroup> 
| `points` | 一个非常简单的渲染器，在屏幕上绘制矩形的四个角点。考虑一下这种“你好，世界”节目 |
| --- | --- |
| 在…里 | `spatial:complex` |   |
|   | `position:float3` | 矩形的中心 |
|   | `angle:float` | 旋转角 |
|   | `rotation_axis: float3` | 旋转轴 |
|   | `size:float` | 尺寸倍增器。如果读数为 1.0，则大小为 2x2 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-123.

<colgroup><col> <col> <col> <col></colgroup> 
| `colored_rectangle` | 绘制彩色矩形 |
| --- | --- |
| 在…里 | `spatial:complex` |   |
|   | `position:float3` | 矩形的中心 |
|   | `angle:float` | 旋转角 |
|   | `rotation_axis: float3` | 旋转轴 |
|   | `size:float` | 尺寸倍增器。如果读数为 1.0，则大小为 2x2 |
| `border:complex` |   |
|   | `border_enabled: enum` | `no`或`yes`之一。 |
|   | `border_width: float` | 如果启用，边框宽度 |
|   | `border_color: float4` | 边框颜色(如果启用) |
| `color:float4` | 区域颜色 |
| 在外 | `render_out:render` | 渲染器输出 |

对于纹理矩形和纹理三角形，我们有两个相互竞争的颜色概念:首先是顶点颜色，其次是纹理颜色。剩下的渲染管道和 OpenGL 的内部状态决定了哪一个胜出，或者它们是如何混合的。ThMAD 中的标准混合模式是`MODULATE`，这意味着颜色值只是相乘。不幸的是，我们不能轻易地在模块的基础上改变这一点，因为 OpenGL 遵循纹理单元的概念，并且只有对于每个纹理单元，纹理组合的方式可以通过使用标准 API 函数来设置。但是有另一种基于模块的控制方法，而且更加强大。

使用着色器而不是函数实际上给了你巨大的权力来定义混合。可以通过在渲染器后面添加渲染器→着色器→ glsl_loader 模块来指定一个着色程序；参见图 [8-6](#Fig6) 。

![A457467_1_En_8_Fig6_HTML.jpg](A457467_1_En_8_Fig6_HTML.jpg)

图 8-6。

Using shaders to control the color blending

例如，下面的代码将允许您添加颜色值，而不是将它们相乘:

顶点明暗器:

```sh
1   varying vec4 vColor;
2   void main(void) {
3     vColor = gl_Color;
4     gl_TexCoord[0] = gl_MultiTexCoord0;
5     gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;
6   }

```

片段着色器:

```sh
1   varying vec4 vColor;
2   uniform sampler2D sampler;
3   void main(void) {
4   vec4 tex = texture2D ( sampler,
5       gl_TexCoord[0].st );
6   gl_FragColor = vec4(vColor.r + tex.r,
7     vColor.g + tex.g,
8     vColor.b + tex.b,
9     vColor.a + tex.a);
10   }

```

片段着色器代码的第 6-9 行显示了混合算法。

### 网状物

网格相关的渲染器。路径是渲染器→网格。见表 [8-128](#Tab128) 至 [8-134](#Tab134) 。

Table 8-134.

<colgroup><col> <col></colgroup> 
| `render_mesh_ribbon` | 该模块正在开发中，目前处于试验阶段(存在性能问题) |

Table 8-133.

<colgroup><col> <col> <col></colgroup> 
| `mesh_vertex_id_render` | 渲染顶点 id(诊断工具) |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `base_color:float4` | 绘制的 id 的颜色 |
| `font_size:float` | 字体大小的缩放比例 |
| `min_box:float3` | 顶点坐标的下限。如果 x、y、z 中的任何一个低于该参数的适当值，顶点将被忽略 |
| `max_box:float3` | 顶点坐标的上限。如果 x、y、z 中的任何一个高于该参数的适当值，顶点将被忽略 |
| `max_id:float` | 要渲染的最大顶点 ID。对应于显示的最大顶点数。如果设置为小于 0.0 的标准值，则没有限制 |
| 在外 | `render_out: render` | 渲染器输出 |

Table 8-132.

<colgroup><col> <col> <col></colgroup> 
| `mesh_transparency_ render` | 按照眼睛/相机的距离顺序渲染网格。因为当混合透明纹理时，顺序很重要，首先排序顺序会产生更真实的效果 |
| --- | --- |
| 在…里 | `tex_a:texture` | 要映射到网格表面的纹理 |
| `mesh_in:mesh` | 输入网格 |
| `vertex_colors: enum` | `no`或`yes`之一。是否使用伴随顶点的颜色。如果是`yes`，将会发生`MODULATE`类型的纹理颜色混合(颜色值倍增)。 |
| 在外 | `render_out: render` | 渲染器输出。 |

Table 8-131.

<colgroup><col> <col> <col> <col></colgroup> 
| `mesh_line_render` | 在顶点之间绘制线条。这通常不会创造美，但它向你展示了顶点的顺序。如果你想要一个真实的线框，使用渲染器→OpenGL _ modifiers→rendering _ mode |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `base_options: complex` |   |
|   | `line_width:float` | 线条宽度。通常你的图形硬件会有一个上限。 |
|   | `override_ base_color: enum` | `no`或`yes`之一。如果是`yes`，将使用`base_color`。否则顶点的颜色。 |
|   | `base_color: float4` | 用于线条的颜色。仅当`override_base_color`设置为`true`时适用 |
|   | `base_color_ add:float4` | 刚刚添加到`base_color` |
| `center_options: complex` |   |
|   | `each_to_ center:enum` | `no`或`yes`之一。如果`yes`，改为从每个顶点到原点(0，0，0)画一条线 |
|   | `center_color: float4` | 中心使用的颜色 |
|   | `center_color_ add:float4` | 刚刚添加到`center_color` |
| 在外 | `render_out: render` | 渲染器输出 |

Table 8-130.

<colgroup><col> <col> <col></colgroup> 
| `mesh_dot_render` | 这是模块`mesh_dot_billboards`的小哥哥。在每个顶点绘制点，但不使用着色器代码 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
| `base_color:float4` | 除非`use_vertex_color`设置为`true`，否则这就是点颜色。 |
| `dot_size:float` | 点的大小 |
| `use_vertex_ color:enum` | `no`或`yes`之一。是否使用顶点本身设置的颜色。 |
| 在外 | `render_out: render` | 渲染器输出。 |

Table 8-129.

<colgroup><col> <col> <col> <col></colgroup> 
| `mesh_dot_billboards` | 在网格位置渲染点。它被称为“广告牌”，因为屏幕上的点都具有相同的大小，无论离眼睛/相机位置有多远。 |
| --- | --- |
| 在…里 | `mesh_in:mesh` | 输入网格 |
|   | `base_color:float4` | 点颜色的一种可能性是使用这个值。着色是由着色器代码完成的，因此可能是也可能不是这种情况。 |
|   | `dot_size:float` | 点的大小。可以使用也可以不使用，这取决于着色器代码。 |
| `use_display_list: enum` | `no`或`yes`之一。是否使用显示列表。如果`yes`，提高性能。 |
| `shader_params: complex` |   |
|   | `vertex_ program:string` | 顶点程序。将接收`dot_size`作为统一浮点。你通常可以让它保持原样。如果你想使用着色器来设置点的大小，写 s.th. like `gl_PointSize` `= 7.0;` |
|   | `fragment_ program:string` | 碎片程序。这里你可以说是使用顶点颜色(`“gl_FragColor = vColor;"`)还是`base_color` ( `“gl_FragColor = base_color;"`)。 |
|   | `uniforms: complex` | 自动制服。这些是`base_color`和`dot_size`的镜子。使用它们或原件来控制模块。 |
|   | `attributes: complex` | 自动属性。未使用。 |
| 在外 | `render_out: render` | 渲染器输出。 |

Table 8-128.

<colgroup><col> <col> <col></colgroup> 
| `mesh_basic_render` | 网格的基本渲染器 |
| --- | --- |
| 在…里 | `tex_a:texture` | 网格描述的曲面的纹理。该锚点是强制性的，如果未连接，将使用定义的顶点颜色，并且锚点`options / vertex_colors`和`options / use_vertex_colors`被设置为`yes` |
| `mesh_in:mesh` | 主网格输入。定义顶点，法线，切线，面和纹理坐标。 |
| `particles: particlesystem` | 如果您想让网格倍增，请将粒子系统连接到此锚点。强制性的。 |
| `particle_cloud: mesh` | 如果你想增加网格，在这里连接另一个网格`B`。与`particles`锚相比，这更适用于静态系统。强制性的。 |
| `options:complex` |   |
| `vertex_colors: enum` | `no`或`yes`之一。如果`yes`是否调用`glEnable(GL_COLOR_MATERIAL)`，顶点本身的颜色将被考虑在内 |
| `use_display_ list:enum` | `no`或`yes`之一。如果`yes`，使用静态绘制模式，性能更好，但灵活性较差。 |
| `use_vertex_ colors:enum` | `no`或`yes`之一。是否将顶点颜色作为数组发送到图形硬件。如果你想有一个基于顶点颜色的着色，设置这个为`yes` |
| `particles_size_ center:enum` | `no`或`yes`之一。如果`yes`，并且只有当`particles`输入锚连接时，使粒子在远离它们的出生位置时变大。 |
| `particles_size_ from_color: enum` | `no`或`yes`之一。如果`yes`，并且只有当`particles`输入锚被连接，误用顶点颜色 R，G，B 值来定义粒子 x，y，z 尺寸的缩放。 |
| `ignore_uvs_in_ vbo_updates: enum` | `no`或`yes`之一。如果`yes`，并且仅在动态模式下(`use_display_list = false`，仅在开始时将顶点纹理坐标上传到图形硬件。这是一种性能优化。 |
| 在外 | `render_out: render` | 渲染器输出 |

### OpenGL 修改器

本小节的模块与 OpenGL 设置和功能密切相关。因此，与其他 ThMAD 模块相比，它们可以被视为更低级的模块。然而，其中一些对你们的国家至关重要。路径是 Renderers → opengl_modifiers。见表 [8-135](#Tab135) 至 [8-158](#Tab158) 。

Table 8-158.

<colgroup><col> <col> <col></colgroup> 
| `rendering_mode` | 渲染模式指定顶点之间的线条和区域会发生什么 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `back_facing:enum` | 其中之一:`points`:仅渲染顶点处的点—`lines`:渲染相邻顶点之间的线，但不绘制面—`solid`:绘制相邻顶点之间的区域 |
| `front_facing:enum` | 与`back_facing`相同的值 |
| `smooth_edges:enum` | `no`或`yes`之一。是否绘制平滑的边缘。 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-157.

<colgroup><col> <col> <col> <col></colgroup> 
| `material_param` | 材料颜色相关参数 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `faces_affected:enum` | `front_facing`、`back_facing`或`front_and_back`中的一种 |
| `properties:complex` |   |
|   | `ambient_ reflectance:float4` | 用于环境反射的颜色。很自然，你会在这里使用深色的东西 |
|   | `diffuse_ reflectance:float4` | 用于漫反射的颜色。通常你把自然表面的颜色放在这里 |
|   | `specular_ reflectance:foat4` | 用于镜面反射的颜色。通常你会在这里放一些明亮或非常明亮的东西 |
|   | `emission_intensity: float4` | 无论什么光线照射到表面都会发出某种颜色 |
|   | `specular_exponent: float` | 定义镜面反射的模糊性。越大，镜面反射出现的斑点就越多。 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-156.

<colgroup><col> <col> <col> <col></colgroup> 
| `light_model` | 要使用的灯光模型 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
|   | `properties:complex` |   |
|   | `ambient_color: float4` | 独立于任何光线使用的环境颜色。环境色会在任何表面上发光，无论位置如何 |
|   | `color_control: enum` | 其中之一:`SINGLE_COLOR`:所有类型灯光的标准颜色计算—`SEPARATE_SPECULAR_COLOR`:对镜面反射颜色使用特殊变量。 |
|   |   | `local_viewer:enum` | 其中之一:`Z-AXIS`:使用 z 轴上的一个点来计算最终颜色值—`EYE_COORDS`:使用摄像机的位置来计算最终颜色值。 |
|   | `num_sides:enum` | `ONE`或`TWO`之一。如果`TWO`，让光线也照射到表面的背面(然而 ThMAD 不能处理这个) |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-155.

<colgroup><col> <col> <col> <col></colgroup> 
| `light_directional` | 方向灯。“定向”意味着计算照明时假设所有光束以平行方式进入 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `properties:complex` |   |
|   | `light_id:enum` | 灯光标识。如果有多个灯光，所有灯光必须有不同的 id |
|   | `enabled:enum` | `no`或`yes`之一。打开或关闭灯。 |
|   | `position:float3` | 光从哪里来。定义光束方向 |
|   | `ambient_color: float4` | 环境颜色。将在所有表面上发光，与灯光的位置无关 |
|   | `diffuse_color: float4` | 漫射色。当表面受到撞击时会折射到各个方向 |
|   | `specular_color: float4` | 镜面颜色。将会以(或多或少)精确的角度反射 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-154.

<colgroup><col> <col> <col></colgroup> 
| `gl_translate` | 翻译所有对象 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `translation:float3` | 平移向量 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-153.

<colgroup><col> <col> <col></colgroup> 
| `gl_scale_one` | 做一个缩放，每个维度的因子相同 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `scale:float` | 所有维度的比例因子 |
| `matrix:enum` | `MODELVIEW`、`PROJECTION`或`TEXTURE`中的一种。缩放应该发生在哪个矩阵堆栈中。 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-152.

<colgroup><col> <col> <col></colgroup> 
| `gl_scale` | 进行缩放 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `scale:float3` | 每个维度中的比例因子 |
| `matrix:enum` | `MODELVIEW`、`PROJECTION`或`TEXTURE`中的一种。缩放应该发生在哪个矩阵堆栈中。 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-151.

<colgroup><col> <col> <col></colgroup> 
| `gl_rotate_quat` | 按照四元数描述的方式旋转 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `rotation:quaternion` | 旋转四元数 |
| `matrix_target:enum` | `MODELVIEW`、`PROJECTION`或`TEXTURE`中的一种。旋转应该发生在哪个矩阵堆栈中 |
| `invert_rotation:enum` | `no`或`yes`之一。如果`yes`，反转旋转 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-150.

<colgroup><col> <col> <col></colgroup> 
| `gl_matrix_multiply` | 将`MODELVIEW`、`PROJECTION`或`TEXTURE`矩阵中的一个乘以给定的矩阵 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `matrix_in:matrix` | 用于乘法的 4x4 矩阵 |
| `matrix_target:enum` | `MODELVIEW`、`PROJECTION`、`TEXTURE`之一 |
| 在外 | `render_out:render` | 渲染器输出 |
| `gl_rotate` | 绕轴旋转 |
| 在…里 | `render_in:render` | 渲染器输入 |
| `axis:float3` | 旋转轴 |
| `angle:float` | 旋转角度 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-149.

<colgroup><col> <col> <col></colgroup> 
| `gl_matrix_get` | 获取`MODELVIEW`、`PROJECTION`或`TEXTURE`矩阵 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `matrix_target:enum` | `MODELVIEW`、`PROJECTION`或`TEXTURE`中的一种 |
| 在外 | `render_out:render` | 渲染器输出 |
| `matrix_out:matrix` | 所选的 4x4 矩阵 |

Table 8-148.

<colgroup><col> <col> <col></colgroup> 
| `gl_line_width` | 如果模块使用线条，则设置线条宽度，而不是自己设置宽度。如果由模块完成，将不会覆盖设置 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `width:float` | 宽度 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-147.

<colgroup><col> <col> <col></colgroup> 
| `gl_get_camera_orientation` | 获取摄像机方位，这是`MODELVIEW`矩阵乘以(0，0，1)。听起来很奇怪，但是不要把这个模块放在子管道中的相机模块之后 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| 在外 | `render_out:render` | 渲染器输出 |
| `direction_out:float3` | 方向 |

Table 8-146.

<colgroup><col> <col> <col></colgroup> 
| `gl_frustum` | 将透视应用于当前投影矩阵 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `left:float` | 剪裁平面的左边缘 |
| `right:float` | 剪裁平面的右边缘 |
| `bottom:float` | 剪裁平面的底部 |
| `top:float` | 剪裁平面的顶部 |
| `near:float` | 最近的距离 |
| `far:float` | 遥远的距离 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-145.

<colgroup><col> <col> <col></colgroup> 
| `gl_fog` | OpenGL 的内置雾化以像素为基础改变颜色。这个模块允许为线性模式设置一些雾化参数:计算一些系数`f = (end-c) / (end-start)`，其中 c 是从相机到原点的距离。然后混合功能是`C" = f ∙ color + (1-f) ∙ fog_color`雾不影响`ALPHA`通道！ |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `status:enum` | `ENABLED`或`DISABLED`之一 |
| `fog_color:float4` | 雾的颜色 |
| `fog_start:float` | 开始参数 |
| `fog_end:` | 结尾参数 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-144.

<colgroup><col> <col> <col></colgroup> 
| `gl_color` | 为本身不设置顶点颜色的模块设置顶点颜色。这不会覆盖模块颜色 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `color:float4` | 颜色 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-143.

<colgroup><col> <col> <col></colgroup> 
| `depth_function` | 如果启用了深度测试，请参见指定测试功能的模块`depth_buffer` |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
|   | `depth_func:enum` | 以下情况之一:`NEVER`:测试总是失败(每个位置的最后一个像素总是获胜)`LESS`:默认值–较近或相同深度的像素(视图方向的 z 轴)获胜–`EQUAL`:不会绘制相同的深度–`LESS_OR_EQUAL`:较近的像素获胜–`GREATER`:相同深度或较远的像素获胜 NOT_EQUAL:较新的像素仅在相同深度的情况下显示更大或相等:较远的像素获胜总是:测试总是通过(每个位置的第一个像素总是获胜) |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-142.

<colgroup><col> <col> <col></colgroup> 
| `depth_buffer_clear` | 清除管道中此处的深度缓冲区 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-141.

<colgroup><col> <col> <col></colgroup> 
| `depth_buffer` | 除非我们需要透明表面，否则不需要绘制其他像素后面的像素。OpenGL 可以保存这种像素深度，并允许检查这种关系 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `depth_test:enum` | `ENABLED`或`DISABLED`之一。使其能够执行深度检查 |
| `depth_mask:enum` | `ENABLED`或`DISABLED`之一。使其具有存储深度信息的缓冲器 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-140.

<colgroup><col> <col> <col> <col></colgroup> 
| 相机→目标 _ 相机 | 从一点看向另一点的照相机。如果要跟踪对象或点，这很有用 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `camera:complex` |   |
|   | `position:float3` | 空间位置 |
|   | `destination:float3` | 我们正在看的点 |
|   | `upvector:float3` | 向上向量 |
|   | `fov:float` | 摄像机视野的角度 |
|   | `near_clipping:float` | 任何比这个距离更近的都将被丢弃 |
|   | `far_clipping:float` | 任何超过这个距离的都将被丢弃 |
|   | `perspective_ correct:enum` | `no`或`yes`之一。如果是`yes`，考虑显示器的宽高比 |
| `ortho:complex` |   |
|   | `enable_ortho:enum` | `no`或`yes`之一。如果`yes`，用正投影(无透视)代替透视投影。“fov”、“near_clipping”和“far_clipping”锚将不起作用 |
|   | `ortho_left:float` | 如果启用了正交，则为左边缘 |
|   | `ortho_right:float` | 如果启用了正交，则为右边缘 |
|   | `ortho_bottom:float` | 如果启用了正交，则为底边 |
|   | `ortho_top:float` | 如果启用了正交，则为顶边 |
|   | `ortho_near:float` | 如果启用了正交，则近剪裁平面 |
|   | `ortho_far:float` | 如果启用了正交，则为远剪裁平面 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-139.

<colgroup><col> <col> <col> <col></colgroup> 
| `orbit_camera`→`orbit_camera` | 观察一个点的照相机，你可以在轨道上定义一个位置来从任何角度观察那个点 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输出 |
|   | `camera:complex` |   |
|   | `rotation:float3` | 旋转，那是我们在轨道上的位置 |
|   | `distance:float` | 轨道离我们观察点的距离 |
|   | `destination:float3` | 我们正在看的点 |
|   | `upvector:float3` | 向上向量 |
|   | `fov:float` | 摄像机视野的角度 |
|   | `near_clipping:float` | 任何比这个距离更近的都将被丢弃 |
|   | `far_clipping:float` | 任何超过这个距离的都将被丢弃 |
|   | `perspective_ correct:enum` | `no`或`yes`之一。如果是`yes`，考虑显示器的宽高比 |
| `ortho:complex` |   |
|   | `enable_ortho:enum` | `no`或`yes`之一。如果`yes`，用正投影(无透视)代替透视投影。那时`fov`、`near_clipping`和`far_clipping`锚将不起作用 |
|   | `ortho_left:float` | 如果启用了正交，则为左边缘 |
|   | `ortho_right:float` | 如果启用了正交，则为右边缘 |
|   | `ortho_bottom:float` | 如果启用了正交，则为底边 |
|   | `ortho_top:float` | 如果启用了正交，则为顶边 |
|   | `ortho_near:float` | 如果启用了正交，则近剪裁平面 |
|   | `ortho_far:float` | 如果启用了正交，则为远剪裁平面 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-138.

<colgroup><col> <col> <col> <col></colgroup> 
| `freelook_camera`→`freelook_camera` | 某个位置的摄像机，以某个方向和某个上方向旋转 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输出 |
| `camera:complex` |   |
|   | `position:float3` | 空间位置 |
|   | `rotation:float3` | 旋转 |
|   | `upvector:float3` | 向上向量 |
|   | `fov:float` | 摄像机视野的角度 |
|   | `near_clipping: float` | 任何比这个距离更近的都将被丢弃 |
|   | `far_clipping: float` | 任何超过这个距离的都将被丢弃 |
|   | `perspective_ correct:enum` | `no`或`yes`之一。如果是`yes`，考虑显示器的宽高比 |
| `ortho:complex` |   |
|   | `enable_ortho: enum` | `no`或`yes`之一。如果`yes`，用正投影(无透视)代替透视投影。那时`fov`、`near_clipping`和`far_clipping`锚将不起作用 |
|   | `ortho_left:float` | 如果启用了正交，则为左边缘 |
|   | `ortho_right: float` | 如果启用了正交，则为右边缘 |
|   | `ortho_bottom: float` | 如果启用了正交，则为底边 |
|   | `ortho_top:float` | 如果启用了正交，则为顶边 |
|   | `ortho_near: float` | 如果启用了正交，则近剪裁平面 |
|   | `ortho_far:float` | 如果启用了正交，则为远剪裁平面 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-137.

<colgroup><col> <col> <col></colgroup> 
| `buffer_clear` | 清除管道中此阶段的输出 |
| --- | --- |
| 在…里 | `render_in: render` | 渲染器输入 |
|   | `color_buffer: enum` | `no`或`yes`之一。是否要清除颜色缓冲区 |
| `clear_color: float4` | 如果该模块清除了颜色缓冲区，则使用该颜色进行清除 |
| `depth_buffer: enum` | `no`或`yes`之一。是否清除深度缓冲区 |
| 在外 | `render_out: render` | 渲染器输出 |

Table 8-136.

<colgroup><col> <col> <col></colgroup> 
| `blend_mode` | 决定了在已有物体上绘制物体时会发生什么 |
| --- | --- |
| 在…里 | `render_in: render` | 渲染器输入 |
| `source_blend: enum` | 新到达的像素会发生什么。具体可以看 OpenGL 规范(或者在自己喜欢的搜索引擎中搜索`gl_blend`)。默认设置是`SRC_ALPHA`，它以 ALPHA 定义的强度绘制新到达的像素，但让现有像素以 1–ALPHA 的强度发光。 |
| `dest_blend: enum` | 已经存在的像素会发生什么。默认设置是 ONE_MINUS_SRC_- ALPHA，这意味着它们以传入像素的 1–ALPHA 定义的强度淡出 |
| `blend_color: enum` | 外部混合颜色，如果需要的话，这取决于前面锚点选择的规则 |
| 在外 | `render_out: render` | 渲染器输出 |

Table 8-135.

<colgroup><col> <col> <col></colgroup> 
| `auto_normalize` | 在对任何可能发生缩放的场景应用照明之前，使用此选项。允许自动重新计算法线向量，这对正确的照明计算是必要的。当着色器工作时，该模块不起作用 |
| --- | --- |
| 在…里 | `render_in: render` | 渲染器输入 |
| 在外 | `render_out: render` | 渲染器输出 |
| `backface_culling` | 如果定义了面(由三个顶点定义的最小比例的区域)，使用顶点排序定义的旋转(左或右)来确定我们是从前面还是从后面看它。如果启用，视图后面的部分会被丢弃 |
| 在…里 | `render_in: render` | 渲染器输入 |
| `status:enum` | `ENABLED`或`DISABLED`之一。是否启用背面剔除 |
| 在外 | `render_out: render` | 渲染器输出 |

### 示波器

示波器用于诊断目的，观察控制器模块在一段时间内做了什么。路径是渲染器→示波器。参见表 [8-159](#Tab159) 和 [8-160](#Tab160) 。

Table 8-160.

<colgroup><col> <col> <col> <col></colgroup> 
| `simple_oscilloscope` | 一种示波器，从输入的浮点阵列中画出由浮点指定的伸长量 |
| --- | --- |
| 在…里 | `data_in:float_ array` | 输入数据 |
| `spatial:complex` |   |
|   | `position:float3` | 周围(不可见)剪辑框在空间中的位置 |
|   | `angle:float` | 围绕旋转轴的角度 |
|   | `rotation_axis: float3` | 旋转轴 |
|   | `size:float` | 周围方框的大小 |
| `color:float4` | 绘画色彩 |
| `line_width:float` | 线条宽度。请注意，您的图形硬件可能会强加一个上限 |
| `axes:complex` |   |
|   | `paint_y_zero: enum` | `no`或`yes`之一。是否绘制 val=0 线 |
|   | `axes_color: float4` | 用于轴的颜色 |
| 在外 | `render_out: render` | 渲染器输出 |

Table 8-159.

<colgroup><col> <col> <col> <col></colgroup> 
| `simple_colorline` | 根据输入数组中的值绘制线段颜色的线条 |
| --- | --- |
| 在…里 | `spatial:complex` |   |
|   |   | `position:float3` | 周围(不可见)盒子在空间中的位置 |
|   | `angle:float` | 围绕旋转轴的角度 |
|   | `rotation_axis: float3` | 旋转轴 |
|   |   | `size:float` | 周围方框的大小 |
| `color_a:float4` | 值为零的数组的颜色 |
| `color_b:float4` | 数组值 1.0 的颜色–中间的颜色将被线性插值 |
| `line_width:float` | 线条宽度。请注意，您的图形硬件可能会强加一个上限 |
| 在外 | `render_out:render` | 渲染器输出 |

虽然示波器更多的是一种诊断工具，但您可能需要通过预先准备一个用于收集浮点的 Maths→Array→float _ Array _ memory _ buffer 模块来确保其可用性，而`simple_colorline`可用于产生可视化效果。虽然线条本身有点无聊，但使用模糊效果可能会大大提高使用场景的数量。

### 粒子系统

Particlesystem 相关渲染器。路径是渲染器→ particlesystems。见表 [8-161](#Tab161) 至 [8-166](#Tab166) 。

Table 8-166.

<colgroup><col> <col> <col></colgroup> 
| `sparks` | 在彼此靠得太近的粒子之间产生火花 |
| --- | --- |
| 在…里 | `particlesystem: particlesystem` | 要渲染的粒子系统。不应该太大，因为邻近计算是昂贵的 |
| `float_array_in: float_array` | 出现火花时调节接近距离的阵列。使用一些你从声音输入中得到的数组 |
| `proximity_level: float` | 火花出现时的接近程度 |
| `color:float4` | 火花颜色 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-165.

<colgroup><col> <col> <col> <col></colgroup> 
| `simple` | 基本粒子系统渲染器。类似于`render_particle_shader`模块，但是允许在纹理渲染(不使用着色器代码)和点精灵渲染(使用着色器代码)之间进行选择 |
| --- | --- |
| 在…里 | `particlesystem: particlesystem` | 要渲染的粒子系统 |
|   | `texture:texture` | 用于渲染粒子的纹理 |
| `options:complex` |   |
|   | `render_type:enum` | `quads`或`point_sprites`之一 |
|   | `size_lifespan_type: enum` | 如何计算生命周期内的大小:`normal`:在生命周期内线性增加`sequence`:由序列指定 |
|   | `size_lifespan_ sequence:sequence` | 如果`size_lifespan_type`设置为`sequence`，则尺寸序列。 |
|   | `alpha_lifespan_ sequence:sequence` | 粒子在其生命周期中是如何发展的 |
|   | `color_lifespan_type: enum` | 如何计算生命周期中的颜色:-`normal`；只取指定的粒子颜色-`sequence`;如序列所指定 |
|   | `r_lifespan_ sequence:sequence` | 如果`color_lifespan_type`设置为`sequence`，则红色序列 |
|   | `g_lifespan_ sequence:sequence` | 如果`color_lifespan_type`设置为`sequence`，则为绿色序列 |
|   | `b_lifespan_ sequence:sequence` | 如果`color_lifespan_type`被设置为`sequence`，则为蓝色序列 |
|   | `Ignore_particles_ att_center:enum` | `no`或`yes`之一。是否绘制位于中心或非常靠近中心的粒子 |
| `shader_params: complex` |   |
|   | `vertex_program: string` | 顶点程序。使用这个来调整位置 |
|   | `fragment_program: string` | 碎片程序。使用这个来调整颜色 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-164.

<colgroup><col> <col> <col> <col></colgroup> 
| `render_particlesystem_ext` | 模块的小哥哥`render_particle_shader`。总是对所有生命周期参数大小、alpha、颜色通道使用序列 |
| --- | --- |
| 在…里 | `particlesystem:` | `The particle system to render` |
|   | `particlesystem` |   |
| `texture:texture` | 用于渲染粒子的纹理 |
| `options:complex` |   |
|   | `size_lifespan_ sequence: sequence` | 如果`size_lifespan_type`设置为`sequence`，则尺寸序列。 |
|   | `alpha_lifespan_ sequence: sequence` | 粒子在其生命周期中是如何发展的 |
|   | `r_lifespan_ sequence: sequence` | 如果`color_lifespan_type`设置为`sequence`，则红色序列 |
|   | `g_lifespan_ sequence: sequence` | 如果`color_lifespan_type`设置为`sequence`，则为绿色序列 |
|   | `b_lifespan_ sequence: sequence` | 如果`color_lifespan_type`被设置为`sequence`，则为蓝色序列 |
|   | `Ignore_ particles_att_ center:enum` | `no`或`yes`之一。是否绘制位于中心或非常靠近中心的粒子 |
| `vertex_program: string` | 顶点程序。使用这个来调整位置 |
| `fragment_program: string` | 碎片程序。使用这个来调整颜色 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-163.

<colgroup><col> <col> <col> <col></colgroup> 
| `render_particle_shader` | 一个更高级的粒子系统渲染器，允许您定义生存期行为，并允许您使用着色器代码以获得最大的渲染灵活性 |
| --- | --- |
| 在…里 | `particlesystem: particlesystem` | 要渲染的粒子系统 |
|   | `texture:texture` | 用于渲染粒子的纹理 |
| `options:complex` |   |
|   | `size_lifespan_ type:enum` | 如何计算寿命期间的大小:`normal`:在寿命期间线性增加`sequence`:由序列指定 |
|   |   | `size_lifespan_ sequence: sequence` | 如果`size_lifespan_type`设置为`sequence`，则尺寸序列。 |
|   | `alpha_lifespan_ sequence: sequence` | 粒子在其生命周期中是如何发展的 |
|   | `color_lifespan_ type:enum` | 如何计算寿命期间的颜色:正常:仅取指定的粒子颜色序列:如序列所指定的 |
|   | `r_lifespan_ sequence: sequence` | 如果`color_lifespan_type`设置为`sequence`，则红色序列 |
|   | `g_lifespan_ sequence: sequence` | 如果`color_lifespan_type`设置为`sequence`，则为绿色序列 |
|   | `b_lifespan_ sequence: sequence` | 如果`color_lifespan_type`被设置为`sequence`，则为蓝色序列 |
|   | `ignore_particles_ att_center:enum` | `no`或`yes`之一。是否绘制位于中心或非常靠近中心的粒子 |
| `shader_params: complex` |   |
|   | `vertex_program: string` | 顶点程序。使用这个来调整位置 |
|   | `fragment_ program:string` | 碎片程序。使用这个来调整颜色 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-162.

<colgroup><col> <col> <col> <col></colgroup> 
| `render_particle_ribbon` | 在 3D 中沿移动的重力带渲染粒子 |
| --- | --- |
| 在…里 | `particlesystem: particlesystem` | 要渲染的粒子系统 |
| `params:complex` |   |
|   | `ribbon_width: float` | 色带的宽度 |
|   | `length:float` | 丝带的长度 |
|   | `friction:float` | 摩擦参数(粒子在沿带轨迹移动时可能会改变它们的速度) |
|   | `step_length: float` | 粒子沿带状轨迹移动速度的因子 |
|   | `color0:float4` | 在每个粒子的寿命期间，粒子的颜色将逐渐减少 |
|   | `color1:float` | 另一个静态颜色参数。 |
| 在外 | `render_out:render` | 渲染器输出 |

Table 8-161.

<colgroup><col> <col> <col></colgroup> 
| `render_particle_center` | 特效粒子系统渲染器违反物理定律，将一些坐标夹在一个中心点上 |
| --- | --- |
| 在…里 | `particlesystem: particlesystem` | 要渲染的粒子系统 |
| `texture:texture` | 用于绘制每个粒子的纹理 |
| `position:float3` | 用于渲染粒子系统的基本位置 |
| `alpha:float` | 人为的附加阿尔法值；来自粒子的所有颜色都只有它们的 RGB 值(不是`ALPHA`！)乘以那个数字 |
| `size:float` | 应用于每个粒子的大小 |
| 在外 | `render_out:render` | 渲染器输出 |

### 着色器

本小节中的着色器是特殊模块；它们都使用相同的代码基础，但在工作中使用任意的着色器代码。后者用一些代码初始化，但是一旦模块在画布上实例化，就可以自由调整。

与所有其他模块的一个显著区别是参数的默认值不适用。因此，在大多数情况下，您必须仔细设置所有可调参数，然后着色器才能按预期工作。

基础代码导致以下参数:参见表 [8-167](#Tab167) 。

表 8-167。

Shader Parameters

<colgroup><col> <col> <col></colgroup> 
| <name given="" by="" shader="" code=""></name> | 着色器基础代码 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `vertex_program:string` | 顶点着色器代码 |
| `fragment_program: string` | 片段着色器代码 |
| `uniforms:complex` | 自动生成的锚点。ThMAD 解析着色器代码，并暴露它在那里找到的所有制服 |
| `attributes:complex` | 自动生成的属性锚点。属性是逐顶点分配的，这使得它们在 ThMAD 中有点难以处理 |
| 在外 | `render_out:render` | 渲染器输出 |

存在以下着色器；参见表 [8-168](#Tab168) 。

表 8-168。

Built-in Shaders

<colgroup><col> <col></colgroup> 
| 名字 | 描述 |
| --- | --- |
| `glsl_loader` | 这是基本的着色器。它描述了一个基础的着色器代码来开发你自己的着色器。对于默认着色器代码，打开新实例化的模块的锚 |
| --- | --- |
| `blend_modes / shader_blend_color_ dodge` | 减淡混合着色器。对于默认着色器代码，打开新实例化的模块的锚。 |
| `blend_modes / shader_blend_overlay` | 覆盖混合着色器。对于默认着色器代码，打开新实例化的模块的锚。 |
| `blend_modes / shader_blend_satadd` | 饱和加法混合着色器。对于默认着色器代码，打开新实例化的模块的锚。 |
| `blend_modes / shader_blend_screen` | 屏幕混合着色器。对于默认着色器代码，打开新实例化的模块的锚。 |
| `lighting_models / normal_map` | 法线贴图照明。对于默认着色器代码，打开新实例化的模块的锚。 |
| `lighting_models / normal_map2` | 另一个法线贴图照明。对于默认着色器代码，打开新实例化的模块的锚。 |
| `lighting_models / shader_2l_diffmap_ specmap` | 差异贴图/特殊贴图照明。对于默认着色器代码，打开新实例化的模块的锚。 |
| `lighting_models / shader_smooth_ lighting_tex` | 纹理照明。对于默认着色器代码，打开新实例化的模块的锚。 |
| `materials / chromatic_dispersion` | 彩色折射着色器。对于默认着色器代码，打开新实例化的模块的锚。 |
| `texture_filters / blur_shader` | 模糊着色器。获取纹理并应用高斯模糊。您需要将`texOffset`设置为不相等的值(0，0)才能看到效果(尝试 0.02 这样的小值)。对于默认着色器代码，打开新实例化的模块的锚。 |

着色器是一个强大的概念。虽然这本书不能给出一个全面的介绍，但是你可以通过例子开始深入这个问题。

### 文本

文本相关的渲染器。路径是渲染器→文本。参见表 [8-169](#Tab169) 。

Table 8-169.

<colgroup><col> <col> <col> <col> <col></colgroup> 
| `text_s` | 在平面上书写字符串 |
| --- | --- |
| 在…里 | `text_in:string` | 正文 |
|   | `font_in:resource` | TTF 字体(附录*。ttf)来使用 |
| `render_type:enum` | 如果是位图，将文本渲染为位图，如果是多边形，则创建多边形来渲染文本。通常使用位图看起来更好。 |
|   | `align:enum` | 如何水平对齐多行文本？`LEFT`、`CENTER`或`RIGHT`中的一种。 |
| `limits / limit_align: float` | 如果大于 0.0，整数部分将从多行文本中选取一行(0 是第一行)。 |
| `appearance:complex` |   |
|   | `glyph_size:float` | 字形大小。将在字体数据中查找最匹配的字形集。 |
|   | `size:float` | 周围方框的大小。当您更改此项时，文本将自动缩放。 |
|   | `leading:float` | 文本行之间的距离 |
|   | `position:float3` | 周围盒子的位置 |
|   | `angle:float` | 周围框的旋转角度 |
|   | `rotation_axis: float3` | 周围盒子的旋转轴 |
|   | `text_alpha:float` | 【正文之 T0】 |
|   | `outline_alpha:float` | 如果在多边形模式下，轮廓的`ALPHA`通道倍增器 |
|   | `outline_color: float4` | 如果处于多边形模式，则为轮廓的颜色 |
|   | `outline_thickness: float` | 如果在多边形模式下，用于轮廓的线条粗细 |
|   | `color:complex` | 文本的颜色 |
|   |   | `red:float` | 红色 |
|   |   | `green:float` | 格林（姓氏）；绿色的 |
|   |   | `blue:float` | 蓝色 |
| 在外 | `render_out:render` | 渲染器输出 |

### 字母 X

一些额外的渲染程序。路径是 Renderers → Xtra。见表 [8-170](#Tab170) 至 [8-172](#Tab172) 。

Table 8-172.

<colgroup><col> <col> <col> <col></colgroup> 
| `skybox` | 为天空盒定制的特殊模块。将从单个输入位图生成六个位图，用于在立方体上进行映射。您可能需要将其连接到纹理→ opengl → bitmcubemap 模块，然后应用着色器代码并将纹理连接到`samplerCube`类型着色器变量。查看示例中的状态→天空盒 _ 彩色 |
| --- | --- |
| 在…里 | `bitmap:bitmap` | 输入位图 |
| 在外 | `render_out:render` | 渲染器输出。你不必用这个 |
| `bitmaps:complex` | 立方体上映射的六个位图 |
|   | `positive_x: bitmap` |
|   | `negative_x: bitmap` |
|   | `positive_y: bitmap` |
|   | `negative_y: bitmap` |
|   | `positive_z: bitmap` |
|   | `negative_z: bitmap` |

Table 8-171.

<colgroup><col> <col> <col></colgroup> 
| `gravity_` `ribbon` | 让丝带围绕中心点旋转。应用非牛顿引力定律:F = -q ∙(位置-中心)。请注意，该算法将向重力中心收缩，因此后者(即`pos`锚点)应该在可视化过程中发生变化。“网格→生成器→丝带”通常会给出比该模块更好的结果 |
| --- | --- |
| 在…里 | `pos:float3` | 重力中心 |
|   | `params:complex` |   |
| `length:float` | 丝带的长度 |
| `ribbon_width: float` | 色带的宽度 |
| `friction:float` | 应用于运动的摩擦力 |
|   | `step_length: float` | 每帧的平流。一旦增加该参数，色带将变得更快 |
| `color0:float4` | 起始颜色 |
| `color1:float4` | 最终颜色 |
| 在外 | `render_out: render` | 渲染器输出 |

Table 8-170.

<colgroup><col> <col> <col> <col></colgroup> 
| `gravity_lines` | 让 40 个质量围绕一个中心点旋转。应用非牛顿引力定律:F = -q ∙(位置-中心)。请注意，该算法将向重力中心崩溃，因此后者(`pos`锚)应该在可视化过程中发生变化。将质量的轨迹渲染为直线 |
| --- | --- |
| `In` | `pos:float3` | 重力中心 |
| `params:complex` |   |
|   | `friction:float` | 应用于运动的摩擦力 |
|   | `step_length: float` | 每帧的平流。一旦增加该参数，质量将变得更快 |
|   | `color0:float4` | 起始颜色 |
|   | `color1:float4` | 最终颜色 |
| `Out` | `render_out:rend er` | 渲染器输出 |

## 选择器

选择器允许通过编程从给定索引的一系列值中选择值。路径是选择器，然后参见表 [8-173](#Tab173) 到 [8-178](#Tab178) 。

Table 8-178.

<colgroup><col> <col> <col> <col> <col> <col></colgroup> 
| `texture_selector` | 从锚内部给出的纹理中选择`texture_x` |
| --- | --- |
| 在…里 | `index:float` | 选择哪个纹理。 |
| `inputs:enum` | 将提供多少纹理。0，1，2，…，16 中的一个 |
|   | `texture_x:complex` | 在这个复杂的锚点中，必须指定输入纹理 |
|   | `texture_0:texture` | 第一纹理 |
|   | `texture_1:texture` | 第二纹理 |
|   | … | 更多纹理 |
| `options:complex` |   |
|   | `wrap:enum` | 如果索引超出界限该怎么办:`Wrap`:环绕索引。例如，如果“inputs”= 3 且没有插值，则选择的纹理为:-1 → val3，0 → val1，1 → val2，2 → val3，3 → val0，…`None_zero`:无扭曲，将越界索引设置为空`None_freeze`:无环绕，设置为最接近的有效值 |
|   | `blend_type:enum` | 其中之一:`Snap`:当索引改变时在纹理之间突然切换—`Linear`:当索引改变时在相邻纹理之间线性混合。—`Sequence`:根据`sequence`锚融合 |
|   | `blend_options: complex` |   |
|   |   | `blend_size: enum` | 当混合时，创建自己的纹理。这是它的大小。8x8、16x16、32x32、64x64、128x128、256x256、512x512、1024x1024 或 2048x2048 中的一种 |
|   |   | `A_crossfade: complex` | 定义纹理 A 的交叉淡入淡出选项(索引下限) |
|   |   |   | `A_sequence: sequence` | 混合时，纹理 A 的序列调制`sequence`参数。 |
|   |   |   | `A_reverse: enum` | `Off`或`on`，是否颠倒顺序 |
|   |   |   | `A_reset_seq_ to_default:` | 扳机。如果`ok`，将交叉渐变序列重置为线性模式。 |
|   |   |   |   | `enum` |   |
|   |   | `B_cross-fade: complex` |   |
|   |   |   | `B_sequence: sequence` | 混合时纹理 B 的序列调制`sequence`参数。 |
|   |   |   | `B_reverse: enum` | `Off`或`on`，是否颠倒顺序。 |
|   |   |   | `B_reset_seq_ to_default: enum` | 扳机。如果`ok`，将最佳交叉渐变序列重置为线性模式。 |
|   | `sequence: sequence` | 仅当`blend_type`设置为`sequence`时，在索引从一个序列变为下一个序列时进行混合。可能被`blend_options`里面的序列进一步调制。 |
|   | `reverse:enum` | `Off`或`on`。如果`On`，且仅当`blend_type`设置为`sequence`，颠倒顺序。 |
|   | `reset_seq_to_ default:enum` | 如果设置为`ok`，触发器会将`sequence`重置为其默认值=线性。 |
| `shaders:complex` | 为了进一步微调纹理之间的混合 |
|   | `vertex_program: string` | 顶点着色器 |
|   | `fragment_program: string` | 片段着色器 |
|   | `shad_param1:float` | 着色器参数(制服) |
|   | `shad_param2:float` |
|   | `shad_param3:float` |
|   | `shad_param4:float` |
|   | `shad_param5:float` |
|   | `shad_param6:float` |
|   | `shad_param7:float` |
|   | `shad_param8:float` |
| 在外 | `result:texture` | 所选择的和可能插入的纹理 |

Table 8-177.

<colgroup><col> <col> <col> <col></colgroup> 
| `string_selector` | 从`string_x`内部锚点给出的字符串值中选择 |
| --- | --- |
| 在…里 | `index:float` | 要选择哪个字符串值。 |
| `inputs:enum` | 将提供多少个字符串值。0，1，2，…，16 中的一个 |
| `string_x:complex` | 在这个复杂的锚点中，必须指定输入字符串值 |
|   | `string_0:string` | 第一个值 |
|   | `string_1:string` | 第二个值 |
|   | `...` | 更多值 |
|   | `wrap:enum` | 如果索引超出界限该怎么办:`Wrap`:环绕索引。例如，如果“输入”= 3 且无插值，则选择的值为:-1 → val3，0 → val1，1 → val2，2 → val3，3 → val0，…`None_zero`:无扭曲，将偏离指数设置为“0.0”`None_freeze`:无环绕，设置为最接近的有效值 |
| 在外 | `result:string` | 选择的值 |

Table 8-176.

<colgroup><col> <col> <col> <col></colgroup> 
| `quaternion_selector` | 从`quaternion_x`内部锚点给出的四元数值中选择 |
| --- | --- |
| 在…里 | `index:float` | 要选择哪个四元数值 |
|   | `inputs:enum` | 将提供多少个四元数值。0，1，2，…，16 中的一个 |
| `quaternion_x: complex` | 在这个复合锚点中，必须指定输入四元数值 |
|   | `quaternion_0: quaternion` | 第一个值 |
|   | `quaternion_1: quaternion` | 第二个值 |
|   | `...` | 更多值 |
| `options:complex` |   |
|   | `wrap:enum` | 如果索引超出界限该怎么办:`Wrap`:环绕索引。例如，如果“输入”= 3 且没有插值，则选择的值为:-1 → val3，0 → val1，1 → val2，2 → val3，3 → val0，…`None_zero`:无扭曲，将偏离指数设置为 0.0`None_freeze`:无环绕，设置为最接近的有效值 |
|   | `interpolation: enum` | 以下之一:`None`:无插值。从输入`index`到所选索引的映射是舍入(inp)—`Linear`:从输入`index`到所选索引的映射是下限(InP)。小数部分进行线性插值`Sequence`:与线性相同，但使用给定的插值顺序 |
|   | `sequence: sequence` | 仅当`interpolation`被设置为`sequence`时，使用它来插入输入索引的小数部分。 |
|   | `reverse:enum` | 仅当`interpolation`设置为`sequence`:`Off`:无反转`On`:从右向左解释序列。T4:当数值下降时自动反转序列 T5:类似于 T6，但再次反转。 |
|   |   | `reset_seq_to_ default:enum` | 一个触发器。如果选择了`ok`，将`sequence`重置为默认余弦形状。 |
| 在外 | `result:quaternion` | 选择的和可能的插值 |

Table 8-175.

<colgroup><col> <col> <col> <col></colgroup> 
| `float_selector` | 从锚点`float_*`给出的浮点值中选择 |
| --- | --- |
| 在…里 | `index:float` | 要选择哪个浮点值。 |
|   | `inputs:enum` | 将提供多少浮点值。0，1，2，…，16 中的一个 |
| `float3_x:complex` | 在这个复杂的锚点中，必须指定输入的浮点值 |
|   | `float_0:float` | 第一个值 |
|   | `float_1:float` | 第二个值 |
|   | `...` | 更多值 |
|   | `options:complex` |   |
|   | `wrap:enum` | 如果索引超出界限该怎么办:`Wrap`:环绕索引。例如，如果“输入”= 3 且没有插值，则选择的值为:-1 → val3，0 → val1，1 → val2，2 → val3，3 → val0，…`None_zero`:无扭曲，将偏离指数设置为 0.0`None_freeze`:无环绕，设置为最接近的有效值 |
|   | `interpolation: enum` | 以下之一:`None`:无插值。从输入“索引”到所选索引的映射为:Round(InP)`Linear`:从输入“索引”到所选索引的映射为:Floor(inp)。小数部分进行线性插值`Sequence`:与线性相同，但使用给定的插值顺序 |
|   | `sequence:sequence` | 仅当`interpolation`被设置为`sequence`时，使用它来插入输入索引的小数部分。 |
|   | `reverse:enum` | 仅当`interpolation`设置为`sequence`:`Off`:无反转`On`:从右向左解释序列。T4:当数值下降时自动反转序列 T5:类似于 T6，但再次反转。 |
|   | `reset_seq_to_ default:enum` | 一个触发器。如果选择了`ok`，将`sequence`重置为默认余弦形状。 |
| 在外 | `result:float` | 选择的和可能的插值 |

Table 8-174.

<colgroup><col> <col> <col> <col></colgroup> 
| `float4_selector` | 从`float4_x`内部锚点给出的`float4`向量中选择 |
| --- | --- |
| 在…里 | `index:float` | 选择哪个`float4`值。 |
|   | `inputs:enum` | 将提供多少个`float4`值。0，1，2，…，16 中的一个 |
| `float3_x:complex` | 在这个复杂的锚点中，必须指定输入值`float4` |
|   | `float4_0:float4` | 第一个值 |
|   | `float4_1:float4` | 第二个值 |
|   | `...` | 更多值 |
| `options:complex` |   |
|   | `wrap:enum` | 如果索引超出界限该怎么办:`Wrap`:环绕索引。例如，如果“输入”= 3 且没有插值，则选择的值为:-1 → val3，0 → val1，1 → val2，2 → val3，3 → val0，…`None_zero`:无扭曲，将偏离指数设置为 0.0`None_freeze`:无环绕，设置为最接近的有效值 |
|   |   | `interpolation: enum` | 以下之一:`None`:无插值。从输入`index`到所选步进的映射为:舍入(inp)—`Linear`:从输入`index`到所选步进的映射为下限(InP)。小数部分进行线性插值`Sequence`:与线性相同，但使用给定的插值顺序 |
|   | `sequence:sequence` | 仅当`interpolation`被设置为`sequence`时，使用它来插入输入索引的小数部分。 |
|   | `reverse:enum` | 仅当`interpolation`设置为`sequence`:`Off`:无反转`On`:从右向左解释序列。T4:当数值下降时自动反转序列 T5:类似于 T6，但再次反转。 |
|   | `reset_seq_to_ default:enum` | 一个触发器。如果选择了`ok`，将`sequence`重置为默认余弦形状。 |
| 在外 | `result:float4` | 选择和可能计算的值 |

Table 8-173.

<colgroup><col> <col> <col> <col></colgroup> 
| `float3_selector` | 从锚`float3_*`给出的`float3`向量中选择 |
| --- | --- |
| 在…里 | `index:float` | 选择哪个`float3`值 |
| `inputs:enum` | 将提供多少个`float3`值。0，1，2，…，16 中的一个 |
| `float3_x:complex` | 在这个复杂的锚点中，必须指定输入值`float3` |
|   | `float3_0:float3` | 第一个值 |
|   | `float3_1:float3` | 第二个值 |
|   | `...` | 更多值 |
| `options:complex` |   |
|   | `wrap:enum` | 如果索引超出界限该怎么办:`Wrap`:环绕索引。例如，如果“输入”= 3 且没有插值，则选择的值为:-1 → val3，0 → val1，1 → val2，2 → val3，3 → val0，…`None_zero`:无扭曲，将偏离指数设置为 0.0`None_freeze`:无环绕，设置为最接近的有效值 |
|   | `interpolation: enum` | 以下之一:`None`:无插值。从输入“索引”到所选索引的映射为:Round(InP)`Linear`:从输入“索引”到所选索引的映射为:Floor(inp)。小数部分进行线性插值`Sequence`:与线性相同，但使用给定的插值顺序 |
|   |   | `sequence: sequence` | 仅当`interpolation`被设置为`sequence`时，使用它来插入输入索引的小数部分。 |
|   | `reverse:enum` | 仅当`interpolation`设置为`sequence`:`Off`:无反转`On`:从右向左解释序列。T4:当数值下降时自动反转序列 T5:类似于 T6，但再次反转。 |
|   | `reset_seq_to_ default:enum` | 一个触发器。如果选择了`ok`，将`sequence`重置为默认余弦形状。 |
| 在外 | `result:float3` | 选择的和可能的插值 |

## 声音

声音模块构建了传入声音的接口。

### 输入 _ 可视化 _ 监听器

监听传入的声音，并为其他模块提供数字输出。如果你想对音频输入做出反应，这是主要的输入模块，如果使用 GUI，你通常会把这个模块放在最左边。路径是声音→输入 _ 可视化 _ 监听器。

从技术上来说，它将使用快速傅立叶变换(FFT)算法将系统声音设备提供的基于时间的输入转换到频域，因此您将能够说出频率分布和频谱每个部分的音量。参见表 [8-179](#Tab179) 。

Table 8-179.

<colgroup><col> <col> <col> <col> <col></colgroup> 
| `input_ visualization_ listener` | 聆听传入的声音 |
| --- | --- |
| 在…里 | `multiplier:float` | 将来自系统音频设备的数据乘以某个数字。默认值为 1.0 |
| 在外 | `vu:complex` | 当前总幅度，由 FFT 结果的系数相加确定。两个数字的复合体，左右立体声通道。 |
|   |   | `vu_l:float` | 左立体声声道。介于 0.0 和 1.0 之间的浮点数 |
|   | `vu_r:float` | 右立体声声道。介于之间的浮点数 |
|   |   |   | 0.0 和 1.0。请注意，`vu_l`和`vu_r`目前是相同的，因为 FFT 只在左声道上运行，左声道的值被复制到右声道。 |
| `octaves:complex` | 基于粗略倍频程的频谱上的振幅。 |
|   | `left:complex` | 左立体声声道。 |
|   |   | `octaves_l_0` | 最低八度，大约从 F 到 f (midi 音调 41 到 53) |
|   |   | `octaves_l_1` | 这是中间 c 音(c' midi 音调 60)所在的位置。大约从 f 到 f’(midi 音调 53 到 65) |
|   |   | `octaves_l_2` | 大约从 f’到 f’’(midi 音调 65 到 77) |
|   |   | `octaves_l_3` | 大约从 f”到 f”’(midi 音调 77 到 89) |
|   |   | `octaves_l_4` | 大约从 f ' ' '到 f ' ' '(midi 音调 89 到 101) |
|   |   | `octaves_l_5` | 大约从 f ' ' ' '到 f ' ' ' '(midi 音调 101 到 113) |
|   |   | `octaves_l_6` | 大约从 f <sup>(5)</sup> 到 f <sup>(6)</sup> (midi 音调 113 直到 125) |
|   |   | `octaves_l_7` | 最高八度从 f <sup>(6)</sup> 到 f <sup>(7)</sup> |
|   | `right:complex` | 右立体声声道。请注意，右声道和左声道显示相同的数字，因为 FFT 仅在左声道上运行，其值仅复制到右声道数组。 |
|   |   | `octaves_r_0` | 最低八度音阶，见`octaves_l_0`的说明 |
|   |   | `octaves_r_1` | 参见`octaves_l_1`的描述 |
|   |   | `octaves_r_2` | 参见`octaves_l_2`的描述 |
|   |   | `octaves_r_3` | 参见`octaves_l_3`的描述 |
|   |   | `octaves_r_4` | 参见`octaves_l_4`的描述 |
|   |   | `octaves_r_5` | 参见`octaves_l_5`的描述 |
|   |   | `octaves_r_6` | 参见`octaves_l_6`的描述 |
|   |   |   | `octaves_r_7` | 最高八度音阶，见`octaves_l_7`的说明 |
| `wave:float_array` | 音频样本本身。包含左声道的样本数据的大小为 512 的数组。右声道被忽略。 |
| `spectrum: float_array` | 光谱。包含频率空间中的振幅的大小为 512 的数组。最初每个值的索引(i=0..511)对应于频率 i / 256 * 44100 / 2，但是我们希望具有相等的调谐范围，因此相应地重新索引。因此，最低值为 86 Hz (= F，midi 41)，最高值为 f <sup>(7)</sup> (超出 midi 范围)。这是八个八度音程或 96 个半音，因此该数组中的每个值对应 96 / 512 = 0.1875 个半音或 18.75 美分。请注意，由于 FFT 算法的性质，较低频率相当粗糙。 |

你可能会问为什么我们没有更低的八度音阶。这是算法所固有的；对于较低的八度音程，我们需要更大的音频计算缓冲区，更多的采样时间来减缓反应，以及更多的 CPU 能力。

### midi→aka _ APC 40 _ 控制器

这是一种在实时表演中专业使用 ThMAD 的硬件控制器。路径是声音 ath:is → aka_apc40_controller。参见表 [8-180](#Tab180) 。

Table 8-180.

<colgroup><col> <col></colgroup> 
| midi→aka _ APC 40 _ 控制器 | 连接到 Akai APC40 midi 控制器 |
| --- | --- |
| 有关参数，请查阅控制器手册。主播也因此得名。 |

### ogg_sample_*

Ogg Vorbis 声音文件格式播放器。路径是声音→ ogg_sample_。参见表 [8-181](#Tab181) 和 [8-182](#Tab182) 。

Table 8-182.

<colgroup><col> <col> <col></colgroup> 
| `ogg_sample_trigger` | 播放 Ogg Vorbis 格式的音频文件。有一个触发器，您可以应用增益和音高修改器 |
| --- | --- |
| 在…里 | `filename: resource` | 要播放的 OGG·沃尔比斯文件 |
| `trigger:float` | 1.0 或以上时开始播放。0.0 或以下时停止播放。播放时，定义速度(> 1 为快，< 1 为慢) |
| `pitch:float` | 另一种改变播放速度(和音高)的方法。设定 0 保持不变(仍然“触发”≠ 1 将改变速度和音高) |
| `gain:float` | 音量增益控制 |

Table 8-181.

<colgroup><col> <col> <col></colgroup> 
| `ogg_sample_play` | 播放 Ogg Vorbis 格式的音频文件。你应该能听到它，而且数据也传到了`input_visualization_listener`。当配置或 ThMAD 启动时，立即开始回放。如果需要触发回放，使用模块`ogg_sample_trigger` |
| --- | --- |
| 在…里 | `filename: resource` | 要播放的 OGG·沃尔比斯文件 |
|   | `format:enum` | 单声道或立体声 |

### 原始样本 _*

Raw 表示无头声音文件，即所有字节都是未压缩的 PCM 声音数据。所需的格式是带符号的 int 16 位 little endian。

例如，您可以使用软件`ffmpeg`创建原始文件。例如，如果您有一个 WAV 文件，您可以通过在终端中输入以下内容将其转换为合适的 RAW 文件:

```sh
ffmpeg -i a.wav -f s16le -acodec
pcm_s16le a.raw

```

路径是声音→ raw_sample_。参见表 [8-183](#Tab183) 和 [8-184](#Tab184) 。

Table 8-184.

<colgroup><col> <col> <col></colgroup> 
| `raw_sample_trigger` | 以 raw 格式播放音频文件。有一个触发器，您可以应用增益和音高修改器 |
| --- | --- |
| 在…里 | `filename:resource` | 要播放的原始文件。 |
|   | `trigger:float` | 1.0 或以上时开始播放。0.0 或以下时停止播放。播放时，定义速度(> 1 为快，< 1 为慢) |
| `pitch:float` | 另一种改变播放速度(和音高)的方法。设定 0 保持不变(仍然“触发”≠ 1 将改变速度和音高) |
| `gain:float` | 音量增益控制 |

Table 8-183.

<colgroup><col> <col> <col></colgroup> 
| `raw_sample_play` | 以 raw 格式播放音频文件。你应该能听到它，而且数据也传到了`input_visualization_listener`。当配置或 ThMAD 启动时，立即开始回放。如果需要触发回放，使用模块`raw_sample_trigger`。 |
| --- | --- |
| 在…里 | `filename:resource` | 要播放的原始文件 |
|   | `format:enum` | 单声道或立体声 |

## 用线串

字符串相关模块。路径为字符串，则参见表 [8-185](#Tab185) 和 [8-186](#Tab186) 。

Table 8-186.

<colgroup><col> <col> <col></colgroup> 
| `res_to_str` | 使用它从资源中获取路径。会输出类似`resources/my.png`的东西 |
| --- | --- |
| 在…里 | `resource_in:resource` | 资源 |
| 在外 | `string_out:string` | 资源路径 |

Table 8-185.

<colgroup><col> <col> <col></colgroup> 
| `float_to_string` | 将浮点转换为字符串 |
| --- | --- |
| 在…里 | `float_in:float` | 浮点输入 |
| `precision:float` | 小数点分隔符后显示的位数 |
| 在外 | `string_out:string` | 字符串表示形式 |

### 系统

系统级模块。路径为系统，则参见表 [8-187](#Tab187) 至 [8-198](#Tab198) 。

Table 8-198.

<colgroup><col> <col> <col> <col></colgroup> 
| `visual_fader` | 一个推子模块，专门用于播放器内部的视觉过渡。使用 ThMAD 播放器的 New → Transition 来查看如何使用它 |
| --- | --- |
| 在…里 | `texture_a_in: texture` | 不要使用 |
| `texture_b_in: texture` | 不要使用 |
| `fade_pos_in: float` | 不要使用 |
| `options:complex` |   |
|   | `transition_ length:float` | 转换需要多少秒 |
| 在外 | `texture_a_out: texture` | 淡出的纹理，即淡出的视觉 |
| `texture_b_out: texture` | 淡入的纹理，即淡入的视觉效果 |
| `fade_pos_out: float` | 内[0.0；1.0]，我们处于过渡阶段的哪个阶段 |

Table 8-197.

<colgroup><col> <col> <col></colgroup> 
| `viewport_size` | 使用它来确定以像素为单位的实际图形输出大小。你通常不使用它，因为大多数坐标是相对的 |
| --- | --- |
| 在外 | `vx:float` | 像素宽度 |
| `vy:float` | 像素高度 |

Table 8-196.

<colgroup><col> <col> <col> <col></colgroup> 
| `to_console` | 定期将值写入控制台。仅适用于艺术家或播放器从控制台启动的情况 |
| --- | --- |
| 在…里 | `out_id:string` | 如果设置，将该字符串添加到控制台输出中 |
|   | `enabled:enum` | `no`或`yes`之一 |
| `show_each:float` | 以秒为单位的输出频率。如果设置为 1.0，输出每一帧将降低 ThMAD。也许设置为 60 或类似的东西 |
| `params:complex` |   |
|   | `show_float: enum` | `no`或`yes`之一。是否打印该值 |
|   | `in_float:float` | 输入浮动 |
|   | `show_float3: enum` | `no`或`yes`之一。是否打印该值 |
|   | `in_float3:float3` | 输入浮动 3 |
|   | `show_float4: enum` | `no`或`yes`之一。是否打印该值 |
|   | `in_float4:float4` | 输入浮动 4 |
|   | `show_ quaternion: enum` | `no`或`yes`之一。是否打印该值 |
|   |   | `in_quaternion: quaternion` | 输入四元数 |

Table 8-195.

<colgroup><col> <col> <col> <col></colgroup> 
| `time` | 告知操作系统时间和排序时间 |
| --- | --- |
| 在外 | `normal:complex` | 时序定时器。 |
|   | `time:float` | 排序时间 |
|   | `dtime:float` | 使用时序定时器计算当前帧和前一帧之间的时间差。 |
| `real:complex` | 操作系统定时器 |
|   | `r_time:float` | 操作系统时间 |
|   | `r_dtime:float` | 使用操作系统计时器计算当前帧和前一帧之间的时间差。 |

Table 8-194.

<colgroup><col> <col> <col></colgroup> 
| `system_sequencer_ control` | 控制时序时间，时序时间是系统时钟的替代时序概念。在 GUI 中，将它放在任何可以使用的地方。该模块没有输出，但控制发动机的内部状态 |
| --- | --- |
| 在…里 | `trig_play:float` | 如果尚未播放，将其值从 0.0 或以下更改为正值会触发播放事件。如果已经在玩了，什么都不做。如果事件被触发，则启动时序计时器(即，现实世界中的一秒将在时序计时器中显示为一秒)。如果事件被触发，且`trig_set_time`为 0 或更小，时序定时器将在其最后一个值启动。否则，从`trig_set_time`给定的值开始。 |
|   | `trig_stop:float` | 如果尚未停止，将其值从 0.0 或以下更改为正值会触发停止事件。时序控制时间停止在其最新值，不再前进。稍后可以使用`trig_play`触发器重启。 |
|   | `trig_rewind:float` | 如果当前正在运行，将其值从 0.0 或以下更改为正值会触发一个回滚事件。如果`trig_set_time`为 0 或更小，将顺序定时器改为 0.0。如果`trig_set_time`大于零，将顺序计时器更改为`trig_set_time`。在这两种情况下都会停止引擎(不再推进排序时间) |
|   | `trig_set_time: float` | 控制发动机倒带或重启时的数值。 |

Table 8-193.

<colgroup><col> <col> <col></colgroup> 
| `state_loader` | 加载一个*。vsx 文件转换到当前状态 |
| --- | --- |
| 在…里 | `filename: resource` | *。vsx 文件。如果使用 state_loader，ThMAD 将文件视为资源，因此它必须位于`/home/[USER]/thmad/ [VERSION]/data/resources`文件夹中。 |
| 在外 | `render_out: render` | 此加载状态的输出。 |

Table 8-192.

<colgroup><col> <col> <col></colgroup> 
| `shutdown` | 如果输入超过 1.0，程序关闭 ThMAD。请注意，如果在 Artiste 中使用，它不会处理您状态中未保存的更改 |
| --- | --- |
| 在…里 | `shutdown:float` | 当该值达到或超过 1.0 时，执行 ThMAD(艺术家或播放器)的无条件关闭 |

Table 8-191.

<colgroup><col> <col> <col> <col> <col></colgroup> 
| `joystick` | 从系统设备访问操纵杆输入`/dev/js*` |
| --- | --- |
| 在外 | `joystick_0: complex` | 第一个操纵杆(仅当连接时，否则锚点不存在) |
|   |   | `j_0_name: string` | 操纵杆的名称(如果系统可以确定的话) |
|   | `axes:complex` |   |
|   |   |   | `j_0_axis0: float` | 第一轴 |
|   |   | `j_0_axis1: float` | 第二个轴(如果存在) |
|   |   | `…` | 可能有更多的轴 |
|   | `buttons: complex` |   |
|   |   | `j_0_button0: float` | 第一个按钮状态 |
|   |   | `j_0_button1: float` | 第二个按钮状态(如果存在) |
|   |   | … | 可能更多的按钮 |
| `joystick_1: complex` | 第二个操纵杆(只有连接，否则锚点不存在)。类似于`joystick_0`的子锚 |
| … | 更多操纵杆(动态检测) |

Table 8-190.

<colgroup><col> <col> <col></colgroup> 
| 文件系统→文件选择器 | 允许在给定路径的情况下动态选择资源 |
| --- | --- |
| 在…里 | `directory_path: string` | 在`/home/[USER]/thmad/ [VERSION]/data`里面选择哪个目录所有的文件包括里面的子文件夹里的文件都会被考虑进去！ |
| `file_id:float` | 从所有找到的文件中选择哪个文件 |
| 在外 | `filename_result: resource` | 选择的资源 |
| `filename_count: float` | 实际找到的文件数 |

Table 8-189.

<colgroup><col> <col> <col> <col></colgroup> 
| `clock` | 允许访问系统时钟 |
| --- | --- |
| 在外 | `clock:complex` |   |
|   |   | `year:float` | 年份减去 1900 年 |
|   | `month:float` | 月，0 =一月 |
|   | `dayofweek:` | 星期几，0 到 6，0 =星期日 |
|   |   | `float` |   |
|   | `day:float` | 一个月中的第一天，1，…，31 |
|   | `hour:float` | 一天中的小时，整数部分= 0，…，23。包含小时的分数！ |
|   | `hour12:float` | 一天中的小时，整数部分= 0，…，11。包含小时的分数！ |
|   | `minute:float` | 一小时中的分钟。包含分钟的分数！ |
|   | `second:float` | 分分秒秒。包含秒的分数！ |
|   | `millisecond: float` | 毫秒级秒。包含毫秒的分数！ |

Table 8-188.

<colgroup><col> <col> <col></colgroup> 
| `blocker_loading` | 仅在加载 ThMAD 时呈现子管道 |
| --- | --- |
| 在…里 | `render_in: render` | 渲染器输入 |
| `fadeout_time: float` | ThMAD 加载开始后不要阻塞那么多秒。然后屏蔽。 |
| 在外 | `render_out: render` | 渲染器输出 |
| `fadeout_out: float` | 会从 1.0 线性下降到 0.0。当达到 0.0 时，开始阻塞。 |

Table 8-187.

<colgroup><col> <col> <col></colgroup> 
| `blocker` | 使用它有条件地阻止渲染子管道运行 |
| --- | --- |
| 在…里 | `render_in: render` | 渲染器输入 |
| `block:float` | 如果该值小于 0.5，则阻塞子管道。如果等于或大于 0.5，让它运行 |
| 在外 | `render_out: render` | 渲染器输出 |

## 纹理

纹理是存在于图形硬件中的图像。它们对于实时图形处理非常重要。

### 缓冲

纹理缓冲区允许将渲染像素数据发送到图形硬件上的缓冲区，以便快速渲染。路径是纹理→缓冲区。见表 [8-199](#Tab199) 至 [8-202](#Tab202) 。

Table 8-202.

<colgroup><col> <col> <col> <col></colgroup> 
| `render_surface_single` | 包含颜色和深度数据的缓冲区。允许反馈，即子流水线中稍后的渲染可以反馈到该模块的输入。纹理不使用小中见大贴图，对放大和缩小都使用“线性”过滤(纹理像素比颜色缓冲像素大或小),并将两个坐标夹到边缘进行环绕 |
| --- | --- |
| 在…里 | `render_in:render` | 我们希望在图形硬件上保存为纹理的图形数据 |
|   | `options:complex` |   |
|   | `texture_size: enum` | 尺寸。4x4、8x8、16x16、32x32、64x64、128x128、256x256、512x512、1024x1024 或 2048x2048 中的一种—`VIEWPORT_SIZE`:视窗大小的一半—`VIEWPORT_SIZE_DIV_2`:视窗大小的四分之一—`VIEWPORT_SIZE_x2`:视窗大小的两倍—`VIEWPORT_SIZE_x4`:视窗大小的四倍 |
|   |   | `size_x:float` | 仅当`texture_size`设置为`CUSTOM_SIZE`时，使用该尺寸 |
|   | `size_y:float` |
|   | `support_feedback: enum` | `no`或`yes`之一。只有启用，反馈才是可能的。 |
|   | `float_texture:enum` | `no`或`yes`之一。如果`yes`，使用浮动纹理代替。对于着色器代码尤其有趣。 |
|   | `alpha_channel: enum` | `no`或`yes`之一。如果`yes`，启用纹理内部的`ALPHA`通道。 |
|   | `clear_color:float4` | 使用的透明颜色 |
| 在外 | `texture_out:texture` | 输出纹理，即指向图形硬件上的数据缓冲区的指针 |

Table 8-201.

<colgroup><col> <col> <col> <col></colgroup> 
| `render_surface_color_ depth_buffer` | 一种缓冲器，可以使用单独的共享深度深度缓冲器，也可以单独输出深度缓冲器 |
| --- | --- |
| 在…里 | `render_in:render` | 我们希望在图形硬件上保存为纹理的图形数据 |
|   | `depth_buffer: texture` | 如果已连接，要使用的深度缓冲区。必须与此模块中的 size 参数指定的大小相同 |
| `options:complex` |   |
|   | `texture_size: enum` | 尺寸。4x4、8x8、16x16、32x32、64x64、128x128、256x256、512x512、1024x1024 或 2048x2048 之一`VIEWPORT_SIZE`:视窗大小`VIEWPORT_SIZE_DIV_2`:视窗大小的一半`VIEWPORT_SIZE_DIV_4`:视窗大小的四分之一`VIEWPORT_SIZE_x2`:视窗大小的两倍`VIEWPORT_SIZE_x4`:视窗大小的四倍 |
|   | `size_x:float` | 仅当`texture_size`设置为`CUSTOM_SIZE`时，使用该尺寸 |
|   | `size_y:float` |   |
|   |   | `float_texture: enum` | `no`或`yes`之一。如果`yes`，使用浮动纹理代替。对于着色器代码尤其有趣。 |
|   | `alpha_channel: enum` | `no`或`yes`之一。如果`yes`，启用纹理内部的`ALPHA`通道。 |
| 在外 | `color_buffer: texture` | 仅输出纹理、颜色缓冲区 |
|   | `depth_buffer: texture` | 输出深度缓冲区。可以与其他`render_surface_color_depth_buffer`模块共享。 |

Table 8-200.

<colgroup><col> <col> <col> <col></colgroup> 
| `render_surface_color_ buffer` | 一个颜色缓冲器，类似于模块`render_buffer`，但是没有深度缓冲器 |
| --- | --- |
| 在…里 | `render_in:render` | 我们希望在图形硬件上保存为纹理的图形数据 |
|   | `options:complex` |   |
|   | `texture_size: enum` | 尺寸。4x4、8x8、16x16、32x32、64x64、128x128、256x256、512x512、1024x1024 或 2048x2048 中的一种—`VIEWPORT_SIZE`:视窗大小的一半—`VIEWPORT_SIZE_DIV_2`:视窗大小的四分之一—`VIEWPORT_SIZE_x2`:视窗大小的两倍—`VIEWPORT_SIZE_x4`:视窗大小的四倍 |
|   | `size_x:float` | 仅当`texture_size`设置为 |
|   |   |   | `CUSTOM_SIZE`，使用这个尺寸 |
|   | `size_y:float` |   |
|   | `float_texture: enum` | `no`或`yes`之一。如果`yes`，使用浮动纹理代替。对于着色器代码尤其有趣。 |
|   | `alpha_channel: enum` | `no`或`yes`之一。如果`yes`，启用纹理内部的`ALPHA`通道。 |
| 在外 | `color_buffer: texture` | 输出纹理，即指向图形硬件上的数据缓冲区的指针 |

Table 8-199.

<colgroup><col> <col> <col> <col></colgroup> 
| `render_buffer` | 代表一种纹理。渲染其输入子管道，并将结果存储在纹理中。数据将保留在那里，即使呈现输入被停用或甚至被移除。纹理不使用小中见大贴图，对放大和缩小都使用“最近的”过滤(纹理像素比颜色缓冲像素大或小),并将两个坐标夹到边缘进行环绕 |
| --- | --- |
| 在…里 | `render_in:render` | 我们希望在图形硬件上保存为纹理的图形数据 |
|   | `options:complex` |   |
|   | `texture_size: enum` | 尺寸。4x4、8x8、16x16、32x32、64x64、128x128、256x256、512x512、1024x1024 或 2048x2048 中的一种—`VIEWPORT_SIZE`:视窗大小的一半—`VIEWPORT_SIZE_DIV_2`:视窗大小的四分之一—`VIEWPORT_SIZE_x2`:视窗大小的两倍—`VIEWPORT_SIZE_x4`:视窗大小的四倍 |
|   |   | `size_x:float` | 仅当`texture_size`设置为`CUSTOM_SIZE`时，使用该尺寸 |
|   | `size_y:float` |
|   | `float_texture: enum` | `no`或`yes`之一。如果`yes`，使用浮动纹理代替。对于着色器代码尤其有趣。 |
|   | `alpha_channel: enum` | `no`或`yes`之一。如果`yes`，启用纹理内部的`ALPHA`通道。 |
|   | `multisample: enum` | `no`或`yes`之一。如果`yes`，启用多级采样，提高像素边缘和角落颜色过渡的平滑度。 |
| 在外 | `texture_out:texture` | 输出纹理，即指向图形硬件上的数据缓冲区的指针 |

### 仿制品

虚拟模块。路径是纹理→假人。参见表 [8-203](#Tab203) 。

Table 8-203.

<colgroup><col> <col> <col></colgroup> 
| `texture_dummy` | 假人；只是让纹理通过。例如在宏内部很有用 |
| --- | --- |
| 在…里 | `texture_in: texture` | 输入纹理 |
| 在外 | `texture_out: texture` | 输出纹理 |

### 效果

纹理效果。路径是纹理→效果。参见表 [8-204](#Tab204) 和 [8-205](#Tab205) 。

Table 8-205.

<colgroup><col> <col> <col></colgroup> 
| `highblur` | 精心制作的模糊效果。使用阴影代码，仅在反馈子管道中使用时有效 |
| --- | --- |
| 在…里 | `texture_in: texture` | 要模糊的输入纹理 |
|   | `translation:float` | 效果的平移部分 |
|   | `blowup_center: float3` | 效果缩放(放大)部分的中心 |
| `blowup_rate: float` | 效果缩放(放大)部分的强度。越高，影响越小。 |
| `texture_size: enum` | 尺寸。4x4、8x8、16x16、32x32、64x64、128x128、256x256、512x512、1024x1024 或 2048x2048 之一`VIEWPORT_SIZE`:视窗大小`VIEWPORT_SIZE_DIV_2`:视窗大小的一半`VIEWPORT_SIZE_DIV_4`:视窗大小的四分之一`VIEWPORT_SIZE_x2`:视窗大小的两倍 |
| 在外 | `texture_out: texture` | 输出纹理 |

Table 8-204.

<colgroup><col> <col> <col></colgroup> 
| `blur` | 模糊不清。使用内部着色器来模糊输入纹理。如果你想获得一个光晕，你可能想要混合同一张图像的一个未模糊和一个模糊版本 |
| --- | --- |
| 在…里 | `glow_source: texture` | 输入纹理。 |
| `start_value:float` | 效果的强度。越高越模糊。 |
| `attenuation:float` | 输出发生前应用的衰减系数。 |
| `texture_size: enum` | 尺寸。4x4、8x8、16x16、32x32、64x64、128x128、256x256、512x512、1024x1024 或 2048x2048 之一`VIEWPORT_SIZE`:视窗大小`VIEWPORT_SIZE_DIV_2`:视窗大小的一半`VIEWPORT_SIZE_DIV_4`:视窗大小的四分之一`VIEWPORT_SIZE_x2`:视窗大小的两倍 |
| `passes:enum` | `ONE`或`TWO`之一。涂两遍大大增强了效果。 |
| 在外 | `texture_out: texture` | 输出纹理 |

### 装载机

接收和发送纹理数据。路径是纹理→加载器。见表 [8-206](#Tab206) 至 [8-211](#Tab211) 。

Table 8-211.

<colgroup><col> <col> <col></colgroup> 
| `texture2bitmap` | 从图形硬件加载纹理，并提供位图形式的数据访问 |
| --- | --- |
| 在…里 | `texture_in: texture` | 输入纹理 |
| 在外 | `bitmap:bitmap` | 位图 |

Table 8-210.

<colgroup><col> <col> <col></colgroup> 
| `png_tex_load` | 加载一个 PNG 文件，并将其作为纹理发送到图形硬件 |
| --- | --- |
| 在…里 | `filename:resource` | PNG 文件。必须位于`/home/[USER]/thmad/ [VERSION]/data/resources`文件夹内 |
|   | `reload:enum` | 一个触发器。如果选择了`yes`，一旦从文件中重新加载数据 |
| 在外 | `texture:texture` | 指向纹理的指针 |
| `bitmap:bitmap` | 如果你还需要位图，它就在这里 |

Table 8-209.

<colgroup><col> <col></colgroup> 
| `png_cubemap_load` | 正在开发中，目前尚未投入使用。 |

Table 8-208.

<colgroup><col> <col> <col></colgroup> 
| `jpeg_tex_load_alpha` | JPEGs 没有`ALPHA`通道。但是您可以使用这个模块并提供同样大小的第二个 JPEG，将它的灰度值映射到输出图像的`ALPHA` |
| --- | --- |
| 在…里 | `filename_rgb: resource` | RGB 数据 |
| `filename_alpha: resource` | `ALPHA`数据 |
| 在外 | `texture:texture` | 指向纹理的指针 |
| `bitmap:bitmap` | 如果您需要，该模块还提供了位图形式的图像 |

Table 8-207.

<colgroup><col> <col> <col></colgroup> 
| `jpeg_tex_load` | 加载 JPEG 并将像素数据作为纹理发送到图形硬件 |
| --- | --- |
| 在…里 | `filename: resource` | 要加载的 JPEG 文件。请注意，JPEGs 没有`ALPHA`通道 |
| 在外 | `texture:texture` | 指向纹理的指针 |
| `bitmap:bitmap` | 如果您需要，该模块还提供了位图形式的图像 |

Table 8-206.

<colgroup><col> <col> <col></colgroup> 
| `bitmap2texture` | 将位图转换为纹理。意味着位图作为纹理上传到图形硬件 |
| --- | --- |
| 在…里 | `bitmap:bitmap` | 输入位图。 |
| `mipmaps:enum` | `no`或`yes`之一。是否使用小中见大贴图，这意味着硬件将保持纹理数据的缩小版本，以便在不需要高度分辨率的情况下更快地渲染。 |
| 在外 | `texture:texture` | 输出纹理 |

### 修饰语

这些操作直接发生在图形硬件上，因此它们是快速操作。路径是纹理→修改器。见表 [8-212](#Tab212) 至 [8-216](#Tab216) 。

Table 8-216.

<colgroup><col> <col> <col></colgroup> 
| 翻译 | 平移纹理 |
| --- | --- |
| 在…里 | `texture_in:texture` | 输入纹理 |
| `translation_vector: float3` | 平移向量。第三个坐标被忽略。 |
| 在外 | `texture_translate_ out:texture` | 输出纹理 |

Table 8-215.

<colgroup><col> <col> <col> <col></colgroup> 
| `tex_parameters` | 纹理参数 |
| --- | --- |
| 在…里 | `texture_in:texture` | 输入纹理 |
|   | `parameters: complex` |   |
|   | `wrap_s:enum` | 如果越界，则第一个纹理坐标的环绕模式:`repeat`:重复纹理】`clamp`:使用纹理的最后一个像素；由于插值可能会显示伪像`clamp_to_edge`:将纹理坐标固定为[0+t/2；1-t/2]其中 t 是纹理元素的宽度/高度(纹理像素)—`clamp_to_border`:将纹理坐标箝位到[0-t/2；1+t/2]其中 t 是纹理像素宽度/高度(纹理像素)—`mirrored_repeat`:重复，即仅取纹理坐标的小数部分，但交替切换[0；1]到[1；0] |
|   | `wrap_t:enum` | 如果超出界限，第一个纹理坐标的环绕模式，值与`wrap_s`相同 |
|   | `border_color: float4` | 指定边框颜色 |
|   | `anisotropic_ filtering:enum` | `no`或`yes`之一。是否使用各向异性过滤。如果`yes`，提高插值质量，但代价是性能 |
|   | `min_filter:enum` | 如果一个纹理元素(纹理像素)比它映射到的区域小，该怎么办。其中之一:`nearest`:使用最近的纹理元素的值，从正在纹理化的像素的中心测量—`linear`:在相邻纹理像素之间应用线性插值—`nearest_mipmap_nearest`:首先选择一个与像素大小最匹配的小中见大贴图，然后按照“最近的”进行处理—`linear_mipmap_nearest`:在两个最匹配的小中见大贴图之间进行线性插值，然后按照“最近的”进行处理。`nearest_mipmap_linear`:首先选择一个与像素大小最匹配的小中见大贴图，然后按照“线性”进行处理`linear_mipmap_linear`:在两个最匹配的小中见大贴图之间进行线性插值，然后按照“最近”进行处理。 |
|   | `mag_filter: enum` | 如果一个纹理像素比它所映射的区域大，该怎么办。其中之一:`nearest`:使用最接近纹理像素中心(曼哈顿距离)的纹理元素值。`linear`:在四个相邻纹理像素之间进行线性插值。 |
| 在外 | `texture_out: texture` | 输出纹理 |

Table 8-214.

<colgroup><col> <col> <col> <col></colgroup> 
| `scale_one` | 与`scale`相同，但对两个纹理坐标使用一个比例因子 |
| --- | --- |
| 在…里 | `texture_in:texture` | 输入纹理 |
|   | `scale_vector:float3` | 坐标的缩放比例。第三个坐标被忽略。 |
| `center:complex` |   |
|   | `use_scale_center:` `enum` | `yes`或`no`，是否指定了缩放中心(否则缩放发生在(0；0 ),也就是 |
|   |   |   | 大概不是你想要的)。 |
|   | `scale_center: float3` | 缩放中心。点(0.5；0.5)位于中间。第三个坐标被忽略。 |
| 在外 | `texture_scale_out: texture` | 缩放纹理 |

Table 8-213.

<colgroup><col> <col> <col> <col></colgroup> 
| 规模 | 缩放纹理 |
| --- | --- |
| 在…里 | `texture_in: texture` | 输入纹理 |
| `scale_vector: float3` | 所有坐标的缩放比例。第三个坐标被忽略。 |
| `center:complex` |   |
|   | `use_scale_ center:enum` | `yes`或`no`，是否指定了缩放中心(否则缩放发生在(0；0)在纹理坐标中，这很可能不是你想要的)。 |
|   | `scale_center: float3` | 缩放中心。点(0.5；0.5)位于中间。第三个坐标被忽略。 |
| 在外 | `texture_scale_ out:texture` | 缩放纹理 |

Table 8-212.

<colgroup><col> <col> <col> <col></colgroup> 
| `rotate` | 旋转纹理。 |
| --- | --- |
| 在…里 | `texture_in: texture` | 输入纹理 |
|   | `rotation_angle: float` | 旋转角度 |
| `rotation_axis: float3` | 旋转轴 |
| `center:complex` |   |
|   | `use_rotate_ center:enum` | `yes`或`no`，是否指定了旋转中心(否则围绕(0；0 ),也就是 |
|   |   |   | 大概不是你想要的)。 |
|   | `rotate_center: float3` | 旋转中心。点(0.5；0.5)位于中间。第三个坐标被忽略。 |
| 在外 | `texture_rotate_ out:texture` | 旋转纹理 |

### 计算机图形学

接近 OpenGL 标准功能的操作。路径是纹理→ OpenGL。见表 [8-217](#Tab217) 至 [8-219](#Tab219) 。

Table 8-219.

<colgroup><col> <col> <col></colgroup> 
| `texture_coord_gen` | 让 OpenGL 为对象提供纹理坐标(用于纹理映射)。 |
| --- | --- |
| 在…里 | `render_in:render` | 渲染器输入 |
| `gen_s:enum` | 如何生成第一个纹理坐标 |
| `gen_t:enum` | 如何生成第二个纹理坐标 |
| `gen_r:enum` | 如何生成第三个纹理坐标？可能没用过，因为 ThMAD 不支持 3D 纹理 |
| `parameter_s: float3` | 第一个坐标映射的参数(如果适用) |
| `parameter_t: float3` | 第二个坐标映射的参数(如果适用) |
| `parameter_r: float3` | 第三坐标映射的参数(如果适用) |
| 在外 | `render_out: render` | 渲染器输出 |

Table 8-218.

<colgroup><col> <col> <col></colgroup> 
| `texture_bind` | 为不提供自身纹理的对象提供纹理。请注意，如果纹理坐标设置正确，它取决于管道中较早的模块。所以如果你使用这个模块，绑定一个纹理到提供他们自己纹理的模块可能会导致一个未定义的行为 |
| --- | --- |
| 在…里 | `render_in: render` | 渲染器输入 |
|   | `tex_in:texture` | 要绑定的纹理 |
| 在外 | `render_out: ren` der | 渲染器输出 |

Table 8-217.

<colgroup><col> <col> <col> <col></colgroup> 
| `6bitm2cubemap` | 立方体贴图在立方体的表面上映射六个面。例如，您可以将渲染器→ xtra →天空盒模块的输出连接到该模块，然后在管道中使用着色器进行渲染 |
| --- | --- |
| 在…里 | `bitmaps:complex` | 位图 |
|   | `positive_x:bitmap` |
|   | `negative_x:bitmap` |
|   | `positive_y:bitmap` |
|   | `negative_y:bitmap` |
|   | `positive_z:bitmap` |
|   | `negative_z:bitmap` |
| 在外 | `texture_out:texture` | 输出纹理 |

根据输入参数，以下机制适用:

*   `Enumeration gen_* = OFF: no generation`
*   `Enumeration gen_* = OBJECT_LINEAR:`

他们应用这个函数:

*   g = p〖t1〗x〖T2〗0〗T3〗p〖T2〗2〖t5〗y〖T6〗0〖T7〗p〖t8〗3〖T9〗z〖T10〗

其中(x <sub>0</sub> ，y <sub>0</sub> ，z <sub>0</sub> ，w <sub>0</sub> )为对象坐标，p <sub>i</sub> 为对应`parameter_*`锚点中提供的参数。然后`g`就是纹理坐标值。这在数学上描述了到参数锚中提供的向量的投影，并测量到原点的距离。

*   `Enumeration gen_* = EYE_LINEAR:`

类似于`OBJECT_LINEAR`，但是`p`首先乘以模型视图矩阵的逆矩阵。这意味着计算将跟随相机的位置

*   `Enumeration gen_* = SPHERE_MAP`:纹理坐标的生成方式使物体看起来像是在反映纹理像素数据。
*   `Enumeration gen_* = NORMAL_MAP or REFLECTION_MAP`:指立方体贴图，其中纹理表示立方体的六个面。法线的计算方式取决于纹理数据的解释，这与`NORMAL_MAP`和`REFLECTION_MAP`不同。细节相当复杂，因此要求读者查阅 OpenGL 教程或文档，这些可以在网上找到。

### 微粒

几个人造纹理，可以用于粒子系统，也可以用于其他目的。路径是纹理→粒子。参见表 [8-220](#Tab220) 和 [8-221](#Tab221) 。

Table 8-221.

<colgroup><col> <col> <col> <col></colgroup> 
| `concentric_circles` | 生成带有同心圆的纹理 |
| --- | --- |
| `In` | `settings:complex` |   |
|   | `frequency:float` | 控制圆之间的间距 |
|   | `attenuation:float` | 控制圆的清晰度 |
|   | `color:float4` | 要使用的颜色 |
|   | `alpha:enum` | `no`或`yes`之一。如果是`yes`，使用`ALPHA`创建形状的透明度。否则，将颜色值与`color`中给出的`ALPHA`相乘，并让输出`ALPHA` = 1.0 |
| `size:enum` | 8x8、16x16、32x32、64x64、128x128、256x256、512x512、1024x1024 或 2048x2048 中的一种 |
| `Out` | `texture:texture` | 指向图形硬件上纹理的指针 |

Table 8-220.

<colgroup><col> <col> <col> <col></colgroup> 
| `blob` | 斑点、星形或树叶，具体取决于设置 |
| --- | --- |
| 在…里 | `settings:complex` |   |
|   | `arms:float` | 如果你想要一颗星星或树叶，手臂的数量 |
|   | `attenuation: float` | 增加该数值以降低模糊度 |
|   | `star_flower: float` | 增加该数值以使中心部分变薄，如花瓣 |
|   | `angle:float` | 在此指定旋转角度 |
|   | `color:float4` | 要使用的颜色 |
|   | `alpha:enum` | `no`或`yes`之一。如果是`yes`，使用`ALPHA`创建形状的透明度。否则，用`color`中给出的`ALPHA`预乘颜色值，并让输出`ALPHA = 1.0`无处不在 |
| `size:enum` | 8x8、16x16、32x32、64x64、128x128、256x256、512x512、1024x1024 或 2048x2048 中的一种 |
| 在外 | `texture:texture` | 指向图形硬件上纹理的指针 |

## 宏指令

使用艺术家 GUI 生成宏。它们是子管道的容器，行为类似于具有输入和输出锚的模块。

保存宏后，下次启动 Artiste 时，它们将出现在模块列表菜单中。在操作系统文件结构中，宏将在这里结束:

```sh
/home/[USER]/thmad/[VERSION]/data/macros/

```

当前版本中的 ThMAD 不能动态构建菜单，这就是为什么你在对模块结构进行更改后必须重新启动它。

## 摘要

本章列出了 ThMAD 中可用的所有模块，并描述了它们的所有参数。