第三章

![image](images/frontdot.jpg)

管理 Linux 文件系统

在[第二章](02.html)中，你已经读到了在使用 Linux 系统时你可能想要完成的一些基本任务。在本章中，您将了解一些更高级的任务。通常，这些任务是用来管理和调优 Linux 计算机的。首先，您将学习如何在电脑上挂载设备，以及如何确保设备在启动时自动挂载。接下来，您将了解如何使用`tar`实用程序创建文件和目录的备份，以及如何使用`dd`创建完整设备的备份。在本章的结尾，你会发现使用链接的好处。

安装盘

在 Linux 计算机上，设备并不总是自动挂载的。因此，您必须知道如何手动挂载设备。特别是如果您是一名服务器管理员，需要将他或她的计算机连接到外部存储器，那么关于安装过程的知识非常重要。这也适用于更常见的情况，例如，当你必须连接一个 USB 密钥，它不会自动安装。

使用`mount`命令

要手动挂载设备，可以使用挂载命令。这个命令的基本语法很容易理解:

```
mount /*what /where*
```

对于*什么*部分，您指定一个设备名，对于*哪里*部分，您提供一个目录。原则上，任何目录都可以使用，但是在任何地方挂载一个设备都没有意义(例如，在`/usr`上)，因为这样做会暂时使该目录中的所有其他文件不可用。

因此，在 Linux 上，创建了两个目录作为默认挂载点。这些是您通常用来装载设备的目录。第一个是目录`/mnt`。这通常是您用于偶尔发生的装载的目录，例如，如果您想要测试某个设备是否真的可以装载。其中的第二个目录是`/media`，在这里您可以安装更经常连接的设备。您可以使用以下命令在该目录中挂载 CD 或 DVD:

```
mount /dev/cdrom /media/
```

如果使用图形用户界面，则在插入设备时会自动创建挂载。例如，如果你在一台运行 GNOME 图形界面的计算机上插入一个光驱，它将被安装在/media 下，在一个与光驱标签名称相对应的目录中。在较新的发行版中，这些挂载是在/run/$USER/media/$LABEL 中创建的，这使得区分不同用户创建的挂载更加容易。

`mount`命令允许您挂载 CD 或 DVD 等设备，但是也可以使用该命令挂载网络共享。你只需要说得更具体些。例如，如果您想要挂载一个名为`myshare`的共享，该共享由名为`lor`的 Windows 计算机提供，您可以使用以下命令:

```
mount -t cifs -o username=yourname //lor/myshare /mnt
```

![Image](images/sq.jpg) **注意**前面命令中的语法可以用来访问 Windows 计算机提供的共享，但是您也可以用它来访问 Samba 文件服务器提供的共享。Samba 是一种可以在任何 Linux 计算机上运行的服务，提供类似 Windows 的文件服务。

您会注意到在最后一个示例中使用了一些额外的选项:

*   首先，提到要使用的文件系统。`mount`命令完全能够通过查看每个文件系统开头的管理来确定本地设备的文件系统。但是，如果您尝试挂载网络上的计算机提供的共享，您确实需要指定文件系统。这是因为`mount`命令在能够访问它之前需要知道它是什么类型的文件系统。在 Windows 机器上的共享示例中，因为您想要在 Windows 文件系统上挂载，所以使用了`cifs`文件系统类型。您还可以使用这种文件系统类型来访问 Samba 服务器上的共享。
*   您需要访问 Samba 文件计算机上的共享的下一个选项是执行挂载的用户的名称。这必须是另一个系统上的有效用户帐户的名称。
*   第三，给出份额的名称。在前面的例子中，使用了计算机名(lor) ,但是，如果您的系统在使用计算机名时遇到问题，也可以使用 IP 地址。计算机名后跟共享名。
*   最后，给出必须创建挂载的目录名。在这个例子中，我将它挂载在`/mnt`上，因为这是一个您只是偶尔执行的挂载。如果这是一个您经常使用的挂载，那么您可以在文件系统中的任何地方创建一个挂载点。目录/srv 通常用于此目的。在这种情况下，使用目录/srv/lor 是有意义的。

在[表 3-1](#Tab1) 中，您可以看到一些您通常希望定期安装的最流行设备的列表。

[表 3-1](#_Tab1) 。安装流行设备

| 

设备

 | 

地址作为

 | 

评论

 |
| --- | --- | --- |
| 软盘 | `/dev/fd0` | 因为现代计算机很少有一个以上的软驱，软驱(如果有的话)会是`fd0.`如果有一个以上的驱动器可用，就用`fd1`，以此类推。 |
| 硬盘驱动器 | `/dev/sdX` | 根据硬盘驱动器安装的总线，您会看到它是`/dev/hdX`(传统 IDE)还是`/dev/sdX` (SCSI 和 SATA)。第一个驱动器的 x 替换为“a”，第二个驱动器的 x 替换为“b”，依此类推。注意，通常你不会挂载一个完整的硬盘，而是在硬盘的一个分区上挂载一个文件系统。驱动器上的分区用一个数字来表示，`/dev/sda1`表示 SCSI 硬盘上的第一个分区，依此类推。在第五章中，你会找到更多关于分区和硬盘布局的信息。 |
| usb 驱动程序 | `/dev/sdX` | USB 驱动器(包括 USB 闪存盘)出现在 SCSI 总线上。通常，您会将它们视为“下一个”SCSI 磁盘。所以，如果你已经有了一个`sda`，USB 设备就会显示为`sdb`。USB 驱动器上通常有一个分区。要安装它，您必须安装这个分区。USB 驱动器上的分区编号工作方式类似于普通硬盘上的分区编号(从 Linux 内核的角度来看，这两种不同的设备类型之间并没有真正的区别)。因此，要将分区挂载到一个已经成为可用的`/dev/sdb`的 USB 驱动器上，您通常会使用`mount /dev/sdb1 /somewhere`(不要忘记用现有目录的名称替换`somewhere`)。 |
| 光驱 | `/dev/sr0` | 在现代电脑上，你会发现光驱的名称是`/dev/sr0`。为了方便起见，您的发行版将创建一个带有名称`/dev/cdrom`或`/dev/dvd`的符号链接(您可以把它比作一个快捷方式)。通过寻址这个符号链接，您可以寻址设备的真实名称。 |
| 磁带驱动器 | `/dev/st0` | 通常，磁带机安装在 SCSI 总线上，可以作为`/dev/st0`安装。 |
| 虚拟机中的硬盘 | `/dev/vdX` | 在 Linux KVM 虚拟机中，硬盘由/dev/vdX 设备提供。命名约定遵循/dev/sdX 的命名约定。 |
| Windows 共享 | *//电脑/共享* | 使用`//`,后跟计算机名，然后是共享。需要额外的选项，例如`-t cifs`来指示要使用的文件系统的类型，以及`-o`*username = your username*来指定您想要使用的用户帐户的名称。 |
| NFS 股票 | *电脑:/共享* | 添加`-t nfs`以表明它是一个 NFS(网络文件系统)服务器。 |

`mount`命令的选项

命令提供了许多选项，其中一些相当高级。`mount`最重要的选项之一是`-t`选项，它指定了您想要使用的文件系统类型。您的电脑通常会自己检测要使用的文件系统，但有时您需要帮助它，因为这种文件系统自检工作不正常。[表 3-2](#Tab2) 列出了你可能在电脑上遇到的一些文件系统(或其他 Linux 系统)。

[表 3-2](#_Tab2) 。Linux 文件系统类型

| 

类型

 | 

描述

 |
| --- | --- |
| `minix` | 这是所有 Linux 文件系统之母。它在最早的 Linux 版本中使用。因为它有一些严重的限制，比如不能处理大于 32MB 的分区，所以它不再常用了。偶尔，它仍然可以在非常小的介质上看到，如引导磁盘或使用嵌入式 Linux 的设备。 |
| `ext2` | 很长一段时间以来，这一直是默认的 Linux 文件系统，它最初是在 20 世纪 90 年代早期开发的。Ext2 文件系统是一个完全符合 POSIX 的文件系统，这意味着它支持典型 UNIX 环境的所有属性。然而，它有一个严重的缺点:它不支持日志，因此很久以前就被取代了。 |
| `ext3` | 基本上，Ext3 是添加了日志的 Ext2。Ext3 的主要优点是它完全向后兼容 Ext2。它的主要缺点是它基于 Ext2，这是一个老式的文件系统，不是为使用数百 GB 分区的世界设计的。 |
| `btrfs` | btrfs (读作 butterfs)是下一代 Linux 文件系统。它提供了许多新的特性，比如多设备文件系统、版本控制和子卷，但是在本书写作的时候，许多发行版还不认为它是稳定的文件系统。当您读到本文时，btrfs 可能是默认的文件系统。 |
| `Reiser` | ReiserFS 是另一种日志文件系统。它是由 Hans Reiser 在 20 世纪 90 年代后期开发的一个全新的文件系统。ReiserFS 只被用作 SUSE Linux 上的默认文件系统，但是甚至 SUSE 也将 Ext3 作为默认文件系统，因为没有足够的社区支持 ReiserFS。 |
| `ext4` | Ext4 是 Ext3 的继任者，它修复了 Ext3 的一些最重要的缺点。例如，Ext4 将使用一个强大的索引系统，帮助你在一个目录中处理大量文件。在撰写本文时，Ext4 仍处于实验阶段，因此我不会在本书中讨论它。 |
| `Xfs` | XFS 文件系统是由超级计算机制造商 SGI 创建的开源文件系统。它有一些优秀的调优选项，这使它成为存储数据的非常好的文件系统。在本章的后面，你会读到更多关于这个文件系统及其选项的内容。由于 btrfs 文件系统还不稳定，xfs 被 SUSE 和 Red Hat 等企业 Linux 发行版用作默认文件系统。 |
| `Msdos` | 例如，如果您需要读取一张软盘，上面有在使用 MS-DOS 的计算机上创建的文件，您可以使用`msdos`文件系统类型挂载它。然而，这是一个已经被`vfat`取代的遗留文件系统。 |
| `Vfat` | vfat 文件系统用于所有使用 fat 文件系统的 Windows 和 DOS 文件系统。用它来访问 Windows 格式的软盘或光盘上的文件。 |
| `ntfs` | 在 Windows 系统上，NTFS 现在是默认的文件系统。不久前，Linux 还没有稳定的开源解决方案来写入 NTFS。在较旧的发行版中，仍然缺少对 NTFS 的写支持。然而，现代发行版提供了完整的读/写支持。您还可以在 Knoppix 等 live cds 上找到一些优秀的 NTFS 工具。在诸如 Red Hat Enterprise Linux 之类的企业 Linux 发行版上，您将找不到对 NTFS 的支持。 |
| `iso9660` | 这是用于装载 CD 的文件系统。通常，您不需要指定您想要使用这个文件系统，因为当您插入 CD 时，它会自动被检测到。 |
| `Cifs` | 在网络上工作时，cifs 文件系统非常重要。这个文件系统允许您通过网络连接到 Windows 计算机提供的共享，如前面的示例所示。通过使用 Samba 服务，Linux 计算机也可以提供使用这个协议的共享(更多细节见第 12 章)。过去，`smbfs`文件系统类型用于处理这些共享，但是，因为 cifs 提供了更好的解决方案，所以它已经在现代 Linux 发行版上取代了`smbfs`。如果挂载 Samba 共享不能与 cifs 一起工作，请尝试 smbfs。 |
| `Nfs` | NFS 用于在 UNIX 计算机之间建立连接。关于 NFS 和桑巴的更多信息，请参见第 12 章。 |

除了`-t`，`mount`命令还有许多其他选项，可以使用`-o`选项作为前缀。这些选项大多依赖于文件系统，因此这里没有提供这些选项的通用列表。您将在`mount`命令的`man`页面中找到特定于您的文件系统的信息。

获得已安装设备的概述

安装的每个设备都记录在配置文件`/etc/mtab`中。你可以用`cat`或者`less`这样的工具浏览这个文件的内容。您还可以使用`mount`命令来查看当前挂载的文件系统。如果这个命令在没有任何其他参数的情况下使用，它会读取`/etc/mtab`的内容，并显示它能找到的所有已挂载文件系统的列表，如[清单 3-1](#FPar2) 所示。

[***清单 3-1***](#_FPar2) 。`mount`命令给出了当前安装的所有设备的概况

```
nuuk:/ # mount
/dev/sda2 on / type ext3 (rw,acl,user_xattr)
proc on /proc type proc (rw)
sysfs on /sys type sysfs (rw)
debugfs on /sys/kernel/debug type debugfs (rw)
udev on /dev type tmpfs (rw)
devpts on /dev/pts type devpts (rw,mode=0620,gid=5)
/dev/sda1 on /boot type ext2 (rw,acl,user_xattr)
securityfs on /sys/kernel/security type securityfs (rw)
nfsd on /proc/fs/nfsd type nfsd (rw)
/dev/sr0 on /media/VMware_Tools type iso9660 (ro,nosuid,nodev,utf8,uid=0)
/dev/sdc1 on /media/disk type vfat
       rw,noexec,nosuid,nodev,flush,fmask=0133,shortname=lower,utf8,uid=0)
```

正如你在[清单 3-1](#FPar2) 中看到的，`mount`不仅给你关于挂载分区的信息，也给你关于系统设备的信息。在现代 Linux 发行版中，这个挂载的系统设备列表可能会很长。

现在，我将忽略关于这些系统设备的所有行，只关注安装了`/dev/sda1`和`/dev/sda2`的两行。在这几行中，您可以首先看到设备的名称。接下来，它们显示装载它们的目录的名称。接下来是文件系统类型，最后是安装设备时使用的选项。您可以看到`sda1`和`sda2`都安装了`rw`选项，这意味着它们可以被读写。同样，这两个文件系统有`acl`和`user_xattr`选项。这些选项在大多数发行版中是默认打开的，允许您在文件系统上使用一些高级安全性。你将在第 7 章中了解更多关于这些选项的内容，该章讨论了权限的使用。

在[清单 3-1](#FPar2) 中你还可以看到一个`/dev/sr0`，它被安装了。如果你看到这个设备，很有可能是指你的光盘设备，这里也是这种情况。您还可以看到所使用的文件系统类型，`iso` 9660，这通常是 CD 设备上使用的文件系统。

最后两行(它们读作一行，但由于印刷限制显示为两行)显示安装的`/dev/sdc` 1 设备。这是一个插入系统的 USB 闪存盘。Linux 内核在连接和安装它的时候自动识别了它，使用了所有需要的选项。不要担心这些选项的具体含义；Linux 内核已经自动检测到安装这个设备到底需要什么。

除了/etc/mtab 文件之外，Linux 还提供了更多选项来查看当前挂载了哪些文件系统。/proc/mounts 文件提供了内核提供的关于当前已有挂载的直接信息。实际上,/etc/mtab 的内容直接来自这个文件。对于挂载的真实文件系统的概述，您可以使用 **df -h** 命令。[清单 3-2](#FPar3) 展示了这个命令如何只显示真实的文件系统，而不提供任何关于挂载的内核接口的信息。

[***清单 3-2***](#_FPar3) 。 **df -h** 命令给出了关于挂载的文件系统的信息

```
[root@server1 ~]# df -h
Filesystem               Size  Used Avail Use% Mounted on
/dev/mapper/centos-root  6.7G  1.4G  5.4G  20% /
devtmpfs                 237M     0  237M   0% /dev
tmpfs                    245M   54M  191M  22% /dev/shm
tmpfs                    245M   25M  221M  10% /run
tmpfs                    245M     0  245M   0% /sys/fs/cgroup
/dev/vda1                497M  138M  360M  28% /boot
/dev/sdb1               1020M   33M  988M   4% /srv/gluster
/dev/drbd0              1021M   34M  988M   4% /var/lib/mysql
```

卸载设备

在 Linux 系统上，当你想从你的计算机上断开一个设备时，你必须先卸载它。卸载设备可确保在设备断开连接之前，仍在缓存中且尚未写入设备的所有数据都已写入文件系统。您将使用`umount`命令来完成这项工作。该命令可以接受两个参数:设备的名称或安装该设备的目录的名称。所以`umount /dev/cdrom`和`umount /mnt`都将为安装在目录`/mnt`上的 CD 设备工作。

当使用`umount`命令时，您可能会得到消息“设备忙”，并且卸载失败。这可能是因为设备上有一个文件处于打开状态，不允许您断开设备连接的原因很明显:断开已安装设备的连接可能会导致数据丢失。所以首先要确保设备没有打开的文件。解决方案有时很简单:如果你想卸载一个 CD，但是你当前在目录`/media/cdrom`中，就不可能断开设备。浏览到另一个目录，然后重试。然而，有时情况会更复杂，您需要首先找出哪些进程当前正在使用该设备。

为此，您可以使用`fuser`命令。该命令显示使用指定文件或文件系统的进程 id(PID)。例如，`fuser -m /media`显示了当前在`/media.`中有打开文件的所有进程的列表。基于这些 PID，您现在可以使用`kill`命令手动终止进程。清单 3-3 展示了如何使用`fuser`列出在`/media,`中打开文件的进程的 PID，以及如何使用下一个`kill`命令终止这些进程。有关流程管理的更多信息，请阅读第 9 章。

[***清单 3-3***](#_FPar4) 。使用`fuser`和`kill`，您可以跟踪和终止阻止卸载设备的进程

```
nuuk:~ # fuser /media
/media:               13061c
nuuk:~ # kill 13061
```

`fuser`命令也允许你自动杀死这些打开的文件。对于在`/media/cdrom`上打开的文件，使用定影器- `km /media/cdrom`。使用该选项时要小心:如果你是 root，它可能会盲目地杀死重要的进程，使你的计算机无法读取。

作为`fuser`命令的替代，您也可以使用`lsof`。它还提供了当前正在使用给定文件系统上的文件的所有进程的列表，但它提供了有关这些进程的更多信息。鉴于`fuser`只给出了进程的 PID，`lsof`也给出了进程名和拥有进程的用户等信息。清单 3-4 显示了`lsof`的结果。

[***清单 3-4***](#_FPar5) 。如果您需要有关阻止您执行卸载的过程的更多详细信息，请使用`lsof`

```
nuuk:/media # lsof /media
COMMAND   PID USER    FD    TYPE DEVICE SIZE NODE NAME
Lsof    10230 root   cwd     DIR   22,0 4096 1856 /media
Lsof    10231 root   cwd     DIR   22,0 4096 1856 /media
Bash    13061 root   cwd     DIR   22,0 4096 1856 /media
```

清单 3-4 中的例子是在一台打开了 Bash shell 并将其当前提示符设置为`/media`目录的计算机上拍摄的。如您所见，这启动了不同的进程，其中 PID 号在第二列。您将需要这个 PID 来管理这个过程；更多信息请见第九章。

在使用`fuser`和`/media`目录上的`-k`开关来终止活动进程后，您应该始终确保通过再次使用`fuser -m /media`来真正终止进程，因为这将向您显示是否还有打开文件的进程。

强制`umount`命令执行其工作的另一种方式是使用如下的`-f`选项:`umount -f /somemount.`该选项特别适用于已经无法访问的 NFS 网络挂载，并且在其他文件系统上不起作用，因此如果您在本地文件系统上尝试它，不会有太大的成功。

如果您想最小化卸载设备的影响，您可以将`umount`与`-l`选项一起使用，这将通过从文件系统层次结构中分离文件系统并在文件系统不再繁忙时清除对文件系统的所有引用来执行“惰性卸载”。使用此选项可以让您立即进行卸载，即使文件系统很忙。但可能需要一些时间来完成。该选项允许您以非常安全的方式卸载繁忙的文件系统，因为它不会立即关闭任何进程。

![Image](images/sq.jpg) **提示**`eject`命令是卸载和弹出光学介质的一种非常简单的方法。此命令将打开 CD 或 DVD 驱动器，并弹出当前在驱动器中的光学媒体。你所要做的就是移除它。然后您可以使用`eject -t`关闭光驱抽屉。

练习 3-1:挂载文件系统

要进行这个练习，你需要将一个 USB 拇指驱动器连接到你的电脑系统。

1.  类型 **cat /proc/partitions** 这提供了系统上当前已知的所有设备的概述。
2.  将 USB thum 驱动器插入您的计算机。再次键入 **cat /proc/partitions** 。你会注意到一个新的设备出现了。对于本练习的其余部分，我将假设设备的名称为/dev/sdb1。如果您的计算机上显示不同的名称，请更改此设备名称。
3.  键入 **mount /dev/sdb1 /mnt** 将设备挂载到/mnt 目录中。
4.  类型**安装**。您将在命令输出的最后一行看到/dev/sdb1 设备。
5.  类型 **df -h** 。这还显示了已装载的设备，以及设备上的可用磁盘空间。
6.  类型 **cd /mnt** 。
7.  类型**卸载/管理**。你会看到一个“设备忙”的错误信息。
8.  键入 **lsof /mnt** 并读取命令的输出。
9.  键入不带任何参数的 **cd** 。这将把你带到你的主目录。
10.  类型**卸载/管理**。您现在可以卸载设备了。
11.  现在，您可以安全地从计算机上移除 USB 拇指驱动器了。

使用`/etc/fstab`自动安装

启动计算机时，有些挂载需要自动发出。为此，Linux 使用`/etc/fstab`文件来指定这些文件系统必须如何以及在哪里挂载。该文件包含必须定期进行的所有装载的列表。在`/etc/fstab`中，您可以声明每次挂载时是否必须在系统启动时自动执行。[清单 3-4](#FPar5a) 显示了一个样本`/etc/fstab`文件的内容。

[***清单 3-4***](#_FPar5a) 。`/etc/fstab`文件确保文件系统在系统引导期间被挂载

```
nuuk:/media  # cat /etc/fstab
/dev/sda2    /                     ext4      acl,user_xattr    1 1
LABEL=boot   /boot                 ext4      acl,user_xattr    1 2
/dev/sda3    swap                  swap      defaults          0 0
proc         /proc                 proc      defaults          0 0
sysfs        /sys                  sysfs     noauto            0 0
debugfs      /sys/kernel/debug     debugfs   noauto            0 0
usbfs        /proc/bus/usb         usbfs     noauto            0 0
devpts       /dev/pts              devpts    mode=0620,gid=5   0 0
```

![Image](images/sq.jpg) **注意**一些发行版使用高级特性，如通用唯一 ID (UUID) 或 LVM 逻辑卷来挂载来自`fstab`的设备。在这一节中，我将基于常规分区来解释`fstab`。你可以在本书第 6 章中找到更多关于这些高级特性的信息。

在清单中，您可以看到在`/etc/fstab`中不仅指定了真实的文件系统。还列出了一些系统文件系统。您不必以管理员身份包含这些文件系统，它们会在您安装服务器时自动添加。

![Image](images/sq.jpg) **注意**`/etc/fstab`文件在系统启动时使用，但是您也可以从命令行使用它:输入`mount -a`命令来挂载`/etc/fstab`中当前未挂载的所有文件系统，并设置选项自动挂载它们。同样，如果一个设备在`/etc/fstab`中定义了它最常用的挂载选项，你不需要在命令行中指定所有的挂载选项。例如，如果`/dev/cdrom`设备在`/etc/fstab,`中，你可以通过使用一个缩短的`mount /dev/cdrom`命令而不是完整的`mount /dev/cdrom /media/cdrom`命令来安装它。

在`fstab` 中，每个文件系统在单独的一行上进行描述，这些行中的字段由制表符或空格分隔。以下字段始终存在:

*   *文件系统*:第一个字段描述要挂载的设备或远程文件系统。通常，您会在这一行看到类似于`/dev/sda1 or computer:/mount`的名字。前者用于指本地分区，而后者用于指由另一台计算机提供的网络共享。
*   *挂载点*:第二个字段用于描述文件系统的挂载点。这通常是必须挂载文件系统的目录。一些文件系统(如交换文件系统)不使用特定的目录作为它们的挂载点。在交换分区的情况下，只有`swap`被用作挂载点。

![Image](images/sq.jpg) **提示**在大多数文件系统中，设备名可以用一个标签代替，比如“ROOT”。在 Ext4 文件系统上，这些标签可以用`tune2fs -L`命令创建，或者在 XFS 系统上用`xfs_admin`创建。使用标签使系统更加健壮，并避免了添加 SCSI 磁盘会添加所有设备名称的情况。标签是静态的，不会在添加磁盘时自动更改。现在，一个替代系统，使用 UUIDs，允许您使用唯一的设备命名。在第 5 章中，你可以读到更多关于 UUIDs 的内容。但是他们有一个缺点，UUID 很长，很难读懂。使用标签的好处是，作为管理员，它们允许您分配一个人类可读的设备名称。

*   *文件系统类型*:第三个字段用于指定您可以使用的文件系统类型。正如您在前面了解到的，许多文件系统都可以在 Linux 上使用。使用它们不需要特定的内核配置，因为大多数文件系统可以作为内核模块激活，在需要时自动加载。除了文件系统的名称，您还可以在这个字段中使用`ignore`。这对于显示当前未使用的磁盘分区很有用。要自动确定文件系统类型，请使用选项`auto`。这是您希望在 CD 和软盘等可移动媒体上使用的内容。但是，不要在固定介质(如分区和逻辑卷)上使用它，因为它可能会导致在启动计算机时挂载文件系统失败。
*   *挂载选项*:第四个字段用于指定挂载文件系统时应该使用的选项。有许多选项可用，其中许多是特定于文件系统的。对于大多数文件系统，使用选项`default`,这确保当计算机启动时文件系统被自动挂载，并禁止普通用户断开挂载。此外，还使用了选项`rw`、`suid`、`dev`、`exec`和`async`。下表描述了一些最常用的选项。请注意，在使用 mount 命令时，您也可以将这些选项用作参数:
    *   `async`:不同步写入文件系统，而是通过写缓存机制。这确保了以最有效的方式执行文件写入，但是如果与文件系统的联系突然中断，您就有丢失数据的风险。
    *   `dev`:将文件系统上的块和字符设备视为设备，而不是常规文件。出于安全原因，最好避免在普通用户可以安装的设备上使用此选项。
    *   `exec:`允许执行二进制文件。
    *   `hotplug:`如果该设备当前不存在，则不报告错误。这对于 USB 介质等热插拔设备很有意义。
    *   `noatime`:每次打开文件时，不更新该文件系统的访问次数。如果在文件系统上执行许多读取操作，此选项会使文件系统的速度有所提高。对于您的计算机正在挂载的所有文件系统，将此选项作为默认选项打开是一个好主意，除非您想要使用记帐系统来跟踪在特定时刻哪个用户访问了哪些文件。
    *   当系统启动或用户使用`mount -a`命令自动挂载`/etc/fstab`中的所有内容时，`noauto:`不会自动挂载文件系统。
    *   `mode:`为在文件系统上创建的新文件设置权限模式(见[第 7 章](07.html))。
    *   `remount:`重新挂载一个已经挂载的文件系统。只有从命令行使用该选项才有意义。
    *   `user:`允许用户挂载文件系统。该选项通常仅用于磁盘和 CD 等可移动设备。
    *   `sync:`在卸载设备之前，确保文件系统的内容与介质同步。
*   *转储状态* :该字段用于使用`dump`命令，这是一种备份文件系统的方法。该字段确定调用`dump`命令时需要转储哪些文件系统。如果该字段的值设置为`0`，则不会被转储；如果设置为`1`，它将在`dump`被调用时被转储。确保在包含重要数据的所有文件系统上将该值设置为`1`，这些数据在使用`dump`进行备份时应始终包含在内。

![Image](images/sq.jpg) **注意**你可能永远不会自己使用`dump`命令来创建备份，但是一些备份实用程序会这样做。因此，如果您想确保您的备份实用程序成功，请在此列中为包含重要数据的所有文件系统赋予值`1`。

*   *Fsck 状态*:`fstab`中的最后一个字段决定了如何使用`fsck`命令检查文件系统。在引导时，引导加载程序将总是检查一个文件系统是否需要用`fsck`来检查。如果是这种情况，必须首先检查根文件系统，因此其值为`1`。其他文件系统应该有编号`2`。如果文件系统具有相同的`fsck`号，将按顺序检查它们。如果文件在不同的驱动器上，可以并行检查它们。如果该值设置为 0，则不会进行自动检查。

警告！如果文件系统配置为在启动时进行自动文件系统检查，自动文件系统检查可能会失败。如果是，您的系统将开始引导并显示消息“输入维护模式的 root 密码”。如果您遇到这种情况，您应该开始检查文件系统的完整性。或者，您可以将/etc/fstab 中的最后一列更改为 0，以关闭自动文件系统检查(这可能会在某个时间点导致文件系统损坏)。

检查文件系统完整性

当系统意外崩溃时，任何打开的文件系统都可能被损坏，这可能会阻止您以正常方式使用这些文件系统。如果发生这种情况，需要检查这些文件系统的一致性，您可以使用`fsck`命令来完成这项工作。在启动时，Linux 总是会自动对文件系统进行快速检查。在某些情况下，这将失败，您将需要手动检查您的计算机文件系统。如果发生这种情况，引导过程将停止，您将看到一个基于文本的登录 shell。本节假设您使用这样一个基于文本的登录 shell 来修复文件系统。

![Image](images/sq.jpg) **警告**切勿在已挂载的文件系统上使用`fsck`，因为这可能会严重损坏文件系统！如果一个文件系统没有打开的文件，您可以使用带有`mount`的`-o remount,ro`选项以只读方式重新挂载它。例如，要在`/usr`上以只读方式重新挂载文件系统，可以使用`mount -o remount, ro /usr`。

您可以使用您想要检查的设备的名称作为参数来启动`fsck`命令:例如，使用`fsck /dev/sda1`来检查`/dev/sda1`上的文件。如果不加任何选项运行该命令，`fsck`将根据`/etc/fstab`中`fsck status`字段的设置，逐一检查`/etc/fstab`中的所有文件系统。通常，这种情况会在系统启动时发生。

如今，系统管理员不必经常使用`fsck`，因为大多数现代文件系统都是日志文件系统。日志用于将文件上的事务写入特定的日志文件。拥有这样的日志可以非常快速地恢复损坏的文件系统。如果日志文件系统损坏，将检查日志，并且可以轻松回滚所有未完成的事务。为了提供一些保护，每隔一段时间会自动检查一次 Ext 或 Ext 文件系统。

![Image](images/sq.jpg) **提示**在非日志文件系统上，`fsck`命令可能需要很长时间才能完成。在这种情况下，当执行手动检查时，可以使用`-C`选项。这个选项会显示一个进度条——当然，这不会让它变得更快，但它至少让您知道还需要等待多长时间才能完成这个过程。目前，`-C`选项仅在 Ext 文件系统上受支持。

创建备份

关于计算机，有一点似乎永远是正确的:有一天它们会出故障。如果有问题的计算机是一个重要的服务器，故障会导致巨大的问题。公司已经破产，因为他们的重要数据丢失了。因此，对您的数据进行合理的备份至关重要。在这一节中，我将介绍两种不同的创建备份的方法，这两种方法都是原生的 Linux 解决方案:使用`tar`进行文件备份和使用`dd`进行设备备份。

使用`tar`制作文件备份

命令行实用程序`tar` 可能是最流行的 Linux 备份实用程序。它是一个独立的实用程序，用于将备份写入归档文件。这个归档文件可以是磁带(因此得名“tar”，它代表*磁带归档程序*)，但也可以是其他任何东西。例如，基于`tar`的备份通常被写入一个文件而不是一个磁带，并且，如果这个文件是用像`bzip2`或`gzip`这样的压缩工具压缩的，您将得到著名的 tarball，这是一种交付软件安装档案的常用方法。在本节中，您将学习如何创建`tar`档案以及如何从中提取文件。我还将提供一些提示和技巧来帮助您充分利用`tar`实用程序。

![Image](images/sq.jpg) **注意**`tar`命令不仅仅用于备份和恢复；在互联网上，你也可以找到`tar`打包的软件档案。即使在使用 yum 或 apt 这样的包管理器的环境中工作，您也会发现有时您也需要解包`tar`档案。

创建档案文件

在其最基本的形式中，`tar`用于创建一个归档文件。以下命令将帮助您对目录`/home`执行此操作:

```
tar -cvf /tmp/home.tar /home
```

该命令将创建`/home`的备份，并将其放入文件`/tmp/home.tar`中。这个归档文件包含相对路径名，这意味着在恢复它时，它将总是恢复运行 tar 命令的目录中的文件。如果要创建重要系统文件和目录的备份，这种方法很有用。例如，下面的命令将创建目录`/home, /srv, /root`和`/var`的备份，并将其写入文件`/tmp/system-backup:`

```
tar -cvf /tmp/system-backup.tar /home /srv /root /var
```

![Image](images/sq.jpg) **注意**当使用`tar`命令时，你*可以*在选项前加一个----------号，但你可以不加。你会遇到这两种语法风格，为了帮助你习惯，我将在本书中两种都用。

这个`tar`命令有几个参数。首先，您需要指出您想用`tar`命令做什么。在这种情况下，您需要创建一个归档文件。(这就是为什么使用选项`c`；“c”代表*创造*。)

之后，我使用了选项`v` ( *冗长* )。虽然这不是必需的，但它经常会派上用场，因为详细输出可以让您看到`tar`命令实际上在做什么。我建议总是使用这个选项，因为有时一个`tar`工作会花费很长时间。(例如，想象一下为硬盘上的所有内容创建一个完整的档案。)在这种情况下，能够监控到底发生了什么是很好的，这就是选项`v`的目的。

接下来，您需要指定您希望`tar`命令将它的输出发送到哪里。如果您没有在这里指定任何东西，`tar`默认为标准输出。换句话说，它只是将所有数据转储到计算机的控制台。这并没有多大作用，所以您应该使用选项`f`(文件)来指定输出应该被写到哪个文件或设备。

在这个例子中，我将输出写到一个常规文件中，但是，您也可以将输出写到一个设备文件中。例如，以下命令对`/home`进行备份，并将其写入`/dev/mt0`设备，该设备通常指磁带机:

```
tar -cvf /dev/mt0 /home
```

`tar`命令的最后一部分明确指定了您想要放入`tar`档案的内容。在这个例子中，目录`/home`被存档。很容易忘记这个选项，但是，如果你这样做了，`tar`会抱怨这是“懦弱的拒绝创建一个空的归档文件”

你应该知道一些关于`tar`的其他事情。首先，参数的顺序*和*有关系。所以，举例来说，`tar -cvf /somefile /somedir`和`tar -f /somefile -vc /somedir`是有区别的。最后一部分顺序不对，`tar`不会知道你想让它做什么。所以，在任何情况下，首先要明确你想让`tar`做什么。在大多数情况下，它要么是`c`(创建一个归档文件)，要么是`x`(提取一个归档文件)，要么是`t`(列出归档文件的内容)。然后指定您希望`tar`如何做到这一点；例如，你可以使用`v`告诉`tar`它应该是冗长的。接下来，使用`f`选项来指示您希望`tar`在哪里写入备份，然后指定您确切想要备份的内容。下面的示例行演示了这个`tar`语法:

```
tar { create | extract} [options] <destination file> <source files or directories>
```

用`tar`创建一个档案是有用的，但是你应该知道`tar`不会压缩你的档案的一个比特。这是因为`tar`最初被认为是一个磁带流实用程序。它将数据传输到文件或(通常)磁带设备。如果您想让`tar`也压缩一个归档的内容，您必须告诉它这样做。`tar`有两个选项来压缩存档文件:

*   `z`:使用此选项，用`gzip`工具压缩`tar`文件。这是最流行的压缩工具，因为它有相当不错的压缩比。这意味着压缩文件时会获得相当多的磁盘空间。此外，创建一个压缩文件并不需要太长时间。
*   `j:`使用此选项，用`bzip2`实用程序压缩 tar 文件。这个工具的压缩率比`gzip`高 10%到 20%,但这是有代价的:它需要的时间是后者的两倍。

因此，如果您想要创建目录`/home`的压缩归档文件，并将该备份写入名为`home.tar.gz`的文件，您可以使用以下命令:

```
tar -czvf home.tar.gz /home
```

![Image](images/sq.jpg) **注意**当然，您也可以从命令行使用`bzip2`和`gzip`实用程序。使用`gzip file.tar`压缩`file.tar`。该命令产生`file.tar.gz`作为其结果。要解压缩该文件，使用`gunzip file.tar.gz`，这将返回原来的`file.tar`。如果你想用`bzip2`做同样的事情，使用`bzip2 file.tar`创建压缩文件。这将创建一个名为`file.tar.bz2`的文件，您可以使用命令`bunzip2 file.tar.bz2`对其进行解压缩。

tar 中的路径名

当使用 tar 创建一个归档文件时，您应该小心创建归档文件的目录。首先，要意识到 tar 归档中的所有路径名都是以相对路径名的形式存储的——如清单 3-5 中的代码[所示，其中的命令提到从文件名中删除了前导/](#FPar18)

除了文件名中的前导/之外，完整的路径名将保留在 tar 存档中。这意味着如果你使用的是 **tar -cvf /tmp/all.tar /。文件名存储为 etc/hosts，而不是/etc/hosts。**

[***清单 3-5***](#_FPar18) 。使用 tar 创建包含绝对文件名的归档文件

```
nuuk:/ # tar cvf /tmp/old.tar /old
tar: Removing leading `/' from member names
/old/
/old/hosts
/old/shadow
/old/passwd
```

如果您创建 tar 归档文件的目的是以后在您喜欢的任何位置提取它，那么在归档文件中使用完整的文件名并不是一个好主意。例如，如果您是一名想要向用户发布他或她的新程序的开发人员，就会出现这种情况。在这种情况下，如果用户可以在他或她想要的任何地方提取归档文件，那就太好了。为此，您有两种选择:

*   在创建备份之前，使用`cd`转到目标目录。
*   使用`tar`选项`-C`告诉`tar`应该创建一个包含相对文件名的存档文件。

在这两者中，我推荐使用后者，因为它更清晰，并且可以创建包含来自多个目录的文件的归档。当您创建具有相对文件名的备份时，您应该总是在`tar`命令的末尾放一个点。这个点告诉`tar`备份当前目录的内容。如果没有这个点，`tar`会告诉你它不想创建一个空的档案。在[清单 3-6](#FPar19) 中，您可以看到如何使用与清单 3-5 中的示例命令相同的目录(`/old`)来创建一个档案。

[***清单 3-6***](#_FPar19) 。创建包含相对文件名的档案

```
nuuk:/ # tar cvf /tmp/old.tar -C /old .
./
./hosts
./shadow
./passwd
```

提取归档文件

既然您已经知道如何创建归档文件，那么提取它就相当容易了。基本上，用于提取归档文件的命令行选项看起来很像最初创建归档文件所需的选项。重要的区别在于，要提取一个文件，您需要选项`x`(提取)，而不是`c`(创建)。以下是一些例子:

*   `tar -xvf /file.tar`:将`file.tar`的内容提取到当前目录
*   `tar -zxvf /file.tar.gz:`提取压缩后的内容`file.tar`到当前目录
*   `tar -xvf /file.tar C /somedir`:将`/file.tar`的内容提取到一个名为`/somedir`的目录下

移动一个完整的目录

大多数时候，`tar`用于将一个或多个目录的备份写到一个文件中。由于对特殊文件(比如数据库中经常使用的陈旧文件)的出色处理，`tar`也经常用于将一个目录的内容移动到另一个目录。让我们假设您想要将目录`/old`中的内容移动到目录`/new`中。有些人通过首先创建一个临时文件，然后将该临时文件提取到新目录中来执行这项任务。这将涉及以下命令:

```
tar cvf /tmp/old.tar -C /old .
tar xvf /tmp/old.tar -C /new
```

这不是最简单的方法，因为您需要两倍于要移动其内容的目录所占用的磁盘空间:原始目录的大小加上临时文件所需的空间。好消息是你不必这样做。使用管道，可以直接将一个目录的内容复制到另一个目录。

为了理解这是如何工作的，首先尝试命令`tar -cC /old`..在这个命令中，选项`c`用于告诉`tar`它应该创建一个归档文件。选项`C`用于使用相对路径名归档目录`/old`的内容。现在，正如您可能已经注意到的，在`tar -cC /var`示例中，选项`f /tmp/old.tar`不用于指定输出到哪里，因此所有输出都被发送到 STDOUT，这是您的控制台。这意味着如果你现在按 Enter，你会看到所有文件的内容在你电脑的控制台上滚动，这不是很有用。

这是命令的前半部分，您最终会在控制台上看到大量输出。现在，在命令的第二部分，您将使用管道将所有输出重定向到另一个命令，即`tar -xC /new`。该命令将从 STDOUT 中捕获`tar`档案，并将其提取到目录`/new`(在运行该命令之前，确保`new`存在)。您将看到这个方法允许您创建一个目录到另一个目录的完美副本。因此，在这种情况下，您需要的完整命令如下所示:

```
tar -cC /old . | tar -xC /new
```

创建增量备份

根据上一节中的信息，您可能会看到如何创建一个或多个目录的备份。例如，`tar -cvf /backup.tar /var /home /srv`命令创建三个目录的备份:`/home`、`/var`和`/srv`。根据这些目录的大小，此命令可能需要一些时间。因为如此大的备份可能需要很长时间，所以进行增量备份通常是有用的；在增量备份中，写入备份的唯一文件是自上次备份以来发生更改的文件。为此，你需要选择`g`来创建一个快照文件。

增量备份总是跟在完整备份之后，因此您必须先创建完整备份。在此完整备份中，您应该创建一个快照文件，该文件包含已写入备份的所有文件的列表。以下命令会为您完成这项工作(在运行该命令之前，请确保目录`/backup`存在):

```
tar -czvg /backup/snapshot-file -f /backup/full-backup.tar.gz /home
```

关于快照文件有趣的事情是，它包含一个已经写入备份的所有文件的列表。如果在完整备份两天后，您希望只备份在这两天内发生更改的文件，您可以重复基本相同的命令。这一次，该命令将检查快照文件，以找出自上次完整备份以来哪些文件发生了更改，并且它将只备份那些发生了更改的文件。因此，您的星期一备份将由以下命令创建:

```
tar -czvg /backup/snapshot-file -f /backup/monday-backup.tar.gz /home
```

这两个命令创建了两个文件:一个包含增量备份的小文件和一个包含完整备份的大文件。在增量备份方案中，您需要确保在某个时间点创建完整备份。为此，只需删除上例中使用的快照文件。由于`tar`没有找到快照文件，它将假设您需要进行完整备份并为您创建新的快照文件。

如果要从增量备份中恢复所有文件，需要恢复每个文件，从创建的第一个文件(通常是完整备份)开始，到最后一个增量备份结束。因此，在本例中，以下两个命令会将文件系统恢复到上次创建增量备份时的状态:

```
tar -xzvf /backup/full-backup.tar.gz
tar -xzvf /backup/monday-backup.tar.gz
```

在本节中，您已经了解了可以与`tar`一起使用的不同选项。为了方便起见，下面列出了最相关的选项:

*   `-c`:使用此选项创建一个档案。
*   `-v`:使用此选项让`tar`显示输出。对于较长的`tar`命令很有用，这样你就可以显示他们在做什么。
*   `-f`:使用该选项指定`tar`应该写入的输出文件的名称。
*   `-C`:在开始`tar`作业之前，使用该选项后接一个目录名来切换到该目录。
*   使用此选项从档案中提取文件。
*   `-g:`使用该选项进行增量或差异备份。
*   `-z:`使用该选项，通过`gzip`压缩来压缩`tar`文件。
*   `-j`:使用该选项通过`bzip2`压缩来压缩`tar`文件。

在[练习 3.2](#Exe2) 中，您将学习如何使用 tar 命令。

练习 3-2:使用 TAR

1.  打开一个根壳。
2.  类型 **tar -cvf /tmp/etc.tar /etc**
3.  键入 **tar -tvf /tmp/etc.tar** 来显示 tar 存档的内容。
4.  键入 **mkdir /temp** 来创建一个临时目录。
5.  类型**tar xvf/tmp/etc . tar-C/temp**。这会提取相对于/temp 目录的 etc.tar 文件的内容。
6.  键入 **rm -rf /temp** 删除/temp 目录及其所有内容。

使用`dd`制作设备备份

您不会找到比`tar`更通用的工具来创建基于文件系统的备份。然而，在某些情况下，您不需要基于文件系统的备份；相反，您希望创建完整设备或其一部分的备份。这就是`dd`命令 派上用场的地方。

![Image](images/sq.jpg) **提示**这听起来可能很抽象。然而，您可以使用`dd`命令做一些非常有用的事情。例如，想象一下将硬盘的全部内容克隆到外部 USB 硬盘的选项。我每周五晚上都这样做，只是为了确保如果我的硬盘出了什么问题，我只需要安装克隆的硬盘就可以拿回我的数据。这不超过五分钟的工作时间(以及在所有数据被复制之前几个小时的等待时间)！

`dd`命令的基本用法相当简单，因为它只需要两个参数:`if=`指定输入文件，`of=`指定输出文件。这些选项的参数可以是文件或块设备。所以，命令`dd if=/etc/hosts of=/home/somefile`可以作为一种复杂的方式来复制文件。然而，我不建议使用`dd`来复制文件；cp 以一种简单得多的方式做到这一点。然而，克隆一个硬盘，你可以用命令`dd if=/dev/sda of=/dev/sdb bs=4096`来做，这是只有`dd`才能做的事情。(选项`bs=4096`指定 dd 应该在 4K 块上工作，这提供了更好的性能。)

![Image](images/sq.jpg) **注** `dd`奇怪的是，是“转换和复制”的简称不幸的是，`cc`命令已经被其他东西使用了，所以开发人员选择使用`dd`来代替。

或者你会怎么想，比如说，命令`dd if=/dev/cdrom of=/mycd.iso`？它可以帮助你创建一个光盘的 ISO 文件，这个文件就在当时的驱动器中。您可能想知道为什么不将 CD 的内容复制到一个名为`/mycd.iso`的文件中呢？原因是，像大多数其他设备一样，CD 通常包含不能通过简单的文件拷贝来复制的信息。例如，如何处理 CD 的引导扇区？你不能在设备上找到这个文件，因为它只是第一个扇区。因为`dd`一个扇区一个扇区地拷贝，另一方面，它也会拷贝那些信息。

![Image](images/sq.jpg) **提示**你知道挂载一个你用`dd`创建的 ISO 文件并不难吗？您需要知道的唯一事情是您必须使用`-o loop`选项，它允许您像任何普通设备一样挂载文件。因此，要在`/mnt`目录中挂载`/mycd.iso`，您需要`mount -o loop /mycd.iso /mnt`。

使用链接

一个非常有用的 Linux 特性——尽管经常被误解——是*链接*。链接可以比作快捷方式:它基本上是指向另一个文件的指针。在 Linux 上(和在任何 UNIX 系统上一样)，支持两种不同的链接:硬链接和符号链接。

为什么要使用链接？

基本上，一个链接可以更容易地找到你需要的文件。您可以为操作系统和在该操作系统上使用的程序文件创建链接，并且可以使用它们来使用户的生活更加方便。假设一些用户属于组`account`，并且您希望组成员在目录`/home/groups/account`中创建所有其他组成员可读的文件。为此，您可以要求用户在每次想要保存文件时切换到正确的目录。或者，您可以为每个用户在其主目录中创建一个链接。这样的链接可以命名为`account`,可以放在所有需要在组帐户的共享目录中保存工作的用户的主目录中，很容易看到这个链接如何使用户更容易地将他们的文件保存到适当的位置。

链接有用的另一个例子来自 FHS 世界，文件系统层次标准。这个标准规定了 Linux 系统应该在哪个目录中存储特定类型的文件。在过去，X 窗口系统将其所有二进制文件安装在`/usr/X11`目录中。后来，X 窗口系统存储其配置文件的目录名被改为`/usr/X11R6`。现在想象一下，如果应用程序在这种变化之后引用了`/usr/X11`目录，会发生什么。它自然会失败，因为该目录已不存在。链接也是这里的解决方案。如果管理员只是创建一个名为`/usr/X11`的链接指向`/usr/X11R6`目录，所有引用`/usr/X11`的应用程序仍然可以使用。

在 Linux 系统上，链接无处不在。安装 Linux 之后，已经有几个链接存在了，作为管理员，添加新的链接很容易。为此，您应该理解符号链接和硬链接之间的区别，这将在接下来的两节“使用符号链接”和“使用硬链接”中解释

使用符号链接

如前所述，链接可以指两种不同的东西:符号链接(也称为软链接)和硬链接。*符号链接*是指文件名称的链接。它最重要的优点是可以用来引用任何地方的文件，甚至是世界另一端的计算机上的文件。符号链接仍然有效。然而，最大的缺点是符号链接自然依赖于原始文件。如果原始文件被删除，符号链接将不再有效。

要创建一个符号链接T5，使用带选项`-s`的 ln 命令。当使用`ln`命令时，确保首先引用原始文件的名称，然后引用您想要创建的链接的名称。例如，如果您想在您的主目录中创建一个名为`computers`的符号链接，该链接引用文件`/etc/hosts`，请使用以下命令:

```
ln -s /etc/hosts ~/computers
```

因此，将在您的主目录中创建一个名为`~/computers`的快捷方式。这个快捷键指的是`/etc/hosts`。因此，任何时候你打开`~/computers`文件，你实际上是在`/etc/hosts`文件中工作。[清单 3-7](#FPar24) 向您展示了在`ls -l,`的输出中，您可以看到结果文件本身并不是一个文件，而是一个符号链接。这由在`ls -l`输出的第一个位置的字母`l`表示，也由列表末尾的箭头表示，该箭头表示该名称所指的文件。

[***清单 3-7***](#_FPar24) 。用`ls -l`你可以看到这个文件实际上是一个符号链接

```
nuuk:~ # ln -s /etc/hosts computers
nuuk:~ # ls -l computers
lrwxrwxrwx 1 root root 10 Jan 19 01:37 computers -> /etc/hosts
```

了解索引节点

为了理解硬链接和符号链接之间的区别，您应该理解 Linux 文件系统中 inodes 的作用。每个 Linux 文件或目录(从技术角度来看，它们之间没有真正的区别)都有一个 inode，这个 inode 包含文件的所有元数据(也就是说，读取文件所需的所有管理数据都存储在它的 inode 中)。例如，inode 包含存储文件的所有块的列表、该文件的所有者信息、权限以及为该文件设置的所有其他属性。在某种意义上，你可以说一个文件实际上是索引节点，名称被附加到这些索引节点上，以便于人们使用它们。

如果您想查看 inodes，在 Ext 文件系统上您可以使用(潜在危险！)命令`debugfs`。这将打开一个低级文件系统调试器，您可以从中发出高级修复命令。您也可以只检查文件系统和其中使用的文件的属性(这一点也不危险)。下面的过程展示了如何在 Ext4 上使用这个文件系统调试器显示给定文件的 inode。注意，这个过程只适用于 Ext 文件系统。

![Image](images/sq.jpg) **注意**只有 Ext2/Ext3 命令`debugfs`可以显示索引节点。事实上，这个文件系统具有像这样强大的实用程序，这有助于使它成为一个非常流行的文件系统。

1.  Use the command `ls -il` to find the inode number of the file `/etc/hosts`. As you can see in [Listing 3-8](#FPar26), the inode number is the first item mentioned in the output of this command.

    [***清单 3-8***](#_FPar26) 。命令`ls -il`显示了文件的索引节点号

    ```
    sander@ubuntu:/$ ls -il /etc/hosts
    15024138 -rw-r--r-- 1 root root 253 2007-06-05 00:20 /etc/hosts
    ```

2.  以 root 身份打开文件系统调试器。启动它时，使用文件所在的 Ext4 文件系统的名称作为参数。例如，我们的示例文件`/etc/hosts`位于一个名为`/dev/sda3`的分区上，所以命令应该是`sudo debugfs /dev/sda3`。这将打开`debugfs`交互提示。
3.  Now use the `debugfs` command stat to display the contents of the inode that you want to examine. For example, in this case you would type **stat <15024138>**. The result of this command is similar to what you see in [Listing 3-9](#FPar27).

    [***清单 3-9***](#_FPar27) 。显示一个信息节点的内容

    ```
    Inode: 13    Type:   regular    Mode:   0644    Flags:  0x0    Generation:   5
    84821287
    User:     0   Group:    0   Size:   1763308
    File ACL: 0    Directory ACL: 0
    Links:  1   Blockcount:   3460
    Fragment:   Address:  0 Number:   0 Size:   0
    ctime:   0x4664e51e -- Tue Jun 5 00:22:54 2007
    atime: 0x4664e51e -- Tue Jun 5 00:22:54 2007
    mtime: 0x4621e007 -- Sun Apr 15 04:19:19 2007
    BLOCKS:
    (0-11):5716-5727,  (IND):5728,  (12-267):5729-5984,  (DIND):5985,  (IND):
    5986,  (268-523):5987-6242,  (IND):6243,  (524-779):6244-6499,  (IND):650
    0,  (780-1035):6501-6756,  (IND):6757,  (1036-1291):6758-7013,  (IND):701
    4, (1292-1547):7015-7270, (IND):7271, (1548-1721):7272-7445
    TOTAL: 1730
    (END)
    ```

4.  使用`quit`命令关闭`debugfs`界面。

理解硬链接和符号链接的区别

当比较符号链接和原始文件时，您会注意到它们之间的明显差异。首先，符号链接和原始文件的 inode 不同:原始文件只是一个直接连接到 inode 的名称，符号链接指的是名称。后者可以从`ls -il (-i`的输出中看出显示的是 inode 号):在符号链接的名称后面，用一个箭头表示你真正在做什么文件。此外，您可以看到符号链接的大小与实际文件的大小有很大不同。符号链接的大小是它所引用的文件名的字节数，因为符号链接中没有其他信息。同样，您可以看到符号链接上的权限是完全开放的。这是因为权限不是在这里管理的，而是在原始文件上管理的。最后，你可以看到符号链接的文件类型被设置为 l，这表明它是一个符号链接(参见[清单 3-10](#FPar28) )。

[***清单 3-10***](#_FPar28) 。展示了符号链接和硬链接之间的区别

```
root@ubuntu:~# ln -s /etc/hosts symhosts
root@ubuntu:~# ln /etc/hosts hardhosts
root@ubuntu:~# ls -il /etc/hosts hardhosts symhosts
15024138 -rw-r--r--     2 root root 253 2007-06-05 00:20 /etc/hosts
15024138 -rw-r--r--     2 root root 253 2007-06-05 00:20 hardhosts
13500422 lrwxrwxrwx 1 root root   10 2007-07-02 05:45 symhosts -> /etc/hosts
```

您可能会问，当原始文件被删除时，符号链接会发生什么变化。嗯，这不难预测！符号链接失败。当使用`ls`命令显示文件属性时，Linux 会显示这一点；当您尝试打开文件时，会收到“文件未找到”的错误信息。

使用硬链接

Linux 文件系统上的每个文件都有一个 inode。如前所述，文件的所有管理数据都保存在其 inode 中。您的计算机实际上完全使用 inodes 工作，文件名只是为了方便那些不太擅长记住数字的人。连接到一个 inode 的每个名称都可以被认为是一个*硬链接*。因此，当您为一个文件创建一个硬链接时，您真正要做的就是向一个 inode 添加一个新名称。为此，使用`ln`命令。关于硬链接，有趣的是原始文件和链接之间没有区别:它们只是连接到同一个 inode 的两个名称。使用它们的缺点是硬链接必须存在于同一设备上，这是相当有限的。但是，如果可能的话，你应该总是创建一个硬链接而不是符号链接，因为它们更快。

[图 3-1](#Fig1) 描述了索引节点、硬链接和符号链接之间的关系。

![9781430268307_Fig03-01.jpg](images/9781430268307_Fig03-01.jpg)

[图 3-1](#_Fig1) 。索引节点、硬链接和符号链接之间的关系

链接摘要

如果您真的想了解一个链接是关于什么的，您确实需要了解 inodes 的角色。如果您只想了解链接的基本知识，请记住以下几点:

*   符号链接就像快捷方式。它指向原始文件并帮助您轻松找到它。但是，如果您删除原始文件，它会断开。
*   硬链接就像是持续同步的文件副本。原始文件和硬链接没有区别；它们都引用相同的块。

现在你已经学习了硬链接和符号链接，是时候用它们做一个练习了。

练习 3-3:使用链接

1.  打开一个根壳。
2.  键入**ln-s/etc/hosts ~/computers**。这将在您的主目录中创建一个名为 computers 的符号链接。
3.  键入**ls-il/etc/hosts ~/computers**。这显示了两个文件的属性。请注意，两个文件上的 inode 号是不同的。
4.  键入**ln/etc/hosts/root/machines**。
5.  键入**ls-il/etc/hosts/root/machines/root/computers**。您会注意到/etc/hosts 和/root/machines 具有相同的属性。
6.  键入 **echo hello > /etc/hosts** 。这将在/etc/hosts 文件中添加一行。
7.  重复命令 5。你会注意到两个硬链接都显示更新的文件大小。
8.  键入 **rm /etc/hosts** 。
9.  类型 **echo /root/machines** 。您仍然会看到以前的/etc/hosts 文件的内容。
10.  键入 **echo /root/computers** 。您将看到一条错误消息:链接引用的文件不再存在。
11.  键入**ln/root/machines/etc/hosts**。这将修复原始的/etc/hosts 文件。

摘要

在本章中，您已经了解了 Linux 文件系统的一些更高级的特性和维护任务。您已经了解了如何使用`mount`命令访问设备。您还了解了如何使用/ `etc/fstab`文件自动安装设备。接下来，讨论了`fsck`命令，教您如何检查并在必要时修复文件系统。接下来，您已经了解了如何使用`tar`和`dd`创建文件和完整设备的备份。在本章的最后一部分，你已经看到了如何使用链接来使你的 Linux 文件系统更加通用。本章讨论了以下命令和配置文件:

*   `mount`:将设备挂载到目录。在 Linux 中，挂载设备是强制性的；不安装设备，就不能使用。
*   `fstab:`表示`/etc`中的配置文件，用于在系统启动时自动安装设备。
*   `mtab:`表示`/etc`中的配置文件，用于跟踪设备的当前安装状态。
*   `umount:`断开已安装的设备。
*   显示目录中当前打开的文件。
*   `lsof:`类似定影器，但显示更多细节。
*   `fsck:`检查文件系统的完整性。
*   `tar:`档案室的文件。这意味着它将多个文件放在一个大文件中。
*   `gzip:`压缩文件。常与`tar`连用。
*   `gunzip`:解压缩用`gzip`压缩过的文件。常与`tar`连用。
*   `bzip2:`替代`gzip`。
*   `bunzip2:`替代`gunzip`。
*   帮助您克隆设备的实用程序。
*   `ln:`创建链接。

在下一章，你将学习如何处理文本文件。