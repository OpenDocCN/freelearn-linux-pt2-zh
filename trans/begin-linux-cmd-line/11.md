第十一章

![image](images/frontdot.jpg)

配置网络

大多数 Linux 计算机在一个互联的世界中运行。因此，配置网络板至关重要。在本章中，您将首先学习如何为您的电脑分配 IP 地址和相关信息。您还将了解一些有用的工具，这些工具将帮助您分析和排除网络连接故障。本章的最后一部分是关于安全外壳(SSH ) ，它可以帮助你安全地连接到其他电脑。

计算机网络快速入门

在研究网络配置的细节之前，首先对它有一个总体的了解是很重要的。这一部分为刚接触这个主题的人解释基本的网络；这不是一个完整的教程，但它试图为没有太多相关知识的人概述最重要的网络概念。

所有的网络都是从地址开始的。网卡上最基本的地址称为媒体访问控制(MAC) 地址。每个网卡都有一个 MAC 地址。这不仅适用于你电脑里的有线网卡，也适用于你用来浏览互联网的手机。这些 MAC 地址是全球唯一的。

尽管可以仅基于 MAC 地址进行通信，但这种解决方案并不理想。这是因为 MAC 地址不包含关于特定计算机在网络上的位置的信息。基于 MAC 地址进行通信的唯一方法是广播到网络中的所有计算机，查询它们以找出哪台计算机具有您正在寻找的 MAC 地址。这适用于小型本地网络(称为 LAN)，但不适用于通过互联网连接到数千英里之外的计算机。

这个问题的解决方案就在 IP 地址里。IP 地址使计算机之间的全球通信成为可能，因为每个 IP 地址都包含有关本地计算机(称为 IP 地址的节点部分)以及计算机所在网络的信息。由于每个 IP 地址都包含这些网络信息，因此可以通过 IP 地址直接访问世界另一端的计算机。

为了将不同的 IP 网络连接在一起，使用了一个*路由器*。这是一台知道如何到达其他 IP 网络的专用机器。大多数路由器只知道几个其他网络，并包含一条*默认路由*。此默认路由引用所有其他 IP 网络地址。最后，大多数路由的网络流量由互联网上的一个主干路由器处理。这些巨大的机器知道如何找到所有的 IP 网络地址。

由于 IP 地址是数字格式的(如 179.237.39.66 ),这对于人类来说不容易处理，因此在互联网上，计算机是通过它们的名称而不是它们的 IP 地址来寻址的。域名服务(DNS)服务器将该名称转换为 IP 地址。

要确保您的电脑可以与互联网上的其他电脑通信，您的电脑需要有一个 IP 地址，并且需要知道在哪里可以找到默认路由器和 DNS 服务器。您可以手动输入所有这些信息(您将在本章后面学习如何操作)，但在许多情况下，DHCP 服务器会自动分发这些信息。如果你在一个工作站上工作，你的电脑会默认联系一个 DHCP 服务器，你会没事的。但是，如果您是负责在网络中启动和运行服务器的管理员，您可能需要自己设置所有这些信息。接下来的部分将教你如何做。

了解网络设备命名

在 Linux 中使用网卡时，需要了解一点网络设备命名。早期的 Linux 系统使用 eth0 作为系统中的物理网卡，wlan0 作为 WiFi 网卡。由于在一些服务器上使用了多个网卡，这种寻址网络设备名称的方式效率不高。由于这个原因，引入了依赖于 BIOS 的网络设备名称。启用此功能时，您将看到网络设备名称，这些名称说明了网卡在机器中的物理位置。

如果使用 BIOS devicenames，您将看到嵌入式网卡的名称 **em** (例如 em1)，以及插入 PCI 插槽的卡的 p <插槽> p <以太网端口>(例如 p6p1)。在虚拟机中，对于固件不支持 BIOS 设备名称的网卡，您可能仍然会看到旧的 eth <号>名称。

对于一些管理员来说，使用 BIOS 设备名称是一个很大的改进。其他人真诚地讨厌它，因为它使机器之间的网络设备名称不一致。如果您不想使用 BIOS 设备名，而是使用旧的命名，请确保 GRUB2 引导加载程序使用引导选项 bios.devname=0 和 net.ifnames=0 **启动您的服务器。**

设置 IP 地址

在安装时，所有的 Linux 发行版都使用 DHCP 来获得 IP 地址。DHCP 提供了一种非常方便的配置网卡的方法，因为即使是简单的家用互联网路由器也有一个嵌入式 DHCP 服务器。然而，在某些情况下，你需要一个固定的 IP 地址。让我们看看这是如何工作的。

在我们开始讨论 IP 地址操作之前，您应该知道有两种方法来管理 IP 地址。有一个 **ifconfig** 命令 ，这个命令已经使用了很长一段时间。然而，对于现代的 Linux 发行版，这个命令不再足够有效，因此有了一种新的管理 IP 地址的方法，使用 **ip** 命令。 **ip** 命令是管理 ip 地址的首选方式，如果您从未使用过 **ifconfig** ，我建议您完全跳过关于 **ifconfig** 的部分。因为一些管理员仍然喜欢使用这个命令，所以我还是包含了如何使用这个命令管理 IP 堆栈的信息。

使用`ip`工具

**ip** 工具是管理 ip 地址配置的默认工具。它有许多选项，允许您管理网络连接的几乎所有方面。例如，您可以使用它来配置 IP 地址，但它也管理路由。其他更高级的操作也通过 **ip** 工具得到支持。

与`ip`命令一起使用的第一个选项决定了你想用这个工具做什么。它是对所谓对象的引用；您可以将这些对象视为更精确地决定您想要做什么的第二命令级别。每个对象都有不同的可能性:

*   `link`:用于管理或显示网络设备的属性。使用它来监控网络接口的当前状态。
*   `addr`:用于管理或显示设备上的 IPv4 或 IPv6 网络地址。
*   `route`:用于管理或显示路由表中的条目。
*   `rule`:用于管理或显示路由策略数据库中的规则。
*   `neigh`:用于管理或显示 ARP 缓存中的条目。ARP 给出关于哪个 MAC 地址使用哪个 IP 地址的信息。通过使用此选项，您可以修改或显示 ARP 信息。
*   `netns`:用于管理 IP 网络名称空间，这是一种在云环境中常用的技术，允许您在使用相同网络接口的同时管理隔离的网络环境。
*   `tunnel`:用于管理或显示 IP 隧道。只有在通过互联网建立虚拟专用网络(VPN) 连接时，您才需要这一功能。VPN 技术在企业环境中非常流行，用于建立安全连接，但在本书中不会进一步讨论。
*   `maddr`:用于管理或显示接口的组播地址。多播地址是可以添加到网卡的组地址。使用多播使用户或应用程序能够同时寻址提供相同功能的所有节点。
*   `mroute`:用于管理或显示组播路由缓存条目。
*   `monitor`:用于监控给定设备上发生的情况。

对于每个对象，您必须使用选项。了解这些选项最简单的方法是使用`ip`命令，后跟对象，再跟关键字`help` 。例如，`ip address help`提供了如何使用`ip address`命令的信息，如[清单 11-1](#FPar1) 所示。

[***清单 11-1***](#_FPar1) 。`ip address help`命令给出了使用 ip 工具配置 IP 地址的帮助

```sh
root@ZNA:~# ip address help
Usage: ip addr {add|del} IFADDR dev STRING
       ip addr {show|flush} [ dev STRING ] [ scope SCOPE-ID ]
                            [ to PREFIX ] [ FLAG-LIST ] [ label PATTERN ]
IFADDR := PREFIX | ADDR peer PREFIX
          [ broadcast ADDR ] [ anycast ADDR ]
          [ label STRING ] [ scope SCOPE-ID ]
SCOPE-ID := [ host | link | global | NUMBER ]
FLAG-LIST := [ FLAG-LIST ] FLAG
FLAG := [ permanent | dynamic | secondary | primary |
          tentative | deprecated ]
```

找出`ip`工具的帮助是如何工作的是一个相当大的挑战，所以我会给你一些关于这个特性的提示。要了解自己需要做什么，首先要分析`Usage:`行。在[清单 11-1](#FPar1) 的例子中，您可以看到其中的两个:一个使用行以`ip addr {add|del}`开始，另一个以`ip addr {show|flush}`开始。让我们来看看第一个，它允许您添加或删除 IP 地址。

如`ip address help is ip addr {add|del} IFADDR dev STRING`所述的完整使用行。因此，您可以从由`STRING`引用的设备(`dev`)中添加或删除由`IFADDR`引用的 IP 地址。现在，一个字符串只是一个字符串，它可以是任何东西(但通常是像`eth0`)。`IFADDR`部分是您将分配给字符串的地址，它提供了更多的选项，这将在下一部分中描述。您可以在帮助输出的下一部分找到该部分的解释:`IFADDR := PREFIX | ADDR peer PREFIX [ broadcast ADDR ] [ anycast ADDR ] [ label STRING ] [ scope SCOPE-ID ]`。在这一行中，帮助解释说您必须使用一个`PREFIX`或`ADDR`语句，后面可能跟有几个选项，如`broadcast`地址、`anycast`地址、`label`或`SCOPE-ID`。但是从帮助中也可以看出，你可以简单地添加一个地址。对其他选项没有进一步的解释，因为这是您在配置 IP 地址时应该了解的信息。这意味着`ip address help`无法告诉你在哪个以太网接口上需要哪个 IP 地址。现在你已经理解了帮助是如何工作的，让我们来看看使用`ip`命令的不同方式。

小费！仅基于帮助文本使用 **ip** 命令是具有挑战性的。您可能更好地尝试记住您可以使用 ip 命令完成的最重要的任务，以及如何完成它们。[表 11-1](#Tab1) 给出了这些命令的概述。

[表 11-1](#_Tab1) 。ip 命令重要示例概述

| 

工作

 | 

命令

 |
| --- | --- |
| 显示当前配置 | ip 地址显示 |
| 向 eth0 添加 IP 地址 | ip 地址添加 10.0.0.10/24 开发 eth0 |
| 显示链接统计 | ip 链接显示 |
| 显示路由表 | ip 路由显示 |
| 添加默认路由 | ip 路由通过 10.0.0.1 添加默认值 |

显示带有 **ip** 的 Ip 地址

`ip`的一个常见用途是显示给定接口的 IP 地址使用信息。要使用的命令是`ip address show`，或者仅仅是`ip address`。注意，如果你清楚地知道你想要什么，并且选项之间没有混淆，你可以用简短的形式指定与`ip`命令一起使用的选项，例如`ip a s`，它完成与`ip address show`相同的事情。清单 11-2 给出了一个例子。

[***清单 11-2***](#_FPar2) 。显示 ip 地址配置和 ip 地址显示

```sh
root@ZNA:~# ip address show
1: lo: <LOOPBACK,UP,10000> mtu 16436 qdisc noqueue
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,10000> mtu 1500 qdisc pfifo_fast qlen 1000
    link/ether 00:0c:29:a0:a5:80 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.33/24 brd 192.168.1.255 scope global eth0
    inet 10.0.0.10/8 brd 10.255.255.255 scope global eth0:0
    inet 10.0.0.20/8 brd 10.255.255.255 scope global secondary eth0:1
    inet6 fe80::20c:29ff:fea0:a580/64 scope link
       valid_lft forever preferred_lft forever
```

正如你所看到的， **ip 地址显示**命令显示的内容非常完整。特别是关于`eth0`(通常是你的固定网卡)的部分很有趣。首先，您可以看到该设备上启用了广播和多播，并且网卡已打开。接下来，它显示了网卡的一些其他属性，如果您需要对网卡的工作方式进行故障排除，这些属性会很有趣。然而，如果您只需要分配一个 IP 地址，您通常不会关心这些参数。最后，以`inet`开头的行显示了分配给网卡的地址，以及它们对应的子网掩码。

显示设备属性

`ip`工具的另一个简单用途是显示设备属性，这可以用`ip link show`命令来完成。这个命令显示您指定的设备的使用统计，但是没有地址信息，这也是显而易见的。`ip link`在链路上工作，`ip address`在 IP 地址上工作。清单 11-3 提供了一个输出的例子。

[***清单 11-3***](#_FPar3) 。使用`ip link show`命令查看链接属性

```sh
root@ZNA:~# ip link show
1: lo: <LOOPBACK,UP,10000> mtu 16436 qdisc noqueue
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,10000> mtu 1500 qdisc pfifo_fast qlen 1000
    link/ether 00:0c:29:a0:a5:80 brd ff:ff:ff:ff:ff:ff
```

`ip link show`显示的信息与网板上的活动有关。特别感兴趣的是为每个设备返回的设备属性(它们显示在设备名称后面的括号中)。例如，您可以看到普通网络接口卡的属性`BROADCAST,MULTICAST,UP`。`BROADCAST`属性表示设备能够向网络中的其他节点发送广播，`MULTICAST`属性表示设备也可以发送多播数据包(该功能在某些网络中被禁用)，而`UP`属性表示设备正在工作。该命令还显示所有 IP 协议属性，例如接口上使用的最大传输单位(`mtu` ) 。

设置 IP 地址

您也可以使用`ip`工具为设备分配 IP 地址。为此，您可以使用类似于`ip address add 10.0.0.10/16 dev eth0`的命令。该命令将`eth0`的 IP 地址设置为 10.0.0.10。对于此 IP 地址，使用 16 位子网掩码，这由直接位于 IP 地址后面的子网掩码 255.255.0.0 `(/16)`的 CIDR 符号表示。广播地址是自动计算的，您可以通过在命令中添加`brd +`来指定。一旦您使用`ip`工具设置了 IP 地址，您可以使用下面的命令来检查设置是否正确:`ip address show dev eth0`(或者只使用`ip a`，这将为您提供所有网卡的地址配置)。

使用`ip`工具时，您也可以向网络接口添加多个 IP 地址。这并不难:只需使用`ip address add 10.0.0.20/16  dev eth0`，10.0.0.20 及其指定的属性将作为第二个 IP 地址添加到`eth0`(假设已经为这个网卡定义了一些其他的 IP 地址)。使用`ifconfig`添加的辅助 IP 地址和使用`ip`工具添加的 IP 地址是有区别的。使用`ifconfig`时，添加了`ip`的地址不会显示。因此，当使用辅助 IP 地址时，确保使用正确的工具来检查它们的属性，当使用传统的 **ifconfig** 工具时，您可能会错过它们。

使用`ifconfig`

您可以使用`ifconfig`来管理和监控网络接口卡。该命令已存在多年；虽然这不是最灵活的命令，但它仍然可以完成工作。最大的优势是:这是一个相对容易使用的命令。如果您使用不带任何参数的`ifconfig`命令，您将看到关于您计算机中网卡当前配置的信息。这方面的一个例子在[清单 11-4](#FPar4) 中。

[***清单 11-4***](#_FPar4) 。`ifconfig`命令可以显示您当前的网络配置参数

```sh
eth0        Link encap:Ethernet HWaddr 00:0C:29:A0:A5:80
            inet addr:192.168.1.33 Bcast:192.168.1.255 Mask:255.255.255.0
            inet6 addr: fe80::20c:29ff:fea0:a580/64 Scope:Link
            UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
            RX packets:3035 errors:0 dropped:0 overruns:0 frame:0
            TX packets:199 errors:0 dropped:0 overruns:0 carrier:0
            collisions:0 txqueuelen:1000
            RX bytes:240695 (235.0 KiB) TX bytes:19035 (18.5 KiB)
            Interrupt:18 Base address:0x1400
Lo          Link encap:Local Loopback
            inet addr:127.0.0.1 Mask:255.0.0.0
            inet6 addr: ::1/128 Scope:Host
            UP LOOPBACK RUNNING MTU:16436 Metric:1
            RX packets:0 errors:0 dropped:0 overruns:0 frame:0
            TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
            collisions:0 txqueuelen:0
            RX bytes:0 (0.0 b) TX bytes:0 (0.0 b)
```

用 **ifconfig** 显示信息

正如您在[清单 11-4](#FPar1) 中看到的，`ifconfig`命令提供了关于网卡的不同种类的信息。它以网卡上使用的协议名称开始。协议用(例如)`Link encap: Ethernet`表示，表示是以太网网板。几乎所有现代 LAN 接口都将以太网作为链路封装类型，但在 WAN 连接中，您可能会看到其他协议，如 PPP。然后 MAC 地址作为`HWaddr`(硬件地址)给出。该地址后面首先是与 IPv4 相关的地址信息(`inet addr`)，然后是 IPv6 地址信息(如果 IPv6 尚未被禁用的话)(`inet6 addr`)。然后给出了几个关于网板的统计数据。请特别注意`RX packets`(接收的数据包)和`TX packets`(发送的数据包)，因为您可以从这些统计数据中看到网卡正在做什么，以及是否发生了任何错误。通常，这里应该没有错误。

![Image](images/sq.jpg) **注意**目前大部分电脑使用 IP 版本 4 的 IP 地址。在第 4 版中，大约有 40 亿个 IP 地址可以被寻址。然而，由于协议规范效率低下，几乎没有更多可用的空闲 IPv4 地址。因此开发了 IPv6(见`www.ipv6.org`)。IPv6 最重要的目的是让更多的 IP 地址可用。然而，迁移到 IPv6 进展缓慢，因为它需要对想要迁移的公司的网络基础设施进行大量的工作。Linux 提供了对 IPv6 的全面支持，大多数发行版甚至默认启用它。IPv6 地址以十六进制表示，如下例所示:feb 0:ff66:ab08:0963:badc:AFE 0:3796:0012。与典型的 IPv4 地址相比，它看起来像 129.13.57.192。

除了关于电脑中存在的物理网络板的信息之外，您还将始终看到关于环回设备(`lo`)的信息，环回设备是电脑上用于内部目的的网络接口。您的计算机需要这个环回设备，因为一些与 IP 相关的服务依赖它；例如，Linux 上使用的图形环境是在环回接口提供的 IP 栈之上编写的。

用 **ifconfig** 配置网卡

虽然您的系统在安装时会提供一个 IP 地址，但是使用`ifconfig`命令动态管理 IP 地址配置是非常重要的。幸运的是，以这种方式配置网络板相对容易:只需添加您想要配置的网络板的名称，后跟您想要在该网络板上使用的 IP 地址(例如，`ifconfig eth0 192.168.1.125`)。该命令将为`eth0`配置默认的 C 类子网掩码 255.255.255.0，这表示 IP 地址的前三个字节是网络地址的一部分，最后一个字节是该网络中唯一的主机标识符。

![Image](images/sq.jpg) **提示**不确定使用的是什么`eth`设备号？您可以通过`udev`机制来管理这一点。在文件`/etc/udev/rules.d/nn-persistent-net.rules`中，你的网卡的 MAC 地址和接口号之间有一个映射。所以如果你想让`eth1`装置呈现为`eth0`，这是你可以改变它的地方。只需将当前名称(如`eth1`)更改为您想要的名称，并重启计算机以使更改生效。

如果您需要一个定制的子网掩码，可以向`ifconfig`添加一个额外的参数，如命令`ifconfig eth0 172.16.18.18 netmask 255.255.255.0 broadcast 172.16.18.255`所示，该命令使用给定的 IP 地址和一个 24 位子网掩码来配置`eth0`设备。如果您使用非默认子网掩码，您还必须指定用于寻址同一网络中所有节点的广播地址；`ifconfig`命令不够智能，无法意识到您正在使用非默认的 IP 地址，也无法相应地计算出正确的广播地址。

![Image](images/sq.jpg) **注意**在 IP 协议中，子网掩码用于区分 IP 地址的网络部分和节点部分。所有 IP 地址都必须有一个子网掩码。为了使使用 IP 更容易，IP 地址有一个默认的子网掩码；例如，以 192 开头的 IP 地址(如 192.1.2.3)的默认子网掩码为 255.255.255.0，这告诉 IP 堆栈前三个字节用于寻址网络，最后一个字节仅用于寻址节点。在某些情况下，管理员可能会选择使用非默认子网掩码，例如，如果他或她需要寻址多个网络，但没有足够的网络地址可用。有两种方法可以写入要使用的子网掩码:所谓的点法(如 255.255.255.0)或 CIDR 法。后者使用斜杠，后跟子网掩码中的字节数。有关子网掩码的更详细解释，请参考`http://en.wikipedia.org/wiki/Subnetwork`。

使用 **ifconfig** 启动和关闭接口

除了向一块网络板添加 IP 地址之外，您还可以使用`ifconfig`命令来启动或关闭一块特定的网络板。例如，`ifconfig eth0 down`关闭界面，`ifconfig eth0 up`用默认设置重新打开界面。如果你想测试一个新的配置，但是你不确定它是否真的能正常工作，这是很有用的。

除了用`ifconfig`来上下网卡，还可以用`ifup`和`ifdown`。这些命令允许您轻松启动或关闭网卡，而无需更改给定网卡的配置。比如要把一块网板弄下来，用`ifdown eth0`；要再次调出，请使用`ifup eth0`。在这两种情况下，都会应用网卡的默认配置。

使用虚拟 Ip 地址和 **ifconfig**

在某些情况下，一个网卡可能需要多个 IP 地址。这些被称为虚拟 IP 地址 ，你可以用`ifconfig`来设置。如果您要在计算机上配置需要自己的 IP 地址的服务，使用虚拟 IP 地址非常有用。例如，想象不同的虚拟 Apache web 服务器，它们都可以通过自己的 IP 地址到达。

![Image](images/sq.jpg) **注意**这并不意味着要运行 Apache 的多个实例，您总是需要一个虚拟 IP 地址配置。使用虚拟 IP 地址只是一种方法。

您可以在相同或不同的 IP 地址范围内使用虚拟 IP 地址。要添加虚拟 IP 地址，请在网络接口名称后添加`:` *n* ，其中 *n* 是一个数字。例如，`ifconfig eth0:0 10.0.0.10`将地址 10.0.0.10 作为虚拟 IP 地址添加到`eth0`。冒号后面的数字必须是唯一的，所以可以用`ifconfig eth0:1 10.0.0.20`添加第二个虚拟 IP 地址，以此类推。当您使用`ifconfig`工具显示您计算机的当前配置时，您将看到所有配置的虚拟 IP 地址，如[清单 11-5](#FPar9) 所示。

[***清单 11-5***](#_FPar9) 。ifconfig 工具也显示虚拟 IP 地址

```sh
root@ZNA:~# ifconfig eth0:0 10.0.0.10
root@ZNA:~# ifconfig eth0:1 10.0.0.20
root@ZNA:~# ifconfig
eth0       Link encap:Ethernet HWaddr 00:0C:29:A0:A5:80
           inet addr:192.168.1.33 Bcast:192.168.1.255 Mask:255.255.255.0
           inet6 addr: fe80::20c:29ff:fea0:a580/64 Scope:Link
           UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
           RX packets:3035 errors:0 dropped:0 overruns:0 frame:0
           TX packets:199 errors:0 dropped:0 overruns:0 carrier:0
           collisions:0 txqueuelen:1000
           RX bytes:240695 (235.0 KiB) TX bytes:19035 (18.5 KiB)
           Interrupt:18 Base address:0x1400
eth0:0     Link encap:Ethernet HWaddr 00:0C:29:A0:A5:80
           inet addr:10.0.0.10 Bcast:10.255.255.255 Mask:255.0.0.0
           UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
           Interrupt:18 Base address:0x1400
eth0:1     Link encap:Ethernet HWaddr 00:0C:29:A0:A5:80
           inet addr:10.0.0.20 Bcast:10.255.255.255 Mask:255.0.0.0
           UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
           Interrupt:18 Base address:0x1400
           Link encap:Local Loopback
           inet addr:127.0.0.1 Mask:255.0.0.0
           inet6 addr: ::1/128 Scope:Host
           UP LOOPBACK RUNNING MTU:16436 Metric:1
           RX packets:0 errors:0 dropped:0 overruns:0 frame:0
           TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
           collisions:0 txqueuelen:0
           RX bytes:0 (0.0 b) TX bytes:0 (0.0 b)
```

练习 11-1:管理 IP 地址

在本练习中，您将学习如何管理 IP 地址。您将使用 **ip** 命令，并了解为什么您不应该再使用 **ifconfig** 命令。

1.  在您的机器上打开一个根 shell。如果你正在使用 Ubuntu，你可以使用 **sudo su** 命令来完成。
2.  输入 **ip 地址显示**。在你的机器中查找网卡的名称。在本练习的剩余部分，我将假设它是 eth0，确保用您的配置中使用的名称替换该名称。
3.  键入 **ip link show** 显示您的网卡的链接统计信息。
4.  键入**ip addr add dev eth 0 10 . 11 . 12 . 13/24**以添加辅助 IP 地址。
5.  使用 **ping 10.11.12.13** 来验证该 IP 地址是否正常工作。
6.  类型 **ifconfig** 。您将看不到您分配的辅助 IP 地址。这就是为什么你不应该再使用 **ifconfig** 的原因。

存储地址配置

当您的计算机启动时，它通常会自动加载其 IP 地址配置。在接下来的部分中，您将会看到这是如何在最重要的 Linux 发行版上工作的。

在 Ubuntu 上存储 IP 地址配置

当您的电脑启动时，它会从`/etc/init.d`启动`networking`脚本。该脚本读取存储在`/etc/network`目录中的配置，或者使用 systemd 脚本(如果您使用的是较新的版本),要特别注意`/etc/network/interfaces`文件。这个配置文件存储了网络板的整个配置。[清单 11-6](#FPar11) 显示了一台有两块以太网卡的计算机的配置示例。

[***清单 11-6***](#_FPar11) 。Ubuntu 上接口文件的内容示例

```sh
root@ZNA:~# cat /etc/network/interfaces
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).
# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
iface eth0 inet static
        address 192.168.1.33
        netmask 255.255.255.0
        network 192.168.1.0
        broadcast 192.168.1.255
        gateway 192.168.1.254
        # dns-* options are implemented by the resolvconf package, if installed
        dns-nameservers 193.79.237.39
        dns-search lan

#The second network board
auto eth1
iface eth1 inet static
        address 10.0.0.10
        netmask 255.255.255.0
        network 10.0.0.0
        broadcast 10.0.0.255
```

从配置文件中可以看到，计算机已经激活了三个网络接口。第一个是`lo`，这是环回接口。许多服务都需要它才能运行，即使您的电脑根本没有网络连接。例如，负责计算机图形显示的 X 服务器使用环回接口来处理内部通信。环回接口始终使用 IP 地址 127.0.0.1。

在大多数情况下，以太网卡用于与世界其他地方连接。如果是第一个网卡，这个网卡用名称`eth0`表示，后面的网卡用名称`eth1`等表示。每个网板的定义都是从`auto eth`开始 *n* ，其中 *n* 是网络接口的编号。此线路用于在计算机启动时自动启动网卡。您可以省略这一行，但是如果您这样做，您将需要使用前面描述的`ifup`或`ifconfig`命令来手动启动网卡。在大多数情况下，你不希望这样做，所以要确保始终使用以`auto`开头的行。

在自动行之后，是接口本身的定义。在本例中，一台计算机配置了两个静态 IP 地址。如果你需要在一个接口上使用 DHCP，确保`iface`行显示为`iface ethn inet dynamic`。接下来是网卡的其余配置。在所有情况下，您都需要地址、网络掩码、网络和广播。其他选项是可选的。

在 Red Hat 上存储 IP 地址配置

在 Red Hat 上，固定 IP 地址配置存储在`/etc/sysconfig/network-scripts/ ifcfg-ethn`文件中。为每个以太网接口创建一个文件。在清单 11-7 中，您可以看到这个文件的样子。

[***清单 11-7***](#_FPar12) 。存储在 Red Hat 上的网络配置

```sh
[root@workstation ~]# cat /etc/sysconfig/network-scripts/ifcfg-eno16777736
TYPE="Ethernet"
BOOTPROTO="none"
DEFROUTE="yes"
IPV4_FAILURE_FATAL="no"
IPV6INIT="yes"
IPV6_AUTOCONF="yes"
IPV6_DEFROUTE="yes"
IPV6_FAILURE_FATAL="no"
NAME="eno16777736"
UUID="67ef89fc-cf5f-449b-b92d-7f980951eace"
ONBOOT="yes"
HWADDR="00:0C:29:25:D0:71"
IPADDR0="192.168.4.9"
PREFIX0="24"
GATEWAY0="192.168.4.2"
DNS1="8.8.8.8"
IPV6_PEERDNS="yes"
IPV6_PEERROUTES="yes"
```

在这个示例配置文件中，您可以看到几个参数。您可以根据需要更改它们，并在使用`ifdown ethn`和`ifup ethn`应用更改后停用和激活设备。以下参数在`ifcfg-ethn`文件中:

*   `DEVICE`:设备名称。这应该是硬件设备的`eth`名称。
*   `HWADDR`:设备的 MAC 地址。确保它对于您正在使用的所有设备都是唯一的。
*   `ONBOOT`:电脑开机时是否必须激活设备。您通常希望将该参数设置为`yes`。
*   `SEARCH`:默认 DNS 搜索域。如果使用了不完整的 DNS 名称(例如 ping linda)，则会附加默认的 DNS 搜索域。
*   `BOOTPROTO`:使用的特定引导协议，如果有的话。如果您希望网卡在激活时自动从 DHCP 服务器获取 IP 地址，请将此项设置为 DHCP。
*   `NETMASK`:您在此接口上与 IP 地址一起使用的网络掩码。
*   `IPADDR`:该接口使用的 IP 地址。
*   `USERCTL`:是否允许最终用户激活和停用该界面。
*   `PEERDNS`:点对点设置中对等体的 DNS 信息。
*   `IPV6INIT`:是否要初始化 IPv6 协议。
*   `NMCONTROL`:作为手动设备配置的替代方法，您可以使用网络管理器应用程序来配置网络设备。这个参数告诉您的系统是否应该使用这个 applet。
*   `GATEWAY`:连接到其他网络上的计算机所需的默认路由器的 IP 地址。
*   `TYPE`:该网卡使用的协议。

在 SUSE 上存储 IP 地址配置

在 SUSE Linux 上，网络信息的存储方式与 Fedora 差不多。配置文件的名称是`/etc/sysconfig/network/ifcfg-nnn`，其中`nnn`代表网卡使用的 MAC 地址。清单 11-8 显示了 SUSE 配置文件的样子。在这个清单中，您可以看到文件`ifcfg-eth- id-00:0c:29:ae:e6:e5`的内容是被请求的。在文件名中，反斜杠用于确保下一个字符不会被 shell 解释。您可以手动更改 SUSE 配置文件，或者使用 YaST 配置工具。

[***清单 11-8***](#_FPar13) 。存储在 SUSE 上的网卡配置

```sh
nuuk:/etc/sysconfig/network # cat ifcfg-eth-id-00\:0c\:29\:ae\:e6\:e5
BOOTPROTO='dhcp'
BROADCAST=''
ETHTOOL_OPTIONS=''
IPADDR=''
MTU=''
NAME='AMD PCnet - Fast 79C971'
NETMASK='255.255.255.0'
NETWORK=''
REMOTE_IPADDR=''
STARTMODE='auto'
UNIQUE='rBUF.weGuQ9ywYPF'
USERCONTROL='no'
_nm_name='bus-pci-0000:02:00.0'
```

在 SUSE 配置文件中，存储了多个参数。下面是对它们的简短解释:

*   `BOOTPROTO`:表示是否应该使用 DHCP 或者接口是否有静态 IP 地址分配。使用 DHCP 或静态。
*   `BROADCAST`:指定网络的广播地址。
*   `ETHTOOL_OPTIONS`:指定将由`ethtool`实用程序解释的`ethtool`命令参数。`ethtool`允许您设置特定参数，如网卡的链接速度、双工模式或接收缓冲区大小。你可以在本章后面的“用`ethtool`调优网卡”一节中读到更多关于这个实用程序的内容。
*   `IPADDR`:指定要使用的 IP 地址。
*   `MTU`:指定最大传输单位。在以太网上默认是`1500`；将其设置为`9000`以启用巨型帧，这对处理大数据包的链路很有用。
*   `NAME`:指定接口的名称。在此输入唯一的名称。`* NETMASK`:用点符号表示网络掩码(255.255.255.0 和 not /24)。
*   `NETWORK`:允许您指定网络的地址。该字段是可选的。
*   `REMOTE_IPADDR`:指定点对点连接中远程节点的 IP 地址。
*   `STARTMODE`:表示该界面必须自动启动还是手动启动。
*   `UNIQUE`:包含 YaST 管理实用程序使用的唯一 ID。
*   `USERCONTROL`:表示是否允许最终用户停止和启动该界面。
*   `_nm_name`:包含对网卡硬件位置的引用。

配置路由

您已经了解了如何为网络接口提供 IP 地址。但是，要在网络上完全正常工作，您还必须指定一些路由。这些路由允许您与其他网络上的计算机通信，反之，它们也允许其他网络上的计算机与您的计算机通信。

作为最低要求，您需要一个默认路由。此项指定将没有本地网络目标的数据包发送到哪里。用作默认路由的路由器始终与您的计算机在同一个网络上；就当它是帮你走出局域网的门吧。你的电脑通常从`/etc/network/interfaces` Ubuntu 文件、Fedora 上的`/etc/sysconfig/network-scripts/ifcfg-eth0`或 SUSE 上的`/etc/sysconfig/network/routes`中获取关于它应该使用的默认路由器的信息。要自己设置默认路径，可以使用两个工具:工具`ip`和工具`route`。在接下来的两个部分中，您将阅读如何做到这一点。ip 工具是管理路线的首选工具。

用路由 管理默认路由

设置默认路线的旧命令是`route`。如果未使用任何选项，它将显示当前在该主机上定义的所有路由的列表。清单 11-9 提供了一个例子。当使用不带选项的`route`命令时，它总是试图解析给定 IP 地址的名称，这需要一些时间。如果你不想执行任何名称解析，使用选项`-n`，这会使命令快很多。

[***清单 11-9***](#_FPar14) 。使用`route`命令查看当前配置的所有路线

```sh
root@ZNA:~# route
Kernel IP routing table
Destination       Gateway          Genmask          Flags  Metric  Ref  Use  Iface

localnet          *                255.255.255.0    U      0       0    0    eth0
10.0.0.0          *                255.0.0.0        U      0       0    0    eth0
default           192.168.1.254    0.0.0.0          UG     0       0    0    eth0
```

在`route`命令的输出中，提供了路由过程所需的所有信息，如清单 11-9 中所示。第一列提供目的地，即为其定义路由的网络或主机。通常，这些是您的计算机通过其本地接口和默认路由连接到的网络。接下来是网关，它是到达指定目的地需要联系的路由器。该字段中的星号(`*`)表示本地计算机是该目的地的网关。如果将外部路由器用作目的地，您将看到该路由器的 IP 地址(或名称)。接下来是`genmask`，它是在指定目的地上使用的子网掩码。然后是`flags`、`metric, ref`和`use`栏目，所有这些栏目都揭示了关于这条路线的更详细的信息。最后，`iface`列揭示了使用什么网络接口来路由数据包。

要指定路由，您至少需要提供两条信息:要添加的网络的 IP 地址或名称，以及默认网关的 IP 地址。所有其他信息都是自动添加的。例如，如果您想指定 IP 地址为 192.168.1.254 的路由器作为默认网关，请使用命令`route add default gw 192.168.1.254`。

如果您需要更改默认网关，您应该知道您首先必须删除此默认网关的旧条目。使用`route del`命令来完成此操作。例如，要删除默认网关的当前设置，请使用`route del default gw`。

使用`ip`工具管理默认路线

如果您知道在定义路线时要输入什么信息，那么使用`ifconfig`或`ip`工具很容易做到这一点。只是语法不同。使用`ip`工具将默认网关设置为 192.168.1.254，使用`ip route add default via 192.168.1.254`命令。此命令确保发送到非本地目的地的所有数据包都通过 192.168.1.254 发送。同样，您可以用`ip route del default`删除默认路线。

存储路由信息

为了确保您的计算机在重新启动后仍然知道默认路由，您应该将其存储在某个地方。在接下来的三节中，您将会看到如何在三个主要发行版中做到这一点。

Ubuntu〔t0〕

当您从命令行输入信息(如默认网关)时，这些信息将在下次重新启动计算机时丢失。为了确保重启后信息仍然存在，将它存储在 Ubuntu 上的`/etc/network/interfaces`文件中。每次网络激活时都会读取该文件。该文件中用于存储默认路由的条目并不复杂:

```sh
gateway 192.168.1.254
```

如果您的计算机中有多个网卡，只需指定一次默认路由的信息就足够了。

Red Hat

在 Red Hat 上，您还可以在存储网络接口配置的文件中指定默认路由的地址。参见本章前面的[清单 11-7](#FPar12) 中的例子。如果您的计算机中有多个网卡，则不需要在每个网卡的配置文件中输入此信息。

将 DNS 名称解析为 IP 地址

如果您想要手动配置网络连接作为最后一部分，您需要指定要使用的 DNS 名称服务器。DNS 服务器确保您的本地网络和互联网上使用的名称可以被翻译成您的计算机建立连接所需的 IP 地址。

要存储 DNS 信息，您需要使用所谓的 DNS 解析器。此 DNS 解析程序存储在`/etc/resolv.conf`文件中；没有命令行实用程序来配置它。通常，`/etc/resolv.conf`文件将包含至少两个 DNS 名称服务器的 IP 地址和一个搜索域。名称服务器规范指出应该联系哪台 DNS 名称计算机来将 DNS 名称转换为 IP 地址，反之亦然。通常，您的互联网提供商会向您提供这些信息。指定至少两个名称服务器，以便在第一个服务器无法访问时，第二个服务器可以完成这项工作。

搜索域指定如果使用不完整的主机名，应该附加什么域名。使用默认 DNS 域名作为搜索域名是有意义的。因此，如果你的计算机的名字是 computer.example.com，设置搜索域名为 example.com。清单 11-10 是`/etc/resolv.conf`文件内容的一个例子。

[***清单 11-10***](#_FPar15) 。`/etc/resolv.conf`文件的例子

```sh
nameserver 192.168.1.10
nameserver 193.79.237.39
search example.com
```

在本例中，您会看到名称服务器 192.168.1.10 被用作默认名称服务器，所有 DNS 请求都将发送给它。如果无法联系到该服务器，则只能联系列表中的第二个服务器(193.79.237.39)。清单 11-10 中的第三行指定了搜索域。例如，如果用户使用包含不完整主机名的命令`ping ftp`，则在`resolv.conf`中使用搜索选项指定的域名会自动添加到该命令中，因此在这种情况下，数据包将被发送到 ftp。example.com。

注意，在三个主要的 Linux 发行版中，都不应该直接编辑/etc/resol.conf 文件。您必须将 DNS 服务器配置包含在网卡配置文件中(Red Hat 上的/etc/sys config/network-scripts/if CFG-eth 0 或 Ubuntu 上的/etc/network/interfaces)。从那里，DNS 名称服务器将被写入/etc/resolv.conf 文件。对/etc/resolv.conf 文件进行的任何手动修改都有可能在网络服务重新启动后丢失。

`/etc/nsswitch.conf`文件的作用

大多数人想当然地认为 DNS 将主机名解析为 IP 地址，但事实并非如此。每台 Linux 计算机都有一个`/etc/nsswitch.conf`文件，它决定了在将主机名翻译成 IP 地址时应该发生什么，反之亦然。这个文件指定了很多东西(比如用户配置，你可以在第 6 章中读到)，但是只有下面几行对于解析主机名很重要:

```sh
hosts:         files dns
networks:      files
```

这两行指定，在解析主机名和网络名时，应该首先搜索(本地)文件，并且只有当文件没有关于给定主机的信息时，才应该使用 DNS 子系统。因此，管理员可以确保在本地解析经常访问的主机名，只有当文件不包含特定主机的信息时，才会联系 DNS。用于将名称解析为 IP 地址的最重要的文件是`/etc/hosts`文件，它是由`/etc/nsswitch.conf`中的`hosts`行上的文件引用的文件。

使用`/etc/hosts`文件

将主机名解析为 IP 地址(反之亦然)的最古老的方法之一是使用`/etc/hosts`文件。它相当原始，因为您必须在每台需要它的计算机上维护该文件，并且在计算机之间没有建立该文件中条目的同步。但这也是一种非常有效的方式来提供当地需要的信息。

![Image](images/sq.jpg) **注**为了解决分散管理的问题，网络信息服务(NIS，原名黄页)是太阳微系统公司发明的。现在，它已经很少被使用了，因为大多数公司都在 DNS 中保存与主机相关的信息。

使用`/etc/hosts`文件可以更快地解析名称并减少互联网流量，您可以使用它来添加任何需要仅在本地可用的主机名。清单 11-11 显示了这个文件的内容示例。

[***清单 11-11***](#_FPar17) 。`/etc/hosts`文件的例子

```sh
[root@workstation ~]# cat /etc/hosts
127.0.0.1    localhost    localhost.localdomain    localhost4 localhost4.localdomain4
::1          localhost    localhost.localdomain    localhost6 localhost6.localdomain6
192.168.4.9  workstation  workstation.example.com
192.168.4.10 server1      server1.example.com
192.168.4.20 server2      server2.example.com
```

如您所见，这个文件的内容相当简单。首先，指定主机的 IP 地址，可以是 IPv4 或 IPv6 地址。接下来，指定主机的完全限定主机名。这是主机本身的名称，后跟其 DNS 后缀。最后，使用短主机名。或者，您可以只提供 IP 地址，后跟要添加的主机的名称，如下行所示:

```sh
192.168.1.180    RNA
```

在现代的 Linux 计算机上，除了本地名称解析之外，通常不需要设置`/etc/hosts`。网络名称解析通常在 DNS 中管理。因此，在这个文件中，您总是需要自己的主机名和 IP 地址。这是在安装计算机时自动配置的。

用`ethtool`调谐网卡

至此，您已经知道如何配置与 IP 相关的参数。网卡本身也有你可能需要修改的设置，你将使用`ethtool`命令 来完成。使用此实用程序，您可以更改网卡属性，如链接速度和双工模式。但是不要高估这个工具。有些以太网卡不被支持，改变设置的唯一方法可能是通过网卡的 BIOS 设置。让我们从显示一些信息开始:发出`ethtool -i eth0`来查看当前使用的驱动属性的概述，如[清单 11-12](#FPar18) 所示。

[***清单 11-12***](#_FPar18) 。ethtool -i 命令提供了驱动程序属性的概述

```sh
[root@lab ~]# ethtool -i eno1
driver: e1000e
version: 2.3.2-k
firmware-version: 0.6-4
bus-info: 0000:00:19.0
supports-statistics: yes
supports-test: yes
supports-eeprom-access: yes
supports-register-dump: yes
supports-priv-flags: no
```

要更改网络板上的双工设置和链接速度，您将使用`-s`选项，后跟以下参数之一:

*   `speed`:该选项改变速度。有效选项为`10, 100`和`1000`。
*   `duplex`:此选项改变双面设定。将其设置为`half`或`full`。
*   `port`:指定使用哪个端口。此选项用于具有不同可用端口的网络接口(这并不常见)。有效的选择是`tp, aui, bnc, mii`和`fibre`。
*   `autoneg`:该选项表示您是否希望使用自动协商来发现网络上使用的设置。

所以，举例来说，如果你想把你的网卡的设置改成全双工和 1000 Mbps 的链接速度，就用`ethtool -s eth0 speed 1000 duplex full`。现在这样使用`ethtool`有一个问题:下次开机需要重新输入这些设置。只有 SUSE 提供了这个问题的解决方案；在 SUSE 上，您可以将`ethtool`配置参数存储在网卡的配置文件中。您已经在清单 11-8 中看到了这一点。在没有提供这种解决方案的其他发行版上，您可以在`/etc/ init.d/boot.local`脚本中包含`ethtool`命令以及您需要的所有参数。这样做，您将确保`ethtool`设置在重启后也能应用。

除了带有`ethtool`的`-i`选项，它给你一个关于你的网络板的简要概述，还有一些其他有用的选项。例如，当使用`ethtool -S`时，你可以得到一些关于你的网络板的非常详细的统计数据，正如你在[清单 11-13](#FPar19) 中看到的。

[***清单 11-13***](#_FPar19) 。给你非常详细的关于你的网卡的统计数据

```sh
[root@lab ~]# ethtool -S eno1
NIC statistics:
     rx_packets: 4423965
     tx_packets: 5086934
     rx_bytes: 2789043235
     tx_bytes: 4708139801
     rx_broadcast: 81778
     tx_broadcast: 4
     rx_multicast: 5044
     tx_multicast: 64
     rx_errors: 0
     tx_errors: 0
     tx_dropped: 0
     multicast: 5044
     collisions: 0
     rx_length_errors: 0
     rx_over_errors: 0
     rx_crc_errors: 0
     rx_frame_errors: 0
     rx_no_buffer_count: 0
     rx_missed_errors: 0
     tx_aborted_errors: 0
     tx_carrier_errors: 0
     tx_fifo_errors: 0
     tx_heartbeat_errors: 0
     tx_window_errors: 0
     tx_abort_late_coll: 0
     tx_deferred_ok: 0
     tx_single_coll_ok: 0
     tx_multi_coll_ok: 0
     tx_timeout_count: 0
     tx_restart_queue: 0
     rx_long_length_errors: 0
     rx_short_length_errors: 0
     rx_align_errors: 0
     tx_tcp_seg_good: 718842
     tx_tcp_seg_failed: 0
     rx_flow_control_xon: 0
     rx_flow_control_xoff: 0
     tx_flow_control_xon: 0
     tx_flow_control_xoff: 0
     rx_csum_offload_good: 4325815
     rx_csum_offload_errors: 3
     rx_header_split: 0
     alloc_rx_buff_failed: 0
     tx_smbus: 0
     rx_smbus: 0
     dropped_smbus: 0
     rx_dma_failed: 0
     tx_dma_failed: 0
     rx_hwtstamp_cleared: 0
     uncorr_ecc_errors: 0
     corr_ecc_errors: 0
     tx_hwtstamp_timeouts: 0
```

分析网络连接

一旦你完成了我刚刚描述的设置任务，你应该有一个工作的网络连接。但是，即使它现在工作得很好，您可能在某个时候需要执行一些调优和故障排除，这正是本节所要讨论的。在这里，您将学习如何测试一切是否正常工作，以及如何监控网络本身和网络接口上发生的情况。这一节我说的工具是顶尖的故障排除工具。

测试连通性

配置网卡后，您需要确保它正常工作。对于这一点，`ping`命令是您的好朋友，因为它很容易使用:输入命令，后跟您想要测试连通性的主机的名称或地址，例如`ping` `www.ubuntu.com`。这迫使`ping`开始连续输出，您可以使用 Ctrl+C 组合键来中断。您也可以发送有限数量的数据包；例如，命令`ping -c 3 192.168.1.254`只向指定的主机发送三个数据包。如果你巧妙的使用`ping`，你可以用它测试很多东西。我建议按以下顺序使用它:

1.  Ping 本地主机。如果您通过了这个测试，那么您已经验证了本地机器上的 IP 堆栈工作正常。
2.  使用 IP 地址 Ping 本地网络上的一台机器:如果这有效，您已经验证了 IP 正确绑定到您计算机的网络板上，并且它可以连接到网络上的其他节点。如果失败，您需要检查您用`ifconfig`或`ip`命令输入的信息；您可能在输入网络接口的子网掩码时出错。
3.  使用 IP 地址在互联网上 Ping 一台机器。一个很好的选择是 8.8.8.8，这是一个 DNS 服务器，在过去的 15 年里没有让我失望过。当然，您可以使用任何其他主机，只要您知道它的 IP 地址。如果 ping 成功，您就验证了本地主机和目的地之间的路由器都工作正常。如果它失败了，那么路由链中的某个地方就有错误。检查本地主机上的`route -n`或`ip route show`，查看是否定义了默认路由。
4.  使用机器的 DNS 名称 Ping 互联网上的机器。如果成功了，一切都正常了。如果这一步失败了(但是测试 3 成功了)，确保您已经输入了应该在`/etc/resolv.conf`中使用的 DNS 服务器的名称。如果这没问题，请检查您的 DNS 服务器是否在工作。

在很多情况下，你会使用不带选项的`ping`命令 。但是有些选项可能有用，这些选项在[表 11-2](#Tab2) 中列出。

[表 11-2](#_Tab2) 。有用的`ping`选项

| 

[计]选项

 | 

描述

 |
| --- | --- |
| `-c count` | 指定要发送的数据包数量。到达该数字后，`ping`命令自动终止。 |
| `-l device` | 指定应该使用的网络设备的名称。在有多个网络设备的计算机上很有用。 |
| `-i seconds` | 指定各个 ping 数据包之间等待的秒数。默认设置是 1 秒。 |
| `-f` | 尽可能快地发送数据包，但只能在收到回复后发送。 |
| `-l` | 不等待回复就发送数据包。如果与`-f`选项一起使用，这可能会对目标主机造成拒绝服务攻击，主机可能会停止正常运行，甚至崩溃。除了这可能对目标计算机造成的未知伤害之外，您可能会发现自己被列入黑名单，甚至被指控犯有刑事罪。因为这是一个非常危险的选项，所以只允许 root 用户使用它。 |
| `-t ttl` | 为发送的数据包设置生存时间(TTL) 。这表示每个数据包在到达目的地的途中可以通过的路由器的最大数量。每经过一个路由器，TTL 就递减 1，直到 TTL 变为 0，这意味着数据包将不再被路由。 |
| `-b` | 向网络的广播地址发送数据包。这将提示每台启动并被允许响应 ping 数据包的主机进行回复。除非有充分的理由，否则不要使用这个命令，因为这个命令会在您的网络上生成大量的数据包。 |

![Image](images/sq.jpg) **注意**为了防止拒绝服务攻击，许多主机被配置为不响应 ping 请求。因此，在测试连通性时，请确保您使用允许应答的主机。

`ping`命令不仅仅用于测试连接是否可以建立；您还可以使用它来检查您的计算机和给定主机之间的往返延迟。经过的时间是网络连接质量的一个重要指标。要检查往返延迟，查看在`ping`命令的结果中列出的`time`参数。[清单 11-14](#FPar21) 提供了一个使用`ping`向`www.ubuntu.com`发送四个数据包的例子。

[***清单 11-14***](#_FPar21) 。测试与`www.ubuntu.com`的连接

```sh
root@ZNA:~# ping -c 4 www.ubuntu.com
PING www.ubuntu.com (82.211.81.158) 56(84) bytes of data.
64 bytes from arctowski.ubuntu.com (82.211.81.158): icmp_seq=1 ttl=51 time=22.0 ms
64 bytes from arctowski.ubuntu.com (82.211.81.158): icmp_seq=2 ttl=51 time=10.7 ms
64 bytes from arctowski.ubuntu.com (82.211.81.158): icmp_seq=3 ttl=51 time=18.6 ms
64 bytes from arctowski.ubuntu.com (82.211.81.158): icmp_seq=4 ttl=51 time=20.8 ms

--- www.ubuntu.com ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3015ms
rtt min/avg/max/mdev = 10.741/18.092/22.057/4.417 ms
```

测试路由

如果您可以 ping 通您的默认路由器，但无法 ping 通互联网上的给定主机，很明显，您的网络和目的主机之间的某个路由器可能有问题。您可以使用`traceroute`命令来找出问题出在哪里。`traceroute`命令使用它发出的 UDP 数据报的 TTL 值。

![Image](images/sq.jpg) **注**数据报是通过 OSI 模型网络层发送的数据包。

其思想是，当 TTL 值达到 0 时，路由器会丢弃数据包，并向发送方发回一条消息。启动时，`traceroute`使用 TTL 值 0，这将导致数据包被第一个路由器丢弃。这就是`traceroute`识别第一个路由器的方式。接下来，它再次将数据包发送到目标目的地，但 TTL 为 1，如您所见，这会导致数据包被第二台路由器丢弃。事情以这种方式继续，直到数据包到达其最终目的地。

要使用`traceroute` ，你通常把主机名作为自变量，如`traceroute` `www.ubuntu.com`。也可以使用主机的 IP 地址，这将产生如清单 11-15 所示的结果。

[***清单 11-15***](#_FPar23) 。用`traceroute`测试网络路由

```sh
root@ZNA:~# traceroute www.ubuntu.com
traceroute to www.ubuntu.com (82.211.81.158), 30 hops max, 40 byte packets
1  192.168.1.254 (192.168.1.254) 72.668 ms 10.361 ms 176.306 ms
2  195.190.249.90 (195.190.249.90) 3.353 ms 9.199 ms 10.351 ms
3  42.ge-4-0-0.xr1.3d12.xs4all.net (194.109.5.49) 6.386 ms 7.237 ms 16.421 ms
4  0.so-6-0-0.xr1.tc2.xs4all.net (194.109.5.10) 11.407 ms 11.447 ms 9.599 ms
5  217.149.46.21 (217.149.46.21) 31.989 ms 29.321 ms 22.756 ms
6  sl-bb21-ams-11-0.sprintlink.net (217.149.32.41) 13.415 ms 13.244 ms 12.569 ms
7  213.206.131.46 (213.206.131.46) 11.147 ms 12.282 ms 11.222 ms
8  ae-0-56.mp2.Amsterdam1.Level3.net (4.68.120.162) 7.862 ms ae-0-54.mp2.Amster\
dam1.Level3.net (4.68.120.98) 11.796 ms ae-0-52.mp2.Amsterdam1.Level3.net\
  (4.68.120.34) 11.000 ms
9  as-0-0.bbr2.London2.Level3.net (4.68.128.110) 21.047 ms ae-1-0.bbr1.London2.\
Level3.net (212.187.128.46) 35.125 ms as-0-0.bbr2.London2.Level3.net\
  (4.68.128.110) 17.183 ms
10  ae-15-53.car1.London2.Level3.net (4.68.117.79) 18.917 ms 17.388 ms ae-25-52.\
car1.London2.Level3.net (4.68.117.47) 18.992 ms
11  tge9-3-146.core-r-1.lon2.\
mnet.net.uk (212.187.196.82) 14.699 ms 17.381 ms 15.293 ms
12  85.133.32.134 (85.133.32.134) 27.130 ms 33.310 ms 37.576 ms
13  82.211.81.76 (82.211.81.76) 16.784 ms 20.140 ms 17.556 ms
14  * * *
15  * * *
16  * * *
17  * * *
```

使用`traceroute`命令，您将看到通过的每个路由器。对于每台路由器，会显示路由器的名称，后跟其 IP 地址，然后是发送到该路由器的三个数据包的往返时间。您经常会看到路由器只回复一串三个星号(`* * *`)，这表明路由器正常转发数据包，但出于安全原因，路由器被配置为不回复 ping 数据包。

测试服务的可用性

当`ping`和`traceroute`命令显示一切正常时，您就自豪地拥有了一个正常工作的网络接口。接下来，您可以测试两种服务的可用性:在您的计算机上的服务和在外部计算机上的服务。因为有如此多的工具可用于测试服务可用性，所以我不会试图涵盖所有的工具，但是我想讨论两个最流行的工具。首先是`netstat`工具，您可以使用它在运行命令的主机上测试服务的可用性。第二个是`nmap`，用于测试其他主机上的可用性。

![Image](images/sq.jpg) **警告**一些管理员认为在他们的主机或网络上使用`nmap`是对他们安全的攻击，因此不会允许。我曾经在美国的一家酒店房间里使用它来查看我在阿姆斯特丹的服务器是否仍在提供所有服务，酒店网络立即将我关闭。在这种情况下，恢复连接可能会很痛苦，所以要小心。

使用 **netstat** 为您的电脑提供服务

如果你想知道你的电脑上有哪些服务，这些服务在做什么，`netstat`命令是一个很好的选择。但是，因为它的许多选项要求您是 root，所以我建议您仅使用`netstat` 作为 root。要查看由`netstat`提供的最有用的信息，使用`-platune`选项，确保您看到关于连接到端口`(-p)`的程序的信息，以及哪些端口实际上正在监听`(-l)`。

其他选项显示所有需要显示的内容`(-a)`，对 TCP `(-t)`和 UDP `(-u)`都这样做，不需要将 IP 地址转换成 DNS 名称`(-n)`，或者带有扩展信息`(-e)`。

如果你认为`netstat -platune`提供了太多的信息，那就用`netstat -tulp`来代替。结果稍微不那么冗长，这使得更容易获得您真正需要的数据。[清单 11-16](#FPar25) 显示了由`netstat -platune`生成的输出的第一个屏幕。

[***清单 11-16***](#_FPar25) 。`netstat -platune`命令提供了你电脑上发生的所有事情的详尽概述

```sh
root@ZNA:~# netstat -platune
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address     Foreign Address    State User\ Inode   PID/Program name
tcp   0      0      127.0.0.1:3306   0.0.0.0:*   LISTEN    103\ 12937    3839/mysqld

tcp   0      0      0.0.0.0:80       0.0.0.0:*    LISTEN    0\ 13209    3965/apache2

tcp   0      0      10.0.0.20:53     0.0.0.0:*    LISTEN    104\ 13737    3737/named

tcp   0      0      10.0.0.30:53     0.0.0.0:*    LISTEN    104\ 13735    3737/named

tcp   0      0      10.0.0.10:53     0.0.0.0:*    LISTEN    104\ 13733    3737/named

tcp   0      0      192.168.1.33:53  0.0.0.0:*    LISTEN    104\ 12821    3737/named

tcp   0      0      127.0.0.1:53     0.0.0.0:*    LISTEN    104\ 12819    3737/named

tcp   0      0      127.0.0.1:953    0.0.0.0:*    LISTEN    104\ 12824    3737/named

tcp6  0      0      :::53            :::*         LISTEN\   104  12816    3737/named

tcp6  0      0      :::22            :::*         LISTEN\   0    13585    4150/sshd

tcp6  0      0      ::1:953    :::*  LISTEN\ 104    12825    3737/named

tcp6  0      0      ::ffff:192.168.1.33:22 ::ffff:192.168.1.6:4197 ESTABLISHED0\ 13761  4229/1

tcp6  0      164    ::ffff:192.168.1.33:22 ::ffff:192.168.1.7:9688 ESTABLISHED0\   13609  4158/0

udp   0      0       0.0.0.0:1024    0.0.0.0:*              104\ 12822    3737/named

udp   0      0      10.0.0.20:53     0.0.0.0:*              104\ 13736    3737/named

udp   0      0      10.0.0.30:53     0.0.0.0:*              104\ 13734    3737/named

udp   0      0      10.0.0.10:53     0.0.0.0:*              104\ 13732    3737/named

udp   0      0      192.168.1.33:53  0.0.0.0:*              104\ 12820    3737/named

udp   0      0      127.0.0.1:53     0.0.0.0:*              104\ 12818    3737/named

udp6  0      0      :::1025          :::*                   104\ 12823    3737/named

udp6  0      0      :::53            :::*                   104\ 12815    3737/named

```

如您所见，`netstat`命令在与`-platune`选项一起使用时会产生大量信息。[表 11-3](#Tab3) 解释了[清单 11-16](#FPar25) 中显示的信息。

[表 11-3](#_Tab3) 。`netstat -` `platune` 提供的信息

| 

项目

 | 

说明

 |
| --- | --- |
| `Proto` | 使用的协议。可以是 TCP 或 UDP。 |
| `Recv-Q` | 使用`netstat`时，该端口接收队列中等待的数据包数量。 |
| `Send-Q` | 使用`netstat`时，等待从该端口发送的数据包数量。 |
| `Local Address` | 本地套接字地址(本地 IP 地址后跟使用的端口号)。 |
| `Foreign Address` | 当前与该主机有开放连接的外部主机(如果有)的地址。 |
| `State` | 连接到上述端口的协议的当前状态。 |
| `User` | 具有启动进程权限的用户的数字用户 ID。 |
| `Inode` | 进程当前打开的文件的信息节点。 |
| `PID/Program name` | PID 和程序的名称，该程序目前已要求上述端口。 |

如您所见，`netstat`提供了您电脑上正在发生的事情的完整概述。如果您收到类似“端口已在使用中”的错误消息，这尤其有用结合`grep`实用程序，很容易了解哪个端口程序当前保持一个端口打开，如果需要，终止该程序。例如，要找出哪个程序当前正在占用端口 80，可以使用`netstat -platune | grep 80`。这将返回类似于

```sh
root@ZNA:~# netstat -platune | grep 80

tcp    0    0 0.0.0.0:80    0.0.0.0:*    LISTEN    0\
    13209    3965/apache2
```

从这一行，您可以看到一个 PID 为 3965 的 Apache web 服务器当前正在监听端口 80。想要移除它，但你不知道如何以正常的方式来做？用`kill 3965`就没了。

使用 **nmap** 检查远程计算机上的服务

`netstat`命令是一个有用的工具，但是它只能在运行它的主机上工作。有时，当您无法连接到给定主机上的给定服务时，您会想知道该服务是否可用。您可以使用`nmap`命令来完成这项工作。像大多数强大的网络工具一样，如果你是 root 用户，`nmap`也能很好地工作。

`nmap`命令 是一个专家工具，可以帮助你找出另一台主机上到底发生了什么。如果你使用得当，那个主机的主人甚至永远不会知道你在那里。然而，您应该意识到，运行所谓的端口扫描来监控给定主机上打开的端口被许多管理员视为入侵，所以请小心您正在使用它，因为如果您在不属于您的主机上使用`nmap`，并且您没有通知它的所有者，您可能会遇到麻烦。

如果你真的想让事情变得简单，就使用不带参数的`nmap`。例如，`nmap 192.168.1.69`在主机 192.168.1.69 上执行基本扫描，以查找其上打开了哪些公共端口。这为日常使用提供了良好的结果；参见[清单 11-17](#FPar26) 中的示例。

[***清单 11-17***](#_FPar26) 。`nmap`命令向您显示主机提供了哪些服务

```sh
root@ZNA:~# nmap 192.168.1.69

Starting Nmap 4.20 ( http://insecure.org ) at 2007-011-01 11:08 EDT
Interesting ports on 192.168.1.69:
Not shown: 1693 closed ports
PORT STATE SERVICE
22/tcp open ssh
111/tcp open rpcbind
139/tcp open netbios-ssn
445/tcp open microsoft-ds
MAC Address: 00:18:8B:AC:C9:54 (Dell)
Nmap finished: 1 IP address (1 host up) scanned in 0.626 seconds
```

清单 11-17 所示的测试可能失败的一个常见原因是`nmap`通常会首先尝试 ping 其目标。在许多主机上，`ping`命令被管理性地禁止、丢弃或忽略。当你对这些主机发布`nmap`时，它们不会透露任何信息。为了确保即使在无法 ping 通的情况下它们也能工作，使用`-P0`选项禁用`ping`。另一个有用的选项是`-O`，它试图猜测目标主机上的操作系统。而且，如果你想确保 TCP 和 UDP 端口都被扫描，你也应该包括`-sT`和`-sU`。因此该命令变得有点长:`nmap -sT -sU -P0 -O 192.168.1.69`将使用所有这些选项扫描目标主机。您会注意到，因为`nmap`需要对这些选项做更多的工作，所以完成命令需要相当长的时间。[清单 11-18](#FPar27) 显示了这次扫描的结果。

[***清单 11-18***](#_FPar27) 。您有很多选项来指定`nmap`应该如何工作

```sh
root@ZNA:~# nmap -sT -sU -P0 -O 192.168.1.69

Starting Nmap 4.20 ( http://insecure.org ) at 2007-011-01 11:11 EDT
Interesting ports on 192.168.1.69:
Not shown: 3176 closed ports
PORT         STATE         SERVICE
22/tcp       open          ssh
111/tcp      open          rpcbind
139/tcp      open          netbios-ssn
445/tcp      open          microsoft-ds
68/udp       open|filtered dhcpc
111/udp      open|filtered rpcbind
631/udp      open|filtered unknown
5353/udp     open|filtered zeroconf
32768/udp    open|filtered omad
MAC Address: 00:18:8B:AC:C9:54 (Dell)
Device type: general purpose
Running: Linux 2.6.X
OS details: Linux 2.6.14 - 2.6.17
Uptime: 0.176 days (since Wed Aug 1 07:23:05 2007)
Network Distance: 1 hop

OS detection performed. Please report any incorrect results at http://insecure.org/nmap/submit/.
Nmap finished: 1 IP address (1 host up) scanned in 1482.860 seconds
```

在最后一个命令中，您很可能会获得更好的结果，但仍然有一个问题:扫描相当嘈杂，因此目标主机可能会记录消息，告诉它的所有者您正在对它使用`nmap`。在大多数情况下，这没有什么错，但如果你真的想让`nmap`通过彻底的安全测试，你应该使用一些隐形选项，如`-sF` (FINscan)、`-sX` (X-mas 树扫描)，或`-sN` (NULL-scan)。所有这些都使用 IP 协议的特定属性来执行秘密扫描，以便目标主机永远不知道您在那里。这些扫描选项的缺点是它们并不总是有效！在许多现代操作系统上，你会发现操作系统忽略了它们，所以你会等待很长时间而没有结果。

练习 11-2:分析网络

在本练习中，您将分析网络中的当前网络配置。

1.  输入 **ip 路由显示**。这将显示您路由器的 IP 地址。
2.  Ping 路由器，使用 **ping <路由器>** 。(用你刚刚找到的 IP 地址替换<路由器>。
3.  记下当前配置的网络地址。通常，网络地址与您的 IP 地址相同，但最后一个字节是 0。所以如果你的 IP 地址是 192.168.1.10，网络地址就是 192.168.1.0。在本例中，我将使用 192.168.1.0 作为示例网络，替换此 IP，使其与您的配置相匹配。使用 **nmap -sP 192.168.1.0/24** 扫描您网络中的 IP 地址。
4.  键入 **nmap <路由器>** (用您路由器的 IP 地址替换<路由器>)。这将显示您的路由器上当前提供的所有服务。
5.  键入 **netstat -tulpen** 。这给出了本地机器上提供的所有服务的列表。

使用安全外壳 远程连接

如果您在一个有多台 Linux 计算机的网络中，您偶尔需要使用 shell 连接到另一台计算机。安全壳就是为此而生的。它还取代了较旧的 telnet 实用程序，后者是在安全性不是今天的问题的时候使用的。SSH 的本质是它的安全性，公钥和私钥自然在其中扮演着重要的角色。第一次联系时，客户端和主机交换公钥和私钥。在这种通信中，主机根据其私钥(所谓的主机密钥)创建一个密钥，并将其用作身份证明。连接时，主机将其公钥发送给客户端。如果这是客户端第一次连接到该主机，主机会回复显示在[清单 11-19](#FPar29) 中的消息。

[***清单 11-19***](#_FPar29) 。与未知主机建立 SSH 会话

```sh
root@ZNA:~# ssh 192.168.1.70
The authenticity of host '192.168.1.70 (192.168.1.70)' can’t be established.
RSA key fingerprint is fd:07:f6:ce:5d:df:6f:a2:84:38:c7:89:f1:3a:a6:34.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.1.70' (RSA) to the list of known hosts.
Password:
Last login: Tue Jul 31 15:34:15 2007 from ida.lan
```

如果客户端相信这确实是预期的主机，它应该对该请求做出肯定的回答，在这种情况下，该主机将被添加到发起 SSH 会话的用户的主目录中的`.` `ssh/known_hosts`文件 中。下次客户端连接到主机时，将检查该文件以查看主机是否已知。该检查基于主机的公钥指纹，该指纹是与主机公钥相关的唯一校验和。只有当该检查与客户端所连接的主机的名称和公钥匹配时，才会建立连接。如果这两个数据不匹配，很可能是客户端试图连接的主机不是预期的主机，连接被拒绝。

一旦确定了您要连接的主机的身份，就会在客户端和主机之间建立一个安全通道。这些安全通道是由会话密钥建立的，会话密钥是一种加密密钥，在主机和客户机上都是相同的，它对两台机器之间发送的所有数据进行加密。客户端和主机基于它们的公钥协商该会话密钥。在这次协商中确定的事情之一是应该使用的协议。例如，会话密钥可以使用不同的加密协议，如 3DES、Blowfish 或 IDEA。

建立安全通道后，客户机上的用户被要求提供凭证:如果什么都没有配置，则提示用户输入他或她的用户名和密码。或者，用户可以使用他或她的公钥/私钥对进行身份验证，从而证明他或她确实是该用户，但是在这之前还需要进行一些配置。

所有这些听起来可能相当复杂，但好的一面是用户不会注意到任何一点。用户只需输入用户名和密码。但是，如果您想超越简单的基于密码的身份验证，就有必要了解发生了什么。

使用公钥/私钥对

SSH 的安全性依赖于公钥/私钥对的使用。默认情况下，客户端尝试使用 RSA 或 DSA 密钥对进行身份验证。要实现这一点，主机必须拥有客户机的公钥，这是您必须手动配置的，您将在后面看到。当客户端有一个公钥/私钥对时，它会用自己的私钥生成一个加密字符串。如果主机能够使用客户端的公钥解密该字符串，则客户端的身份通过了身份验证。

当使用公钥/私钥对时，您可以配置不同的东西。首先，用户需要确定他或她想要使用什么加密算法。为此，他或她可以在 RSA 和 DSA(其中 DSA 被认为更强)之间进行选择。接下来，用户必须决定是否用密码保护他或她的私钥。

使用密码短语很重要，因为私钥实际上被用作用户的身份。如果有人窃取了这个私钥，就有可能伪造密钥所有者的身份，因此，用密码保护私钥是一个非常好的主意。

使用安全外壳

基本上，Secure Shell 是一套工具，由三个主程序和一个守护进程`sshd`组成。在 Fedora/Red Hat 和 SUSE 上，默认安装 SSH。在 Ubuntu 上，你需要先用`apt-get install openssh-server`安装它。

在 SSH 中，有三个工具可用:`ssh`、`scp`和`sftp`。第一个是`ssh`，用于建立安全的远程会话。比方说，它类似于 telnet，但受到密码保护。第二个命令是`scp`，这是一个非常有用的命令，用于在运行 SSH 进程的另一台计算机上复制文件。第三个是`sftp`，是一个安全的 FTP 客户端接口。使用它可以建立到运行`sshd`的计算机的安全 FTP 会话。

所有这些工具的两个最大优点是，它们可以在没有任何准备或设置的情况下使用，并且您可以完全根据您的需要来设置它们。它们既是易于使用的工具，又是非常专业的工具。

使用 **ssh** 命令T3】

使用 SSH 最简单的方法是输入`ssh`命令，后跟您想要连接的主机的名称。例如，要连接到主机`AMS.sandervanvugt.com`，使用`ssh AMS.sandervanvugt.com`。

根据您之前是否连接过该主机，它可能会检查主机凭据或只询问您的密码。`ssh`命令不要求用户名，因为它假设您想要使用与您本地登录相同的身份连接到另一台主机。如果您更愿意使用另一个用户帐户登录，您可以用两种方式之一来表明这一意图:您可以指定用户名，并在建立到远程主机的连接时在它后面跟一个&符号，或者您可以使用`-l`选项，后面跟您想要用来连接到另一个主机的用户帐户的名称。所以，基本上，`ssh linda@AMS.sandervanvugt.com`和`ssh -l linda AMS.sandervanvugt.com`完成了同样的事情。建立会话后，使用`exit`命令(或 Ctrl+D)关闭会话并返回到您自己的机器。

现在，如果只需要输入一两个命令，登录远程主机似乎很麻烦。如果您经常遇到这种情况，最好知道您可以在`ssh`命令的末尾指定命令的名称:`ssh -l linda@AMS.sandervanvugt.com` `ls -l`提供了用户 linda 在另一台主机上的主目录中的一长串文件。当然，这并不是如何对主机使用“仅一个命令”会话的最现实的例子，但是当您从 shell 脚本工作时，您可能会看到它的价值。

使用 **scp** 安全复制文件

`scp`命令是 SSH 套件中您肯定会喜欢的另一部分。它被用来安全地复制文件。如果你知道`cp`命令是如何工作的，你就会知道如何处理`scp` 。唯一的区别是它需要一个完整的网络路径名，包括主机名和要复制的文件名。此外，如果您不想使用当前登录的用户名，也应该包括用户名。考虑以下示例:

```sh
scp /some/file linda@AMS.sandervanvugt.com:/some/file
```

这个简单的命令将`/some/file`复制到`AMS.sandervanvugt.com`,并以名称`file`将其放在该主机上的目录`/some`中。当然，也可以反过来做:`scp root@SFO.sandervanvugt.com:/some/file /some/file`将`/some/file`从名为`SFO.sandervanvugt.com`的远程主机复制到本地主机。您也会喜欢`-r`选项，因为它允许您复制完整的子目录结构。

使用 **sftp** 进行安全的 ftp 会话

作为使用`scp`复制文件的替代方法，您可以使用`sftp`命令 。该命令用于连接运行`sshd`程序的计算机，并与之建立安全的 FTP 会话。从`sftp`命令中，您可以看到一个看起来非常像普通 FTP 客户端界面的界面。所有标准的 FTP 命令在这里也可以工作，唯一的区别是，在这种情况下，它是安全的。例如，您可以使用`ls`和`cd`命令浏览到一个目录，并查看哪些文件可用，然后从那里使用`get`命令将文件复制到当前的本地目录。打开`sftp`界面后，您可以使用以下 FTP 命令将文件复制到您的电脑或从电脑中复制文件:

*   将文件从您的电脑复制到另一台电脑
*   `mput`:将多个文件从您的电脑复制到另一台电脑
*   `get`:将文件从另一台电脑复制到您的电脑
*   `mget`:将多个文件从另一台电脑复制到您的电脑上

在建立到另一台计算机的 FTP 会话之前，使用本地计算机上的`cd`命令切换到您想要复制文件的目录。您的主目录可能是一个不错的位置。当使用`put, mput, get`和`mget`传输文件时，该目录被用作默认的本地目录。要在名为 nuuk 的计算机上建立一个`sftp`会话，首先使用以下命令:

```sh
sftp nuuk
```

此命令假设您希望使用相同的用户帐户连接到远程主机。如果您想要使用另一个用户帐户进行连接，请将其放在远程服务器名称的前面，如以下命令所示:

```sh
sftp sander@nuuk
```

您现在将看到一个`SFTP`提示，并且将位于远程主机上为用户提供的根目录中。在这里，您可以使用标准的 Linux 命令，比如`ls`来显示文件列表，`pwd`来打印您的工作目录，`cd`来切换到另一个目录。现在，您可以在电脑和远程电脑之间传输文件。例如，下面的命令将使用`sftp`将`/etc/hosts`文件复制到本地计算机上的当前目录:

```sh
get /etc/hosts
```

完成文件复制后，使用`quit`或`exit`命令终止`sftp`会话。

配置 SSH

在 SSH 环境中，一个节点可以同时是客户机和服务器。这意味着你的电脑可以向他人提供 SSH 服务，同时使用 SSH 连接他人。所以，你可以想象，这两个方面都有一个配置文件。客户端配置在`/etc/ssh/ssh_config`，主机使用`/etc/ssh/sshd_config`。为主机设置选项并不难理解:只需将它们放在守护进程`/etc/ssh/sshd_config`的配置文件中。但是，对于客户端设置，情况要复杂得多，因为有几种方法可以覆盖默认的客户端设置:

*   通用的`/etc/ssh/ssh_config`文件适用于所有发起 SSH 会话的用户。如果个人用户在他或她的主目录的`.ssh`目录中创建一个`.ssh_config`文件，他或她可以覆盖这些文件。
*   您正在连接的主机上的`sshd_config`文件必须支持`/etc/ssh/ssh_config`中的选项。例如，如果您允许从客户端进行基于密码的鉴定，但电脑不允许，它就不会工作。
*   两个文件中的选项都可以用命令行选项覆盖。

[表 11-4](#Tab4) 概述了一些最有用的选项，您可以使用这些选项来配置`ssh_config`中的客户端。

[表 11-4](#_Tab4) 。`ssh_config`中有用的选项

| 

[计]选项

 | 

描述

 |
| --- | --- |
| `Host` | 该选项将以下声明(直到下一个`Host`关键字)限制到特定主机。因此，该选项应用于用户连接的主机。主机名采用命令行中指定的名称。使用此参数为特定主机增加一些额外的安全性。您也可以使用通配符，如*和？引用多个主机名。 |
| `CheckHostIP` | 如果该选项设置为`yes`(默认值)，SSH 将检查`known_hosts`文件中的主机 IP 地址。将此用作防止 DNS 或 IP 地址欺骗的保护措施。 |
| `Ciphers` | 该选项采用多个参数，用于指定不同加密算法在 SSHv2 会话中的使用顺序(版本 2 是目前默认的 SSH 版本)。 |
| `Compression` | 此选项的是/否值指定是否在 SSH 会话中使用压缩。默认为否。 |
| `ForwardX11` | 这个非常有用的选项指定是否转发 X11 连接。如果设置为 yes，SSH 会话的图形屏幕可以通过安全隧道转发。结果是，确定在何处绘制图形屏幕的 DISPLAY 环境变量被正确设置。如果您不想在默认情况下启用 X 转发，请在建立 SSH 会话时在命令行上使用-X 选项。 |
| `LocalForward` | 该选项指定本地机器上的 TCP/IP 端口通过 SSH 转发到远程机器上的指定端口。(详见本章后面的“通用 TCP 端口转发”。) |
| `LogLevel` | 使用此选项可以指定日志消息的详细级别。默认值为`INFO`。如果这还不够深入的话，`VERBOSE`、`DEBUG`、`DEBUG1`、`DEBUG2`和`DEBUG3`会提供更多的信息。 |
| `PasswordAuthentication` | 使用此选项指定是否要使用密码验证。默认情况下，使用密码验证。在使用密钥进行身份验证的安全环境中，您可以安全地将此选项设置为 no，以完全禁用密码身份验证。 |
| `Protocol` | 该选项指定 SSH 应该使用的协议版本。默认值设置为`2,1`(这表示应该首先使用版本 2，如果不成功，则尝试版本 1)。最好完全禁用版本 1，因为它有一些已知的安全问题。 |
| `PubkeyAuthentication` | 使用此选项指定是否要使用基于公钥的身份验证。该选项应始终设置为默认值(`yes`)，因为基于公钥的认证是最安全的认证方式。 |

客户端计算机上的`ssh_config`对应的是主机上的`sshd_config`文件。许多您可以在`ssh_config`文件中使用的选项也可以在`sshd_config`文件中使用。然而，有些选项是特定于 SSH 的主机端的。[表 11-5](#Tab5) 给出了其中一些选项的概述。

[表 11-5](#_Tab5) 。`sshd_config` 中的重要选项

| 

[计]选项

 | 

描述

 |
| --- | --- |
| `AllowTcpForwarding` | 使用此选项指定是否允许客户端进行 TCP 端口转发。这是一个非常有用的特性，您可能希望保留它的默认值(`yes`)。 |
| `Port` | 使用此选项指定 SSH 进程监听的端口。默认情况下，`sshd`正在监听端口 22。如果 SSH 进程直接连接到互联网，这将导致许多人尝试对您的主机进行暴力攻击。考虑在其他端口上运行 SSH 进程以提高安全性。 |
| `PermitRootLogin` | 使用此选项指定是否允许超级用户登录。要为您的主机增加额外的安全性，请考虑将此选项设置为`no`值。如果设置为`no`，根用户必须以普通用户的身份建立连接，并从那里使用`su`成为根用户或使用`sudo`以根用户权限执行某些任务。 |
| `PermitEmptyPasswords` | 使用此选项指定是否允许用户使用空密码登录。从安全的角度来看，这不是一个好主意，因此缺省的 no 值在大多数情况下是合适的。但是，如果您想从脚本运行 SSH 并在不输入密码的情况下建立连接，那么将该参数的值更改为`yes`会很有用。 |
| `ChallengeResponseAuthentication` | 该选项指定是否允许用户使用密码登录。如果希望通过强制用户仅使用公钥/私钥对登录来增加主机的安全性，请将该参数的值设为 no。 |
| `X11Forwarding` | 使用此选项指定是否允许客户端使用 X11 转发。在大多数 Linux 发行版中，这个参数的默认值是`yes`。 |

使用基于 SSH 密钥的认证

现在您已经了解了 SSH 的所有基础知识，让我们看看一些更高级的选项。其中最重要的是基于密钥的认证，SSH 通过基于公钥/私钥的认证来使用它。在深入研究基于密钥的身份验证的配置之前，让我们先看看这些密钥是如何使用的。

密码学简介

通常，您可以使用两种加密方法:对称和非对称。对称加密速度更快，但安全性较低，非对称加密速度较慢，但更安全。在对称密钥环境中，双方使用相同的密钥加密和解密消息。对于非对称密钥，使用公钥和私钥，这是用于 SSH 的重要技术。

如果使用非对称密钥，每个用户都需要自己的公钥/私钥对，每台计算机也需要一对。在这些密钥中，私钥必须始终受到保护:如果私钥被泄露，私钥所有者的身份也会被泄露。简而言之，窃取用户的私钥就像窃取用户的身份一样。

因此，私钥通常存储在一个非常安全的地方，除了它的所有者之外，没有人能够访问它；通常这是在`~/.ssh`中。另一方面，公钥对每个人都是可用的。

公钥/私钥通常用于三个目的:加密、身份验证和认可。

要发送加密的消息，发送方用接收方的公钥加密消息，接收方可以用匹配的私钥解密消息。这种情况要求，在发送加密消息之前，您必须拥有消息接收人的公钥。

其他选项是使用公钥/私钥进行身份验证，或者证明消息自创建以来未被更改。这种方法被称为非否认。在身份验证的示例中，私钥用于生成加密的令牌，即 salt。如果这个 salt 可以用想要认证的人的公钥解密，那就证明主机确实在与正确的人打交道，并且可以授权访问。但是，这种技术要求在进行任何身份验证之前将公钥复制到主机上，当使用密钥来证明消息没有被篡改时也是如此。

在 SSh 环境中使用基于公钥/私钥的认证

当使用基于 SSH 密钥的身份验证时，您必须确保对于需要使用该技术的所有用户，公钥在他们想要登录的主机上是可用的。登录时，用户创建一个使用用户私钥签名的鉴定请求。该身份验证请求与该用户希望进行身份验证的计算机上的同一用户的公钥相匹配。如果匹配，则允许用户访问；否则，用户访问将被拒绝。

基于公钥/私钥的认证在所有主要的 Linux 发行版上都是默认启用的，所以只有当没有密钥时，计算机才会提示用户输入密码。以下步骤总结了当用户尝试与主机建立 SSH 会话时会发生的情况:

1.  如果启用了公钥认证(默认)，SSH 会检查用户主目录中的`.ssh`目录，以查看是否存在私钥。
2.  如果找到了私钥，SSH 会创建一个包含一些数据的包(salt)，用私钥加密这个包，然后将它发送给主机。公钥也随该数据包一起发送。
3.  主机现在检查用户的主目录中是否存在名为`authorized_keys`的文件。否则，用户就不能用他或她的密钥进行身份验证。如果文件确实存在，并且公钥是允许的密钥(并且也与先前存储在主机上的密钥相同)，则主机使用该密钥来检查签名。
4.  如果签名通过验证，用户将被授予访问权限。如果无法验证签名，主机会提示用户输入密码。

所有这些听起来很复杂，但实际上并不复杂。如果设置得当，一切都是透明的。此外，建立连接时几乎没有任何明显的延迟。通常不会超过一秒钟。

为基于密钥的认证设置 SSh

解释如何为基于密钥的身份验证设置 SSH 的最佳方式是通过一个示例。在以下过程中，为 root 用户启用了基于密钥的身份验证。

1.  On the desktop where root is working, use the command `ssh-keygen -t dsa -b 1024`. This generates a public/private key pair of 1,024 bits. [Listing 11-20](#FPar30) shows what happens.

    [***清单 11-20***](#_FPar30) 。使用`ssh-keygen`生成公钥/私钥对

    ```sh
    workstation # ssh-keygen -t dsa -b 1024
    Generating public/private dsa key pair.
    Enter file in which to save the key (/root/.ssh/id_dsa) :
    Enter passphrase (empty for no passphrase):
    Enter same passphrase again:
    Your identification has been saved in /root/.ssh/id_dsa.
    Your public key has been saved in /root/.ssh/id_dsa.pub.
    The key fingerprint is:
    59:63:b5:a0:c5:2c:b5:b8:2f:99:80:5b:43:77:3c:dd root@workstation
    ```

    我会解释发生了什么。本例中的用户使用`ssh-keygen`命令生成一个公钥和一个私钥。用于生成该密钥的加密算法是 DSA，它被认为比它的替代方案 RSA 更安全。选项`-b 1024`指定应该对密钥使用 1024 位加密。你可能知道这个号码越长，越安全。但是，请注意，多位加密算法也需要更多的系统资源才能使用。生成密钥后，该命令会提示您将其保存在某个地方。默认情况下，在您的主目录中会创建一个名为`.ssh`的目录，并且在这个目录中会创建一个名为`id_dsa`的文件。该文件包含私钥。

    接下来，系统会提示您输入一个密码，这是一个重要的额外保护层，可以添加到密钥中。因为任何能够访问您的私钥的人(这并不容易)都可以伪造您的身份，所以您的私钥应该始终受到密码短语的保护。两次输入相同的密码后，私钥被保存，相关的公钥被生成并保存在文件`/root/.ssh/id_dsa.pub`中。此外，还会生成一个密钥指纹。此指纹是您的密钥的摘要，是在密钥上计算的校验和，用于在密钥被更改时提醒您。确保您的密码不易被猜到；弱密码使强密钥无用。

2.  创建公钥/私钥对后，必须将公钥传送给主机。最终目标是将`id_dsa.pub`文件的内容放在主机上的`/root/.shh/ authorized_keys`文件中。但是你不能简单地将文件复制到目标文件`authorized_keys`，因为其他的密钥可能已经存储在那里了。因此，首先使用`scp`将文件复制到一个临时位置。命令`scp /root/.ssh/id_dsa. pub root@host:/root/from_workstation_key.pub`会做这项工作。
3.  现在公钥在主机上，您必须将它放在`authorized_keys`文件中。但是，在这样做之前，请确保。`ssh`目录存在于用户 root 的主目录中的主机上，并且它将用户和组 root 作为其所有者和权限模式 700。然后，在将目录`/root`作为当前目录的主机上，使用`cat from_workstation_key.pub >> .ssh/authorized_keys`。这个命令将公钥文件的内容附加到`authorized_keys`文件中，因此不会覆盖已经存在的任何文件。
4.  希望没有错误发生，你已经成功了。回到您的工作站，启动一个到主机的 SSH 会话，在那里您刚刚将您的公钥复制到了`authorized_keys`文件。您会注意到，系统不再提示您输入密码，而是提示您输入密码短语。这证明一切都起作用了。但是，请注意，您需要为您希望能够与之建立会话的每个受密钥保护的主机重复此过程。

按照这些步骤中描述的方式使用密钥是使 SSH 验证更加安全的一个很好的方法。但是有一个缺点:如果你需要从一个 shell 脚本或者`cron`作业自动建立一个 SSH 会话，如果你第一次被提示输入一个密钥，这就不太方便了。因此，需要某种方法来自动执行这样的作业。一种解决方案是创建一个特殊的用户帐户，该帐户具有有限的权限，并且其私钥上没有密码短语。另一个解决方案是运行`ssh-agent`，它在使用密钥之前缓存密钥，您将在下一节学习如何做到这一点。

缓存关键字与`ssh`-`ssh-agent`-

您可以使用`ssh-agent`来避免不断输入私钥。使用这个程序，您可以缓存给定 shell 环境的键。在从 shell 提示符启动`ssh-agent`之后，您需要为属于它的私钥添加密码短语。这是您将为特定的 shell 所做的事情，因此在您关闭该特定的 shell 或加载另一个 shell 之后，您将需要再次向该 shell 添加密码短语。

将密码添加到`ssh-agent` 后，密码存储在 RAM 中，只有将密钥添加到 RAM 中的用户才能从中读取。另外，`ssh-agent`只听你在本地启动的`ssh`和`scp`命令，所以你无法通过网络访问由`ssh-agent`保存的密钥。所以你可以确定使用`ssh-agent`是非常安全的。除了安全之外，它也非常简单。启用`ssh-agent`并向其添加密码短语是一个简单的两步程序:

1.  在 shell 提示符下，使用`ssh-agent`,后跟您想要使用的 shell 的名称。例如，使用`ssh-agent /bin/bash`为 Bash shell 激活`ssh-agent`。
2.  现在输入`ssh-add`。系统会提示您输入当前私钥的密码，然后您会看到添加了消息身份，后面是密码被添加到`ssh-agent`的私钥。

![Image](images/sq.jpg) **提示**安全 Shell 是一种访问其他主机的好方法。但是您知道吗，您还可以使用它在远程主机上挂载文件系统。所有现代版本的 SSH 都支持这个特性:只需使用`sshfs`来访问远程主机上的所有文件和目录，就像该主机上的本地用户一样。如果你知道如何用`mount`命令挂载一个目录，那么使用`sshfs`就很容易了。例如，命令`sshfs linda@AMS:/data /mnt`允许访问远程主机上的`/data`目录，并将该目录连接到本地计算机上的`/mnt`。默认情况下不安装安全外壳，所以使用`apt-get install sshfs`将其安装在您的计算机上。

使用 SSH 隧道传输流量

除了建立远程登录会话、复制文件和在远程主机上执行命令之外，您还可以使用 SSH 进行 TCP 端口转发。当这样使用时，SSH 是一个简单的 VPN 解决方案，能够通过安全连接隧道连接到几乎任何不安全的协议。在这一节中，我将首先讨论 X 转发，然后您将看到如何使用 SSH 转发几乎任何协议。

x 转发

如果您可以在主机上启动一个应用程序，所有工作负载都由主机执行，而您可以从客户端控制该应用程序，这难道不是很有用吗？嗯，你可以用 SSH X 转发。要使用 X 转发，您首先必须建立到您想要连接的主机的 SSH 会话。接下来，从这个 SSH 会话中，您启动图形应用程序，它将在您的工作站上绘制屏幕，同时在主机本身上完成所有工作。

听起来不错？建立这样的环境只有两个要求:

*   确保在主机上的`/etc/ssh/sshd_config`中将`X11Forwarding`选项设置为`yes`。
*   从客户端使用`ssh -X`命令连接到主机。或者，您可以在客户端配置文件`/etc/ssh/ssh_config`中设置`X11Forwarding`选项，这允许您默认转发图形会话。然而，这造成了一个小的安全问题，因此在大多数 Linux `distributions`上，这个设置是默认不启用的。

现在您已经与您的主机建立了 SSH 会话，启动您最喜欢的图形程序。程序本身将在远程主机上执行，您将在本地看到屏幕。

![Image](images/sq.jpg) **注意**使用 SSH 的 X-forwarding 会话确实很酷，但是有一个限制:在建立 SSH 会话的客户机上需要一个 X 服务器。这个 X 服务器被用作图形硬件的驱动程序，您希望在客户机上运行的应用程序需要它来显示它的屏幕。在 Linux、UNIX 或 Macintosh 机器上，这不成问题，因为默认情况下会有一个 X 服务器。然而，这在 Windows 上是个问题。最常见的用于 Windows 的 SSH 客户端是 PuTTY，尽管它非常有用，但不包含 X 服务器。一个好的 Windows X 服务器是 Xming，它是一个免费的 X 服务器，你可以从网上下载。

通用 tCp 端口转发

x 是唯一一个在 SSH 软件中硬编码端口转发的服务。对于其他一切，您需要手动进行端口转发，使用`-L`(本地转发)或`-R`(远程端口转发)选项。让我们看看[图 11-1](#Fig1) 中的例子。

![9781430268307_Fig11-01.jpg](images/9781430268307_Fig11-01.jpg)

[图 11-1](#_Fig1) 。示例网络

这个示例网络有三个节点:AMS 是管理员工作的节点，ATL 是中间的节点，AMS 直接连接到 ATL，但不连接到位于防火墙后面的 SLC。ATL 与 SLC 有直接连接，不受任何防火墙的阻碍。

以下命令说明了端口转发的一个简单例子:

```sh
linda@AMS:~> ssh -L 4444:ATL:110 linda@ATL
```

在此示例中，用户 linda 将到其本地主机上的端口 4444 的连接转发到主机 ATL 上的端口 110，就像该主机上的用户 linda 一样。例如，这就是您在该主机上与不安全的 POP 服务建立安全会话的方式。localhost 首先建立到运行在 ATL 上的 SSH 主机的连接。这个 SSH 主机连接到 ATL 的端口 110，而`ssh`绑定到本地主机的端口 4444。现在，在本地端口 4444 和主机端口 110 之间建立了一个加密会话:发送到本地主机端口 4444 的所有内容实际上都到达了主机端口 110。例如，如果您将 POP 邮件客户端配置为从本地端口 4444 获取邮件，那么它实际上会从 ATL 的端口 110 获取邮件。

请注意，本例中使用了非特权端口。只有 root 用户可以连接到端口号低于 1024 的特权端口。无论您连接到哪个端口，您都应该检查服务配置文件`/etc/services`，其中端口号与服务名称相匹配，表明端口通常用于什么(如果有的话)，并使用`netstat -platune | grep <your-intended-port>`来确保端口没有被使用。

本地端口转发的一个小变化是远程端口转发，它涉及将远程主机上的远程端口上的所有连接转发到您机器上的本地端口。

为此，使用`-R`选项，如下例所示:

```sh
linda@AMS:~> ssh -R 4444:AMS:110 linda@ATL
```

在本例中，用户 linda 连接到主机 ATL(参见命令的最后一部分)。在这个远程主机上，端口 4444 通过使用构造`-R 4444`来寻址。该远程端口被重定向到本地主机上的端口 110。因此，任何发往 ATL 上的端口 4444 的内容都会被重定向到 AMS 上的端口 110。如果 ATL 是客户端，AMS 是运行 POP 邮件服务器的主机，并且用户 linda 想要连接到该服务器，那么这个示例将非常有用。端口转发证明有用的另一个例子是当您想要转发到的主机不能直接到达时，可能是因为它在防火墙后面。在这种情况下，您可以建立一个到另一台主机的隧道，该隧道可以通过 SSH 到达。想象一下，在[清单 11-6](#FPar11) 中，主机 SLC 正在运行我们的用户琳达想要连接的 POP 邮件服务器。该用户将使用以下命令:

```sh
linda@AMS:~> ssh -L 4444:SLC:110 linda@ATL
```

在这个例子中，linda 将她本地主机上端口 4444 的连接转发给运行 SSH 的主机 ATL。该主机进而将连接转发到主机 SLC 上的端口 110。注意，在这个场景中，惟一的要求是 ATL 激活了 SSH 服务；SLC 不需要这样做。还要注意，主机 AMS 没有必要与 SLC 直接联系，因为这就是 ATL 的用途。

在这些例子中，您已经学习了如何使用`ssh`命令来完成端口转发，但是这不是唯一的方法。如果端口转发连接需要一直可用，您可以将它放在客户端计算机的`ssh`配置文件中。如果你想让它只为你的用户帐户工作，把它放在你的主目录的`.ssh/config`中，或者如果你想让它适用于你机器上的所有用户，把它放在`/etc/ssh/ssh_config`中。应该作为`ssh -L 4444:ATL:110`的替代的参数是`LocalForward 4444 ATL:110`。

练习 11-3:使用 SSH

在本练习中，您将配置 SSH。如果这不符合您的操作需求，请确保更改回配置。

1.  打开一个根壳。
2.  用编辑器打开配置文件/etc/ssh/sshd_config ，找到显示 **Port 22** 的那一行。在这条线的下面，添加一条线**端口 2222** 。这告诉您的服务器在两个不同的端口上提供服务。
3.  键入 **systemctl restart sshd** 来重启 ssh 服务器。
4.  键入 **ssh -p 2222 localhost** 以 root 身份连接到正在监听 localhost 的服务器上的端口 2222。我们在这里使用 localhost，因为它允许您在不需要配置额外服务器的情况下完成这个练习。
5.  键入**退出**。这将关闭当前的 SSH 会话。
6.  键入 **ssh-keygen** 。这将生成一对 SSH 密钥。
7.  键入 **ssh-copy-id localhost** 将公钥复制到目标服务器上的 authorized_keys 文件中。
8.  再次键入 **ssh -p 2222 localhost** 。这将使您无需输入密码即可连接到本地主机。

摘要

在本章中，您已经学习了如何设置网络连接。首先，我们研究了 IP 地址是如何分配给网络接口卡的。我们讨论了 IPv4 地址和 IPv6 地址。接下来，您将了解如何使用基本命令(如`ping`和`traceroute`)或高级工具(如`nmap`)对网络连接进行故障诊断。在本章的最后一部分，你已经学习了如何用 SSH 创建一个远程会话。您已经了解了以下命令:

*   `ifconfig`:监控和设置 IP 地址和其他网卡相关信息的传统命令
*   `ip`:监控和设置 IP 地址和其他网卡相关信息的新命令
*   `route`:显示和设置路由信息的命令
*   `ethtool`:显示和设置网卡物理性能相关设置的命令，如双工模式和速度
*   `ping`:测试与其他计算机连接的工具
*   `traceroute`:帮助您分析网络上主机可达性的实用程序
*   帮助你检查其他主机提供哪些服务的实用程序
*   帮助你找出本地主机提供哪些服务的实用程序
*   帮助你建立一个到远程计算机的外壳连接的命令，用加密技术保护
*   `scp`:在主机之间安全复制文件的命令
*   `sftp`:安全 FTP 客户端
*   `ssh-keygen`:生成公钥/私钥的命令，您可以将这些公钥/私钥用于自动 SSH 连接建立，其中密钥用于身份验证
*   `ssh-agent`:缓存与 SSH 使用的私钥相关联的密码短语的命令

在下一章，你将了解如何在你的电脑上设置像桑巴和 NFS 这样的文件服务。