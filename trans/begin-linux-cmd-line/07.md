第七章

![image](images/frontdot.jpg)

管理权限

在 Linux 系统上，权限用于保护访问。在本章中，您将学习如何修改所有权以适应权限。首先，介绍了基本的读、写和执行权限。接下来，您将学习如何应用高级 Linux 权限来获得额外的安全性。最后，在本章的结尾，您将学习如何创建访问控制列表，将权限授予多个用户或组，以及如何使用属性为文件添加额外的保护层。

设置所有权

文件和目录所有权对于使用权限至关重要。在本节中，您将了解如何确定所有权，以及如何更改文件和目录的用户和组所有权。

显示所有权

在 Linux 上，每个文件和每个目录都有一个所有者。为了确定您作为用户是否拥有文件或目录的权限，shell 会检查所有权。首先它会看你是不是*用户所有者*，也就是文件的*用户。如果您是用户，您将获得为该用户设置的权限，并且 shell 不会做更多的工作。如果您不是用户所有者，shell 将检查您是否是*组所有者*的成员，该组所有者也被称为文件*的*组。如果您是该组的成员，您将获得该组的权限来访问该文件，并且 shell 不会做更多的工作。如果您既不是用户也不是组所有者，您将获得 others 实体的权限。这个实体适用于其他所有人。*

从上面可以看出，权限不是附加应用的。这意味着既是所有者又是所有者组成员的用户只能使用用户所有者权限，而不能使用组所有者权限。

![Image](images/sq.jpg) **注意**除非特别提到，本章中所有适用于文件的内容同样适用于目录。所以如果你读到一个文件，你可以假设它也适用于一个目录。

要查看当前的所有权分配，您可以使用`ls -l`命令。该命令显示用户和组所有者。在清单 7-1 的[中，您可以看到在使用公共组方法的系统上目录`/home`中目录的所有权设置，其中所有用户都是同一个组`users`的成员。在这个输出中，您可以在第三列看到用户所有者的名称，然后在第四列看到组的名称。](#FPar2)

[***清单 7-1***](#_FPar2) 。使用`ls -l`显示用户和组所有权

```
nuuk:/home # ls -l
total 24
drwxr-xr-x 8   alex         users 4096 Dec 12 12:02 alex
drwxr-xr-x 8   caroline     users 4096 Dec 12 12:02 caroline
drwxr-xr-x 8   linda        users 4096 Dec 10 11:36 linda
drwxr-xr-x 8   sander       users 4096 Dec 10 13:22 sander
drwxr-xr-x 8   sanne        users 4096 Dec 12 11:59 sanne
drwxr-xr-x 8   stephanie    users 4096 Dec 12 12:01 stephanie
```

使用`ls command`，您可以显示给定目录中文件的所有权。有时，获取系统中给定用户或组作为所有者的所有文件的列表可能会很有用。为此，您可以将`find`与其`-user`参数一起使用。例如，以下命令将显示所有以用户 linda 为所有者的文件:

```
find / -user linda
```

您还可以使用`find`来搜索拥有特定组的文件。例如，以下命令将搜索组`users`拥有的所有文件:

```
find / -group users
```

更改用户所有权

当使用权限操作时，知道如何改变文件所有权是很重要的。为此，有一个`chown`命令。这个命令的语法不难理解:

```
chown *who what*
```

例如，以下命令会将文件`account`的所有权更改为用户 julie:

```
chown julie account
```

`chown`命令有一个重要的选项:`-R`。您可能会猜到它是做什么的，因为这个选项也适用于许多其他命令；它允许你递归地设置所有权，这允许你设置当前目录和下面所有东西的所有权。这包括文件和目录。以下命令会将目录`/home`及其下所有内容的所有权更改为用户 julie:

```
chown -R julie /home
```

更改组所有权

你实际上有两种方法来改变组所有权。您可以使用`chown`来完成这项工作，但是也有一个名为`chgrp`的特定命令来完成这项工作。如果您想使用`chown`命令，请在组名前使用`.`或`:`。下面将把目录`/home/account`的组所有者更改为组`account`:

```
chown .account /home/account
```

要了解如何使用`chgrp`命令更改组所有权，请想象以下示例，其中`chgrp`将目录`/home/account`的组所有权设置为组`account`:

```
chgrp account /home/account
```

和`chown`的情况一样，您可以使用选项`-R`和`chgrp`来递归地改变组的所有权。如果您需要更改用户所有权和组所有权，`chown`为您提供了这个选项。指定选项后，指定用户名，后跟一个点或冒号，紧接着是要设置为所有者的组的名称。作为命令的最后一部分，提到您想要为其设置所有权的文件或目录的名称。例如，以下命令将在一个命令中将用户琳达和组`sales`设置为所有者:

```
chown -R linda.sales /home/sales
```

默认所有权

您可能已经注意到，当用户创建文件时，会应用默认的所有权。创建该文件的用户将自动成为用户所有者，该用户的主要组将自动成为组所有者。通常，这将是在`/etc/passwd`文件中设置为用户主要群组的群组。然而，如果用户是多个组的成员，他或她可以使用 **newgrp** 命令更改有效的主要组。

为了显示当前有效的主要组，用户可以使用`groups`命令。首先列出此时作为主要组有效的组，然后是用户所属的所有其他组的名称。下面是一个例子:

```
linda@nuuk:~> groups
users dialout video
```

或者，可以使用 **id** 命令。该命令显示有关用户帐户的信息，其中首先列出有效的主要组。

如果当前用户 linda 想要更改有效的主要组，她可以使用`newgrp`命令，后跟她想要设置为新的有效主要组的组名。在[清单 7-2](#FPar3) 中，您可以看到用户 linda 如何使用这个命令使`sales`成为她的有效主组。

[***清单 7-2***](#_FPar3) 。使用 newgrp 更改有效主组

```
linda@nuuk:~> groups
users dialout video sales
linda@nuuk:~> newgrp sales
linda@nuuk:~> groups
sales dialout video users
linda@nuuk:~>
```

更改有效的主要组后，用户创建的所有新文件都将该组作为其组所有者。使用`exit`返回初始的主要组设置。这将关闭使用了另一个有效主要组的子外壳，并将您带回先前的有效主要组设置。

练习 7-1:改变所有权

1.  打开一个根壳。
2.  键入 **mkdir -p /data/sales** 来创建目录/data/sales。接下来输入 **mkdir /data/account** 来创建/data/account 目录。
3.  键入**chown marcha:sales/data/sales**，后跟**chown marcha:account/data/account**。这使得用户 marcha 成为这两个目录的用户所有者，并确保组 sales 是/data/sales 目录的所有者，并且组 account 被设置为/data/account 目录的所有者。
4.  键入 **ls -l /data** 检查/data/account 和/data/sales 上的所有权设置。

基本权限:读、写和执行

Linux 权限系统 发明于 20 世纪 70 年代。由于计算需求在那些年是有限的，所以当时创建的基本许可系统也相当有限。

这个系统由三个权限组成，您可以将它们应用于文件和目录。在本节中，您将了解系统如何工作以及如何修改这些权限。

在此之前，我们先来看看如何读取当前权限。最好的方法是使用`ls -l`，它将显示当前目录中所有文件和目录的列表。第一个字符表示文件的类型。例如，如果它是一个目录，它给出`d`;如果它是一个符号链接，它给出`l`。接下来是九个字符，用于指定为文件或目录设置的权限。第一组三个是用户权限，第二组三个是组权限，最后一组三个是授予其他人的权限。因此，在下面的示例命令列表中，用户琳达拥有`rwx`，群组所有者`sales`拥有`r-x`，而其他人则没有任何权限:

```
ls -ld /home/sales
drwxr-x--- 2    linda    sales    4096    sales
```

了解读、写和执行权限

这三个基本权限允许您读取、写入和执行文件。这些权限在应用于文件或目录时的效果会有所不同。如果应用于文件，读取权限赋予您打开文件进行读取的权利。这意味着您可以读取其内容，但也意味着您的计算机可以打开该文件来处理它。例如，需要访问库的程序文件可能需要对该库的读取权限。由此可见，读取权限是处理文件所需的最基本的权限。

如果应用于目录，读取权限允许您列出该目录的内容。您应该知道，该权限不允许您读取目录中的文件。Linux 权限系统不知道继承，读取文件的唯一方法是使用对该文件的读取权限。然而，要打开一个文件进行读取，您确实需要对该目录的读取权限，因为否则您将看不到该文件。注意，对一个目录只有读权限是不够的。对目录的读取权限总是需要与执行权限一起使用。没有执行权限，用户将无法访问该目录。

正如您可能猜到的那样，如果将写权限应用于一个文件，它将允许您在该文件中写入内容。换句话说，write 允许您修改现有文件的内容。但是，它不允许您创建新文件或删除现有文件。为此，您需要对要创建文件的目录具有写权限。在目录上，此权限还允许您创建和删除新的子目录。

注意:让我用一个例子来阐述这一点。如果 root 用户在 linda 的主目录中创建了一个文件，那么 linda 用户是否可以删除这个文件？很多人对这个问题给出了错误的答案:由于 root 创建了该文件，用户 linda 对该文件没有写权限。然而，这一点都不重要。为了能够删除文件，您需要对目录的写权限，而对文件的权限根本不重要。

执行权限是您执行文件所需的权限。这意味着您需要执行您创建的任何程序文件或脚本文件。它永远不会被默认设置，这使得 Linux 几乎对病毒免疫。该目录的所有者将能够对该目录中的文件应用执行权限。同样，如果你是文件的所有者，你可以使用 **chmod** 命令来设置该文件的执行权限。

![Image](images/sq.jpg) **注意**虽然几乎没有针对 Linux 的病毒，但这并不意味着你在使用 Linux 的时候就可以免受安全问题的困扰。病毒的 Linux 替代品叫做*根包*。您可以将 root kit 比作 Windows 世界中的特洛伊木马:root kit 是一个后门，允许他人控制您的计算机。防范 root kits 的最佳安全措施是不使用 root 权限，除非真的有必要。

鉴于文件的执行权限允许用户运行程序文件，如果应用于目录，则允许用户使用`cd`命令进入该目录。这意味着 execute 是目录的一个重要权限，您将看到它通常作为默认权限应用于目录。没有它，就没有办法进入那个目录！因此，如果您想拥有目录的读取权限，您还必须拥有执行权限。仅仅给用户一个目录的读权限是没有意义的。[表 7-1](#Tab1) 总结了基本权限的使用。

[表 7-1](#_Tab1) 。使用的读、写和执行权限

| 

同意

 | 

应用于文件

 | 

应用于目录

 |
| --- | --- | --- |
| 阅读 | 打开一个文件 | 列出目录的内容 |
| 写 | 更改文件的内容 | 创建和删除文件 |
| 执行 | 运行程序文件 | 转到目录 |

应用读取、写入和执行权限

要应用权限，可以使用`chmod`命令。使用`chmod` 时，可以设置用户、组和其他人的权限。您可以在两种模式下使用此命令:相对模式和绝对模式。在绝对模式下，三位数用于设置基本权限。[表 7-2](#Tab2) 给出了权限及其数字表示的概述。

[表 7-2](#_Tab2) 。权限的数字表示

| 

同意

 | 

数字表示

 |
| --- | --- |
| 阅读 | four |
| 写 | Two |
| 执行 | one |

设置权限时，您应该计算您需要的值。例如，如果您想为用户设置读取、写入和执行权限，为组设置读取和执行权限，为其他人设置读取和执行文件`/somefile`的权限，您可以使用下面的`chmod`命令:

```
chmod 755 /somefile
```

以这种方式使用`chmod`时，所有当前权限都被您设置的权限所取代。如果要修改相对于当前权限的权限，可以在相对模式下使用`chmod`。当在相对模式下使用`chmod`时，你用三个指示器来指定你想要做什么。首先，您将指定想要更改谁的权限。为此，您可以在用户(`u`)、组(`g`)和其他(`o`)之间进行选择。接下来，使用一个操作符从当前模式中增加或减少权限，或者以绝对方式设置权限。最后，您使用`r`、`w`和`x`来指定您想要设置的权限。

![Image](images/sq.jpg) **注意**你会经常设置读写权限。对于 execute 权限，情况并非如此。尽管您会一直在目录上设置它，但是您很少会对文件应用执行权限，除非它们是应该作为程序文件运行的文件。

在相对模式下更改权限时，可以省略“向谁”部分来添加或删除所有实体的权限。例如，以下代码将为所有用户添加执行权限:

```
chmod +x somefile
```

在相对模式下工作时，您也可以使用更复杂的命令。例如，以下内容将向组添加写权限，并删除其他人的读权限:

```
chmod g+w,o-r somefile
```

在学习高级权限之前，让我们先练习应用基本权限。

练习 7-2:应用基本权限

本练习继续练习 7-1 中执行的任务。在完成本练习中的任务之前，请确保您已经完成了本练习。

1.  打开一个根壳。
2.  要确保所有者和组拥有对目录及其内容的所有权限，请在/data/sales director 上使用 **chmod -R 770 /data/sales** 。
3.  让我们使用/data/account 上的相对权限做同样的事情:type **chmod -R u=rwx，g=rwx，o=- /data/account** 。
4.  键入 **ls -l /data/** 以验证权限已被正确应用。

高级权限

除了您刚刚读到的基本权限之外，Linux 还有一组高级权限。这些是特殊用途的权限，后来被添加到可用 Linux 权限的 spectre 中，以满足对更高级安全设置的需求。

了解高级权限

有三种高级权限。首先是*设置用户 ID* (SUID)权限T3。在某些特定情况下，您可能希望将此权限应用于可执行文件。

默认情况下，运行可执行文件的用户使用自己的权限运行该文件(前提是该用户拥有运行该文件所需的所有权限)。对于普通用户，这通常意味着程序的使用受到限制。但是，在某些情况下，用户需要能够以 root 权限运行命令。例如，考虑用户需要更改他或她的密码的情况。为此，用户需要将新密码写入`/etc/shadow`文件。但是，该文件对于拥有非超级用户权限的用户来说是不可写的:

```
nuuk:/home # ls -l /etc/shadow
-rw-r----- 1 root shadow 853 Dec 12 12:02 /etc/shadow
```

SUID 许可为这个问题提供了一个解决方案。在`/usr/bin/passwd`文件上，默认情况下应用该权限。因此，当更改他或她的密码时，用户暂时拥有 root 权限，这允许用户写入`/etc/passwd`文件。您可以看到 SUID 权限，在通常情况下您会看到用户权限的`x`的位置，有一个`ls -l`作为`s`;

```
nuuk:/ # ls -l /usr/bin/passwd
-rwsr-xr-x 1 root shadow 73300 May  4  2007 /usr/bin/passwd
```

SUID 的许可可能看起来有用——确实有用——但同时，它也有潜在的危险。如果应用错误，您可能会放弃根权限。意外。因此，我建议您小心使用。我来解释一下原因。

想象一个名为`gone`的 shell 脚本，它包含以下内容:

```
#!/bin/bash
rm -rf /
```

现在假设用户 linda 找到了这个 shell 脚本并试图执行它。会发生什么？她将只删除自己的文件。这是因为对于所有其他文件，她没有足够的权限删除它们。现在假设这个 shell 脚本拥有 root 用户和 SUID 权限集。因此，该脚本上的`ls -l`将给出以下内容:

```
ls -l gone
-rwsr-xr-x 1    root root     19    gone
```

但是，如果 linda 试图在这种情况下运行这个脚本，会发生什么呢？你能想象会发生什么吗？它实际上会删除这台计算机硬盘上的所有文件，因为脚本是在 linda 拥有 root 权限的子 shell 中执行的。这是因为 root 用户是脚本的所有者，并且设置了 SUID 权限。因此 linda 将以 root 用户身份运行它，鉴于此，她将拥有足够的权限来执行她的破坏性命令。出于这个原因，关于申请 SUID，你需要记住一件事:不要！

第二个特殊权限是*设置组 ID* (SGID)。 这个权限有两个效果。

如果应用于可执行文件，它将授予执行该文件的用户该文件的组所有者的权限。因此，SGID 可以或多或少地完成 SUID 所做的事情。然而，为了这个目的，SGID 很少被使用，你也不应该自己用它来完成这个任务！

当应用于一个目录时，SGID 可能是有用的，因为您可以使用它来设置在该目录中创建的文件和子目录的默认组所有权。默认情况下，当用户创建文件时，他或她的有效主要组被设置为该文件的所有者。例如，如果您有一个共享的组环境，这不是很有用，因为没有人能够修改您正在创建的文件，即使他们是同一个组的成员。

假设用户 linda 和 lori 在会计部门工作，并且都是会计组的成员。然而，出于安全原因，管理员决定与私有主组合作。这意味着 linda 是她主要群组 linda 的唯一成员，而 lori 是她主要群组`lori`的唯一成员。然而，这两个用户都是`accounting`组的成员，但是作为次要组设置。

默认情况下，当这些用户中的任何一个创建文件时，主组成为所有者。但是，如果您创建一个共享组目录(比如，`/data/account`)，并确保 SGID 权限应用于该目录，并且组 accounting 被设置为该目录的组所有者，则在该目录及其所有子目录中创建的所有文件也会将组`accounting`作为默认组所有者。请注意，这是非常有用的行为，因此，您应该考虑在所有共享组环境中使用 SGID。

SGID 权限显示在`ls -l`的输出中，在您通常可以找到组执行权限的位置带有一个`s`:

```
nuuk:/groups # ls -ld account
drwxr-sr-x 2 root account 4096 Dec 14 15:17 account
```

第三个特殊权限是*粘位*。在多个用户可以在同一个目录中创建文件的环境中，此权限有助于防止文件被意外删除。因此，它被作为默认权限应用于`/tmp`目录。

没有T3 的粘性位权限，如果一个用户可以在一个目录中创建文件，他或她也可以从那个目录中删除文件。在共享的群组环境中，这可能是令人讨厌的。假设用户 linda 和 lori 都拥有对目录`/groups/account`的写权限，因为他们是组`accounting`的成员。这意味着 linda 能够删除 lori 创建的文件，反之亦然。这可能不是一个理想的情况。

当应用粘滞位权限时，只有满足以下任一条件时，用户才能删除文件:

*   用户是文件的所有者。
*   用户是文件所在目录的所有者。

请注意，这意味着粘滞位不能用来阻止用户从他们的主目录中删除文件。由于用户是主目录的所有者，因此用户将始终拥有从该目录中删除文件的权限。

使用`ls -l`时，在正常看到别人执行权限的位置，可以看到粘滞位为`t`:

```
nuuk:/groups # ls -ld account/
drwxr-sr-t 2 root account 4096 Dec 14 15:17 account/
```

应用高级权限

要应用 SUID、SGID 和粘性位，也可以使用`chmod`。SUID 的数值为 4，SGID 的数值为 2，粘性位的数值为 1。如果要应用这些权限，需要给`chmod`加一个四位数的参数，其中第一位数指的是特殊权限。例如，下面的代码行将 SGID 权限添加到一个目录中，并为用户设置`rwx`，为组和其他人设置`rx`:

```
chmod 2755 /somedir
```

如果您必须在绝对模式下使用`chmod`之前查找当前设置的权限，这是相当不切实际的(如果您不这样做，您将冒覆盖权限的风险)。因此，如果需要应用任何特殊权限，我建议使用相对模式。对于 SUID，使用`chmod u+s`；对于 SGID，用`chmod g+s`；对于 sticky bit，使用`chmod +t`,后跟您想要设置权限的文件或目录的名称。

表 7-3 给出了你需要知道的关于这些特殊权限的所有信息。

[表 7-3](#_Tab3) 。与 SUID、SGID 和粘粘的比特一起工作

![Table7-3](images/Table7-3.jpg)

当在绝对模式下使用`chmod`应用这些权限时，您将使用四位数(通常只使用三位数)来设置权限。在这四个数字中，第一个与特殊权限相关。因此在命令`chmod 4755 somefile`中，SUID 权限被设置为`somefile`，在`chmod 3755`中，SGID 和粘滞位被应用。在练习 7-3 中，您将对您的测试机器应用高级权限。

练习 7-3:应用高级权限

请注意，本练习继续了您在练习 7-1 和 7-2 中完成的任务。在应用本练习中的任务之前，请确保完成这些练习。

1.  以用户 marcha 的身份打开一个 shell。使用 **id** 验证 marcha 是 sales 以及 account 组的成员。
2.  输入命令**触摸/数据/销售/市场**。这将在共享组环境中创建一个空文件。使用相同的命令在这个目录中创建更多的文件。
3.  键入 **ls -l /data/sales** 并注意销售组在文件中没有被指定为组所有者。
4.  打开一个根壳。在根 shell 中，键入 **chmod g+s /data/*** 。这将对/data/sales 目录和/data/account 目录应用 SGID 权限。
5.  以用户 daphne 的身份打开一个 shell。检查她是否是销售组的成员。如果不是这样，请确保在继续之前，她已被分配为销售团队的一员。
6.  类型**echo Daphne>>/数据/销售/马尔卡**。请注意，这不起作用。这是因为 daphne 是作为“others”实体的一部分来访问该文件的，该实体对该文件没有写权限。
7.  使用 **touch /data/sales/daphne** 作为用户 daphne 创建一个文件，并重复几次该命令。使用 **ls -l /data/sales** 来验证这些文件已经继承了目录的组所有者，因为已经在目录上设置了 SGID 权限。
8.  仍然作为 daphne，键入 **rm -f /data/sales/marcha。**注意这是有效的。作为销售组的成员，daphne 拥有对该目录的写权限，因此她可以删除该目录中的所有文件。
9.  打开一个根 shell，键入 **chmod +t /data/*** 将 sticky bit 应用于/data/sales 和/data/account。
10.  再次以用户 daphne 的身份打开一个 shell，并尝试删除 marcha 在/data/sales 中创建的其他文件。因为现在已经应用了粘滞位权限，所以不再允许这样做。

使用访问控制列表

即使添加了 SUID、SGID 和粘滞位等附加特性，Linux 许可计划中仍然缺少重要的功能。特别是，能够授予多个用户和组对同一个文件或目录的权限为此，访问控制列表(ACL)被添加进来。在本节中，您将了解什么是 ACL 以及如何应用它们。

了解 ACL

没有 ACL 的 Linux 权限系统有两个严重的缺点:

*   只能有一个用户所有者和一个组所有者。
*   不可能使用继承来将在较高级别(如目录)上设置的权限继承给较低级别的权限(如该目录中的文件)。

ACL 子系统解决了这些缺点。通过将这个特性添加到您的文件系统中，您可以向文件系统中的其他实体授予权限，并且还可以使用继承。

尽管 ACL 子系统为您的服务器增加了强大的功能，但有一个缺点:并非所有的实用程序都支持它。这意味着在复制或移动文件时，您可能会丢失 ACL 设置，并且您的备份软件可能无法备份 ACL 设置。不过这不一定是个问题。ACL 通常应用于目录，以确保在目录中创建的新文件将自动获得您希望它们拥有的权限。将 ACL 视为在设计文件系统布局时应用的东西，而不是在以后应用的东西。您很少会在单个文件上设置 ACL。这意味着您不会有太多的 ACL，只是在文件系统中的智能位置应用了一些。因此，恢复您正在使用的原始 ACL 将会相对容易，即使您的备份软件不支持它们。

为 ACL 准备您的文件系统

在开始使用 ACL 之前，您必须验证您的文件系统支持 ACL。情况并非总是如此。如果 ACL 不是，您需要确保您的文件系统是用`acl`选项挂载的(大多数发行版会自动为您这样做)。对于一个已挂载的文件系统，您可以通过使用`acl`选项重新挂载该文件系统来实现。下面一行显示了如何对根文件系统执行此操作:

```
mount -o remount,acl /
```

更好的解决方案是将 ACL 选项放在`fstab`中，这样当您的系统重新启动时，它会一直被激活。清单 7-3 展示了在 SUSE 系统中默认情况下这是如何实现的。请注意，在本例中，还使用了 user_xattr 挂载选项，以提供对用户扩展属性的支持(将在本章后面详细讨论)。

[***清单 7-3***](#_FPar9) 。要使用 ACL，您需要装载支持 ACL 的文件系统

```
nuuk:/ # cat /etc/fstab
/dev/system/root     /      ext4    acl,user_xattr 1 1
/dev/sda1            /boot  ext4    acl,user_xattr 1 2
/dev/system/swap     swap   swap    defaults       0 0
...
```

小费！ACL 是否可以用在文件系统上并不总是很清楚。找出答案的最佳方法是尝试应用 setfacl 命令，如下所述。如果此命令向您显示“不支持操作”错误消息，则 ACL 支持不可用，您需要按照上述方法解决此问题。

使用 setfacl 和 getfacl 更改和查看 ACL 设置

要使用 ACL，您需要使用`setfacl`命令。这个命令有许多选项，其中一些选项相当混乱。在这一节中，我将只讨论有用的选项，这些选项并不太难理解。`setfacl` 的基本语法如下:

```
setfacl [*options*] *operation entity*:*entityname*:*permissions file*
```

在此示例中，使用了以下组件:

*   *选项*:使用该部分的特定选项来调节`setfacl`的工作方式。一些选项可能会有用:
    *   `-d`:使用该选项设置默认 ACL。这是一个由子目录和文件继承的 ACL 设置。
    *   `-k`:使用此选项删除默认 ACL。
    *   `-R`:使用此选项递归应用 ACL 设置。

![Image](images/sq.jpg) **注意**默认 ACL 用于新文件，不影响现有文件。所有新文件都将获得您在默认 ACL 中设置的权限。基本上，通过使用选项`-d`，您可以启用权限继承。如果没有选项-d，setfacl 命令只对现有文件有效。要确保所有新文件都将获得所需的 ACL 设置，您应该使用 setfacl 命令两次。首先使用-d 选项来设置默认 ACL，然后使用-R 选项而不使用-d 选项来处理当前存在的文件。

*   *操作*:该操作告诉`setfacl`添加或删除一个 ACL 设置。以下操作可用:
    *   `--set`:使用此操作设置一个 ACL。它将取代任何现有的 ACL，所以要小心使用。
    *   `-m`:如果需要修改 ACL，使用`-m`。它不会替换现有的 ACL，而是添加到当前设置中。
    *   `-x`:使用此选项删除现有的 ACL。
*   *实体和实体名称*:这两个定义了你想为谁设置 ACL。实体有两种类型:`u`表示用户，`g`表示组。指定实体的类型后，您需要指定实体的名称。
*   *权限*:这些是您想要使用 ACL 设置的权限。使用前面讨论过的 Linux 权限。
*   `File`:这是您想要应用 ACL 的文件或目录的名称。

基于这些信息，是时候看看一些例子了，从一些简单的开始。假设您想要将组`account`作为拥有权限的人(这被称为受信者)添加到目录`account`。执行此操作的`setfacl`命令如下:

```
setfacl -m g:account:rwx account
```

然而，不先查看当前的权限就开始处理 ACL 是没有意义的。因此，在清单 7-4 中，您可以看到目录`/groups/account`在我更改 ACL 前后的权限设置。

[***清单 7-4***](#_FPar12) 。更改 ACL 前后的权限设置

```
nuuk:/groups # ls -l
total 4
drwxr-sr-t    2 root users 4096 Dec 14 15:17 account
nuuk:/groups # setfacl -m g:account:rwx account
nuuk:/groups # ls -l
total 8
drwxrwsr-t+ 2 root users 4096 Dec 14 15:17 account
```

正如你所看到的，已经有一个群主，`users`，这个群主并没有因为用`setfacl`更改 ACL 而受到影响。唯一表明发生了什么事情的是直接显示在`ls -l`中许可列表后的`+`标志。这个`+`表示 ACL 是有效的。

要查看 ACL 本身，您需要使用`getfacl`命令。在清单 7-5 的[中，您可以看到这个命令为我刚刚应用了 ACL 的目录`account`显示了什么。](#FPar13)

[***清单 7-5***](#_FPar13) 。用`getfacl`显示 ACL 设置

```
nuuk:/groups # getfacl account
# file: account
# owner: root
# group: users
user::rwx
group::r-x
group:account:rwx
mask::rwx
other::r-x
```

正如您在`getfacl`的输出中看到的，这个命令显示了用户和组所有者的名称以及为他们设置的权限。接下来，它显示还有一个拥有`rwx`权限的组帐户。忽略`mask`行中显示的信息；ACL 掩码是一个复杂和令人困惑的特性，您只需要在糟糕的目录结构设计中进行补偿，因此我将在本书中忽略它。在最后一行，还显示了其他人的权限。

在第二个例子中，我将向您展示如何修改现有的 ACL，使其成为默认 ACL。基本上，您使用的是之前见过的相同命令，但是添加了选项`-d`。此外，该命令通过使用逗号分隔两个组的名称，在 ACL 设置中添加第二个组:

```
nuuk:/groups # setfacl -d -m g:account:rwx,g:sales:rx account
```

此时，您有一个默认 ACL。这意味着在`/groups/account`下创建的所有文件和所有目录将获得相同的 ACL 设置。您可以用`getfacl`命令来显示这一点，如[清单 7-6](#FPar14) 所示。

[***清单 7-6***](#_FPar14) 。使用 getfacl 显示默认 acl 设置

```
nuuk:/groups # getfacl account
# file: account
# owner: root
# group: users
user::rwx
group::r-x
group:account:rwx
mask::rwx
other::r-x
default:user::rwx
default:group::r-x
default:group:sales:r-x
default:group:account:rwx
default:mask::rwx
default:other::r-x
```

如您所见，这里不仅显示了用户和组所有者的姓名，还显示了他们的权限以及将应用于新文件的默认设置。但是，您应该注意到，在这一点上，普通的 Linux 权限模式和 ACL 设置之间存在一种有趣的混合。这显示了属于组`users`的用户 linda 在目录`/groups/account`中创建子目录的时间。您可以在清单 7-7 中的[目录中看到`getfacl`的结果:对于“普通”用户和组所有者，应用普通的所有权规则，并添加 ACL 设置。这意味着当您使用默认 ACL 时，您应该在应用它们之前仔细计划您想要做什么！](#FPar15)

[***清单 7-7***](#_FPar15) 。ACL 和普通所有权规则都是有效的

```
linda@nuuk:/groups/account> getfacl subdir
# file: subdir
# owner: linda
# group: users
user::rwx
group::r-x
group:sales:r-x
group:account:rwx
mask::rwx
other::r-x
default:user::rwx
default:group::r-x
default:group:sales:r-x
default:group:account:rwx
default:mask::rwx
default:other::r-x
```

您现在已经学会了如何使用 ACL。如果您需要增强 Linux 文件系统权限的能力，这是一个有用的特性。我个人在配置 Linux 文件服务器时非常依赖它，这通常是一个环境，其中一个组的需求不同于另一个组。我还在 web 服务器环境中使用它来授权开发人员访问 HTML 文档根目录中的所有文件，而不改变该环境中的默认权限，这可能会对 web 服务器的工作产生负面影响。不过请尽量少用这个特性，因为应用了太多 ACL 的 Linux 系统更难理解。

练习 7-4:与 ACLS 一起工作

在本练习中，您将应用 ACL。请注意，本练习延续了练习 7-1 至 7-3，请确保在完成本练习中描述的步骤之前，您已经完成了这些练习。

1.  打开一个根壳。
2.  键入**getfacl/data/sales/marcha**来检查分配给该文件的当前 acl。由于没有应用 ACL，您将只能看到权限设置。
3.  键入**setfacl-R-m g:account:rx/data/sales**以确保帐户组获得/data/sales 目录中所有文件的权限。
4.  再次键入**getfacl/data/sales/marcha**检查新应用的 acl 设置。
5.  键入 **touch /data/sales/newfile** 并使用**getfacl/data/sales/new file**检查文件上的 ACL 设置。您会注意到没有应用 ACL 设置，因为还没有创建默认 ACL。
6.  键入**setfacl-m d:g:account:rx/data/sales**将默认 acl 应用于销售目录。
7.  在/data/sales 中创建另一个新文件，并使用 **getfacl** 检查新文件上的 acl 设置。
8.  使用**setfacl-m d:g:sales:rx/data/account**后跟**setfacl-R-m g:account:rx/data/sales**

使用 umask 设置默认权限

在关于 ACL 的讨论中，您已经学习了如何使用默认 ACL。如果不使用 ACL，有一个 shell 设置决定了您将获得的默认权限:`umask`。在本节中，您将了解如何使用该设置修改默认权限。

您可能已经注意到，在创建新文件时，会设置一些默认权限。这些权限由`umask`设置决定，这是一个 shell 设置，在所有用户登录系统时应用。在`umask`设置中，使用了一个数值，该数值是从可以对文件自动设置的最大权限中减去的；文件的最大设置为`666`，目录的最大设置为`777`。换句话说，要从`umask`中获得数字权限，需要从`666`中减去`umask`，从`777`中减去文件。

然而，这一规则也有一些例外；您可以在[表 7-4](#Tab4) 中找到`umask`设置的完整概述。在`umask`中使用的数字中，与`chmod`命令的数字参数一样，第一个数字表示最终用户权限，第二个数字表示组权限，最后一个数字表示为其他人设置的默认权限。默认的`022`设置为`644`用于所有新文件，而`755`用于所有在你的服务器上创建的新目录。

[表 7-4](#_Tab4) 。`umask`值及其结果

| 

价值

 | 

应用于文件

 | 

应用于目录

 |
| --- | --- | --- |
| Zero | 直读式记录 | 一切 |
| one | 直读式记录 | 直读式记录 |
| Two | 阅读 | 阅读并执行 |
| three | 阅读 | 阅读 |
| four | 写 | 编写并执行 |
| five | 写 | 写 |
| six | 没有任何东西 | 执行 |
| seven | 没有任何东西 | 没有任何东西 |

有两种方法可以改变`umask`设置:针对所有用户和针对单个用户。如果您想为所有用户设置`umask`，您必须确保`umask`设置已输入到配置文件`/etc/profile`中。如果在此文件中更改了`umask`，它将应用于登录到您的服务器后的所有用户。您可以通过在`/etc/profile:`中添加如下一行来设置默认值`umask`

```
umask 027
```

除了在`/etc/profile`中设置 umask(适用于登录系统的所有用户)之外，还可以在一个名为`.profile`的文件中更改`umask`设置，该文件创建于个人用户的主目录中。此文件中应用的设置仅适用于单个用户；因此，如果您需要更多的粒度，这是一个不错的方法。我个人喜欢这个特性，它将用户根的默认`umask`改为`027`，而普通用户在许多发行版上使用默认的 umask `022`。

使用属性

权限总是与受信者相关，受信者是对文件或目录拥有权限的用户或组。属性提供了一种不同的方式来指定可以对文件做什么。无论是谁访问文件，属性都会发挥作用。当然，这是有区别的:文件的所有者可以设置文件属性，而其他用户(除了超级用户)不能这样做。在某些情况下，使用属性很有用，但并不常见。

对于文件属性，在使用前必须在`/etc/fstab`中提供一个选项。这是在本章前面的[清单 7-3](#FPar9) 中的`fstab`示例中可以看到的`user_xattr`选项。有些属性可用，但尚未实现。不要使用它们，因为它们不会给你带来任何好处。以下是可以应用的最有用的属性:

*   `A`:该属性保证文件的访问时间不被修改。通常，每次打开文件时，必须将文件访问时间写入文件的元数据。这会对性能产生负面影响；因此，在定期访问的文件上，`A`属性可以用来禁用这个特性。
*   `a`:该属性允许添加文件，但不允许删除文件。例如，您可以在日志文件上使用它作为额外的安全层，确保可以添加条目，但不会意外删除日志文件。
*   `c`:如果您使用的文件系统支持卷级压缩，此文件属性可确保文件在压缩引擎第一次激活时被压缩。
*   `D`:该属性确保对文件的更改被立即写入磁盘，而不是先缓存。对于重要的数据库文件，这是一个有用的属性，可以确保它们不会在文件缓存和硬盘之间丢失。
*   `d`:该属性确保在使用`dump`实用程序的备份中不备份文件。
*   `I`:该属性为启用了索引的目录启用索引(参见[第 5 章](05.html)了解更多关于索引的细节)。对于像 Ext3 这样不使用 b 树数据库来快速访问文件的原始文件系统，这允许更快的文件访问。
*   `j`:该属性确保在 Ext3 文件系统上，文件首先被写入日志，然后才被写入硬盘上的数据块。使用此选项可确保日志提供最大程度的保护，并将丢失数据的可能性降至最低。
*   `s`:删除文件后，用零覆盖存储文件的块。这可以确保文件在被删除后无法恢复。
*   `u`:该属性保存取消删除的信息。这允许开发一个实用程序来处理这些信息，以挽救被删除的文件。

![Image](images/sq.jpg)例如，只要还没有开发出可以使用这个属性来恢复被删除文件的应用程序，应用`u`属性就没有意义。

如果你想应用属性，你可以使用`chattr`命令。例如，使用`chattr +s somefile`将属性`s`应用到`somefile`。需要再次删除属性吗？然后使用`chattr -s somefile`，它将被删除。要获得当前应用的所有属性的概览，使用`lsattr`命令。

练习 7-4:使用属性

1.  打开一个根壳。
2.  键入 **touch /root/somefile** 来创建一个测试文件。
3.  键入 **chattr +i /root/somefile** 将“不可变”属性应用于文件。
4.  仍然以 root 用户身份，使用 **rm -f /root/somefile** 尝试删除文件。你会注意到这不起作用。属性适用于所有用户，包括 root 用户！
5.  使用 **chattr -i /root/somefile** 。这将移除该属性。您现在可以删除该文件了。

摘要

在本章中，您已经学习了如何使用权限。在确定有效权限时，您首先发现了所有权的作用。接下来，您学习了三个基本权限:读、写和执行。接下来，您了解了如何使用高级功能，如 SUID、SGID 和粘滞位权限以及 ACL。您还了解了如何应用文件属性来为您的文件系统增加额外的安全层。本章讨论了以下命令:

*   `chown`:更改文件和目录的所有权。
*   `chgrp`:更改文件和目录的组所有权。
*   `groups`:列出用户的组所有权。
*   `newgrp`:临时更改用户的有效主组。
*   `chmod`:更改文件和目录的权限模式。
*   `setfacl`:设置 ACL。
*   `getfacl`:读取当前 ACL。
*   `chattr`:改变文件属性。
*   `lsattr`:列出文件属性。

在下一章，你将学习过程管理。