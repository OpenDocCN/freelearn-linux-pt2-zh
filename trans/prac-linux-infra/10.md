# 10.故障排除工具

故障排除是一门艺术，也是一门科学。为了有效地进行故障诊断，您必须了解某些东西是如何工作的，以及在哪里查找问题。知识有助于理解事物是如何工作的；经验有助于决定去哪里找。故障排除是一门艺术，因为每个人都有独特的处理问题的方式；这是一门科学，因为有一种方法，如果遵循这种方法，可以帮助解决最常见错误的大子集。

本章是关于本书中解释的各种应用程序的故障排除。它也是关于 Linux 基础设施管理人员所需的 Linux 系统的一般故障排除。

## 传输控制协议

网络基础从开放系统互连(OSI)层开始( [`https://en.wikipedia.org/wiki/OSI_model`](https://en.wikipedia.org/wiki/OSI_model) )。有效的故障排除意味着对该层及其组件非常熟悉。OSI 层的简要总结如表 [10-1](#Tab1) 所示。协议缩写扩展见表 [10-2](#Tab2) 。

表 10-2。

Protocol Acronym Expansion

<colgroup><col> <col> <col> <col></colgroup> 
| 首字母缩略词 | 膨胀 | 首字母缩略词 | 膨胀 |
| --- | --- | --- | --- |
| 超文本传送协议 | 超文本传输协议 | 文件传送协议 | 文件传送协议 |
| 动态主机配置协议 | 动态主机配置协议 | 因特网中继会谈 | 互联网中继聊天 |
| 坦克激光瞄准镜（Tank Laser-Sight 的缩写） | 传输层安全性 | 安全协议 | 互联网协议安全性 |
| 美国信息交换标准代码 | 美国信息交换标准代码 | 网络文件系统 | 网络文件系统 |
| 位置遥控(remote position control) | 远程过程得 | 服务器信息块 | 服务器消息块 |
| 袜子 | 插座的缩写 | 三氯苯酚 | 传输控制协议 |
| 用户数据报协议(User Datagram Protocol) | 用户数据报协议 | 啊 | 认证标题 |
| 断续器 | 数据报拥塞控制协议 | 互联网协议(Internet Protocol) | 因特网协议 |
| 以太网所用协议之一(Internet Packet eXchange) | 网间分组交换 | 线性低密度聚乙烯 | 链路层发现协议 |
| 巴基斯坦人民党 | 点对点协议 | 胞啶 5-二磷酸（cytidine 5-diphosphate 的简写） | 思科发现协议 |
| 虚拟局域网 | 虚拟局域网 | 通用串行总线 | 通用串行总线 |
| 数字式用户线路 | 数字用户线路 | 综合业务数字网 | 综合业务数字网 |
| 电气电子工程师学会 | 电气和电子工程师学会 |   |   |

表 10-1。

OSI Layer

<colgroup><col> <col></colgroup> 
| OSI 层 | 协议示例 |
| --- | --- |
| 应用 | HTTP、FTP、DHCP、IRC |
| 陈述 | TLS、IPSec、ASCII |
| 会议 | NFS、RPC、SMB、SOCKS |
| 运输 | TCP、UDP、AH、DCCP |
| 网络 | IP、IPX、AppleTalk |
| 数据传输器 | LLDP，PPP，CDP，VLAN，IEEE 802.11 |
| 物理的 | 以太网、USB、DSL、ISDN、IEEE 1394 |

有效的网络故障排除需要沿着 OSI 各层向上或向下进行。假设源网络设备和目的网络设备彼此不通信，则可能启动故障排除过程的典型工作流包括以下内容:

In the application layer, check that the application itself is up by reviewing log files. Use commands such as `strace` and `ltrace` to analyze application behavior after you have exhausted the basics (`ps`, `top`).   Move to the presentation layer. If the application is using a public key infrastructure (PKI), look at the certificate status and the key exchange.   The session layer can be debugged using protocol-specific commands. Network File System (NFS) statistics can be obtained with `nfsstat`; remote procedure call (RPC) can be debugged using `rpcinfo`.   The transport and network layers can be debugged using `tcpdump`, `ifconfig`, `traceroute`, `ping`, `ip`, `netstat/ss`, and `lsof`.   The data link layer should be looked at next. Sometimes virtual local area networks are misconfigured or there can be wireless configuration issues.   Last, troubleshooting the Ethernet can be done with `ethtool` and `arp`, and by looking at the physical defects in cables as well as connectors.  

在大型组织中，故障排除通常涉及多个团队。网络工程可能拥有第一到第四层，而站点可靠性工程可能拥有第五到第七层。

### 工具

`tcpdump`用于转储网络流量。通过分析网络流量，您可以获得关于特定问题的大量信息。`tcpdump`是 Linux 上最有用的网络调试工具之一。Wireshark ( [`https://www.wireshark.org`](https://www.wireshark.org/) )也是一个用于捕获网络流量的图形用户界面应用程序。

当试图调试两个网络端点之间的连接问题时，可以使用`tcpdump`来分析它们之间的对话。清单 10-1 显示了由`tcpdump`捕获的三方 TCP 握手。

清单 10-1。三次 TCP 握手

`## SYN PACKET (1`<sup>`st`</sup>T2】

`10.1.1.1.58632 > 10.1.1.2.domain:``Flags [S]`T2】

`## SYN WITH ACK (2`<sup>`nd`</sup>T2】

`10.1.1.2.domain > 10.1.1.1.58632:``Flags [S.]``, cksum 0xa5f3 (correct), seq 1846955773,``ack`T4】

`#ACK (3`<sup>`rd`</sup>T2】

`10.1.1.1.58632 > 10.1.1.2.domain:``Flags [.]``, cksum 0x0cdd (correct),``ack`T4】

发起连接的源是 10.1.1.1。目的地是 10.1.1.2。第一步，信源发送一个`SYN`数据包。你可以分辨出这是一个`SYN`包，因为`SYN`标志被设置:`(Flags [S])`。在一个`TCP`包中，一个标志有 9 位。如果`SYN`位被置位，则该包是一个`SYN`包( [`https://en.wikipedia.org/wiki/Transmission_Control_Protocol`](https://en.wikipedia.org/wiki/Transmission_Control_Protocol) )。

第二个数据包是从目的地 10.1.1.2 到源 10.1.1.1。这也是一个`SYN`数据包，从`Flags [S.]`字段可以看出。此外，它还设置了`ACK`位，由`S`之后的周期指定。目的地正在确认来自源的第一个`SYN`数据包。

完成握手的第三个数据包是从 10.1.1.1 到 10.1.1.2 的`ACK`数据包，可以通过`Flags [.]`看到。

对于排除连接关闭故障，`tcpdump`也非常有用，如清单 10-2 所示。连接 10.1.1.1 发送一个`FIN`包；因为数据包是由 10.1.1.1 发送的，所以它被认为处于`ACTIVE CLOSE`状态。数据包包含`ACK`的原因是因为它正在确认来自 10.1.1.2 的前一个数据包。第二分组由目的地 10.1.1.2 发送；它由一个`FIN`数据包组成，并包含由 10.1.1.1 发送的对`FIN`的 ACK。在目的地，端口被认为处于`PASSIVE CLOSE`状态。主机 10.1.1.1 然后确认由 10.1.1.2 发送的`FIN`包，并且连接被关闭。

清单 10-2。关闭 TCP 连接

`#FIN WITH ACK`

`10.1.1.1.58632 > 10.1.1.2.domain:``Flags [F.]`T2】

`#FIN WITH ACK`

`10.1.1.2.domain > 10.1.1.1.58632:``Flags [F.]`T2】

`#ACK`

`10.1.1.1.58632 > 10.1.1.2.domain:``Flags [.]`T2】

#### 以太网帧

以太网帧是有线网络最基本的组成部分。媒体访问控制(MAC)地址是分配给使用以太网的设备的唯一标识符。

MAC 地址是 48 位；24 位是电气和电子工程师协会分配的组织唯一标识符。只要保持唯一性，其他 24 位可以由组织自己分配。您可以在 [`http://standards.ieee.org/develop/regauth/oui/public.html`](http://standards.ieee.org/develop/regauth/oui/public.html) 搜索分配的组织唯一标识符。例如，苹果拥有 28:cf:e9。

除了源和目的 MAC 地址这一显而易见的字段之外，以太网帧还包含另一个在排除网络故障时很有用的重要字段:`EtherType`字段。该字段描述封装在以太网帧有效载荷中的数据包的协议。对于 IP 数据包，最常见的类型是 0x800。您可以在 [`https://en.wikipedia.org/wiki/EtherType`](https://en.wikipedia.org/wiki/EtherType) 找到更多关于可以封装的不同类型协议的信息。图 [10-1](#Fig1) 显示了一个以太网类型 II 帧( [`https://en.wikipedia.org/wiki/Ethernet_frame#mediaviewer/File:Ethernet_Type_II_Frame_format.svg`](https://en.wikipedia.org/wiki/Ethernet_frame#mediaviewer/File:Ethernet_Type_II_Frame_format.svg) )。

![A978-1-4842-0511-2_10_Fig1_HTML.jpg](A978-1-4842-0511-2_10_Fig1_HTML.jpg)

图 10-1。

An Ethernet frame

网络设备使用地址解析协议(ARP)来确定需要与之通信的另一台设备的 MAC 地址。清单 10-3 显示了网络上的 ARP 广播。在清单中，10.1.1.50 是寻找 10.1.1.40 的主机的 IP 地址，因此它发送一个广播 ARP 数据包。目的地 10.1.1.40 收到数据包后，会用其 MAC 地址做出响应。

清单 10-3。ARP 广播

`# tcpdump -c 1 broadcast`

`22:10:52.140086 ARP, Request who-has 10.1.1.50 tell 10.1.1.40, length 46`

`# arp -a`

`www.example.com` `(10.1.1.40) at 00:12:f2:9a:17:00 [ether] on eth0`

有关以太网的更多信息，请访问

*   [T2`https://standards.ieee.org/develop/regauth/tut/eui.pdf`](https://standards.ieee.org/develop/regauth/tut/eui.pdf)
*   [T2`https://en.wikipedia.org/wiki/Address_Resolution_Protocol`](https://en.wikipedia.org/wiki/Address_Resolution_Protocol)

#### IP 数据包

为了有效地排除网络故障，您首先必须了解网络的组成部分。图 [10-2](#Fig2) 显示了一个 IPv4 包( [`http://courses.oreillyschool.com/sysadmin5/Tcpdump_Intro.html`](http://courses.oreillyschool.com/sysadmin5/Tcpdump_Intro.html) )。

![A978-1-4842-0511-2_10_Fig2_HTML.jpg](A978-1-4842-0511-2_10_Fig2_HTML.jpg)

图 10-2。

IPv4 packet (IPv6 packets are significantly different)

IP 包是互联网的基础，也是几乎所有其他网络的基础。除了明显的源和目的 IP 地址，另一个要跟踪的重要字段是生存时间(`TTL`)字段。当数据包的`TTL`到期时，它将被丢弃。对 IP 数据包进行故障排除应该包括跟踪`TTL`字段。

`protocol`字段指定下一级协议。您可以在 [`https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml`](https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml) 查看所有协议列表。对于 TCP 数据包，协议字段的值为`6`。

`flags`字段指定数据包是否被分段。位 1 表示不分段；第 2 位表示该数据包之后还有更多碎片数据包。

#### TCP 数据包

熟悉 TCP 数据包的格式会使故障排除变得容易得多。TCP 数据包是 HTTP 和 SSH 等协议的基础。图 [10-3](#Fig3) 显示了一个带有 IP 报头的 TCP 数据包。当使用诸如`tcpdump`之类的工具时，您可以查看通过网络传输的 TCP 数据包。数据包中的一些重要字段如下:

*   源端口和目的端口
*   序列号和确认号
*   TCP 标志，如`ACK`、`SYN`和`FIN`

使用 TCP 数据包信息分析网络流量的一种方法是，确保在建立新连接时成功完成三次 TCP 握手，这在本章前面已经演示过。

当您捕获输出时，不同的 TCP 标志可以让您了解网络对话的位置。通过查看序列号和确认号，您可以确定网络上的延迟和带宽问题。TCP 窗口大小在解决延迟和带宽问题时也起着重要作用。TCP 窗口大小是根据发送和接收窗口动态调整的。与 TCP 相关联的端口号让您知道使用的是哪种协议。例如，安全外壳(SSH)使用端口 22；HTTP 使用端口 80，HTTPS 使用端口 443。使用源端口号和目的端口号，您可以判断出通过线路通信的两台网络设备之间是否存在任何连接问题。

![A978-1-4842-0511-2_10_Fig3_HTML.jpg](A978-1-4842-0511-2_10_Fig3_HTML.jpg)

图 10-3。

TCP Packet with IP header  ( [`https://upload.wikimedia.org/wikipedia/commons/5/50/Ntwk_tcp_header.jpg`](https://upload.wikimedia.org/wikipedia/commons/5/50/Ntwk_tcp_header.jpg) )

## 网络服务

网络服务是监听特定端口的应用程序。安全外壳守护程序(SSHD)是一种提供 SSH 登录功能的网络服务。站点可靠性工程师会遇到与网络服务相关的问题，并且应该知道如何解决这些问题。清单 10-4 提供了一个排除 SSHD 服务故障的例子。清单中的步骤也有解释。

*   步骤 1:确定服务正在监听哪个端口。要找出服务的端口号，请查看`/etc/services`文件。因为您正在排除 SSH 故障，所以您可以在`/etc/services`中“`grep ssh`”。这个动作表明 SSH 正在监听端口 22。
*   步骤 2:使用`netstat`命令判断 SSHD 是否真的在监听它应该连接的端口。在清单 10-4 中，你可以看到 SSHD 正在监听 0.0.0.0:22，这意味着所有的接口。`-n`要求`netstat`只显示数字 IP，`-l`只显示监听套接字，`-p`显示附加到套接字的进程 ID (PID)。您也可以使用`ss`命令显示类似的输出。
*   第三步:使用`pgrep`确认 PID，如`netstat`命令所示。最后一列中的`netstat`命令显示进程 2106 正在运行 SSHD。属于 SSH 的其他 PID 是为不同的 SSH 连接生成的 SSH 进程。
*   `Step 4:`使用`lsof`查看 PID 2106 打开了哪些套接字，确认了 IPv4 和 IPv6 套接字打开并监听端口 22。
*   步骤 6:从另一台主机，使用`nc`通过 TCP 连接到端口 22。根据`nc`命令的输出，您可以断定您能够成功连接。尝试这样做的原因是，当防火墙阻止服务时，它仍在侦听，但不允许传入连接。

因为所有的六个步骤都起作用了，所以您可以断定服务正在运行和侦听，并且没有防火墙阻止连接。下一步是使用`ssh`命令，确定连接是否正常工作，或者是否出现错误。

清单 10-4。SSHD 故障排除

`#STEP 1`

`# egrep -i '^ssh ' /etc/services`

`ssh             22/tcp                          # The Secure Shell (SSH) Protocol`

`ssh             22/udp                          # The Secure Shell (SSH) Protocol`

`ssh             22/sctp                         # SSH`

`#STEP 2`

`# netstat -nlp | grep -i ssh`

`tcp        0      0 0.0.0.0:22                  0.0.0.0:*          LISTEN      2106/sshd`

`tcp        0      0 :::22                       :::*               LISTEN      2106/sshd`

`# ss -nlp | grep -i ssh`

`LISTEN     0      128            *:22                       *:*      users:(("sshd",2106,5))`

`#STEP 3`

`# pgrep -l ssh`

`2106 sshd`

`13048 sshd`

`13050 sshd`

`17947 sshd`

`17949 sshd`

`#STEP 4`

`# lsof -p 2106 | grep LISTEN`

`sshd    2106 root    3u  IPv4  13932      0t0     TCP *:ssh (LISTEN)`

`sshd    2106 root    4u  IPv6  13934      0t0     TCP *:ssh (LISTEN)`

`#STEP 5`

`$ nc -z``www.example.com`T2】

连接`www.example.com`端口 22【TCP/ssh】成功！

## 中央处理器

CPU 瓶颈会给应用程序带来很大的麻烦。在过去，对称多处理(SMP)非常流行。它意味着处理器对内存的平等访问。因为每个系统没有很多处理器插槽，所以 SMP 工作得很好。现代系统有许多处理器，所以 SMP 可能成为瓶颈。现代系统不使用 SMP，而是使用非均匀内存访问(NUMA)。NUMA 体系结构的每个处理器都有一组内存，这样可以加快内存访问速度，减少争用。因为内存组离 CPU 更近，所以访问速度更快。因为您可以尝试减少 CPU 访问其自身存储体之外的内存的需求，所以争用会更少。图 [10-4](#Fig4) 显示了 NUMA 与 SMP 的对比。

![A978-1-4842-0511-2_10_Fig4_HTML.jpg](A978-1-4842-0511-2_10_Fig4_HTML.jpg)

图 10-4。

.NUMA versus SMP

在 RedHat/CentOS 系统上，有一个名为`numad`的用户级守护进程，它试图为 CPU 有效地分配内存。要查看每个节点的命中和未命中次数，有一个非常有用的命令叫做`numastat. numa_hit`，它是处理器节点能够在自己的内存库中找到所需内容的次数。这个数字越大越好。`numa_miss`是节点的本地内存没有包含所需数据的次数。对于每一个`numa_miss`，在另一个节点上都有一个对应的`numa_foreign`。如清单 10-5 所示，对于`node0`，`numa_miss`值和`node1 numa_foreign`值是一样的，正如所料。如果您看到大量的`numa_miss`值，那么`numad`可能没有运行。

清单 10-5。`numastat`

`# numastat -s`

`node0           node1`

`numa_hit              1372185763       967156789`

`numa_miss               41539199        18158406`

`numa_foreign            18158406        41539199`

`interleave_hit             74145           66562`

`local_node            1370279665       959977346`

`other_node              43445297        25337849`

`## Ensure that numad is configured to run on start`

`# chkconfig numad --list`

`numad                  0:off        1:off        2:on        3:on        4:on        5:on        6:off`

要有效地使用 NUMA，您有三种选择:

Enable `numad` and let it manage your NUMA architecture.   Use the `taskset` command to assign affinity to processes.   Use `numalib` when writing your program to take advantage of NUMA.  

## 处理

Unix 中的进程由以下组件组成:

*   堆栈:连续内存地址空间的单个区域
*   文本:程序源代码
*   数据:程序的所有输入
*   堆:存储文件、锁和套接字的内存

线程是轻量级进程；它们有自己独特的堆栈，但是在其他线程之间共享文本、数据和堆。`/proc`伪文件系统有大量关于正在运行的进程的信息。清单 10-6 展示了一些可以在`/proc`中找到的有用的东西。在清单中，您可以看到两个进程:一个进程 id (PID)为 1，另一个进程的 PID 为 1766。PID 1 是`init`，是 Linux 中的第一个进程。在清单 10-6 中，PID 1766 是`rsyslog`。在 Linux 中，每个进程都有一个唯一的 PID。在`/proc. systemd` ( [`http://en.wikipedia.org/wiki/Systemd`](http://en.wikipedia.org/wiki/Systemd) )下每个 PID 都有一个目录，在较新版本的 Linux 中取代`init`成为 PID 1。

Linux 中的进程是从一个环境开始的。能够查看进程正在使用的环境有助于故障排除。例如，PATH 变量可以让我们知道进程在哪里寻找它需要的命令。查看`init`进程环境，我们看到三个变量:一个是`HOME`，另一个是`TERM`，最后一个是`PATH. tr`格式化输出以便于阅读。

清单 10-6。使用`/proc`文件系统

`# (cat /proc/1/environ; echo) | tr '\000' '\n'`

`HOME=/`

`TERM=linux`

`PATH=/sbin:/bin:/usr/sbin:/usr/` `bin`

每次打开一个文件，都会有一个与之相关的文件描述符。通过查看进程打开的文件描述符，我们可以找出文件和文件系统的问题。PID 1766 是`rsyslog`，我们可以看到它打开了各种日志文件。

`# ls -l 1766/fd`

`total 0`

`lrwx------ 1 root root 64 Oct  3 12:24 0 -> socket:[12975]`

`l-wx------ 1 root root 64 Oct  3 12:24 1 -> /var/log/messages`

`l-wx------ 1 root root 64 Oct  3 12:24 2 -> /var/log/cron`

`lr-x------ 1 root root 64 Oct  3 12:24 3 -> /proc/kmsg`

`l-wx------ 1 root root 64 Oct  3 12:24 4 -> /var/log/secure`

`l-wx------ 1 root root 64 Oct  3 12:24 5 -> /var/log/maillog`

Linux 中的用户和进程对他们可以消耗的资源有限制。有时，进程会达到这些限制并停止运行。重要的是能够看到极限并弄清楚它们是什么。大多数限制可以通过编辑`/etc/security/limits.conf`文件来修复。粗体字的极限比其他极限更常见。

`# cat 1766/limits`

`Limit                     Soft Limit           Hard Limit           Units`

`Max cpu time              unlimited            unlimited            seconds`

`Max file size             unlimited            unlimited            bytes`

`Max data size             unlimited            unlimited            bytes`

`Max stack size            10485760             unlimited            bytes`

`Max core file size        0                    unlimited            bytes`

`Max resident set          unlimited            unlimited            bytes`

`Max processes             127199               127199               processes`

`Max open files            1024                 4096                 files`

`Max locked memory         65536                65536                bytes`

`Max address space         unlimited            unlimited            bytes`

`Max file locks            unlimited            unlimited            locks`

`Max pending signals       127199               127199               signals`

`Max msgqueue size         819200               819200               bytes`

`Max nice priority         0                    0`

`Max realtime priority     0                    0`

`Max realtime timeout      unlimited            unlimited            us`

`Max core file size`与程序崩溃时内存转储的大小有关。保持这种限制是非常有用的，因为核心转储的非常大的程序会导致文件系统被填满。

`Max processes`对于多用户系统特别有用。它限制了一个用户可以创建的进程的数量，从而保护系统免受一个用户在多用户系统上意外创建的`fork`炸弹的影响。

`Max open files`限制一个进程可以打开的文件数量，或者一个用户可以打开的文件数量。设置此值可以防止进程或用户用文件填满文件系统。

`Max msgqueue size`对于使用消息队列的系统很有用，比如数据库。这个数字经常需要根据数据库供应商的建议进行调整。

命令行包括进程和命令行参数，也可以从`/proc`文件系统中查看。这有助于我们弄清楚在流程开始时给了它什么选项。

`# cat 1766/cmdline`

`/sbin/rsyslogd-i/var/run/syslogd.pid-c5`

/ `proc`中另一个有用的信息是流程可执行文件的链接。如果使用`ps`命令时看不到完整路径，检查`/proc/<pid>/exec`中的软链接。

`# ls -l 1/exe`

`lrwxrwxrwx 1 root root 0 Sep 30 14:03 1/exe -> /sbin/init`

`statm`列出内存使用统计。乍一看，它们是神秘的；但是，它们是针对特定指标的。尺寸以页为单位。应该考虑页面大小本身来计算整个程序和其他数字的正确大小。

`# cat 1766/statm`

`62385 1326 209 89 0 57069 0`

`# Explanation of the numbers as seen by statm`

`total program size -> 62385`

`resident -> 1326`

`share -> 209`

`text -> 89`

`lib -> 0 (unused)`

`data -> 57069`

`dirty pages -> 0 (unused)`

在对应用程序进行故障排除时,`status`文件也非常有用。在我们的`rsyslogd`示例中，我们可以看到进程正在休眠，如`State`行所示。此外，我们可以了解虚拟内存使用的峰值，包括物理内存和交换内存，为 314MB。我们还可以获得有关该进程接收到的不同信号的有用信息。需要跟踪的另一个重要字段是`nonvoluntary_ctxt_switches`。该字段指定了 CPU 必须将其周期从进程中转移出去的次数。这里的大量数据可能需要进一步调查。

`# cat /proc/1766/status`

`Name:        rsyslogd`

`State:        S (sleeping)`

`Tgid:        1766`

`Pid:        1766`

`PPid:       1`

`TracerPid:     0`

`Uid:      0    0      0      0`

`Gid:      0    0      0      0`

`Utrace:        0`

`FDSize:        64`

`Groups:`

`VmPeak:         314688 kB`

`VmSize:         249540 kB`

`VmLck:         0 kB`

`VmHWM:      5320 kB`

`VmRSS:      5304 kB`

`VmData:   228120 kB`

`VmStk:       156 kB`

`VmExe:       356 kB`

`VmLib:      2360 kB`

`VmPTE:        88 kB`

`VmSwap:              0 kB`

`Threads:       4`

`SigQ:        2/127199`

`SigPnd:       0000000000000000`

`ShdPnd:       0000000000000000`

`SigBlk:       0000000000000000`

`SigIgn:       0000000001001206`

`SigCgt:       0000000180114c21`

`CapInh:       0000000000000000`

`CapPrm:       ffffffffffffffff`

`CapEff:       ffffffffffffffff`

`CapBnd:       ffffffffffffffff`

`Cpus_allowed: ff`

`Cpus_allowed_list:        0-7`

`Mems_allowed:        00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000001`

`Mems_allowed_list:        0`

`voluntary_ctxt_switches:        64`

`nonvoluntary_ctxt_switches:        0`

除了获取每个进程的信息之外，`/proc`文件系统的另一个用途是获取一般的系统信息。为了找出系统的所有挂载，我们可以使用`cat /proc/mounts`，它显示了不同挂载点上的选项。

`# cat /proc/mounts | head -5`

`rootfs / rootfs rw 0 0`

`proc /proc proc rw,relatime 0 0`

`sysfs /sys sysfs rw,relatime 0 0`

`devtmpfs /dev devtmpfs rw,relatime,size=8140740k,nr_inodes=2035185,mode=755 0 0`

`devpts /dev/pts devpts rw,relatime,gid=5,mode=620,ptmxmode=000 0 0`

更多参考，请参见 [`http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html`](http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html) 。

### 了解 ps

要排除进程故障，`ps`命令非常方便。清单 10-7 显示了一些有用的`ps`选项。弄清楚一个进程已经运行了多长时间有助于解决内存耗尽问题。如果您有一个进程的多个实例在运行，那么基于 PID 的排序可以用来判断哪个进程首先启动。你也可以按开始时间排序来解决这个问题。

清单 10-7。使用`ps`对流程进行故障排除

`# Figure out how long a process has been running. In this case, it's init and rsyslog`

`$ ps -eo pid,cmd,etime | egrep -E 'init|rsyslog'`

`1 /sbin/init                  45-13:00:59`

`1766 /sbin/rsyslogd -i /var/run/ 45-12:52:42`

`10419 egrep -E init|rsyslog             00:01`

`# Sort based on process id`

`$ ps kpid -ef | head -5`

`UID        PID  PPID  C STIME TTY      STAT   TIME CMD`

`root         1     0  0 Aug18 ?        Ss     0:08 /sbin/init`

`root         2     0  0 Aug18 ?        S      0:00 [kthreadd]`

`root         3     2  0 Aug18 ?        S      0:01 [migration/0]`

`root         4     2  0 Aug18 ?        S      0:40 [ksoftirqd/0]`

`# Sort based on start time of process`

`$ ps kstart_time -ef | head -5`

`UID        PID  PPID  C STIME TTY      STAT   TIME CMD`

`root         1     0  0 Aug18 ?        Ss     0:08 /sbin/init`

`root         2     0  0 Aug18 ?        S      0:00 [kthreadd]`

`root         3     2  0 Aug18 ?        S      0:01 [migration/0]`

`root         4     2  0 Aug18 ?        S      0:40 [ksoftirqd/0]`

## 唱片

当应用程序或 Linux 服务器遇到输入/输出(I/O)问题时，可以从以下几个方面着手:

*   磁盘性能
*   文件系统调整
*   廉价磁盘冗余阵列(RAID)类型
*   贮藏

磁盘类型对磁盘 I/O 有影响。在找出磁盘瓶颈时非常有用的几个命令包括`iostat`和`iotop`。

`iostat`首次运行时显示自上次启动以来的值。此后，每个下一个值都是自上次运行以来的值。要想知道哪个设备正忙，可以查看每秒的传输量，或`tsp`值。之后，查看`Blk_read`和`Blk_wrtn`值，它们分别表示每秒读取或写入的数据量，单位为块。每个块是 512 字节。

在`iostat`的输出中，一个更重要的值是`iowait`。这是 CPU 等待块设备(如磁盘)的时间。如果这个数字很大，那么系统上的进程正在等待磁盘 I/O，您应该考虑获得一个更快的磁盘子系统。

另一个需要关注的值是“窃取”百分比。这表示虚拟机管理程序从一台虚拟机窃取 CPU 周期以提供给另一台虚拟机的时间。如果这个数字很大，那么您有太多的虚拟机运行在一个虚拟机管理程序上，您需要将一些虚拟机移动到另一个虚拟机管理程序。清单 10-8 显示了一个`iostat`输出的例子。

清单 10-8。`iostat`

`# iostat`

`avg-cpu:  %user   %nice %system %iowait  %steal   %idle`

`0.88    0.01    0.19    0.01    0.00   98.92`

`Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn`

`sda               0.29         1.16         5.52     570626    2704192`

`dm-0              0.09         0.68         0.32     333948     158440`

`dm-1              0.00         0.01         0.00       2576          0`

`dm-2              0.65         0.40         5.19     197626    2544776`

`dm-3              0.00         0.02         0.00      11834        912`

`avg-cpu:  %user   %nice %system %iowait  %steal   %idle`

`22.55    0.00   76.47    0.98    0.00    0.00`

`Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn`

`sda               7.84         0.00      5498.04          0       5608`

`dm-0            687.25         0.00      5498.04          0       5608`

`dm-1              0.00         0.00         0.00          0          0`

`dm-2              0.00         0.00         0.00          0          0`

`dm-3              0.00         0.00         0.00          0          0`

`avg-cpu:  %user   %nice %system %iowait  %steal   %idle`

`6.86    0.00   93.14    0.00    0.00    0.00`

`Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn`

`sda            1210.78         0.00    928674.51          0     947248`

`dm-0         120155.88         0.00    961247.06          0     980472`

`dm-1              0.00         0.00         0.00          0          0`

`dm-2              0.00         0.00         0.00          0          0`

`dm-3              0.00         0.00         0.00          0          0`

对系统上的磁盘进行故障诊断时，必须将分区的通用唯一标识符(UUID)映射到分区名。`blkid`命令显示了 UUID 和分区之间的关系，如清单 10-9 所示。还显示了`lsblk`命令，它给出了磁盘分区的良好树形结构，从而帮助您解决与磁盘相关的问题。

清单 10-9。Linux 分区 UUID

`# blkid`

`/dev/loop0: LABEL="CentOS_6.4_Final" TYPE="iso9660"`

`/dev/sda1: SEC_TYPE="msdos" UUID="0D0B-EDD2" TYPE="vfat"`

`/dev/sda2: UUID="2494e765-1e20-47e2-a068-d2165e9d6863" TYPE="ext4"`

`/dev/sda3: UUID="qkXEix-y7nX-KfTD-zGQz-QBgE-f9Uu-0xYO2K" TYPE="LVM2_member"`

`/dev/sda4: UUID="18PFqD-P7kz-lnzG-4kUe-gL6C-dIer-ShYeVa" TYPE="LVM2_member"`

`/dev/mapper/vg_hv1-lv_swap: UUID="32a60536-ae0d-4d5b-ac04-2b721e9abee5" TYPE="swap"`

`/dev/mapper/vg_hv1-lv_root: UUID="7b51a9fa-2514-4c76-b91c-ddb91c336315" TYPE="ext4"`

`/dev/mapper/vg_hv1-lv_var: UUID="19750d8a-ccf0-4196-a6c2-be7678985cf0" TYPE="ext4"`

`/dev/mapper/vg_hv1-lv_home: UUID="20e57eef-1be8-4be2-b9a7-aac90ed979c9" TYPE="ext4"`

`/dev/mapper/vg_hv1-lv_tmp: UUID="0dd34d7a-8749-4c7e-9163-ea78c278cf1d" TYPE="ext4"`

`# lsblk`

`NAME                       MAJ:MIN   RM    SIZE  RO  TYPE MOUNTPOINT`

`loop0                           7:0    0    4.1G   0  loop /mnt/CentOS6.4`

`sda                             8:0    0    931G   0  disk`

■t0]

■t0]

■t0]

──ζ〔t0〕

──ζ〔t0〕

──ζ〔t0〕

──ζ〔t0〕

──t0〕

ε〔t0〕

■t0]

`sr0                           11:0     1   1024M   0  rom`

## 文件系统

要解决文件系统问题，您首先需要了解磁盘的几何结构以及如何在磁盘上创建文件系统。磁盘有盘片，是双面的。每个盘片上都有同心圆，称为轨道。轨道被分成扇区。每个扇区通常是 512 字节。柱面是盘片所有表面上对应的一组磁道。清单 10-10 显示了一个磁盘的例子。

清单 10-10。磁盘分区

`# parted`

`GNU Parted 2.1`

`Using /dev/sda`

`Welcome to GNU Parted! Type 'help' to view a list of commands.`

`(parted) unit mb print`

`Model: Dell Virtual Disk (scsi)`

`Disk /dev/sda: 999654MB`

`Sector size (logical/physical): 512B/512B`

`Partition Table: gpt`

`Number  Start     End       Size      File system  Name     Flags`

`1      1.05MB    211MB     210MB     fat16                 boot`

`2      211MB     840MB     629MB     ext4`

`3      840MB     210555MB  209715MB                        lvm`

`4      210555MB  600000MB  389445MB               bigdisk`

更多信息，请参见 [`http://kias.dyndns.org/comath/42.html`](http://kias.dyndns.org/comath/42.html) 。

### 提前阅读

更改预读值有助于加快文件系统的读取速度。预读通过预取数据并将其加载到页面缓存中来加速文件访问。默认大小是 1024，您可以增加这个值来加快文件读取速度，如清单 10-11 所示。

清单 10-11。启用预读

`# blockdev --getra  /dev/sda`

`1024`

`# blockdev --setra 2048 /dev/sda`

`# blockdev --getra  /dev/sda`

`2048`

#### 标杆管理

为了防止应用程序磁盘 I/O 出现问题，一种可能的方法是找出应用程序的磁盘 I/O 需求，然后使用基准测试工具测试各种存储子系统。该策略支持正确的应用程序部署。一些可用于存储子系统基准测试的工具包括:

*   Iozone ( [`http://www.iozone.org/`](http://www.iozone.org/)
*   hdpar([`http://linux.die.net/man/8/hdparm`](http://linux.die.net/man/8/hdparm)

## 袭击

对磁盘问题进行故障排除时，理解 RAID 非常重要。RAID 有很多等级；一些常见的问题包括:

*   RAID 0:跨磁盘剥离数据。没有冗余或容错。这样做的好处是，由于多次读取和写入，性能得到了提高。
*   RAID 1:镜像数据，无需条带化或奇偶校验计算。至少有两个驱动器；如果其中一个失败，您仍然可以访问您的数据
*   RAID 5:具有分布式奇偶校验的块级条带化。奇偶校验分布在驱动器之间。该级别至少需要三个磁盘。丢失一个驱动器会导致性能下降。
*   RAID 6:具有双重分布式奇偶校验的块级条带化。这种策略允许两个驱动器出现故障。
*   RAID 1+0:先镜像再剥离。该级别至少需要四个磁盘。
*   RAID 0+1:分条，然后镜像。这一级别至少需要四个驱动器。

对硬件磁盘问题进行故障诊断时，您应该知道正在使用哪个 RAID 级别(如果有的话)。其原因是，当一个或多个驱动器出现故障时，某些 RAID 级别会以降级模式运行，而其他 RAID 级别即使有一个驱动器出现故障也会完全失效。作为初始设计和实施一部分，最好保留一个备用 RAID 驱动器，以便在 RAID 驱动器出现故障时使用。大多数 RAID 控制器开始用备用驱动器自动构建故障驱动器。在 RAID 卷重建期间，性能通常会降低。磁盘越大，重建逻辑 RAID 卷所需的时间就越长。

有关 RAID 的更多信息，请访问

*   [T2`https://en.wikipedia.org/wiki/RAID`](https://en.wikipedia.org/wiki/RAID)
*   突袭计算器( [`https://www.icc-usa.com/raid-calculator/`](https://www.icc-usa.com/raid-calculator/) `)`
*   RAID 等级教程( [`http://www.thegeekstuff.com/2010/08/raid-levels-tutorial/`](http://www.thegeekstuff.com/2010/08/raid-levels-tutorial/) )

## 记忆

内存是以称为页面的块来管理的，一般是 4096 字节；1MB 等于 256 页，1GB 等于 256，000 页。每个页面都通过一个页表条目来引用。页表条目位于 CPU 的内存管理单元中。

为了管理大内存，CentOS/RedHat 增加了页面大小，从而减少了页表条目的数量。在 RedHat/CentOS 6 中，默认的大页面大小是 2MB。对于具有 16GB 虚拟内存的系统，这相当于 8000 页。清单 10-12 显示了如何检查当前页面大小并增加它。要开始使用大页面，请根据您的内存需求将`/proc/sys/vm/nr_hugepages`的值设置为一个数字。例如，如果您的应用程序需要 4GB RAM，您可以将该值设置为 2000。

Note

RedHat 6 使用透明的 HugePages，即 THP，它不需要你设置巨大页面的值。因此，在清单 10-12 中，您可以看到`HugePages`的值是`0`。透明的`HugePages`在`AnonHugePages`设置中可见。

清单 10-12。增加页面大小

`# View Transparent HugePage information`

`$ cat /proc/meminfo | grep Huge`

`AnonHugePages:   3162112 kB`

`HugePages_Total:       0`

`HugePages_Free:        0`

`HugePages_Rsvd:        0`

`HugePages_Surp:        0`

`Hugepagesize:       2048 kB`

`# View number of huge pages reserved`

`$ cat /proc/sys/vm/nr_hugepages`

`0`

`# Check if transparent huge pages are used by default`

`$ cat /sys/kernel/mm/redhat_transparent_hugepage/enabled`

`[always] madvise never`

`# echo "2000" >> /proc/sys/vm/nr_hugepages`

`# cat /proc/sys/vm/nr_huge` `pages`

`2000`

评估任何应用程序的内存使用都应该是应用程序设计的一部分。内存的价格波动很大，购买昂贵的内存会导致企业的额外成本。应用程序内存不足的症状包括:

*   缓慢的性能
*   频繁的应用程序崩溃
*   不一致的性能
*   数据丢失

### 内存类型

Linux 内存可以分为以下几种类型:

*   物理的
*   交换
*   躲藏
*   减轻

物理内存由系统中的内存模块组成。交换是磁盘中用于内存的部分。缓存是指加载到物理内存中的文件，以加快磁盘访问速度。缓冲是指物理内存中加载的原始磁盘块。缓存和缓冲区都被释放回空闲内存池，供应用程序按需使用。要确定您的系统是否内存不足，以下工具很有用:

*   `free`
*   `vmstat`
*   `top`
*   `sar`

如果系统内存不足，会发生两种情况。一种是内核恐慌，系统崩溃。另一个原因是，为了防止内核崩溃，Linux 激活了内存不足(OOM)杀手。OOM 杀手杀死程序导致内存耗尽。这种策略可以防止内核恐慌。清单 10-13 是一个使用这些工具解决系统内存问题的例子。

使用`free`命令，我们首先检查系统上的可用内存。该系统有 1GB RAM，如 996 总大小所示。记忆也是通过查看`/proc/meminfo`来确认的；`MemTotal`字段显示 1GB 内存。请注意，18MB 被缓存，6MB 在缓冲区中。“真正的”空闲内存是 853MB，这是通过将`free`、`buffers`和`cached`的值相加得到的(828 + 6 + 18 = 852)。该系统没有交换内存，因此显示为 0。

清单 10-13。内存故障排除

`# free -` `m`

`total       used       free     shared    buffers     cached`

`Mem:           996        168        828          0          6         18`

`-/+ buffers/cache:        142        853`

`Swap:            0          0          0`

`# head -5 /proc/meminfo`

`MemTotal:        1020388 kB`

`MemFree:          848076 kB`

`Buffers:            6944 kB`

`Cached:            19176 kB`

`SwapCached:            0 kB`

让我们运行一个消耗一定内存量的程序，比如 300MB。

`##Consume 300MB of memory`

`# ./eatmemory 300M`

当我们在运行 300MB 程序后检查内存时，我们看到使用的内存从 168 增加到 473 (168 + 305)。注意，缓存和缓冲区保持不变，空闲的`-/+ buffers/cache`从 853 减少到 548。5MB 的区别是程序本身在运行。我们可以通过查看`/proc/meminfo`来确认空闲内存的减少，我们看到`MemFree`现在是 535MB 而不是 848MB。

`## Check free memory`

`# free -m`

`total       used       free     shared    buffers     cached`

`Mem:           996        473        523          0          6         18`

`-/+ buffers/cache:        447        548`

`Swap:            0          0          0`

`# head -10 /proc/meminfo`

`MemTotal:        1020388 kB`

`MemFree:          535072 kB`

`Buffers:            6960 kB`

`Cached:            19208 kB`

`SwapCached:            0 kB`

让我们通过增加 900MB 的使用量来尝试消耗比系统上更多的内存。一旦我们试图消耗更多的可用资源，OOM 就会启动并杀死我们的程序。当我们在内存消耗者被杀死后检查空闲内存时，`free`现在是 845MB。请注意，磁盘缓存已经从 18MB 减少到 6MB。内核已经把装载在内存中的磁盘缓存让给了我们的程序。缓冲器也是如此；它们从 6MB 降到了 1MB。

`# ./eatmemory 900M`

`Eating 943718400 bytes in chunks of 1024...`

`Killed`

`# free -m`

`total       used       free     shared    buffers     cached`

`Mem:           996        150        845          0          1          6`

`-/+ buffers/cache:        142        853`

`Swap:            0          0` `0`

如果我们查看`/var/log/messages`，我们会看到一条关于 Linux OOM killer 激活并杀死消耗内存的进程的消息。

`Sep 28 14:55:15 server kernel: eatmemory invoked oom-killer: gfp_mask=0x280da, order=0, oom_adj=0, oom_score_adj=0`

`Sep 28 14:55:15 server kernel: eatmemory cpuset=/ mems_allowed=0`

`Sep 28 14:55:15 server kernel: Pid: 27950, comm: eatmemory Not tainted 2.6.32-431.5.1.el6.x86_64 #1`

`Sep 28 14:55:15 server kernel: Call Trace:`

`Sep 28 14:55:15 server kernel: [<ffffffff810d05a1>] ? cpuset_print_task_mems_allowed+0x91/0xb0`

`Sep 28 14:55:15 server kernel: [<ffffffff81122950>] ? dump_header+0x90/0x1b0`

`...[SNIP]...`

`Sep 28 14:55:15 server kernel: [27830]    89 27830    20340      227   0       0             0 pickup`

`Sep 28 14:55:15 server kernel: [27950]     0 27950   206967   205992   0       0             0 eatmemory`

`Sep 28 14:55:15 server kernel: Out of memory: Kill process 27950 (eatmemory) score 779 or sacrifice child`

`Sep 28 14:55:15 server kernel: Killed process 27950, UID 0, (eatmemory) total-vm:827868kB, anon-rss:823932kB, file-rss:36kB`

如果我们在问题之前和之后检查`vmstat`，我们也可以将事件联系起来。在我们的内存消耗器启动之前，还有 865M 的空闲内存。在我们开始消耗内存后，`free`减少到 331MB。当我们开始消耗更多的内存时，`free`减少到 113MB，之后我们的进程被终止，`free`现在返回到 864MB。

`# vmstat 1`

`procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----`

`r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st`

`...[SNIP]...`

`0  0      0 865280   1824   7184    0    0     0    12  114  217  0  0 97  3   0`

`0  0      0 865280   1824   7188    0    0     0     0  110  206  0  0 100  0  0`

`0  0      0 857528   3328  11880    0    0  6172    16  309  694  1  1 82 16   0`

`0  0      0 857528   3328  11876    0    0     0     0  109  209  0  0 100  0  0`

`0  0      0 855984   3508  12476    0    0   780     0  213  516  1  1 94  4   0`

`0  0      0 855992   3508  12480    0    0     0     0  111  207  0  0 100  0  0`

`0  0      0 855992   3508  12480    0    0     0     0  108  206  0  0 100  0  0`

`0  0      0 856016   3508  12480    0    0     0     0  152  278  0  0 100  0  0`

`0  0      0 852744   3784  13820    0    0  1612    44  175  330  0  1 91  8   0`

`...[SNIP]...`

`0  0      0 852792   3860  13824    0    0     0     0  126  232  0  0 100  0  0`

`0  0      0 852792   3860  13824    0    0     0     0  116  213  0  0 100  0  0`

`./eatmemory 500M    <--- Start consuming memory; notice that free reduces to 331MB from 852MB.`

`procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----`

`r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st`

`0  0      0 331860   3860  13824    0    0    12     0  308  222  3 17 80   0  0`

`0  0      0 331860   3860  13836    0    0     0     0  111  210  0  0 100  0  0`

`0  0      0 331860   3860  13836    0    0     0     0  108  207  0  0 100  0  0`

`0  0      0 331860   3860  13836    0    0     0     4  111  212  0  0 100  0  0`

`...[SNIP]...`

`./eatmemory 900M    <---- Consume even more memory; free now reduces to 113MB from 331MB.`

`procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----`

`r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st`

`2  1      0 113420     80    924    0    0  1404    32  503 1079  8 30 63  0  0`

`OOM kicks in at this point and our process is killed, thereby releasing memory. free is back up to 864MB.`

`0  0      0 864684    432   5164    0    0  4000     0  205  684  0  3 97  0  0`

`0  0      0 864684    432   5156    0    0     0     0  111  211  0  0 100  0  0`

如果我们在几分钟后观察系统，我们会注意到缓冲区和缓存增加了。它们分别是 80MB 和 924MB，但是自从我们的进程被终止后，它们分别增加到了 5112MB 和 15，460MB。

`## After 10 minutes`

`# vmstat 1`

`procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----`

`r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st`

`0  0      0 850076   5112  15464    0    0     0     1    2    9  0  0 100 0  0`

`0  0      0 850068   5120  15460    0    0     0    12  119  216  0  0 98  2  0`

当`/proc`中`panci_on_oom`的值设置为`0`时，OOM killer 激活。这是默认值。如果您希望禁用 OOM，将该值更改为`1`。

`# cat /proc/sys/vm/panic_on_oom`

`0`

使用`sar`我们可以关联我们的发现。`sar`应显示与`vmsta` t 和`free`一致的输出。`sar`的一个警告是，默认情况下，它每十分钟报告一次数据。这意味着，如果我们的记忆增加和减少事件发生在十分钟内，我们就会错过它们。您可以使用 internal 和 count 选项从`sar`获得更细粒度的数据，如`sar <interval> <count>`所示。

`$ sar -r`

`09:20:01 AM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit`

`...[SNIP]...`

`12:50:01 PM    590372    430016     42.14     99288    172044    157856     15.47`

`01:00:01 PM    587620    432768     42.41     99304    172068    163948     16.07`

`01:10:01 PM    563184    457204     44.81     99652    192968    165464     16.22`

`# At this point we consume 300MB memory; notice kbbuffers goes from 99652 to 5172.`

`01:20:02 PM    854128    166260     16.29      5172     14820    173072     16.96`

`01:30:01 PM    854012    166376     16.31      5272     14820    173072     16.96`

`...[SNIP]...`

`# Now we run eatmemory with 900MB option, causing kbbuffers to go down even more; same with # kbcached`

`03:00:01 PM    860088    160300     15.71      2004      8136    181020     17.74`

`03:10:01 PM    858732    161656     15.84      2400      9180    181020     17.74`

`# Once the OOM kills the eatmemory process, both kbbuffers and kbcached start to increase`

`03:20:01 PM    849680    170708     16.73      5076     15312    181020     17.74`

#### 调优虚拟内存

虚拟内存可以定义为物理内存和交换空间。通常在虚拟内存中可以找到进程、文件系统缓存和内核。您可以通过以下方式控制虚拟内存:

*   交换性
*   `min_free_kbytes`
*   `dirty_ratio`
*   `dirty_background_ratio`
*   `drop_caches`

您可以使用`sysctl`实用程序或通过编辑`/etc/sysctl.conf`文件来修改内核参数。“交换性”是内核将进程交换到磁盘的趋势。该值可以设置在 0 到 100 之间，默认值为 60。将该值增加到 60 以上会导致内核主动交换不活动的进程。较低的值会导致内核将非活动进程保留在内存中更长时间。例如，如果您使用基于内核的虚拟机(KVM ),那么最好不要换出不活动的虚拟机，因为它们作为 Linux 进程在虚拟机管理程序上运行。因此，您可以选择将 swappiness 值从 60 减小到一个较小的数值。

您不能禁用 Linux 页面缓存(在`free`命令的缓存列中看到的值)。但是，您可以限制缓存值，以下是一些方法:

*   `vm.vfs_cache_pressure`(默认值= 100):控制内核回收内存的趋势。增加该值会使内核频繁回收缓存内存，从而减少页面缓存的大小。
*   `vm.dirty_background_ratio`(默认值= 20): Linux 通常使用一个名为`pdflush`的进程将数据写出页面缓存。这个数字表示系统内存的百分比，即`pdflush`开始写出脏数据的页数。减少该数字会导致`pdflush`更快地写出脏数据。`vm.dirty_ratio`(默认值= 40):表示进程写出它们自己的脏数据的内存页数的百分比。减少这个数字会导致进程更早地写出脏数据，从而限制页面缓存的大小。
*   `vm.dirty_expire_centisecs`(默认值= 3000，单位为毫秒):表示脏页的过期时间。减少这个数字使它们更有资格被`pdflush`写出。
*   `vm.swappiness`(默认值= 60):减少该数字会限制页面缓存大小。

关于 Linux 内存的更多信息，请访问

*   [T2`https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/s-memory-tunables.html`](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/s-memory-tunables.html)
*   [T2`https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Virtualization_Tuning_and_Optimization_Guide/sect-Virtualization_Tuning_Optimization_Guide-Memory-Huge_Pages.html`](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/6/html/Virtualization_Tuning_and_Optimization_Guide/sect-Virtualization_Tuning_Optimization_Guide-Memory-Huge_Pages.html)
*   [T2`https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Tuning_and_Optimizing_Red_Hat_Enterprise_Linux_for_Oracle_9i_and_10g_Databases/sect-Oracle_9i_and_10g_Tuning_Guide-Large_Memory_Optimization_Big_Pages_and_Huge_Pages-Configuring_Huge_Pages_in_Red_Hat_Enterprise_Linux_4_or_5.html`](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Tuning_and_Optimizing_Red_Hat_Enterprise_Linux_for_Oracle_9i_and_10g_Databases/sect-Oracle_9i_and_10g_Tuning_Guide-Large_Memory_Optimization_Big_Pages_and_Huge_Pages-Configuring_Huge_Pages_in_Red_Hat_Enterprise_Linux_4_or_5.html)
*   [T2`http://www.thomas-krenn.com/en/wiki/Linux_Performance_Measurements_using_vmstat`](http://www.thomas-krenn.com/en/wiki/Linux_Performance_Measurements_using_vmstat)

## 域名系统

调试域名系统(DNS)最重要的工具之一就是`dig`。在 BIND 服务器设置期间，以及之后，使用`dig`可以帮助找到许多问题的根源，并确保您的 DNS 服务器按预期工作。`dig`的用法一般是`dig @server name type`。如果没有指定服务器，`dig`在`/etc/resolv.conf`查看服务器。如果没有指定类型，`dig`查找`A`记录。清单 10-14 显示了如何使用`dig`来查找 DNS 记录。

清单 10-14。使用挖掘命令

`#query the A record of www.example.com`

`$ dig www.example.org`

`; <<>> DiG 9.8.2rc1-RedHat-9.8.2-0.23.rc1.el6_5.1 <<>> www.example.org`

`;; global options: +cmd`

`;; Got answer:`

`;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 28891`

`;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0`

`;; QUESTION SECTION:`

`;www.example.org.                IN        A`

`;; ANSWER SECTION:`

`www.example.org.        21599    IN        A        93.184.216.119`

`;; Query time: 43 msec`

`;; SERVER: 8.8.8.8#53(8.8.8.8)`

`;; WHEN: Tue Aug 26 22:55:38` `2014`

`;; MSG SIZE  rcvd:` `49`

通过`dig`显示大量对故障排除有用的信息。让我们回顾一些信息。首先，`dig`给出了我们正在使用的`dig`的版本；在这种情况下，它是 v9.8\. `dig`还列出了我们提供的选项，这就是`+cmd`。虽然我们没有明说`+cmd`，但这是隐含的。您也可以在`dig`命令行上指定`+nocmd`，它不会显示所使用的选项。

问题部分告诉你，你要的是`www.example.org`的`A`记录。同样，答案部分显示了所提问题的答案。

还显示了查询时间(在本例中为 43 毫秒)以及收到的消息大小。

您可以在您的`$HOME/.digrc`文件中为`dig`指定各种选项。设置好 DNS 服务器后，使用`dig`命令检查 DNS 服务器的响应。

如果您想获得没有所有调试信息的 DNS 记录，那么您可以使用`dig`的`+short`选项，它只返回答案，如清单 10-15 所示。

清单 10-15。挖掘选项

`#query the same A record; this time, just return the IP address`

`$ dig +short www.example.org`

`93.184.216.119`

`#find out the start of authority (SOA) for example.org`

`$  dig +short example.org soa`

`sns.dns.icann.org. noc.dns.icann.org. 2014080856 7200 3600 1209600 3600`

`#query the NS or name server record for example.org`

`$ dig +short example.org ns`

`b.iana-servers.net.`

`a.iana-servers.net.`

`#see if there is a TXT record for example.org`

`$ dig +short example.org txt`

`"v=spf1 -all"`

`"$Id: example.org 2783 2014-08-07 17:40:21Z mvergara $"`

`#look up the hostname for the given IP address`

`$ dig +short -x 74.125.239.51`

`nuq04s19-in-f19.1e100.net.`

`#find out the MX record for gmail.com`

`$ dig +short gmail.com mx`

`20 alt2.gmail-smtp-in.l.google.com.`

`30 alt3.gmail-smtp-in.l.google.com.`

`5 gmail-smtp-in.l.google.com.`

`10 alt1.gmail-smtp-in.l.google.com.`

`40 alt4.gmail-smtp-in.l.google.com.`

### 网络管理命令行工具

`nslookup`传统上用于调试 DNS 然而，`dig`已经成为`nslookup. nslookup`事实上的替代工具，也可以以类似于`dig`的方式使用，并且支持交互式查询。清单 10-16 显示了`nslookup`的基本用法。

清单 10-16。`nslookup`使用

`##`

`# By default 'nslookup' uses the name server in /etc/resolv.conf`

`$ nslookup`

`> server`

`Default server: 8.8.8.8`

`Address: 8.8.8.8#53`

`Default server: 8.8.4.4`

`Address: 8.8.4.4#53`

`>`[`www.yahoo.com`T3】](http://www.yahoo.com)

`Server:         8.8.8.8`

`Address:        8.8.8.8#53`

`# The reason this answer is nonauthoritative is because 8.8.4.4 is not the authority for yahoo.com.`

`Non-authoritative answer:`

[T0](http://www.yahoo.com)T1】

`Name:        fd-fp3.wg1.b.yahoo.com`

`Address: 206.190.36.45`

`Name:        fd-fp3.wg1.b.yahoo.com`

`Address: 206.190.36.105`

`# To get the 'mx' record, set the type to 'mx'`

`> set type=mx`

`> yahoo.com`

`Server:         8.8.8.8`

`Address:        8.8.8.8#53`

`Non-authoritative answer:`

`yahoo.com        mail exchanger = 1 mta7.am0.yahoodns.net.`

`yahoo.com        mail exchanger = 1 mta6.am0.yahoodns.net.`

`yahoo.com        mail exchanger = 1 mta5.am0.yahoodns.net.`

`> set type=soa`

`> yahoo.com`

`Server:         8.8.8.` `8`

`Address:        8.8.8.8#53`

`Non-authoritative answer:`

`yahoo.com`

`origin = ns1.yahoo.com`

`mail addr = hostmaster.yahoo-inc.com`

`serial = 2014092411`

`refresh = 3600`

`retry = 300`

`expire = 1814400`

`minimum = 600`

#### 绑定统计文件

可以将 BIND 配置为存储有关其性能的统计数据。要启用绑定统计，在`named.conf`文件中启用清单 10-17 所示的选项。

清单 10-17。绑定统计文件

`[ statistics-file path_name; ]`

`[ zone-statistics yes ; ]`

要让 BIND 转储统计数据，使用`rndc stat` s 命令，这将导致 BIND 创建由`path_name`定义的统计数据文件。对 BIND 进行故障排除时，查看统计文件非常有帮助。如果您需要弄清楚 BIND 服务器正在接收的查询的类型，您可以在统计文件中找到这些信息。此外，您可以使用统计信息来确定如何扩展绑定服务器。绑定统计信息可分为以下几个部分:

*   传入请求:传入服务器的请求总数
*   传入查询:按类型、`A`、`NS`、`SOA`等划分的请求
*   Outoging 查询:该绑定服务器进行的查询
*   名称服务器统计
*   区域维护统计
*   解析统计数据
*   缓存数据库资源记录集(数据库资源集)
*   套接字 I/O 统计
*   每个区域的查询统计

清单 10-18 显示了绑定统计文件的简要总结。统计信息是从 BIND 服务器启动时开始累积的。

清单 10-18。绑定统计输出

`+++ Statistics Dump +++ (1412550650)`

`++ Incoming Requests ++`

`2863814921 QUERY`

`6239 NOTIFY`

`++ Incoming Queries ++`

`2059811570 A`

`12 NS`

`9055 SOA`

`193324325 PTR`

`195930 MX`

`21 TXT`

`610472679 AAAA`

`1275 SRV`

`1 DS`

`1 DNSKEY`

`52 AXFR`

`...[SNIP]...`

## 动态主机配置协议

围绕 DHCP 故障排除的一些常见问题需要对协议本身有基本的了解。RFC 2131 ( [`https://www.ietf.org/rfc/rfc2131.txt`](https://www.ietf.org/rfc/rfc2131.txt) )中列出了 DHCP 涉及的各种报文。RFC 2132 ( [`https://www.ietf.org/rfc/rfc2132.txt`](https://www.ietf.org/rfc/rfc2132.txt) )中定义了各种选项和供应商扩展。一些消息如下:

*   `DHCPDISCOVER`
*   `DHCPOFFER`
*   `DHCPREQUEST`
*   `DHCPACK`
*   `DHCPNAK`
*   `DHCPDECLINE`
*   `DHCPRELEASE`
*   `DHCPINFORM`

当客户端被配置为使用 DHCP 时，它会发出一条`DHCPDISCOVER`消息。这是定位可用服务器的广播消息。因为它是广播的，所以它仅限于广播域，除非在路由器上启用了 IP 助手，将 DHCP 广播请求转发到适当的 DHCP 服务器。

服务器收到`DHCPDISCOVER`消息后，用`DHCPOFFER`响应，其中包含配置参数。然后，客户端使用`DHCPREQUEST`请求一个 DHCP IP。客户端确认服务器在请求中发送的参数。然后服务器向客户端发送`DHCPACK`，确认来自客户端的`DHCPREQUEST`。如果客户端的租约已经到期或者客户端在`DHCPREQUEST`中有一些不正确的参数，服务器发送`DHCPNAK`。如果客户端拒绝`DHCPOFFER`，它会将`DHCPDECLINE`发送给服务器，这可能是因为地址已经被使用。在客户端准备放弃 DHCP IP 地址之后，它发送一个`DHCPRELEASE`消息。`DHCPINFORM`也是客户端到服务器的消息，要求本地配置。

调试 DHCP 问题时，如果使用`tcpdump`查看网络流量，部分或全部消息将可见。清单 10-19 显示了如何解释 DHCP 流量。

使用`tcpdump`，我们捕获客户端和服务器之间的 DHCP 流量。DHCP 服务器为 10.1.1.10，MAC 地址为 00:50:56:bd:7d:21。DHCP 客户端的 MAC 地址为 00:50:56:bd:7f:f6，IP 地址为 10.1.1.50。我们使用的`tcpdump`选项是`-v`(冗余)、`-n`(不将 IP 转换为主机名)、`-e`(打印链接级报头)和`-s0`(来自每个打包器的 snarf 0 长度字节的数据，而不是默认的 65，535 字节)。我们正在为 DHCP 捕获端口 67 和 68 的流量。

最初，我们看到来自客户端的`DHCPDISCOVER`消息，如粗体所示。该消息的目的地址被广播。

清单 10-19。DHCP 对话

`# tcpdump -vnes0 -i eth0 port 67 or port 68`

`tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes`

`05:58:12.000470 00:50:56:bd:7f:f6 > Broadcast, ethertype IPv4 (0x0800), length 342: (tos 0x10, ttl 128, id 0, offset 0, flags [none], proto UDP (17), length 328)`

`0.0.0.0.bootpc > 255.255.255.255.bootps: BOOTP/DHCP, Request from 00:50:56:bd:7f:f6, length 300, xid 0xa033135f, Flags [none]`

`Client-Ethernet-Address 00:50:56:bd:7f:f6`

`Vendor-rfc1048 Extensions`

`Magic Cookie 0x63825363`

`DHCP-Message Option 53, length 1: Discover`

`Parameter-Request Option 55, length 13:`

`Subnet-Mask, BR, Time-Zone, Classless-Static-Route`

`Domain-Name, Domain-Name-Server, Hostname, YD`

`YS, NTP, MTU, Option 119`

`Default-Gateway`

然后，服务器用`DHCPOFFER`响应客户端，如粗体所示。

`05:58:13.001158 00:50:56:bd:7d:21 > 00:50:56:bd:7f:f6, ethertype IPv4 (0x0800), length 342: (tos 0x10, ttl 128, id 0, offset 0, flags [none], proto UDP (17), length 328)`

`10.1.1.10.bootps > 10.1.1.50.bootpc: BOOTP/DHCP, Reply, length 300, xid 0xa033135f, Flags [none]`

`Your-IP 10.1.1.50`

`Client-Ethernet-Address 00:50:56:bd:7f:f6`

`Vendor-rfc1048 Extensions`

`Magic Cookie 0x63825363`

`DHCP-Message Option 53, length 1: Offer`

`Server-ID Option 54, length 4: 10.1.1.10`

`Lease-Time Option 51, length 4: 600`

`Subnet-Mask Option 1, length 4: 255.255.255.0`

`BR Option 28, length 4: 172.24.81.255`

`Domain-Name Option 15, length 14: "example.com"`

`Domain-Name-Server Option 6, length 8: 172.24.0.7,172.24.0.8`

`Default-Gateway Option 3, length 4: 172.24.81.3`

第三步是客户端用`DHCPREQUEST`响应。

`05:58:13.001634 00:50:56:bd:7f:f6 > Broadcast, ethertype IPv4 (0x0800), length 342: (tos 0x10, ttl 128, id 0, offset 0, flags [none], proto UDP (17), length 328)`

`0.0.0.0.bootpc > 255.255.255.255.bootps: BOOTP/DHCP, Request from 00:50:56:bd:7f:f6, length 300, xid 0xa033135f, Flags [none]`

`Client-Ethernet-Address 00:50:56:bd:7f:f6`

`Vendor-rfc1048 Extensions`

`Magic Cookie 0x63825363`

`DHCP-Message Option 53, length 1: Request`

`Server-ID Option 54, length 4: 10.1.1.10`

`Requested-IP Option 50, length 4: 10.1.1.50`

`Parameter-Request Option 55, length 13:`

`Subnet-Mask, BR, Time-Zone, Classless-Static-Route`

`Domain-Name, Domain-Name-Server, Hostname, YD`

`YS, NTP, MTU, Option 119`

`Default-` `Gateway`

第四步是客户端用`DHCPACK`响应。

`05:58:13.003958 00:50:56:bd:7d:21 > 00:50:56:bd:7f:f6, ethertype IPv4 (0x0800), length 342: (tos 0x10, ttl 128, id 0, offset 0, flags [none], proto UDP (17), length 328)`

`10.1.1.10.bootps > 10.1.1.50.bootpc: BOOTP/DHCP, Reply, length 300, xid 0xa033135f, Flags [none]`

`Your-IP 10.1.1.50`

`Client-Ethernet-Address 00:50:56:bd:7f:f6`

`Vendor-rfc1048 Extensions`

`Magic Cookie 0x63825363`

`DHCP-Message Option 53, length 1: ACK`

`Server-ID Option 54, length 4: 10.1.1.10`

`Lease-Time Option 51, length 4: 600`

`Subnet-Mask Option 1, length 4: 255.255.255.0`

`BR Option 28, length 4: 172.24.81.255`

`Domain-Name Option 15, length 14: "example.com"`

`Domain-Name-Server Option 6, length 8: 172.24.0.7,172.24.0.8`

`Default-Gateway Option 3, length 4: 172.24.81.3`

## 结论

在本章中，我们讨论了 TCP/IP、CPU、磁盘、内存、DNS 和 DHCP 的故障排除。我们研究了许多工具，这些工具针对特定的主题，可用于调试您可能遇到的各种问题。以下是一些值得研究的附加工具:

*   Valgrind:用于内存分析( [`http://valgrind.org/`](http://valgrind.org/) )
*   OProfile:用于应用程序分析( [`http://oprofile.sourceforge.net/news/`](http://oprofile.sourceforge.net/news/) )
*   SystemTap:用于收集正在运行的系统的信息( [`https://sourceware.org/systemtap/`](https://sourceware.org/systemtap/) )
*   Perf:统计正在运行的程序( [`https://perf.wiki.kernel.org/index.php/Main_Page`](https://perf.wiki.kernel.org/index.php/Main_Page) )