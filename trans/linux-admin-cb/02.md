# 使用 SSH 进行远程管理

本章将介绍以下配方:

*   使用 ssh-keygen 生成和使用密钥对
*   SSH 客户端参数和选项
*   使用客户端 SSH 配置文件
*   修改服务器端 SSH 配置文件
*   旋转主机按键并更新`known_hosts`
*   使用本地转发
*   使用远程转发
*   代理跳转和堡垒主机
*   使用 SSH 创建一个 SOCKS 代理
*   理解和使用 SSH 代理
*   在一个盒子上运行多个 SSH 服务器

# 介绍

在第一章中，我们使用一个命令对虚拟机进行 SSH:

```sh
$ ssh adam@127.0.0.1 -p2222
adam@127.0.0.1's password: 
Last login: Mon Aug 6 17:04:31 2018 from gateway
[adam@localhost ~]$
```

在这一章中，我们将对此进行扩展，着眼于使用 SSH 密钥对使连接更加容易；运行 SSH 的安全优势；更改客户端和服务器端配置；设置端口转发和反向端口转发连接；了解 ProxyJump 和 bastion 主机，以及使用 SSH 设置临时代理；最后，我们将研究 SSH 代理，并在我们的虚拟机上设置一个额外的 SSH 服务器。

本章假设您对 SSH 有初步的了解。

# 技术要求

正如在第一章中介绍的，我们将在本章和以后的所有工作中使用游民和虚拟盒子。这使我们能够快速调配用于测试的基础架构，并为您节省了每次创建多个虚拟机的手动工作。

If you really, really, don't want to use VirtualBox or Vagrant, then you don't have to, and I've tried to keep the examples as generic as possible, but you will probably find it much easier if you do.

我整理了以下`Vagrantfile`供本章使用:

```sh
# -*- mode: ruby -*-
# vi: set ft=ruby :

$provisionScript = <<-SCRIPT
sed -i 's#PasswordAuthentication no#PasswordAuthentication yes#g' /etc/ssh/sshd_config
systemctl restart sshd
SCRIPT

Vagrant.configure("2") do |config|
 config.vm.provision "shell",
 inline: $provisionScript

 config.vm.define "centos1" do |centos1|
   centos1.vm.box = "centos/7"
   centos1.vm.network "private_network", ip: "192.168.33.10"
   centos1.vm.hostname = "centos1"
   centos1.vm.box_version = "1804.02"
 end

 config.vm.define "centos2" do |centos2|
   centos2.vm.box = "centos/7"
   centos2.vm.network "private_network", ip: "192.168.33.11"
   centos2.vm.hostname = "centos2"
   centos2.vm.box_version = "1804.02"
 end

 config.vm.define "centos3" do |centos3|
   centos3.vm.box = "centos/7"
   centos3.vm.network "private_network", ip: "192.168.33.12"
   centos3.vm.hostname = "centos3"
   centos3.vm.box_version = "1804.02"
 end
end
```

Note something new about this `Vagrantfile`. We've included a provision step, which runs the code assigned to the variable at the top of the file. In this case, we're making some changes to the SSH configuration of the default CentOS image, so our examples work as we expect. We've put all three VMs on their own private network.

最好创建一个名为`Chapter Two`的文件夹，并将这段代码复制到一个名为`Vagrantfile`的文件中，或者如果您使用的是 GitHub 中的代码，请导航到正确的文件夹。

从包含您的`Vagrantfile`的文件夹中运行`vagrant up`应该配置两个虚拟机进行测试。

配置完成后，请确保您可以通过运行以下命令连接到第一个:

```sh
$ vagrant ssh centos1
```

Vagrant is great for testing purposes, but you shouldn't use it in a production environment for deploying machines. Some of the decisions that are made are for ease of use (such as those around the default `vagrant` user in our image) and as a result, are not best practices for a secure deployment.

# 使用 ssh-keygen 生成和使用密钥对

密码很棒，但也很糟糕。

大多数人使用弱密码，虽然我希望不是你，但总有可能你的团队中有人没有你这样的纪律，求助于`football99`或类似的东西来连接到你的共享远程主机。

启用密码访问后，只要有足够的时间和足够的处理能力，任何人都可以通过暴力强行进入您的机器，从任何国家连接到您的服务器。

I say "might" because as long as you use secure passwords of a decent length, passwords can be hard to guess, even with the power of a sun. Consult your company security policy when deciding these things, or read up on the best practices at the time you're writing the policy yourself.

这是钥匙进来的地方。

SSH 密钥基于公钥密码的概念。它们分为两个部分:一个`public`部分和一个`private`部分，公共部分可以放在服务器上，私有部分可以放在笔记本电脑或安全 u 盘(本身是加密和密码保护的)上。

Despite the obvious suggestion of public and private half, I have frequently seen people misunderstand this concept and share their private half instead of the public one. This generally results in the key being labelled as compromised, and the individual in question being asked to generate a new pair, with a short chat about the definition of `private` and `public` in the meantime.

一旦您的密钥的公共部分在您的服务器上，您就可以使用您的密钥的本地、私有部分来进行身份验证。

SSH 密钥甚至可以提供一定程度的便利，因为大多数操作系统都带有某种钥匙串，可以在用户登录时自动解锁，并且可以安全地存储密钥的私有部分。然后，对机器的 SSH 就变成了一件微不足道的事情，在这里你可以安全地连接而不需要任何提示！

我们将生成一个 SSH 密钥对，并使用该密钥对在我们的机器之间进行 SSH。

# 准备好

首先，确保两个虚拟机之间配置了专用网络。

您可以使用*技术要求*部分的`Vagrantfile`来完成此操作。

连接到您的第一台机器:

```sh
$ vagrant ssh centos1
```

使用 [第 1 章](01.html)*简介和环境设置*中的命令`ip a`，检查`centos1`的 IP 地址配置是否正确。

我们预计是`192.168.33.10`，在`eth1`设备下:

```sh
[vagrant@centos1 ~]$ ip a
<SNIP>
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
 link/ether 08:00:27:ac:f2:12 brd ff:ff:ff:ff:ff:ff
 inet 192.168.33.10/24 brd 192.168.33.255 scope global noprefixroute eth1
 valid_lft forever preferred_lft forever
 inet6 fe80::a00:27ff:feac:f212/64 scope link 
 valid_lft forever preferred_lft forever
```

您也可以使用`hostname -I`获取一个盒子的 IP 地址，如下图所示，但是您应该注意，您不会得到一个明显的接口名称:

```sh
$ hostname -I
10.0.2.15 192.168.33.10
```

检查您是否可以从`centos1`内 ping 通`centos2`的 IP 地址。

我们将第二个 IP 设置为`192.168.33.11`:

```sh
$ ping 192.168.33.11
PING 192.168.33.11 (192.168.33.11) 56(84) bytes of data.
64 bytes from 192.168.33.11: icmp_seq=1 ttl=64 time=1.17 ms
64 bytes from 192.168.33.11: icmp_seq=2 ttl=64 time=0.997 ms
64 bytes from 192.168.33.11: icmp_seq=3 ttl=64 time=1.18 ms
```

我们的虚拟机之间有网络连接！

If you're unable to ping between machines, start by checking your network settings within VirtualBox, and connect to each of your machines using the `vagrant ssh` command to check the assigned IP address.

# 怎么做...

我们将使用两种类型的密钥来检查生成密钥并将其复制到远程主机的步骤。

首先，我们将生成一个更传统的**Rivest-Shamir-Adleman**(**RSA**)密钥，然后我们将生成一个更新类型的密钥，`Ed25519`密钥。

# RSA 示例

首先，我们将生成密钥，确认保存密钥的默认位置，并在出现提示时提供密码:

```sh
$ ssh-keygen -b 4096 -C "Example RSA Key"
Generating public/private rsa key pair.
Enter file in which to save the key (/home/vagrant/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/vagrant/.ssh/id_rsa.
Your public key has been saved in /home/vagrant/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:hAUNhTqXtfnBOkXMuIpxkvtTkM6NYRYxRbT5QWSVbOk Example RSA Key
The key's randomart image is:
+---[RSA 4096]----+
|      =@*=+o.o   |
|      o++=+ =    |
|     o.=+*.o     |
|    * X.+.+.E    |
|     & *S+..     |
|    o = = .      |
|     . . .       |
|      o          |
|       .         |
+----[SHA256]-----+
```

The randomart image in the preceding code is mostly for humans so that keys can be validated by sight. Personally, I've never used it (other than a little further along in this chapter,) but you might.

接下来，我们将把新生成的 RSA 密钥复制到`centos2`，当出现提示时为`centos2`提供密码:

The default password for the `vagrant` user on these boxes is `vagrant`.

```sh
$ ssh-copy-id 192.168.33.11
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/home/vagrant/.ssh/id_rsa.pub"
The authenticity of host '192.168.33.11 (192.168.33.11)' can't be established.
ECDSA key fingerprint is SHA256:LKhW+WOnW2nxKO/PY5UO/ny3GP6hIs3m/ui6uy+Sj2E.
ECDSA key fingerprint is MD5:d5:77:4f:38:88:13:e7:f0:27:01:e2:dc:17:66:ed:46.
Are you sure you want to continue connecting (yes/no)? yes
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
vagrant@192.168.33.11's password: 

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh '192.168.33.11'"
and check to make sure that only the key(s) you wanted were added.
```

最后，我们将通过刚才生成的密钥来检查我们是否可以访问`centos2`。

生成密钥时，系统会提示我们输入设置的密码。需要时输入:

```sh
[vagrant@centos1 ~]$ ssh 192.168.33.11
Enter passphrase for key '/home/vagrant/.ssh/id_rsa': 
[vagrant@centos2 ~]$
```

# Ed25519 示例

与我们的 RSA 示例一样，我们将从生成新密钥开始，这次将类型指定为“ed25519”。

Ed25519 keys are elliptical-curve based and a lot of very clever people believe they offer superior security to RSA. The keys themselves are also much shorter (which we'll touch on later,) meaning if you've ever got to type one out, it's a lot less work. Annoyingly you can't use the public half of an Ed25519 key for encrypting files, as you can with an RSA public half, so there's a trade off but it depends on your needs.

我们将再次接受保存密钥的默认位置，并提供密码:

```sh
[vagrant@centos1 ~]$ ssh-keygen -t ed25519 -C "Example Ed25519 key"
Generating public/private ed25519 key pair.
Enter file in which to save the key (/home/vagrant/.ssh/id_ed25519): 
/home/vagrant/.ssh/id_ed25519 already exists.
Overwrite (y/n)? y
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/vagrant/.ssh/id_ed25519.
Your public key has been saved in /home/vagrant/.ssh/id_ed25519.pub.
The key fingerprint is:
SHA256:nQVR7ZVJMjph093KHB6qLg9Ve87PF4fNnFw8Y5X0kN4 Example Ed25519 key
The key's randomart image is:
+--[ED25519 256]--+
|          o*o+=+=|
|          ..+.B*=|
|           ooB Bo|
|         . +o.B+E|
|        S +.. +==|
|         ..  +.+=|
|        ..    o o|
|        ...    o.|
|         o.     +|
+----[SHA256]-----+
```

我们要把我们的新钥匙复制到`centos2`上。请注意，我们还将`id_ed25519.pub`文件指定为要复制的文件:

Again, the default password for these boxes is `vagrant`.

```sh
[vagrant@centos1 ~]$ ssh-copy-id -i .ssh/id_ed25519.pub 192.168.33.11
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: ".ssh/id_ed25519.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
vagrant@192.168.33.11's password: 

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh '192.168.33.11'"
and check to make sure that only the key(s) you wanted were added
```

If you've run this example straight after the one before it, you may be asked for the passphrase to your RSA key, instead of the password to the box itself. This is fine, and it highlights the fact that key-based authentication is attempted first. If this is the case for you, simply provide the passphrase to your RSA key.

安装后，尝试 SSH 到`centos2`，指定`Ed25519`密钥的私有部分:

```sh
[vagrant@centos1 ~]$ ssh 192.168.33.11 -i .ssh/id_ed25519
Enter passphrase for key '.ssh/id_ed25519': 
Last login: Wed Aug  8 10:06:33 2018 from 192.168.33.10
[vagrant@centos2 ~]$
```

# 它是如何工作的...

异步密钥和公钥加密的原理可能会让人们难以理解。在很大程度上，你不需要担心密钥生成的数学问题——你应该知道你最终会得到两个密钥，一个公共密钥和一个私有密钥。

Dimble, an entirely fictional engineer who thinks it's a good idea to store his `private` SSH key on a public `GitLab` server in a repository named `my stuff` is a security risk, because he never owned a dictionary, and believes that the word private means "share it with the world", which it doesn't. He also disabled the passphrase on his `private` key because he didn't like the fact there was an extra step between him and his server. Don't be like Dimble—keep your `private` key safe and secure.

# 公钥和私钥文件

如前所述，我们在这里所做的是创建两个文件，其中一半可以自由传递(公共的一半)，另一半我们安全地保存在其他地方(私有的一半)。

默认情况下，这些文件位于用户的主目录中，在隐藏的`.ssh`文件夹中:

```sh
[vagrant@centos1 ~]$ pwd
/home/vagrant
[vagrant@centos1 ~]$ ls -a
.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .ssh
[vagrant@centos1 ~]$ ls .ssh
authorized_keys  id_ed25519  id_ed25519.pub  id_rsa  id_rsa.pub  known_host
```

我们的密钥的公共部分以`.pub`结尾，私有部分没有文件扩展名。

让我们看看这四个文件:

```sh
[vagrant@centos1 ~]$ cat .ssh/id_rsa
-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,9AFF0BD949B955DA3595262BB18E5BF7

n1K6zUfhIynq9dwRMAGlMuTU/7Ht3KgBuelsWy3mxJM+NxprFkhAV2cyEVhnJI+5
xgDkx7+6PcGVv/oQAH3pSICefZSJvHvnFLO+M7HKkcmdz9IYXlQC1gkeZwhS6708
<SNIP>
wTXVajpn0anc3TWDw78sZkLmoP5MEs14gJvyegmyLd8qAGvSmfXYNFgYh49hnX9E
vdAmtTJPqglcw0F1JVCOEevIWA/WoIkkTAgLuKvka5ZepKKnScwnRiAhKTVXCN3W
-----END RSA PRIVATE KEY-----
```

我们的 RSA 密钥的私有部分是一个敏感的文件，当我们生成它时，它是`4096`位，这个文件会很长(因此是我的截图)。

我们的 RSA 密钥的公共部分是放在远程机器上的文件。它仍然受到我们指定的位长的影响，尽管它远不如私有的那一半长。

```sh
[vagrant@centos1 ~]$ cat .ssh/id_rsa.pub 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCwR6+SAohzU9f1SAha634StlJaBGIZ+k5Rb6T6L4VqxHIfRwCV+uciXbkTg8+lxiP8whGYEiDxfPveqW1xf87JYlWTT3ZT3gd3pfxY1+IgRB7j5Ttd2RBCMeMYB9VJWLqib6K9oeHJyGzM39aJqE2AzxKxc+rXeXT16RlFxs7nDZwS9xV7Dai9LB/Jez0pT8pLFVD/QRsGw0uMjMMSjmKqxPrDpHzZ3OUymB5AdyVfts4JTZINSrWdejPR8G93pzH4S8ZYijhgpOnSuoyGhMnwAjwOJyNkkFOT1rKCuzpW33hr2c1pJSBPZTAx2/ZvB1He2/UweBF2VeQpSruQB7tXkQMeXSQBpe+/zMqOLD82vake3M8mqNpFJoVG3afr9RcCXtqn7cF3fDEqj7nNk0Em6/9akO2/tK5KInWhyOjKdV41ntB6IVPGJWOUBmnvf9HVpOMa8rxeb3KpBqnn6z70rjMTKqHmAQ5BeCuVSezTl4xAUP940PbkHSm0mDeWYMi2AgbofKDGBmH/GGUn3QeahhiLTXGzbIHszbXJdJ5dn30oWAPovW/gc0CeeHgUV7IwJ6wxVIz8jYKpjtDtIPYDs+RJMrWo8qPnhHWxA6HVp42eUylh7eazPUzitfZ2SBQHe3ShbBHTh2wHcLcRoVgSMrMJmfQ7Ibad5ZiWepobJw== Example RSA Key
```

请注意，我们在最后还有一个注释，`Example RSA Key`，这是我们在生成时指定的。当没有注释被显式传递时，这通常是生成它的盒子的用户和机器主机名。

```sh
[vagrant@centos1 ~]$ cat .ssh/id_ed25519
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzaC1rZXktdjEAAAAACmFlczI1Ni1jYmMAAAAGYmNyeXB0AAAAGAAAABCV2EFqnw
9/2J52LIVBzp50AAAAEAAAAAEAAAAzAAAAC3NzaC1lZDI1NTE5AAAAIEGnqP8zTx50SwjP
+Fe26RdDx2W3/TQ+0ET8ylxfFB+aAAAAoJUzLk7IAaszO2npeAJIgfYmsqWCcgTM+EfF15
3A1iw4PruO+q8b3BxAjFZGK0tjFTSm3rkKtM9+JYTxOI+CSnEyqPnjnCjPODa7aF/X8GBt
RNkSKBlM7aROwpon0Z8UXH+Js8uyNOsKto+DS+BfVSKvshkQ6bNF/5DlU0fQcnRaYnVdyl
mIJUaPLdl/vKLwF+S4OyU87n8rac0ezjfAOhk=
-----END OPENSSH PRIVATE KEY-----
```

然后，就是我们的私有(敏感)`Ed25519`键。请注意，该文件比其对应的 RSA 文件短得多，这是因为`Ed25519`密钥的长度是固定的(这也意味着在生成时会忽略`-b`标志)。

```sh
[vagrant@centos1 ~]$ cat .ssh/id_ed25519.pub 
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIEGnqP8zTx50SwjP+Fe26RdDx2W3/TQ+0ET8ylxfFB+a Example Ed25519 key
```

在这里，我们有我们的公共`Ed25519`文件，如此之短，以至于你可以想象把它写在一张纸上，然后交给你的同事复制到服务器上(尽管他们真的，真的不会为此感谢你，而且很可能不会很快给你泡杯茶)。

我们也有我们的评论，`Example Ed25519 key`。

Obviously, printing the private halves of the keys that I've just generated flies in the face of what I said about passing around private keys, although it's for documentation, and I'm going to destroy these VMs once I'm finished with them, so I felt adding them here for clarity was important. DO NOT USE THESE KEYS.

# 授权密钥文件

当您连接到远程主机时，SSH 会根据`authorized_keys`列表验证您提供的密钥标识。

在我们的例子中，我们使用`ssh-copy-id`命令将我们的密钥放在远程服务器上。这实际上是把它放在你正在连接的家庭用户的一个特定文件中。

在我们的`centos2`主机上，我们可以在用户的主目录`.ssh`下找到这个文件:

```sh
[vagrant@centos2 ~]$ pwd
/home/vagrant
[vagrant@centos2 ~]$ ls .ssh/
authorized_keys
```

查看该文件会发现以下内容:

```sh
[vagrant@centos2 ~]$ cat .ssh/authorized_keys 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDNkm9JCaRa/5gunzDZ8xO2/xwRvUx03pITH6f4aYziY/j+7o39XnmNyLRVpvh16u9W75ANJeFpBD7lkevluvaFVRQnZGAhuIdGqLHBlGDnVzkzcQGUFc/fcAc9rDAFGa0h7+BF18P0jpOMXfHQu8+7+cBjJ6cW+ztKerG2ali/JLtSHFirXaVTkOKYkwYVfK7z7nmdMsSzgEOsfg5XrylI+ufhGdgWCKtweHsBeAVWjBBbvNaIwgdRVpB1YmLkLgLN7NxRs53OuejwArLS6tvNS+ZBDiSX+was9gErrhGhZ1mdiOMbd3/oTfFEcOiRNOv/+7Tk4P8fJbnO1dzM8Gid vagrant
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCwR6+SAohzU9f1SAha634StlJaBGIZ+k5Rb6T6L4VqxHIfRwCV+uciXbkTg8+lxiP8whGYEiDxfPveqW1xf87JYlWTT3ZT3gd3pfxY1+IgRB7j5Ttd2RBCMeMYB9VJWLqib6K9oeHJyGzM39aJqE2AzxKxc+rXeXT16RlFxs7nDZwS9xV7Dai9LB/Jez0pT8pLFVD/QRsGw0uMjMMSjmKqxPrDpHzZ3OUymB5AdyVfts4JTZINSrWdejPR8G93pzH4S8ZYijhgpOnSuoyGhMnwAjwOJyNkkFOT1rKCuzpW33hr2c1pJSBPZTAx2/ZvB1He2/UweBF2VeQpSruQB7tXkQMeXSQBpe+/zMqOLD82vake3M8mqNpFJoVG3afr9RcCXtqn7cF3fDEqj7nNk0Em6/9akO2/tK5KInWhyOjKdV41ntB6IVPGJWOUBmnvf9HVpOMa8rxeb3KpBqnn6z70rjMTKqHmAQ5BeCuVSezTl4xAUP940PbkHSm0mDeWYMi2AgbofKDGBmH/GGUn3QeahhiLTXGzbIHszbXJdJ5dn30oWAPovW/gc0CeeHgUV7IwJ6wxVIz8jYKpjtDtIPYDs+RJMrWo8qPnhHWxA6HVp42eUylh7eazPUzitfZ2SBQHe3ShbBHTh2wHcLcRoVgSMrMJmfQ7Ibad5ZiWepobJw== Example RSA Key
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIEGnqP8zTx50SwjP+Fe26RdDx2W3/TQ+0ET8ylxfFB+a Example Ed25519 key
```

在这里，我们可以看到三个键，三行。

第一个关键如下:

```sh
[vagrant@centos2 ~]$ cat .ssh/authorized_keys | head -n1
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDNkm9JCaRa/5gunzDZ8xO2/xwRvUx03pITH6f4aYziY/j+7o39XnmNyLRVpvh16u9W75ANJeFpBD7lkevluvaFVRQnZGAhuIdGqLHBlGDnVzkzcQGUFc/fcAc9rDAFGa0h7+BF18P0jpOMXfHQu8+7+cBjJ6cW+ztKerG2ali/JLtSHFirXaVTkOKYkwYVfK7z7nmdMsSzgEOsfg5XrylI+ufhGdgWCKtweHsBeAVWjBBbvNaIwgdRVpB1YmLkLgLN7NxRs53OuejwArLS6tvNS+ZBDiSX+was9gErrhGhZ1mdiOMbd3/oTfFEcOiRNOv/+7Tk4P8fJbnO1dzM8Gid vagrant
```

这是游民用来连接虚拟机的密钥。它不是我们创造的。

第二条如下:

```sh
[vagrant@centos2 ~]$ cat .ssh/authorized_keys | head -n2 | tail -n1
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCwR6+SAohzU9f1SAha634StlJaBGIZ+k5Rb6T6L4VqxHIfRwCV+uciXbkTg8+lxiP8whGYEiDxfPveqW1xf87JYlWTT3ZT3gd3pfxY1+IgRB7j5Ttd2RBCMeMYB9VJWLqib6K9oeHJyGzM39aJqE2AzxKxc+rXeXT16RlFxs7nDZwS9xV7Dai9LB/Jez0pT8pLFVD/QRsGw0uMjMMSjmKqxPrDpHzZ3OUymB5AdyVfts4JTZINSrWdejPR8G93pzH4S8ZYijhgpOnSuoyGhMnwAjwOJyNkkFOT1rKCuzpW33hr2c1pJSBPZTAx2/ZvB1He2/UweBF2VeQpSruQB7tXkQMeXSQBpe+/zMqOLD82vake3M8mqNpFJoVG3afr9RcCXtqn7cF3fDEqj7nNk0Em6/9akO2/tK5KInWhyOjKdV41ntB6IVPGJWOUBmnvf9HVpOMa8rxeb3KpBqnn6z70rjMTKqHmAQ5BeCuVSezTl4xAUP940PbkHSm0mDeWYMi2AgbofKDGBmH/GGUn3QeahhiLTXGzbIHszbXJdJ5dn30oWAPovW/gc0CeeHgUV7IwJ6wxVIz8jYKpjtDtIPYDs+RJMrWo8qPnhHWxA6HVp42eUylh7eazPUzitfZ2SBQHe3ShbBHTh2wHcLcRoVgSMrMJmfQ7Ibad5ZiWepobJw== Example RSA Key
```

这是我们生成的 RSA 密钥。请注意，由于我们指定的自定义`4096`位长度，它比游民默认值长。

我们的第三个关键如下:

```sh
[vagrant@centos2 ~]$ cat .ssh/authorized_keys | tail -n1
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIEGnqP8zTx50SwjP+Fe26RdDx2W3/TQ+0ET8ylxfFB+a Example Ed25519 key
```

这是我们的`Ed25519`键。

You could, if you so wished, manually copy public keys into the `authorized_keys` file on the host you're connecting to. The `ssh-copy-id` command we used is simply a convenient way of cutting out a few of the extra steps.

# 还有更多...

SSH 对其文件拥有的**权限**很敏感。

您不希望您的私钥被任何可能在您系统上的随机用户读取，因此，如果普通 SSH 认为您设置了错误的权限，它将不起作用。

一般来说，如果您刚刚生成了密钥，这不会成为问题，但是如果您稍后在计算机之间移动密钥，您可能会发现您稍微破坏了权限。

一个好的经验法则是假设锁定设置:

```sh
[vagrant@centos1 ~]$ ls -lha .ssh/
total 28K
drwx------. 2 vagrant vagrant  134 Aug  8 14:05 .
drwx------. 3 vagrant vagrant   95 Aug  8 10:29 ..
-rw-------. 1 vagrant vagrant  389 Aug  7 16:40 authorized_keys
-rw-------. 1 vagrant vagrant  464 Aug  8 10:04 id_ed25519
-rw-r--r--. 1 vagrant vagrant  101 Aug  8 10:04 id_ed25519.pub
-rw-------. 1 vagrant vagrant 3.3K Aug  8 11:15 id_rsa
-rw-r--r--. 1 vagrant vagrant  741 Aug  7 16:43 id_rsa.pub
-rw-r--r--. 1 vagrant vagrant  535 Aug  8 11:39 known_hosts
```

在上面的命令中，我们可以看到密钥的公共和私有部分(id_rsa 密钥和 id_ed25519 密钥)具有不同的值。

键的公共半部分(`*.pub`)具有值`644`(读/写、读、读):

```sh
-rw-r--r--.
```

密钥的私有一半具有值 600(读/写，无，无):

```sh
-rw-------.
```

# 要密码短语还是不要密码短语

虽然您可以在没有密码的情况下生成密钥，并且有这样做的有效用例(例如，在自动化部署的情况下)，但是使用密码生成您自己的密钥被认为是最佳实践。

这确实意味着，如果您的钥匙没有在钥匙串中解锁(钥匙串本身可能会在您登录机器时解锁)，系统会提示您输入密码来解锁钥匙。您可能会认为这是一个麻烦，但是可以从安全洋葱(多层安全)的角度来考虑...这不是一个很好的类比，除非安全让你哭。)如果你丢失了私钥，捡到它的恶意者将无法使用它来访问你的东西。

If you do lose a private key, or leave it on a USB stick on a bus, you should immediately rotate your keys by revoking the old one from any location where the public half is installed, and generating a new pair to use.

# 附加标志

当我们生成密钥时，我们还添加了几个标志。

与任何软件一样，检查您正在运行的命令的手动页面可以提供大量额外的细节:

```sh
$ man ssh-keygen
```

为了避免一点点头痛，我将突出一些您可能感兴趣的选项，从`-b`开始:

```sh
-b bits
```

在生成我们的 RSA 密钥期间，我们使用`-b`标志来指定大量的位。最小值为`1024`，默认值为`2048`。您的营业地可能对 RSA 密钥的长度有要求。

接下来，我们有评论标志:

```sh
-C comment
```

我们用这个给我们的钥匙添加了一些描述。如果你对不同的东西使用不同的密钥(这是我的`GitLab`密钥，这是我的个人服务器密钥，这是我的公司服务器密钥，等等)可能会有用。

如果确实需要多个键，您可能希望在生成命令中传递新键的名称(而不是在出现提示时键入):

```sh
-f filename
```

我们还有`-l`打印钥匙的指纹，和/或 ASCII 艺术，如果你愿意的话。这对于验证密钥对非常有用:

```sh
-l (or -lv for a pretty picture)
```

如果您想更改私人半部的密码，但不想生成新密钥，可以使用`-p`选项:

```sh
-p
```

要指定您希望生成的密钥类型，您可以使用`-t`选项:

```sh
-t dsa | ecdsa | ed25519 | rsa
```

选择要生成的密钥类型时，请考虑您的需求。RSA 通常是最兼容的，但是您的公司可能有其他政策，或者您可能有个人偏好。

I've come across two scenarios where `Ed25519` keys couldn't be used – one was an in-house script that required RSA for encrypting files, and the other was OpenStack, at the time.

最后，有一个不错的老`-v`，从早期开始提供详细的输出:

```sh
-v
```

这可以多次传递，即`-vvv`也是有效的，每次`v`增加调试级别。

# 请参见

这一部分特意不涉及 SSH 密钥交换的细节或不同类型的密钥(除了我们示例中使用的两种)。关于 SSH 有很多优秀的书籍可以提供丰富的信息，OpenSSH 开发人员自己也在不断地对软件进行改进。OpenSSH 只是 SSH 的一种实现，但它是迄今为止最受欢迎的。这是我用过的每一个 Linux 发行版的默认设置，在 macOS 上也在使用，这也是 BSD(尤其是 OpenBSD，它就是在这里开发的)上的标准。

# SSH 客户端参数和选项

正如我们已经讨论过的，SSH 是一个功能强大的软件，虽然它可以用一种非常简单的方式来访问您的服务器，但它也非常灵活。

在本节中，我们将了解在可能有不同需求的环境中 SSH 使用的常见标志。

我们将使用和以前一样的流浪盒子。

# 准备好

与前一部分一样，确认两个游民箱都已启用，并使用`vagrant`命令连接到第一个:

```sh
$ vagrant ssh centos1
```

# 怎么做...

我们先来看看 SSH 的基础知识。

# 使用主机名而不是 IP 的 SSH

到目前为止，在我们的示例中，我们一直使用 IP 地址来连接到我们的远程主机。

SSH 还能够连接到主机名。

首先，我们必须创建一个快速主机条目，这样我们就可以将我们的名称解析为一个 IP 地址:

```sh
[vagrant@centos1 ~]$ echo "192.168.33.11 centos2" | sudo tee -a /etc/hosts
```

The preceding code is a quick way to make a remote host resolvable to a name. There's no guarantee that it will stick on some systems, especially those where a third party controls the `hosts` file. In a real-world scenario, it is highly likely you'll have some sort of DNS setup that will make connecting to hostnames easier.

我们现在应该能够使用主机名称进行 SSH:

```sh
[vagrant@centos1 ~]$ ssh centos2
The authenticity of host 'centos2 (192.168.33.11)' can't be established.
ECDSA key fingerprint is SHA256:LKhW+WOnW2nxKO/PY5UO/ny3GP6hIs3m/ui6uy+Sj2E.
ECDSA key fingerprint is MD5:d5:77:4f:38:88:13:e7:f0:27:01:e2:dc:17:66:ed:46.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'centos2' (ECDSA) to the list of known hosts.
Enter passphrase for key '/home/vagrant/.ssh/id_rsa': 
Last login: Wed Aug 8 11:28:59 2018 from fe80::a00:27ff:fe2a:1652%eth1
[vagrant@centos2 ~]$
```

请注意，我们再次不得不接受我们所连接的主机的指纹。

# 切换到不同的用户

如果您正在连接的用户与您正在本地使用的用户不同(在我们的示例中，总是`vagrant`和`vagrant`，那么您可以在命令行上手动指定用户名。

第一种方法是使用以下语法:

```sh
[vagrant@centos1 ~]$ ssh vagrant@centos2
```

第二种方式是用旗帜:

```sh
[vagrant@centos1 ~]$ ssh centos2 -l vagrant
```

# 切换到不同的端口

如果您正在连接的 SSH 服务器正在不同的端口上侦听(这很常见)，那么您可能必须指定有问题的端口。

默认值为`22`，但是如果您因为任何原因更改了该值，您也可以指定新端口，例如`2020`:

```sh
[vagrant@centos1 ~]$ ssh centos2 -p2020
```

Note this example won't work right now, because we haven't changed the port the server is listening on.

# 切换到 IPv6 地址

IPv6 地址看起来比它们实际上要壮观得多，明智的做法是，你应该尽早掌握它们(即使人们已经预测 IPv6 的统治地位超过十年了)。

对于本例，我们将找到`centos2`的 IPv6 地址并连接到该地址。

首先，连接到`centos2`并运行`ip a`命令:

```sh
[vagrant@centos2 ~]$ ip a
<SNIP>
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:56:c5:a7 brd ff:ff:ff:ff:ff:ff
    inet 192.168.33.11/24 brd 192.168.33.255 scope global noprefixroute eth1
       valid_lft forever preferred_lft forever
    inet6 fe80::a00:27ff:fe56:c5a7/64 scope link 
       valid_lft forever preferred_lft forever
```

我在前面的代码中突出显示了 IPv6 地址。

回到`centos1`，让我们使用 IPv6 进行连接:

```sh
[vagrant@centos1 ~]$ ssh fe80::a00:27ff:fe56:c5a7%eth1
Enter passphrase for key '/home/vagrant/.ssh/id_rsa': 
Last login: Wed Aug  8 11:44:34 2018 from 192.168.33.10
[vagrant@centos2 ~]$ 
```

请注意，我们必须在命令末尾指定网络接口。这仅在链路本地地址的情况下是必要的，对于全局 IPv6 地址不应该是必要的。

A comparison to link-local addresses in the IPv6 world are subnets in the IPv4 world, that is, link-local devices are those that can see each other on a local network, via their link-local addresses (which themselves are generated based on factors like the MAC address of the interface that the address is on). They should always have the link-local prefix (`FE80::/10`).

# 运行命令前的扫描

虽然您将主要使用 SSH 连接到远程盒子，但也可以在远程主机上运行命令，而不必在那里逗留。

在这里，我们正在运行一个命令来打印远程盒子上的主机名文件，同时停留在`centos1`:

```sh
[vagrant@centos1 ~]$ ssh 192.168.33.11 "cat /etc/hostname"
Enter passphrase for key '/home/vagrant/.ssh/id_rsa': 
centos2
[vagrant@centos1 ~]$ 
```

This is especially useful for automation software, or scripts that you want to run locally but which interact with remote machines.

# SSH 和 X11 转发

`X11`转发是在远程盒子上运行一个程序，并在本地机器上显示该程序的行为。

您可以使用以下命令设置您的会话:

```sh
[vagrant@centos1 ~]$ ssh centos2 -X
```

There are security implications of working with `X11` forwarding. Consult your distribution's manual page for information around this, as the default behavior can differ from distribution to distribution. Currently, this is only possible with `X` Window Manager setups, and the more modern Wayland display server protocol doesn't have a similar ability, due in part to wanting to keep things simple.

# 它是如何工作的...

SSH 是一个大型且功能丰富的程序。当您使用标志来操纵它的行为时，您是在为自己的目的修改默认行为。

与任何命令一样，它们可以很简单:

```sh
$ ssh 192.168.33.11
```

但它们也可能很复杂:

```sh
$ ssh -Y -D9999 -J buser@BASTION:22 -L 8888:127.0.0.1:80 myself@centos2 -p4433
```

作为一个练习，如果需要的话，使用 SSH 手册页，看看你是否能算出这个命令会完成什么。

# 还有更多...

SSH 转义字符是一个需要注意的重要附加元素。

有时，您可以连接到系统，但您的连接会超时，从而锁定您的会话。

这通常表现为一个未关闭且无响应的终端。一般不能点击 *Ctrl* + *D* 注销，不能打字。

相反，您可以按以下键:

```sh
~. 
```

While the key combination is officially listed as `~.` it actually requires the *Enter* key being pressed first (as in, newline), so it's frequently written as `\n~`.

This tip is brought to you by an eagle-eyed technical editor!

这是一个波浪号字符(在键盘上找到它，通常使用 S*shift*键)，后跟一个点。

您的会话应该立即断开。

查看 SSH 手册页了解更多转义字符。

# 请参见

同样，SSH 选项比我在本食谱中列出的要多得多，我们还没有在本章的其余部分涵盖一些有自己部分的选项，但是仍然有相当多的选项我们不会在这里使用。

在一个无聊的周二看看 SSH 的手册页。我说了。

# 使用客户端 SSH 配置文件

虽然能够使用命令行参数来操作 SSH 很好，但不必费心也很好。

如果你有一个日复一日工作的系统，用你的典型参数永久地配置你的设置可能是有益的。这就是客户端 SSH 配置文件的来源。

在我们的示例框中，默认的`ssh_config`文件位于`/etc/ssh/`目录中。如果您愿意，请打开此文件查看，但不要做任何更改。

# 准备好了

与前一部分一样，确认两个游民箱都已启用，并使用`vagrant`命令连接到第一个:

```sh
$ vagrant ssh centos1
```

为了给用户配置不同的选项，我们将在主目录中创建一个 SSH 配置文件。

这与我们的大多数 SSH 文件`~/.ssh/`处于相同的位置。

Whenever you see a `~` character, think of it as **my home** in your head. Expanded, this location is `/home/vagrant/.ssh/`.

创建文件，锁定权限，并在您选择的编辑器中打开它——我将使用`vi`。

一定要叫它`config`:

```sh
[vagrant@centos1 ~]$ touch ~/.ssh/config
[vagrant@centos1 ~]$ chmod 600 ~/.ssh/config
[vagrant@centos1 ~]$ vi ~/.ssh/config
```

# 怎么做...

在您的`config`文件中，创建四个块的起点。

一个应该是通配符块(使用`*`)，另一个应该是名称`CentOS2`的变体(注意大写):

```sh
Host * !CentOS2-V6
 IdentityFile ~/.ssh/id_ed25519
 Port 22

Host CentOS2-V4
 Hostname 192.168.33.11
 User vagrant

Host CentOS2-V6
 Hostname fe80::a00:27ff:fe56:c5a7%%eth1
 IdentityFile ~/.ssh/id_rsa
 Port 22
 User vagrant

Host CentOS2-Hostname
 Hostname centos2
 User vagrant
```

Note that in the V6 entry, we actually use two percentage signs, instead of the single one we used on the command line. This is so that SSH doesn't misinterpret what we mean and try to read the entry with a `%e` value.

在这些块中，我们根据之前在命令行中所做的工作设置了一些基本选项。

有了这些设置，我们可以保存并退出我们的配置文件，并尝试连接到我们指定的主机。

首先，我们将连接到另一个虚拟机的 IPv4 地址:

```sh
[vagrant@centos1 ~]$ ssh CentOS2-V4 
Enter passphrase for key '/home/vagrant/.ssh/id_ed25519': 
Last login: Wed Aug  8 13:31:41 2018 from fe80::a00:27ff:fe2a:1652%eth1
[vagrant@centos2 ~]$ 
```

接下来，我们将使用我们的 IPv6 地址:

```sh
[vagrant@centos1 ~]$ ssh CentOS2-V6
Enter passphrase for key '/home/vagrant/.ssh/id_rsa': 
Last login: Wed Aug  8 13:34:26 2018 from 192.168.33.10
[vagrant@centos2 ~]$ 
```

最后，我们将解析主机的主机名:

```sh
[vagrant@centos1 ~]$ ssh CentOS2-Hostname 
Enter passphrase for key '/home/vagrant/.ssh/id_ed25519': 
Last login: Wed Aug  8 13:34:04 2018 from fe80::a00:27ff:fe2a:1652%eth1
[vagrant@centos2 ~]$ 
```

Most systems will also auto complete entries in the SSH config file. Try it out yourself by typing `ssh C` and hitting *Tab* three times.

# 它是如何工作的...

从通配符主机条目(`Host *`)开始，这是一个全局条目。该块中的设置将适用于所有主机(除了`CentOS2-V6`，我们将很快进入):

```sh
Host * !CentOS2-V6
 IdentityFile ~/.ssh/id_ed25519
 Port 22
```

在这里，我们已经说过，这个文件中的每台主机都将使用我们的`Ed25519`键进行连接，我们将始终在端口`22`上进行连接。该块通常应用于全局设置。如果您愿意，也可以完全省略它:

```sh
Host CentOS2-V4
 Hostname 192.168.33.11
 User vagrant
```

在我们的第一个特定主机块中，我们称之为`CentOS2-V4`，我们指定了主机的 IPv4 地址和要使用的用户。

连接到此条目时，显示的详细信息如下所示:

```sh
[vagrant@centos1 ~]$ ssh -v CentOS2-V4 
OpenSSH_7.4p1, OpenSSL 1.0.2k-fips  26 Jan 2017
debug1: Reading configuration data /home/vagrant/.ssh/config
debug1: /home/vagrant/.ssh/config line 1: Applying options for *
debug1: /home/vagrant/.ssh/config line 5: Applying options for CentOS2-V4
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 58: Applying options for *
debug1: Connecting to 192.168.33.11 [192.168.33.11] port 22.
debug1: Connection established.
debug1: identity file /home/vagrant/.ssh/id_ed25519 type 4
<SNIP>
debug1: rekey after 134217728 blocks
debug1: SSH2_MSG_NEWKEYS sent
debug1: expecting SSH2_MSG_NEWKEYS
debug1: SSH2_MSG_NEWKEYS received
debug1: rekey after 134217728 blocks
debug1: SSH2_MSG_EXT_INFO received
debug1: kex_input_ext_info: server-sig-algs=<rsa-sha2-256,rsa-sha2-512>
debug1: SSH2_MSG_SERVICE_ACCEPT received
debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic,password
debug1: Next authentication method: gssapi-keyex
debug1: No valid Key exchange context
debug1: Next authentication method: gssapi-with-mic
debug1: Unspecified GSS failure.  Minor code may provide more information
No Kerberos credentials available (default cache: KEYRING:persistent:1000)

debug1: Unspecified GSS failure.  Minor code may provide more information
No Kerberos credentials available (default cache: KEYRING:persistent:1000)

debug1: Next authentication method: publickey
debug1: Offering ED25519 public key: /home/vagrant/.ssh/id_ed25519
debug1: Server accepts key: pkalg ssh-ed25519 blen 51
Enter passphrase for key '/home/vagrant/.ssh/id_ed25519': 
debug1: Authentication succeeded (publickey).
Authenticated to 192.168.33.11 ([192.168.33.11]:22).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: network
debug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Sending environment.
debug1: Sending env LANG = en_GB.UTF-8
Last login: Wed Aug  8 13:46:27 2018 from 192.168.33.10
```

在这一团噪音中，我们可以看到一些至关重要的东西，为了您的方便，我们鼓起了勇气。

首先，我们可以看到 SSH 从哪里开始从我们的配置文件中读取配置数据。它应用通配符条目的设置，然后是该特定主机的设置。

稍后，我们可以看到主机通配符块中指定的`Ed25519`键的提示。

最后，我们可以看到我们的会话被认证到`192.168.33.11`(或 IPv4 地址)。

如果我们现在看一下`CentOS-V6`区块，我们开始看到差异:

```sh
Host CentOS2-V6
 Hostname fe80::a00:27ff:fe56:c5a7%%eth1
 IdentityFile ~/.ssh/id_rsa
 Port 22
 User vagrant
```

Again, note the double percentage signs. 

首先，您会注意到我们已经指定了端口和一个不同的`IdentityFile`条目。这是由于`Host *`区块不适用于`CentOS2-V6`，如下图所示:

```sh
Host * !CentOS2-V6
```

这意味着通配符块中的任何设置都不适用于`CentOS2-V6`。

如果我们再次以冗长的方式连接到主机，我们会看到以下内容:

```sh
[vagrant@centos1 ~]$ ssh -v CentOS2-V6
OpenSSH_7.4p1, OpenSSL 1.0.2k-fips  26 Jan 2017
debug1: Reading configuration data /home/vagrant/.ssh/config
debug1: /home/vagrant/.ssh/config line 1: Skipping Host block because of negated match for CentOS2-V6
debug1: /home/vagrant/.ssh/config line 9: Applying options for CentOS2-V6
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 58: Applying options for *
debug1: Connecting to fe80::a00:27ff:fe56:c5a7%eth1 [fe80::a00:27ff:fe56:c5a7%eth1] port 22.
debug1: Connection established.
debug1: identity file /home/vagrant/.ssh/id_rsa type 1
debug1: key_load_public: No such file or directory
<SNIP>
debug1: Next authentication method: publickey
debug1: Offering RSA public key: /home/vagrant/.ssh/id_rsa
debug1: Server accepts key: pkalg rsa-sha2-512 blen 535
Enter passphrase for key '/home/vagrant/.ssh/id_rsa': 
debug1: Authentication succeeded (publickey).
Authenticated to fe80::a00:27ff:fe56:c5a7%eth1 ([fe80::a00:27ff:fe56:c5a7%eth1]:22).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: network
debug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Sending environment.
debug1: Sending env LANG = en_GB.UTF-8
Last login: Wed Aug  8 13:50:39 2018 from fe80::a00:27ff:fe2a:1652%eth1
```

具体不同的是关于匹配配置的行，这一次通知我们不会应用通配符块，因为`CentOS2-V6`匹配被否定。

我们还可以看到这次改为使用`id_rsa`，我们已经专门连接到了主机的 IPv6 地址。

最后，我们来看看`CentOS2-Hostname`:

```sh
[vagrant@centos1 ~]$ ssh -v CentOS2-Hostname 
OpenSSH_7.4p1, OpenSSL 1.0.2k-fips  26 Jan 2017
debug1: Reading configuration data /home/vagrant/.ssh/config
debug1: /home/vagrant/.ssh/config line 1: Applying options for *
debug1: /home/vagrant/.ssh/config line 15: Applying options for CentOS2-Hostname
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 58: Applying options for *
debug1: Connecting to centos2 [192.168.33.11] port 22.
debug1: Connection established.
debug1: identity file /home/vagrant/.ssh/id_ed25519 type 4
debug1: key_load_public: No such file or directory
debug1: identity file /home/vagrant/.ssh/id_ed25519-cert type -1
debug1: Enabling compatibility mode for protocol 2.0
debug1: Local version string SSH-2.0-OpenSSH_7.4
debug1: Remote protocol version 2.0, remote software version OpenSSH_7.4
debug1: match: OpenSSH_7.4 pat OpenSSH* compat 0x04000000
debug1: Authenticating to centos2:22 as 'vagrant'
debug1: SSH2_MSG_KEXINIT sent
debug1: SSH2_MSG_KEXINIT received
debug1: kex: algorithm: curve25519-sha256
<SNIP>
debug1: Next authentication method: publickey
debug1: Offering ED25519 public key: /home/vagrant/.ssh/id_ed25519
debug1: Server accepts key: pkalg ssh-ed25519 blen 51
Enter passphrase for key '/home/vagrant/.ssh/id_ed25519': 
debug1: Authentication succeeded (publickey).
Authenticated to centos2 ([192.168.33.11]:22).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: network
debug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Sending environment.
debug1: Sending env LANG = en_GB.UTF-8
Last login: Wed Aug  8 13:55:20 2018 from fe80::a00:27ff:fe2a:1652%eth1
```

再次注意配置的匹配，以及我们连接到 IPv4 地址的事实。

我们还可以做一件事，提高连接的详细程度，进入下一个调试级别，并希望看到其他值得注意的东西:

```sh
[vagrant@centos1 ~]$ ssh -vv CentOS2-Hostname 
OpenSSH_7.4p1, OpenSSL 1.0.2k-fips  26 Jan 2017
debug1: Reading configuration data /home/vagrant/.ssh/config
debug1: /home/vagrant/.ssh/config line 1: Applying options for *
debug1: /home/vagrant/.ssh/config line 15: Applying options for CentOS2-Hostname
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 58: Applying options for *
debug2: resolving "centos2" port 22
debug2: ssh_connect_direct: needpriv 0
debug1: Connecting to centos2 [192.168.33.11] port 22.
debug1: Connection established.
```

在这里，我们可以看到第二个调试级别(`debug2`)，具体来说，我们可以看到`centos2`在块中给出并解析为地址的时刻。

# 还有更多...

您可能已经注意到，在我的示例中，我的名字混合使用了大写和小写字符(例如，`CentOS2-V4`)。我这样做是因为这意味着我知道我什么时候在使用我的 SSH 配置文件，并且可以一目了然地确定我正在使用我配置的设置。

没有什么能阻止你创建这样一个街区:

```sh
Host centos2
 Hostname 192.168.33.11
 User vagrant
```

这是完全有效的，设置将被正常读取。

你也可以做一些聪明的事情，比如特定的领域匹配。如果您必须管理由域区分的两组不同的服务器，您可以执行以下操作:

```sh
Host *.examplecake.com
  Port 2222
  User Alie

Host *.examplebiscuit.co.uk
  Port 5252
  User Gingerbread
```

尝试连接到其中任一域中的主机将导致使用特定的配置选项:

```sh
[vagrant@centos1 ~]$ ssh -v potato.examplecake.com
OpenSSH_7.4p1, OpenSSL 1.0.2k-fips 26 Jan 2017
debug1: Reading configuration data /home/vagrant/.ssh/config
debug1: /home/vagrant/.ssh/config line 1: Applying options for *
debug1: /home/vagrant/.ssh/config line 19: Applying options for *.examplecake.com
debug1: Reading configuration data /etc/ssh/ssh_config
```

# 请参见

`ssh_config`手册页值得一看，哪怕你只是用它来入睡。

# 修改服务器端 SSH 配置文件

在最后几节中，我们将重点放在客户端配置上。我们在命令行上调整了连接字符串，并编写了一个配置文件，当连接到我们的第二个主机时，SSH 会自动读取该文件。

在本节中，我们将在第二台主机上查看`sshd_config`文件，或者配置 tango 的服务器端。

我们将做一些例子和常规的改变来让你熟悉这个概念。

# 准备好了

连接到`centos1`和`centos2`。最好从外面(在单独的窗口中，使用`vagrant ssh`)进行操作:

```sh
$ vagrant ssh centos1
$ vagrant ssh centos2
```

并排放置您的终端窗口，以便于查看。

There is a chance that you will break SSH access to your server in this section, which is why I advise using Vagrant for your testing. If you do make a mistake, don't worry – simply destroy your VMs and start again.

# 怎么做...

在你的`centos2`机器上，在你喜欢的编辑器中打开`/etc/ssh/sshd_config`。

这个文件很大，当你第一次打开它的时候，它看起来有点令人生畏。

列出的选项是 SSH 服务器(`sshd`)启动时将读取的大多数设置，并应用于您正在运行的守护程序。

# 更改默认端口

我们将从一个简单的开始，即更改运行 SSH 守护程序的默认端口:

```sh
# If you want to change the port on a SELinux system, you have to tell
# SELinux about this change.
# semanage port -a -t ssh_port_t -p tcp #PORTNUMBER
#
#Port 22
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::
```

更改前面的代码，使`Port`行取消注释，现在为`2222`:

```sh
#
Port 2222
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::
```

正如这个块之前的提示所告诉我们的，我们还必须修改 SELinux，以便它知道 SSH 守护程序将尝试使用不同的端口。

这个文件建议我们使用`semanage`，就这么办吧。

首先，我们将找到哪个包提供语义:

```sh
[vagrant@centos2 ~]$ sudo yum whatprovides semanage
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirror.vorboss.net
 * extras: mozart.ee.ic.ac.uk
 * updates: mozart.ee.ic.ac.uk
base/7/x86_64/filelists_db                                                    | 6.9 MB  00:00:01 
extras/7/x86_64/filelists_db                                                  | 588 kB  00:00:00 
updates/7/x86_64/filelists_db                                                 | 2.4 MB  00:00:00 
policycoreutils-python-2.5-22.el7.x86_64 : SELinux policy core python utilities
Repo        : base
Matched from:
Filename    : /usr/sbin/semanage
```

然后，我们将安装它:

```sh
[vagrant@centos2 ~]$ sudo yum install -y policycoreutils-python
```

最后，我们将使用新端口运行推荐的命令:

```sh
[vagrant@centos2 ~]$ sudo semanage port -a -t ssh_port_t -p tcp 2222
```

完成后，我们可以安全地重新启动 SSH 守护程序:

```sh
[vagrant@centos2 ~]$ sudo systemctl restart sshd
```

这不应该让你离开虚拟机，因为`sshd`的设计是为了使更改不会导致访问丢失，即使这些更改会阻止你再次登录(一旦你主动断开连接)。)

请尝试现在注销，然后再次登录。

一个预先警告:这应该失败！

不要害怕！相反，连接到您的第二个终端上的`centos1`(此时您应该有两个到`centos1`的连接打开)，然后 SSH 回到`centos2`上，如下所示:

```sh
[vagrant@centos1 ~]$ ssh 192.168.33.11 -p2222
```

恭喜你！SSH 现在运行在不同的端口上！

您可以使用以下命令在操作系统中确认这一点(我们将在后面详细介绍:)

```sh
[vagrant@centos2 ~]$ ss -nl sport = :2222
Netid State      Recv-Q Send-Q   Local Address:Port                  Peer Address:Port 
tcp   LISTEN     0      128                  *:2222                             *:* 
tcp   LISTEN     0      128                 :::2222                            :::*  
```

Note that in the preceding code, we're printing both the IPv4 and IPv6 values.

# 更改监听地址

默认情况下，SSH 将侦听所有地址和接口:

```sh
#AddressFamily any
#ListenAddress 0.0.0.0
#ListenAddress ::
```

我们将对此进行更改，以便它只监听 IPv4 和我们的`eth1`地址。

将前面的选项更改为以下选项:

```sh
AddressFamily inet
ListenAddress 192.168.33.11
#ListenAddress ::
```

我们取消了其中两个选项的注释，并更改了它们的值。

In the preceding block, you may have noticed that `ListenAddress ::` is also listed. Here, `::` is the IPv6 equivalent of `0.0.0.0` in IPv4.

重新启动 SSH 守护程序:

```sh
[vagrant@centos2 ~]$ sudo systemctl restart sshd
```

运行我们之前的`ss`命令，您可能会注意到 IPv6 选项已经消失:

```sh
[vagrant@centos2 ~]$ ss -nl sport = :2222
Netid State      Recv-Q Send-Q   Local Address:Port                  Peer Address:Port 
tcp   LISTEN     0      128      192.168.33.11:2222                             *:*      
```

如果我们现在退出会话到`centos2`(使用 *Ctrl* + *D* )并尝试 SSH 到 IPv6 链路本地地址，它将失败:

```sh
[vagrant@centos1 ~]$ ssh fe80::a00:27ff:fe56:c5a7%eth1 -p2222
ssh: connect to host fe80::a00:27ff:fe56:c5a7%eth1 port 2222: Connection refused
```

巨大的成功——我们已经排除了任何趋势引领者登录我们的 IPv6 服务器的可能性！

On to a serious note for a minute, I've been hearing about the demise of IPv4 and the rise of IPv6 for years, pretty much since I started in computing. In that time, not much has changed, and both carriers and service providers have continued to eke everything they can out of IPv4, even introducing horrible things such as Carrier-grade NAT. I do hope that IPv6 picks up steam, not least because we're effectively out of IPv4 addresses to allocate.

# 更改守护程序日志记录级别

SSH 可以登录几个级别，由`LogLevel`设置决定:

```sh
# Logging
#SyslogFacility AUTH
SyslogFacility AUTHPRIV
#LogLevel INFO
```

可能性有`QUIET`、`FATAL`、`ERROR`、`INFO`、`VERBOSE`、`DEBUG`、`DEBUG1`、`DEBUG2`和`DEBUG3`。

The SSH daemon manual lists the `DEBUG` options as all violating the privacy of users, and therefore it is not recommended that you use them.

我们将把这个提升到`VERBOSE`:

```sh
# Logging
#SyslogFacility AUTH
SyslogFacility AUTHPRIV
LogLevel VERBOSE
```

重新启动 SSH 守护程序:

```sh
[vagrant@centos2 ~]$ sudo systemctl restart sshd
```

现在，让我们看看这有什么不同。

以下是我们在`INFO`级别的`secure`日志:

```sh
[vagrant@centos2 ~]$ sudo grep "1137" /var/log/secure
Aug  7 16:40:44 localhost sshd[1137]: Accepted publickey for vagrant from 10.0.2.2 port 53114 ssh2: RSA SHA256:1M4RzhMyWuFS/86uPY/ce2prh/dVTHW7iD2RhpquOZA
Aug  7 16:40:45 localhost sshd[1137]: pam_unix(sshd:session): session opened for user vagrant by (uid=0)
```

这是我们在 T1 级别的日志:

```sh
[vagrant@centos2 ~]$ sudo grep "5796" /var/log/secure
Aug  8 15:00:00 localhost sshd[5796]: Connection from 192.168.33.10 port 39258 on 192.168.33.11 port 2222
Aug  8 15:00:00 localhost sshd[5796]: Postponed publickey for vagrant from 192.168.33.10 port 39258 ssh2 [preauth]
Aug  8 15:00:02 localhost sshd[5796]: Accepted publickey for vagrant from 192.168.33.10 port 39258 ssh2: ED25519 SHA256:nQVR7ZVJMjph093KHB6qLg9Ve87PF4fNnFw8Y5X0kN4
Aug  8 15:00:03 localhost sshd[5796]: pam_unix(sshd:session): session opened for user vagrant by (uid=0)
Aug  8 15:00:03 localhost sshd[5796]: User child is on pid 5799
```

# 不允许超级用户登录

有些发行版默认拒绝 root 登录，这被广泛认为是一个好主意。在这里，我们有一个用户(游民)，我们可以用它来四处走动，这样我们就不需要以 root 身份登录。

用`PermitRootLogin`找线:

```sh
#LoginGraceTime 2m
#PermitRootLogin yes
#StrictModes yes
```

改为`no`:

```sh
#LoginGraceTime 2m
PermitRootLogin no
#StrictModes yes
```

重新启动 SSH 守护程序:

```sh
[vagrant@centos2 ~]$ sudo systemctl restart sshd
```

This does not disallow `local` root login, so in a pinch, you can still connect to a console (or plug a keyboard and mouse into the physical machine) and log in with the root user locally.

# 禁用密码(强制使用密钥)

因为我们在这台主机上有我们的公钥，我们不再需要允许基于密码的访问。

找到`PasswordAuthentication`线:

```sh
#PermitEmptyPasswords no
PasswordAuthentication yes
```

将此行改为`no`:

```sh
#PermitEmptyPasswords no
PasswordAuthentication no
```

重新启动 SSH 守护程序:

```sh
[vagrant@centos2 ~]$ sudo systemctl restart sshd
```

The eagle-eyed among you will have noticed that I already flipped this setting once, in the `Vagrantfile` at the start of this chapter. This was to allow us to use Vagrant as a learning experience, and we are effectively reversing the reversal right now.

# 设置当日消息(motd)

只要您的`PrintMotd`设置设置为`yes`，您就可以让用户在登录时看到`/etc/motd`的内容。

首先，确保在 SSH 守护程序配置中将其设置为`yes`:

```sh
#PermitTTY yes
PrintMotd yes
#PrintLastLog yes
```

接下来，重启 SSH 守护进程，然后将`/etc/motd`文件修改为合理的内容。或者，您可以使用以下命令:

```sh
sudo sh -c 'echo "This is a testing system, how did you get here?" > /etc/motd'
```

现在，只要您登录，就会打印此消息。

This feature is usually used by companies to warn bad actors who are attempting to gain access to their systems. Occasionally, it's used by bored system administrators to quote Futurama at you.

# 已用网络设置

我要介绍的最后一个选项是`UseDNS`条目，因为它是相当多的人的痛苦来源:

```sh
#UseDNS yes
UseDNS no
```

在这里，我们可以看到`UseDNS`在我们的配置文件中已经被显式设置为`no`。这是默认设置。

当设置为`no`时，SSH 守护程序将不会查找远程主机名，并根据该主机名检查远程 IP 是否映射回预期的 IP。

为了进一步迷惑你，这里是`UseDNS `的手动输入:

"Specifies whether sshd(8) should look up the remote host name, and to check that the resolved host name for the remote IP address maps back to the very same IP address.
If this option is set to no (the default) then only addresses and not host names may be used in ~/.ssh/authorized_keys from and sshd_config Match Host directives."

这意味着当`UseDNS`设置为`yes`时，并且您正在连接的机器没有反向 DNS 条目集，SSH 将尝试将其期望的 IP 与其看到的相匹配，并且可能无法做到这一点。

In practice, all this means is that if your DNS is broken on the box you're trying to connect to, you have to wait around like a lemon for a bit while the DNS request times out, and eventually let you in. To frustrate matters further, this feature is almost useless out of the box, as highlighted in this mailing list email: [https://lists.centos.org/pipermail/centos-devel/2016-July/014981.html](https://lists.centos.org/pipermail/centos-devel/2016-July/014981.html).

# 允许用户

我们已经拒绝了根用户对我们系统的访问，但是如果我们想更进一步，指定我们想要授予访问权限的用户呢？

为此，我们需要`AllowUsers`设置。

这很少是默认设置，甚至在`sshd_config`文件中被注释掉，所以我们将它添加到底部:

```sh
#       PermitTTY no
#       ForceCommand cvs server
AllowUsers vagrant
```

重新启动 SSH 守护程序:

```sh
[vagrant@centos2 ~]$ sudo systemctl restart sshd
```

现在，您有了一个只有`vagrant`用户才能 SSH 到的系统。你也可以在这个列表中添加多个名字，甚至用`DenyUsers`来代替这个白名单。

如果我们愿意，我们可以使用`AllowGroups`和`DenyGroups`在组的基础上工作(而不是单个用户名)。

# 它是如何工作的...

现在，我们已经完成并更改了一些常见的设置，我们将快速了解当您重新启动 SSH 守护程序时会发生什么。

SSH 的`systemd`单元文件看起来与此类似，尽管您的系统可能会有所不同:

```sh
[vagrant@centos2 ~]$ cat /etc/systemd/system/multi-user.target.wants/sshd.service 
[Unit]
Description=OpenSSH server daemon
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target sshd-keygen.service
Wants=sshd-keygen.service

[Service]
Type=notify
EnvironmentFile=/etc/sysconfig/sshd
ExecStart=/usr/sbin/sshd -D $OPTIONS
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartSec=42s

[Install]
WantedBy=multi-user.target
```

默认情况下，我们可以看到使用的二进制是`/usr/sbin/sshd`，而`$OPTIONS`是从其他地方传递过来的(在本例中是`EnvironmentFile`值，如前所列)。

阅读`sshd`手册，我们发现以下部分:

`-f config_file`选项([https://man.openbsd.org/sshd](https://man.openbsd.org/sshd))描述如下:

"Specifies the name of the configuration file. The default is /etc/ssh/sshd_config. sshd refuses to start if there is no configuration file."

在这里，我们有了为什么`sshd_config`被默认读取的答案——它被烤进去了。

# 还有更多...

我们只介绍了人们在为自己的环境配置 SSH 守护程序时倾向于更改的一些基本选项，但是大多数管理员根本不做任何更改，不管配置的默认值是什么。

# 请参见

为了更好地理解所有可用的守护程序选项，请通读`sshd_config`手册页，并查看`sshd`可执行文件的页面。

# 旋转主机密钥和更新已知主机

有一点我们还没有提到，那就是主机密钥和`known_hosts`文件。

这是一个经常被忽视的问题，所以我想花几分钟来看看这些被忽视的宝藏。

在本节中，我们将检查当您第一次 SSH 到一台新机器时会发生什么，然后我们将更改该机器的密钥，以查看这给我们带来了什么问题。

# 准备好

在不同的会话中连接到`centos1`和`centos2`:

```sh
$ vagrant ssh centos1 $ vagrant ssh centos2
```

如果您正在进行全新的设置，请从`centos1`SSH 到`centos2`，并在收到主机密钥时接受它。

注销`centos2`:

```sh
[vagrant@centos1 ~]$ ssh 192.168.33.11
The authenticity of host '192.168.33.11 (192.168.33.11)' can't be established.
ECDSA key fingerprint is SHA256:D4Tu/OykM/iPayCZ2okG0D2F6J9H5PzTNUuFzhzl/xw.
ECDSA key fingerprint is MD5:4b:2a:42:77:0e:24:b4:9c:6e:65:69:63:1a:57:e9:4e.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.33.11' (ECDSA) to the list of known hosts.
vagrant@192.168.33.11's password: 
[vagrant@centos2 ~]$ logout
Connection to 192.168.33.11 closed.
[vagrant@centos1 ~]$ 
```

我们现在在`known_hosts`文件中有一个条目，如下所示:

```sh
[vagrant@centos1 ~]$ cat .ssh/known_hosts 
192.168.33.11 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBOK52r7ZJ8hwU34RzaY3AD7HitT6UP2qBv3WK8lWEELSoeTsmJ4+zO8QiuULp3cCQBKYqi55Z60Vf/hsEMBoULg=
```

请注意，该 IP 和密钥位于`centos2`:

```sh
[vagrant@centos2 ~]$ cat /etc/ssh/ssh_host_ecdsa_key.pub 
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBOK52r7ZJ8hwU34RzaY3AD7HitT6UP2qBv3WK8lWEELSoeTsmJ4+zO8QiuULp3cCQBKYqi55Z60Vf/hsEMBoULg=
```

我们可以通过查看两台机器上的密钥指纹，并比较 ASCII 艺术来轻松证明这一点。

在`centos2`上，如下所示:

```sh
[vagrant@centos2 ~]$ ssh-keygen -lv -f /etc/ssh/ssh_host_ecdsa_key.pub 
256 SHA256:D4Tu/OykM/iPayCZ2okG0D2F6J9H5PzTNUuFzhzl/xw no comment (ECDSA)
+---[ECDSA 256]---+
|   . .       o.  |
|  . . o.    o..  |
| o . =. .  + o.  |
|. o o.+.    B  . |
|.  + +..S. o o E.|
|. + +o. oo. .  .o|
|.+ o +o ...     o|
|o.o . +*         |
|.    o=*=        |
+----[SHA256]-----+
```

并且从`centos1`上的`known_hosts`文件如下:

```sh
[vagrant@centos1 ~]$ ssh-keygen -lv -f .ssh/known_hosts 
256 SHA256:D4Tu/OykM/iPayCZ2okG0D2F6J9H5PzTNUuFzhzl/xw 192.168.33.11 (ECDSA)
+---[ECDSA 256]---+
|   . .       o.  |
|  . . o.    o..  |
| o . =. .  + o.  |
|. o o.+.    B  . |
|.  + +..S. o o E.|
|. + +o. oo. .  .o|
|.+ o +o ...     o|
|o.o . +*         |
|.    o=*=        |
+----[SHA256]-----+
```

That's genuinely the first time I've ever used the `-v` option to get the ASCII art out of a key for comparison purposes.

# 怎么做...

现在我们已经确认了我们的设置，我们将更改`centos2`上的主机键，看看会发生什么。

在`centos2`上，运行以下程序:

```sh
[vagrant@centos2 ~]$ sudo mv /etc/ssh/ssh_host_ecdsa_key* /home/vagrant/
[vagrant@centos2 ~]$ ls
ssh_host_ecdsa_key  ssh_host_ecdsa_key.pub
```

我们刚刚在`centos1`移动了我们认为是福音的钥匙。

Our session stays up because we're already authenticated and connected. If we were to disconnect at this point, we would have to accept a different set of keys (we moved the ECDSA keys, but there's still `Ed25519` host keys available, which SSH would pick up instead).

现在，我们将使用 catall`-A`标志生成一组新的密钥:

```sh
[vagrant@centos2 ~]$ sudo ssh-keygen -A
ssh-keygen: generating new host keys: RSA1 DSA ECDSA
```

我们可以通过检查目录来确认这些存在:

```sh
[vagrant@centos2 ~]$ ls -l /etc/ssh/ssh_host_ecdsa_key*
-rw-------. 1 root root 227 Aug  8 16:30 /etc/ssh/ssh_host_ecdsa_key
-rw-r--r--. 1 root root 174 Aug  8 16:30 /etc/ssh/ssh_host_ecdsa_key.pub
```

注销`centos2`并尝试重新登录:

```sh
[vagrant@centos1 ~]$ ssh 192.168.33.11
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that a host key has just been changed.
The fingerprint for the ECDSA key sent by the remote host is
SHA256:vdJTJW4ewGtOAdQXCXJ+cbjvrNm9787/CQQnCeM9fjc.
Please contact your system administrator.
Add correct host key in /home/vagrant/.ssh/known_hosts to get rid of this message.
Offending ECDSA key in /home/vagrant/.ssh/known_hosts:1
ECDSA host key for 192.168.33.11 has changed and you have requested strict checking.
Host key verification failed.
[vagrant@centos1 ~]$
```

宋承宪试图让你免于做坏事。因为它已经知道你试图连接的 IP，并且有一个`known_hosts`条目，它会将文件中的已知密钥与盒子中的密钥进行比较。

因为我们刚刚重新生成了盒子上的密钥，所以出现了一个看起来很可怕的错误。

It's worth getting over the mental block of just scoffing and working around this error. Try to lend yourself five seconds of thought and confirm that the error is expected. Too often, I've seen people immediately grumble when faced with this message and bypass it straight away. If you've already accepted the key on a box once, you shouldn't see a warning about it again, this can mean that the box has been tampered with, or your connection is being "man in the middle'd." Be vigilant!

从我们的`known_hosts`文件中清除旧密钥(其行位置在前面的代码中被加粗):

```sh
[vagrant@centos1 ~]$ ssh-keygen -R 192.168.33.11
# Host 192.168.33.11 found: line 1
/home/vagrant/.ssh/known_hosts updated.
Original contents retained as /home/vagrant/.ssh/known_hosts.olds 
```

您现在应该可以再次 SSH 到`centos2`并接受新密钥:

```sh
[vagrant@centos1 ~]$ ssh 192.168.33.11
The authenticity of host '192.168.33.11 (192.168.33.11)' can't be established.
ECDSA key fingerprint is SHA256:vdJTJW4ewGtOAdQXCXJ+cbjvrNm9787/CQQnCeM9fjc.
ECDSA key fingerprint is MD5:c3:be:16:5b:62:7f:4d:9c:0b:15:c0:cd:d6:87:d6:d6.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.33.11' (ECDSA) to the list of known hosts.
vagrant@192.168.33.11's password: 
Last login: Wed Aug  8 16:26:50 2018 from 192.168.33.10
[vagrant@centos2 ~]$ 
```

# 它是如何工作的...

我们使用的`ssh-keygen`命令是将期望的主机键放置在默认位置的快速方法。因为我们已经删除了预期的密钥，所以我们将无法连接到我们的主机，并被提示之前看到的可怕错误:

```sh
<SNIP>
debug1: Server host key: ecdsa-sha2-nistp256 SHA256:zW4PXt4o3VRA/OiePUc4VoxBY50us9vl2vemgcrLduA
debug3: hostkeys_foreach: reading file "/home/vagrant/.ssh/known_hosts"
debug3: record_hostkey: found key type ECDSA in file /home/vagrant/.ssh/known_hosts:1
debug3: load_hostkeys: loaded 1 keys from 192.168.33.11
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
<SNIP>
```

在前面的片段中，我们可以看到 SSH 检查我们的`known_hosts`文件，然后从远程主机获取密钥，最后抛出一个 fit。

要重新连接到主机，我们只需从客户端的`known_hosts`文件中删除违规条目，然后再次尝试连接。

We used `-R` to remove the offending key, but you can use any method to do so as it's just a text file. If you wish you can even empty the entire `known_hosts` file, but this will also mean you'll have to accept keys for every box you've ever connected to, once again.

# 还有更多...

那么，如果从服务器上删除所有主机密钥会发生什么？

这就是你得到的:

```sh
[vagrant@centos2 ~]$ sudo rm /etc/ssh/ssh_host_*
[vagrant@centos2 ~]$ logout
Connection to 192.168.33.11 closed.
[vagrant@centos1 ~]$ ssh  192.168.33.11 
ssh_exchange_identification: read: Connection reset by peer
```

此时，您可以重新配置虚拟机，或者通过控制台登录并生成新密钥。

# 技术要求

确认您的两个游民箱都已启用，并使用`vagrant`命令连接到这两个箱。

如果您以前更改过 SSH 配置文件，最好先销毁您的盒子并重新配置它们:

```sh
$ vagrant ssh centos1
$ vagrant ssh centos2
```

# 使用本地转发

本地转发是将本地 TCP 端口或 Unix 套接字映射到远程端口或套接字的行为。它通常用于安全访问系统(通过要求用户首先对盒子进行 SSH，从而加密他们的连接)，或者用于故障排除。

在本节中，我们将在`centos2`上启动一个小的`webserver`，我们将从`centos1`连接到这个小的`webserver`，首先通过直接连接到 IP 和端口，然后通过连接到映射的本地端口，利用端口转发。

# 准备好

在`centos2`上，运行以下命令:

```sh
[vagrant@centos2 ~]$ python -m SimpleHTTPServer 8888
Serving HTTP on 0.0.0.0 port 8888 ...
```

你刚刚创建了一个基于 Python 的小型网络服务器，监听端口`8888`的每个地址。

您可以通过从`centos1`运行`curl`命令来确认这一点:

```sh
[vagrant@centos1 ~]$ curl 192.168.33.11:8888
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><html>
<title>Directory listing for /</title>
<body>
<h2>Directory listing for /</h2>
<hr>
<ul>
<li><a href=".bash_logout">.bash_logout</a>
<li><a href=".bash_profile">.bash_profile</a>
<li><a href=".bashrc">.bashrc</a>
<li><a href=".ssh/">.ssh/</a>
</ul>
<hr>
</body>
</html>
```

请注意`centos2`中主目录内容的列表。

在`centos2`上，你应该看到你的连接(`200`响应):

```sh
[vagrant@centos2 ~]$ python -m SimpleHTTPServer 8888
Serving HTTP on 0.0.0.0 port 8888 ...
192.168.33.10 - - [09/Aug/2018 10:47:13] "GET / HTTP/1.1" 200 -
```

Python's built-in web server module is very handy for testing. I used it here because it's available out of the box in our installation, but I wouldn't use it in a production environment, as there are better (and faster) alternatives.

要确认我们尚未在端口`9999`上获得任何本地监听，请从`centos1`执行另一个`curl`命令:

```sh
[vagrant@centos1 ~]$ curl 127.0.0.1:9999
curl: (7) Failed connect to 127.0.0.1:9999; Connection refused
```

# 怎么做...

我们将本地转发连接到本地端口`9999`到远程端口`8888`。

# 在命令行上

从`centos1`开始运行以下内容:

```sh
[vagrant@centos1 ~]$ ssh -f -L 9999:127.0.0.1:8888 192.168.33.11 sleep 120
```

系统可能会提示您输入密码(取决于您在按键设置方面所做的工作)，然后返回`centos1`提示。

我们的 SSH 连接将保持两分钟。

现在，我们运行`curl`，检查我们的转发是否正常:

```sh
[vagrant@centos1 ~]$ curl 127.0.0.1:9999
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><html>
<title>Directory listing for /</title>
<body>
<h2>Directory listing for /</h2>
<hr>
<ul>
<li><a href=".bash_history">.bash_history</a>
<li><a href=".bash_logout">.bash_logout</a>
<li><a href=".bash_profile">.bash_profile</a>
<li><a href=".bashrc">.bashrc</a>
<li><a href=".ssh/">.ssh/</a>
</ul>
<hr>
</body>
</html>
```

成功！这里，我们在转发端口上卷曲`centos1`的本地主机 IP 地址，我们从`centos2`获得目录列表！

# 使用 SSH 配置文件

如果我们想在每次连接到`centos2`时创建这个转发设置，我们可以将该选项添加到 SSH 配置文件中。

在下面的代码中添加加粗的行:

```sh
Host * !CentOS2-V6
 IdentityFile ~/.ssh/id_ed25519
 Port 22

Host CentOS2-V4
 Hostname 192.168.33.11
 LocalForward 9999 127.0.0.1:8888
 User vagrant

Host CentOS2-V6
 Hostname fe80::a00:27ff:fe56:c5a7%%eth1
 IdentityFile ~/.ssh/id_rsa
 Port 22
 User vagrant

Host CentOS2-Hostname
 Hostname centos2
 User vagrant
```

现在，如果您 SSH 到指定的主机，您将创建一个转发连接，而不必指定它:

```sh
[vagrant@centos1 ~]$ ssh -f CentOS2-V4 sleep 120
[vagrant@centos1 ~]$ curl 127.0.0.1:9999
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><html>
<title>Directory listing for /</title>
<body>
<h2>Directory listing for /</h2>
<hr>
<ul>
<li><a href=".bash_history">.bash_history</a>
<li><a href=".bash_logout">.bash_logout</a>
<li><a href=".bash_profile">.bash_profile</a>
<li><a href=".bashrc">.bashrc</a>
<li><a href=".ssh/">.ssh/</a>
</ul>
<hr>
</body>
</html>
```

每个主机不仅限于一个`LocalForward`条目，您可以有几个。

# 它是如何工作的...

当您在 SSH 中使用`-L`标志时，您指定在列出的第一个端口上对本地机器进行的任何连接尝试都将被转发到远程主机和端口。

让我们分解命令:

```sh
[vagrant@centos1 ~]$ ssh -f -L 9999:127.0.0.1:8888 192.168.33.11 sleep 120
```

首先，命令末尾的`-f`和`sleep 120`是在我们执行测试时创建会话并将其作为背景的快速方法:

```sh
-f ... sleep 120
```

In the real world, you're not limited to just one Terminal window, and generally, you'll find yourself opening a session to a remote host in one window while you work in another.

第二部分是有趣的部分:

```sh
-L 9999:127.0.0.1:8888
```

这里，我们说本地端口`9999`应该有任何连接请求被转发到`127.0.0.1:8888`上的远程主机。

由于我们创建 web 服务器的方式，下面也是有效的语法:

```sh
-L 9999:192.168.33.11:8888
```

这是因为我们的远程网络服务器正在监听所有地址，所以我们没有将请求发送到远程本地主机地址，而是使用`eth1`地址。

I've frequently seen setups where less secure programs are run on the localhost address only, meaning that if you want to access the program, you have to SSH to the remote host first. You're also not limited to cURL and the command line—you could navigate to `http://127.0.0.1:9999` in your web browser, and it would still work.

# 还有更多...

SSH 的提示和技巧有点没完没了，但是下面的内容可以很好地练习。

# 观看我们的 SSH 会话

如果您想查看 SSH 隧道何时关闭，请运行以下命令:

```sh
[vagrant@centos1 ~]$ ps aux | grep "ssh -f" | grep -v grep
vagrant   3525  0.0  0.2  82796  1196 ?        Ss   11:03   0:00 ssh -f -L 9999:127.0.0.1:8888 192.168.33.11 sleep 120
```

断开连接后，此过程将结束:

```sh
[vagrant@centos1 ~]$ ps aux | grep "ssh -f" | grep -v grep
[vagrant@centos1 ~]$ 
```

# 连接到远程主机以外的系统

`LocalForwarding`甚至可以用来访问远程机器可以看到的主机，但是你的本地机器不能。

考虑以下配置条目:

```sh
Host *
 IdentityFile ~/.ssh/id_ed25519
 Port 22

Host CentOS2-V4
 Hostname 192.168.33.11
 LocalForward 7777 192.168.33.12:6666
 User vagrant
```

在这个例子中，`centos2`可以看到带有 IP `192.168.33.12`的主机，以及它在端口`6666`上监听的服务器。

当我们连接到`centos2`并创建隧道时，我们可以本地连接到`127.0.0.1:7777`，在`192.168.33.12:6666`上查看网络服务器。

This is widely used in conjunction with bastion hosts, which we will look at soon.

# 请参见

将本地连接尝试转发到远程主机可能是一种非常有用的故障排除和访问控制方法。

查看 SSH 手册页，了解本食谱中列出的选项的更多详细信息和扩展。

在大多数 Linux 系统上，可以使用以下命令调出 SSH 手册页:

```sh
$ man ssh
```

# 使用远程转发

在前一节中，我们研究了将本地连接尝试转发到远程机器的能力。

在本节中，我们将看一些非常相似的东西:远程转发。

通过远程转发，对远程计算机上指定地址和端口的连接尝试通过您设置的 SSH 隧道传递回来，并在本地计算机(您的客户端)上进行处理。

从`centos1`开始。

Before we start it's worth noting that remote forwarding is a great way to punch holes out of networks, which means that it can also be a nightmare for security professionals charged with maintaining a network. With great power comes great etc.

# 准备好

确认您的两个游民箱都已启用，并连接到两个:

```sh
$ vagrant ssh centos1
$ vagrant ssh centos2
```

# 怎么做...

首先，我们将从在提示符下使用单个命令开始，然后我们将了解如何使用 SSH 配置文件设置每次 SSH 到机器的连接。

# 在命令行上

在`centos1`上，运行以下程序:

```sh
[vagrant@centos1 ~]$ ssh -R 5353:127.0.0.1:22 192.168.33.11
```

一旦连接到`centos2`，运行以下程序:

```sh
[vagrant@centos2 ~]$ ssh 127.0.0.1 -p5353
```

可能会提示您添加主机密钥，然后提示您输入密码。我们正在连接回`centos1`，所以请提供默认的游民密码。

您应该会看到`centos1`命令行提示:

```sh
vagrant@127.0.0.1's password: 
Last login: Thu Aug  9 12:29:56 2018 from 127.0.0.1
[vagrant@centos1 ~]$ 
```

# 使用 SSH 配置文件

和`LocalForward`一样，我们也可以为`RemoteForward`连接使用 SSH 配置文件:

```sh
Host *
 IdentityFile ~/.ssh/id_ed25519
 Port 22

Host CentOS2-V4
 Hostname 192.168.33.11
 LocalForward 9999 127.0.0.1:8888
 RemoteForward 5353 127.0.0.1:22
 User vagrant
```

在这里，您可以看到我们在命令行部分使用的确切设置，仅在配置文件中指定，因此它总是可用的，而不必每次都键入标志:

```sh
[vagrant@centos1 ~]$ ssh CentOS2-V4
[vagrant@centos2 ~]$ ssh 127.0.0.1 -p5353
[vagrant@centos1 ~]$ 
```

# 它是如何工作的...

我们在这里真正做的是...奇怪:

1.  我们将 SSH 连接到`centos2`，同时表示对远程机器(`centos2`)上端口`5353`的任何连接尝试都将通过 SSH 会话传递回我们的客户端(`centos1`)。
2.  然后，我们在我们的远程机器(`centos2`)上运行 SSH，指定本地主机地址和我们传递回`centos1`、`127.0.0.1:5353`的端口。

3.  连接尝试通过我们建立的 SSH 会话传递回`centos1`，SSH 服务器接受连接请求。
4.  因此，我们通过在`centos2`上指定本地地址和远程转发端口来本地 SSH 到`centos1`。

迷茫？我是第一次有人向我解释这个。

为了更好地理解这一点，我们可以使用`w`命令。

在`centos1`上，这给了我们以下内容:

```sh
[vagrant@centos1 ~]$ w
 12:47:50 up  2:10,  2 users,  load average: 0.00, 0.02, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
vagrant  pts/0    10.0.2.2         10:38    6.00s  1.07s  0.08s ssh -R 5353:127.0.0.1:22 192.168.33.
vagrant  pts/1    127.0.0.1        12:44    6.00s  0.07s  0.05s w
```

在这里，我们可以看到我们默认的游民连接(从`10.0.2.2`开始)，但我们也可以看到一个本地连接。

显然，我们已经从本地主机地址(`127.0.0.1`)SSH 到我们的机器。这实际上是我们在`centos2`上使用以下命令建立的 SSH 会话:

```sh
[vagrant@centos2 ~]$ ssh 127.0.0.1 -p5353
```

在`centos2`上，`w`命令给出了如下信息:

```sh
[vagrant@centos2 ~]$ w
 12:48:08 up  2:09,  2 users,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
vagrant  pts/0    10.0.2.2         10:43    0.00s  0.92s  0.04s w
vagrant  pts/1    192.168.33.10    12:44   24.00s  0.07s  0.04s ssh 127.0.0.1 -p5353
```

在这里，我们可以看到我们默认的游民连接(从`10.0.2.2`开始)，但是我们也可以看到来自`centos1` ( `192.168.33.10`)的远程连接。

# 还有更多...

这不仅可以用于 SSH。同样，我们可以将端口从远程会话转发到本地机器，我们有丰富的选择。

让我们在`centos1`上启动并后台一个简单的 web 服务器:

```sh
[vagrant@centos1 ~]$ python -m SimpleHTTPServer 8888 &
[1] 6010
```

现在，让我们 SSH 到`centos2`，同时声明在远程机器上向`127.0.0.1:7777`发出的任何请求都将沿着已建立的 SSH 会话传递回`centos1`:

```sh
[vagrant@centos1 ~]$ ssh -R 7777:127.0.0.1:8888 192.168.33.11
```

在`centos2`上，我们现在应该可以`curl 127.0.0.1:7777`并在`centos1`上看到游民的主目录内容:

```sh
[vagrant@centos2 ~]$ curl 127.0.0.1:7777
127.0.0.1 - - [09/Aug/2018 12:56:43] "GET / HTTP/1.1" 200 -
 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><html>
<title>Directory listing for /</title>
<body>
<h2>Directory listing for /</h2>
<hr>
<ul>
<li><a href=".bash_history">.bash_history</a>
<li><a href=".bash_logout">.bash_logout</a>
<li><a href=".bash_profile">.bash_profile</a>
<li><a href=".bashrc">.bashrc</a>
<li><a href=".ssh/">.ssh/</a>
</ul>
<hr>
</body>
</html>
```

成功！

# 请参见

虽然这看起来用途有限，但就俏皮的技巧而言，你可能会在职业生涯中发现一些奇怪的案例。

我曾经在一两个场合使用过这种方法，当远程机器上的域名系统被破坏时，我会通过一个已建立的 SSH 连接将域名系统请求转发回去。

# 代理跳转和堡垒主机

我们将看一看一个非常新的 SSH 选项，一个稍旧的 SSH 选项，以及这个食谱中堡垒主机(或跳转框)的概念。

我们需要三台机器，因为我们将使用一台机器作为通往另一台机器的“门户”。

# 准备好

设置您的三个虚拟机，最好使用本章顶部的`Vagrantfile`。

连接到每个盒子，然后检查从`centos1`开始，你可以 ping `centos2`和`centos3`:

```sh
[vagrant@centos1 ~]$ ping 192.168.33.11
PING 192.168.33.11 (192.168.33.11) 56(84) bytes of data.
64 bytes from 192.168.33.11: icmp_seq=1 ttl=64 time=2.54 ms
64 bytes from 192.168.33.11: icmp_seq=2 ttl=64 time=1.09 ms
64 bytes from 192.168.33.11: icmp_seq=3 ttl=64 time=0.929 ms
^C
--- 192.168.33.11 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2009ms
rtt min/avg/max/mdev = 0.929/1.524/2.548/0.728 ms
[vagrant@centos1 ~]$ ping 192.168.33.12
PING 192.168.33.12 (192.168.33.12) 56(84) bytes of data.
64 bytes from 192.168.33.12: icmp_seq=1 ttl=64 time=0.743 ms
64 bytes from 192.168.33.12: icmp_seq=2 ttl=64 time=1.15 ms
64 bytes from 192.168.33.12: icmp_seq=3 ttl=64 time=1.12 ms
^C
--- 192.168.33.12 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2015ms
rtt min/avg/max/mdev = 0.743/1.008/1.157/0.187 ms
```

如果你使用的是所提供的`Vagrantfile`，这些在`192.168.33.11`和`192.168.33.12`上。

# 怎么做...

从`centos1`开始，运行以下命令:

```sh
[vagrant@centos1 ~]$ ssh -J vagrant@192.168.33.11:22 192.168.33.12
```

系统可能会提示您接受密钥，并询问您的密码。

你会发现自己在`centos3`上，已经跳过了`centos2`:

```sh
[vagrant@centos3 ~]$ 
```

# 使用 SSH 配置文件

通过在 SSH 配置文件中指定`ProxyJump`选项，可以使用相同的技巧:

```sh
Host *
 IdentityFile ~/.ssh/id_ed25519
 Port 22

Host CentOS2-V4
 Hostname 192.168.33.11
 User vagrant

Host CentOS3-V4
 Hostname 192.168.33.12
 User vagrant
 ProxyJump CentOS2-V4
```

现在可以通过`centos2`SSH 到`centos3`:

```sh
[vagrant@centos1 ~]$ ssh CentOS3-V4
vagrant@192.168.33.11's password: 
vagrant@192.168.33.12's password: 
Last login: Thu Aug  9 14:15:03 2018 from 192.168.33.11
[vagrant@centos3 ~]$ 
```

# 它是如何工作的...

`-J`和`ProxyJump`选项是通过指定主机连接到其他主机的一种方式。

`-J [user@]host[:port]`的官方手册页([https://man.openbsd.org/ssh](https://man.openbsd.org/ssh))的手册条目如下:

Connect to the target host by first making a ssh connection to the jump host described by destination and then establishing a TCP forwarding to the ultimate destination from there. Multiple jump hops may be specified separated by comma characters. This is a shortcut to specify a ProxyJump configuration directive.

从[https://man.openbsd.org/ssh_config](https://man.openbsd.org/ssh_config)到`ProxyJump`的手动输入如下:

Specifies one or more jump proxies as either [user@]host[:port] or an ssh URI. Multiple proxies may be separated by comma characters and will be visited sequentially. Setting this option will cause ssh(1) to connect to the target host by first making a ssh(1) connection to the specified ProxyJump host and then establishing a TCP forwarding to the ultimate target from there.

如果我们在 SSH 中使用`-v`标志，我们可以更详细地看到发生了什么:

```sh
[vagrant@centos1 ~]$ ssh -v CentOS3-V4
OpenSSH_7.4p1, OpenSSL 1.0.2k-fips  26 Jan 2017
debug1: Reading configuration data /home/vagrant/.ssh/config
debug1: /home/vagrant/.ssh/config line 1: Applying options for *
debug1: /home/vagrant/.ssh/config line 8: Applying options for CentOS3-V4
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 58: Applying options for *
debug1: Setting implicit ProxyCommand from ProxyJump: ssh -v -W %h:%p CentOS2-V4
debug1: Executing proxy command: exec ssh -v -W 192.168.33.12:22 CentOS2-V4
<SNIP>
debug1: permanently_drop_suid: 1000
OpenSSH_7.4p1, OpenSSL 1.0.2k-fips  26 Jan 2017
debug1: Reading configuration data /home/vagrant/.ssh/config
debug1: /home/vagrant/.ssh/config line 1: Applying options for *
debug1: /home/vagrant/.ssh/config line 4: Applying options for CentOS2-V4
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 58: Applying options for *
debug1: Connecting to 192.168.33.11 [192.168.33.11] port 22.
debug1: Connection established.
debug1: key_load_public: No such file or directory
<SNIP>
debug1: kex_input_ext_info: server-sig-algs=<rsa-sha2-256,rsa-sha2-512>
debug1: SSH2_MSG_SERVICE_ACCEPT received
debug1: Authentications that can continue: publickey,gssapi-keyex,gssapi-with-mic,password
debug1: Next authentication method: gssapi-keyex
debug1: No valid Key exchange context
debug1: Next authentication method: gssapi-with-mic
debug1: Unspecified GSS failure.  Minor code may provide more information
No Kerberos credentials available (default cache: KEYRING:persistent:1000)

debug1: Unspecified GSS failure.  Minor code may provide more information
No Kerberos credentials available (default cache: KEYRING:persistent:1000)

debug1: Next authentication method: publickey
debug1: Trying private key: /home/vagrant/.ssh/id_rsa
debug1: Trying private key: /home/vagrant/.ssh/id_dsa
debug1: Trying private key: /home/vagrant/.ssh/id_ecdsa
debug1: Trying private key: /home/vagrant/.ssh/id_ed25519
debug1: Next authentication method: password
vagrant@192.168.33.11's password: 
debug1: Authentication succeeded (password).
Authenticated to 192.168.33.11 ([192.168.33.11]:22).
debug1: channel_connect_stdio_fwd 192.168.33.12:22
debug1: channel 0: new [stdio-forward]
debug1: getpeername failed: Bad file descriptor
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: network
debug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Remote protocol version 2.0, remote software version OpenSSH_7.4
debug1: match: OpenSSH_7.4 pat OpenSSH* compat 0x04000000
debug1: Authenticating to 192.168.33.12:22 as 'vagrant'
debug1: SSH2_MSG_KEXINIT sent
debug1: SSH2_MSG_KEXINIT received
debug1: kex: algorithm: curve25519-sha256
debug1: kex: host key algorithm: ecdsa-sha2-nistp256
debug1: kex: server->client cipher: chacha20-poly1305@openssh.com MAC: <implicit> compression: none
debug1: kex: client->server cipher: chacha20-poly1305@openssh.com MAC: <implicit> compression: none
debug1: kex: curve25519-sha256 need=64 dh_need=64
debug1: kex: curve25519-sha256 need=64 dh_need=64
debug1: expecting SSH2_MSG_KEX_ECDH_REPLY
<SNIP>
vagrant@192.168.33.12's password: 
debug1: Authentication succeeded (password).
Authenticated to 192.168.33.12 (via proxy).
debug1: channel 0: new [client-session]
debug1: Requesting no-more-sessions@openssh.com
debug1: Entering interactive session.
debug1: pledge: proc
debug1: client_input_global_request: rtype hostkeys-00@openssh.com want_reply 0
debug1: Sending environment.
debug1: Sending env LANG = en_GB.UTF-8
Last login: Thu Aug  9 14:22:08 2018 from 192.168.33.11
[vagrant@centos3 ~]$
```

在前面的输出中，我们可以看到连接序列中发生的关键步骤:

1.  SSH 读取我们正在连接的主机的配置。
2.  SSH 意识到它必须使用一个`ProxyJump`主机来访问指定的盒子。
3.  SSH 将`ProxyJump`选项翻译成等效的`ProxyCommand`条目。
4.  SSH 读取`ProxyJump`主机的配置。
5.  SSH 连接并验证`ProxyJump`主机。
6.  SSH 使用其与`ProxyJump`建立的连接来连接到目的主机。
7.  SSH 注意到它已经通过了目标主机的身份验证(通过代理)。

# 还有更多...

现在您已经了解了`ProxyJump`的基础知识，让我们来看看一些您可能会发现有用的场景。

不止一次，以下列方式使用`ProxyJump`节省了我几毫秒的时间！

# 多台主机

虽然前面给出的例子相对简单，但值得注意的是，您可以使用`ProxyJump`做一些相当复杂的事情。

您可以按照手册页的建议列出主机，也可以链接主机，如下所示:

```sh
Host *
 Port 22

Host CentOS2-V4
 Hostname 192.168.33.11
 User vagrant

Host CentOS3-V4
 Hostname 192.168.33.12
 User vagrant
 ProxyJump CentOS2-V4

Host CentOS4-V4
 Hostname 192.168.33.14
 User vagrant
 ProxyJump CentOS3-V4
```

`ProxyJump`本身的优势应该是显而易见的:使用这种技术，您可以创建一个设置，在该设置中，只需从您的本地机器发出一个命令就可以访问远程的、否则无法访问的盒子。

通常，您可以在具有一台入口服务器的环境中使用`ProxyJump`。

`ProxyJump` also makes forwarding ports easier. If you add a `LocalForward` line to `CentOS4-V4` in the preceding code, SSH will take care of handling the traffic through the `ProxyJump` hosts, too! This can be especially handy as it stops you having to forward ports manually, potentially through several hosts.

# ProxyCommand(代理命令)

我们在调试消息中看到的是 SSH 将相当简单的`ProxyJump`条目翻译成`ProxyCommand`行。

`ProxyCommand`是比较传统的设置这种转发的方式，但不仅语法上比较气人，还比较乱。

考虑以下示例:

```sh
Host *
 Port 22

Host CentOS2-V4
 Hostname 192.168.33.11
 User vagrant

Host CentOS3-V4
 Hostname 192.168.33.12
 User vagrant
 ProxyCommand ssh -v -W %h:%p CentOS2-V4
```

看起来更尴尬，不是吗？但它的工作原理是一样的。

这在较旧的发行版上可能很有用，它们可能还没有获得`ProxyJump`特性。

If you ever forget the syntax for `ProxyCommand` and you have a box around that supports `ProxyJump`, remember that the `ProxyCommand` syntax is printed for you in the `SSH -v` debug we created before.

# 堡垒主机

所有这些都很好，但是如果您管理服务器，为什么需要这些呢？尤其是你控制的服务器...

考虑你的环境。

在办公室里，你可能可以访问公司控制下的每一台机器，因为你坐在一个局域网上，可以不受限制地访问所有其他网段。

在远程，您的网络边界上可能有一台虚拟专用网机器，在能够 SSH 到其他机器之前，您需要首先建立到该机器的连接。

堡垒主机是您可能会考虑的东西，它们可以与虚拟专用网结合使用。

作为系统管理员，您可以决定希望人们 SSH 到机器的单一入口点，以便轻松记录流量并管理密钥，这可能是因为您只是出于报复，希望每个人的配置文件都那么长？

与您的网络团队合作，咨询您公司的政策，并设计一个您可以轻松维护的网络，其他人不会介意使用。

Your company may have specific security policies in place that limit what you're allowed to do. Remember, it's not about what you *can* do, it's about what you should do. No one will congratulate you for being clever when you're being marched out of the office for bypassing security. By all means highlight security problems when you see them, just don't exploit them.

# 使用 SSH 创建一个 SOCKS 代理

SSH 很棒。

我永远不会厌倦谈论它有多棒，如果我不提它的一个最好的特性:快速轻松地设置 SOCKS 代理的能力，那将是我的失职。

在前面的部分中，我们转发了单个端口，但是如果我们使用一个堡垒主机来连接网络中的多个不同网站，会怎么样呢？您想在 SSH 配置文件中添加几十行吗？还是每次手动键入每个端口并映射？

我不这么认为。

这就是`-D`旗的由来。

参见 SSH 手册页中的`-D [bind_address:]port`([https://man.openbsd.org/ssh](https://man.openbsd.org/ssh)):

Specifies a local "dynamic" application-level port forwarding. This works by allocating a socket to listen to port on the local side, optionally bound to the specified bind_address. Whenever a connection is made to this port, the connection is forwarded over the secure channel, and the application protocol is then used to determine where to connect to from the remote machine. Currently the SOCKS4 and SOCKS5 protocols are supported, and ssh will act as a SOCKS server. Only root can forward privileged ports. Dynamic port forwardings can also be specified in the configuration file.
IPv6 addresses can be specified by enclosing the address in square brackets. Only the superuser can forward privileged ports. By default, the local port is bound in accordance with the GatewayPorts setting. However, an explicit bind_address may be used to bind the connection to a specific address. The bind_address of "localhost" indicates that the listening port be bound for local use only, while an empty address or '*' indicates that the port should be available from all interfaces.

这意味着只需一个命令，您就可以建立一个连接，然后通过它(从网络浏览器或其他支持`SOCKS`代理的应用程序)转发流量。您不必在防火墙上打孔，也不必手动映射端口。

`SOCKS` itself is an internet protocol, and quite an old one at that, though we still actively use `SOCKS5`, which was approved by the Internet Engineering Task Force in 1996! It's like any other proxy server, allowing you to exchange packets over a connection; in this case, our SSH tunnel. Applications may choose to natively support SOCKS proxies or not, but a lot of commons ones will (Firefox, for example).

我们开始吧。

# 准备好了

在本节中，我们将使用`centos1`和`centos2`。

确保您有一个对两台机器开放的连接:

```sh
$ vagrant ssh centos1
$ vagrant ssh centos2
```

在`centos2`上，让我们再次设置我们的小型网络服务器:

```sh
[vagrant@centos2 ~]$ python -m SimpleHTTPServer 8888 &
[1] 7687
```

# 怎么做...

连接到`centos1`，在这里我们将首先使用一个命令设置我们的 SOCKS 代理，然后看看每次 SSH 到盒子时如何启动代理。

# 在命令行上

让我们建立 SSH 会话，同时断开已建立的会话:

```sh
[vagrant@centos1 ~]$ ssh -f -D9999 192.168.33.11 sleep 120
vagrant@192.168.33.11's password: 
[vagrant@centos1 ~]$ 
```

一旦建立(直到睡眠结束)，我们可以使用我们的代理来查询`centos2`通过 SSH 会话可以看到的任何东西。

让我们在`centos2`上查看我们的网络服务器，从`centos1`开始:

```sh
[vagrant@centos1 ~]$ all_proxy="socks5://127.0.0.1:9999" curl 127.0.0.1:8888
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><html>
<title>Directory listing for /</title>
<body>
<h2>Directory listing for /</h2>
<hr>
<ul>
<li><a href=".bash_history">.bash_history</a>
<li><a href=".bash_logout">.bash_logout</a>
<li><a href=".bash_profile">.bash_profile</a>
<li><a href=".bashrc">.bashrc</a>
<li><a href=".lesshst">.lesshst</a>
<li><a href=".mysql_history">.mysql_history</a>
<li><a href=".ssh/">.ssh/</a>
</ul>
<hr>
</body>
</html>
[vagrant@centos1 ~]$
```

太棒了！我们已经针对本地主机地址运行了一个 cURL，但是通过代理传递它，我们的请求已经针对`centos2`运行了！

# 使用 SSH 配置文件

如前所示，通过使用 SSH 配置文件也可以实现同样的目的:

```sh
Host *
 Port 22

Host CentOS2-V4
 Hostname 192.168.33.11
 User vagrant
 DynamicForward 9999
```

我们现在可以确信，每次连接时，我们的代理都是可用的:

```sh
[vagrant@centos1 ~]$ ssh -f CentOS2-V4 sleep 120
```

再来看看 web 服务器的内容:

```sh
[vagrant@centos1 ~]$ all_proxy="socks5://127.0.0.1:9999" curl 127.0.0.1:8888
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><html>
<title>Directory listing for /</title>
<body>
<h2>Directory listing for /</h2>
<hr>
<ul>
<li><a href=".bash_history">.bash_history</a>
<li><a href=".bash_logout">.bash_logout</a>
<li><a href=".bash_profile">.bash_profile</a>
<li><a href=".bashrc">.bashrc</a>
<li><a href=".lesshst">.lesshst</a>
<li><a href=".mysql_history">.mysql_history</a>
<li><a href=".ssh/">.ssh/</a>
</ul>
<hr>
</body>
</html>
```

为了证明我们确实在使用代理，让我们在没有建立会话的情况下尝试`curl`命令(您必须等待 SSH 超时，或者如果进程还没有死亡，则终止该进程):

```sh
[vagrant@centos1 ~]$ all_proxy="socks5://127.0.0.1:9999" curl 127.0.0.1:8888
curl: (7) Failed connect to 127.0.0.1:9999; Connection refused
```

# 它是如何工作的...

当您将`-D`选项添加到 SSH，或者将`DynamicForward`选项添加到您的 SSH 配置文件中时，您是在告诉 SSH 您想要在您的`local`端指定一个端口，该端口将转发通过您的 SSH 连接收到的任何请求。

让我们分解我们的命令:

```sh
[vagrant@centos1 ~]$ ssh -f -D9999 192.168.33.11 sleep 120
```

首先，正如我们之前所做的，我们使用`-f`和睡眠来保持连接打开，同时一旦连接建立，我们返回到`centos1`提示:

```sh
-f ... sleep 120
```

我们还用随机选择的端口指定了我们的`-D`选项:

```sh
-D9999
```

I use `9999` through force of habit, but occasionally I mix it up a bit by using `7777`, or even `6666` if I'm feeling really wild. You may use whichever port you wish (above `1024`, as those below this can only be used by root.)

一旦我们建立，我们使用以下命令来检查我们的代理是否可用:

```sh
[vagrant@centos1 ~]$ all_proxy="socks5://127.0.0.1:9999" curl 127.0.0.1:8888
```

把它分成两部分，我们从为这次运行设置的变量开始:

```sh
all_proxy="socks5://127.0.0.1:9999"
```

cURL 使用`all_proxy`作为为其运行设置 SOCKS 代理的方式。

在你的浏览器中，你可以在设置下找到设置`SOCKS`服务器的选项，在其他一些应用中，可以在需要的时候配置`SOCKS`代理。Gnome 的网络管理器如下所示:

![](img/5dcbe70c-ae11-4f6b-a090-19800aa7a1a0.png)

我们命令的另一部分是`curl`:

```sh
curl 127.0.0.1:8888
```

通过我们的`all_proxy`设置，cURL 知道使用端口`9999`上的 SOCKS 代理进行连接，这意味着当我们查询`127.0.0.1:8888`时，我们通过 SSH 会话发送该请求以在`centos2`上进行解析。

整洁！

# 还有更多...

如果你想更进一步，看看在你的远端使用`tcpdump`来检查通过你的网络的流量:

```sh
[vagrant@centos2 ~]$ sudo tcpdump port 8888 -ilo -n
```

你应该看到交通流量通过:

```sh
<SNIP>
15:18:48.991652 IP 127.0.0.1.54454 > 127.0.0.1.ddi-tcp-1: Flags [F.], seq 79, ack 618, win 700, options [nop,nop,TS val 16534669 ecr 16534658], length 0
15:18:48.991677 IP 127.0.0.1.ddi-tcp-1 > 127.0.0.1.54454: Flags [.], ack 80, win 683, options [nop,nop,TS val 16534669 ecr 16534669], length 0
<SNIP>
```

# 理解和使用 SSH 代理

我们简短地谈到的一件事是 SSH 代理的概念。

当您 SSH 到服务器(设置密钥后)并且系统提示您输入密码时，您实际上正在做的是解密您的公钥-私钥对的私钥部分(默认情况下是`id_rsa`文件)，这样它就可以用来验证您是您所说的那个对抗远程主机的人。每次 SSH 到服务器时，这样做可能会很乏味，尤其是当您管理数百或数千个不断变化的盒子时。

这就是 SSH 代理进来的地方。在会话期间，一旦您给了私钥密码，它们就在某个地方供您现在解密的私钥使用。

一旦您将私钥加载到代理中，代理就负责将密钥呈现给您连接到的任何服务器，而无需您再次键入密码，从而节省宝贵的时间和手指疲劳。

大多数桌面 Linux 发行版会在您的用户会话中启动某种 SSH 代理，有时会在您登录到您的用户帐户时解锁您的私钥。

macOS 为`UseKeychain`([https://developer . apple . com/library/archive/technotes/TN 2449/_ index . html](https://developer.apple.com/library/archive/technotes/tn2449/_index.html))提供了特定的 SSH 配置文件选项:

"On macOS, specifies whether the system should search for passphrases in the user's keychain when attempting to use a particular key. When the passphrase is provided by the user, this option also specifies whether the passphrase should be stored into the keychain once it has been verified to be correct. The argument must be "yes" or "no". The default is "no"."

如果你在桌面上运行苹果操作系统，你可以考虑这个选项。

在我安装的 Ubuntu 笔记本电脑上，寻找一个正在运行的代理揭示了这一点:

```sh
$ env | grep SSH
SSH_AUTH_SOCK=/run/user/1000/keyring/ssh
SSH_AGENT_PID=1542
```

寻找这个进程标识显示我的`ssh-agent`正在运行什么:

```sh
adam 1542 0.0 0.0 11304 320 ? Ss Aug04 0:02 /usr/bin/ssh-agent /usr/bin/im-launch env GNOME_SHELL_SESSION_MODE=ubuntu gnome-session --session=ubuntu
```

在本节中，我们将在`centos1`上启动一个 SSH 代理，并向其中加载一个密钥。

# 准备好

与前一部分一样，确认两个游民箱都已启用，并使用`vagrant`命令连接到第一个:

```sh
$ vagrant ssh centos1
```

确保您在`centos1`上有可用的 SSH 密钥。如果需要，请重新阅读前面关于生成 SSH 密钥的部分:

```sh
[vagrant@centos1 ~]$ ls .ssh/
authorized_keys  config  id_ed25519  id_ed25519.pub  known_hosts
```

如果还没有，将您的密钥复制到`centos2`，如果需要，接受主机密钥:

```sh
[vagrant@centos1 ~]$ ssh-copy-id 192.168.33.11
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/home/vagrant/.ssh/id_ed25519.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
vagrant@192.168.33.11's password: 

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh '192.168.33.11'"
and check to make sure that only the key(s) you wanted were added.

[vagrant@centos1 ~]$ 
```

检查尝试登录`centos2`是否会提示您输入密钥密码:

```sh
[vagrant@centos1 ~]$ ssh 192.168.33.11
Enter passphrase for key '/home/vagrant/.ssh/id_ed25519': 
```

确保你在`centos1`开始。

# 怎么做...

首先运行`ssh-agent`命令:

```sh
[vagrant@centos1 ~]$ ssh-agent
SSH_AUTH_SOCK=/tmp/ssh-9On2mDhHTL8T/agent.6693; export SSH_AUTH_SOCK;
SSH_AGENT_PID=6694; export SSH_AGENT_PID;
echo Agent pid 6694;
```

您可以看到它打印了几个环境变量和它运行的进程标识。

我们可以证实这是事实:

```sh
[vagrant@centos1 ~]$ pidof ssh-agent
6694
```

复制为您提供的各种变量，并将其粘贴到同一窗口中:

```sh
[vagrant@centos1 ~]$ SSH_AUTH_SOCK=/tmp/ssh-9On2mDhHTL8T/agent.6693; export SSH_AUTH_SOCK;
[vagrant@centos1 ~]$ SSH_AGENT_PID=6694; export SSH_AGENT_PID;
[vagrant@centos1 ~]$
```

现在，运行`ssh-add`命令，并在出现提示时填写您的密钥密码:

```sh
[vagrant@centos1 ~]$ ssh-add
Enter passphrase for /home/vagrant/.ssh/id_ed25519: 
Identity added: /home/vagrant/.ssh/id_ed25519 (vagrant@centos1)
[vagrant@centos1 ~]$ 
```

你可以看到它通知你，它添加了你的身份。

SSH 到`centos2`，当系统没有提示您输入密码时，请准备好大吃一惊:

```sh
[vagrant@centos1 ~]$ ssh 192.168.33.11 
Last login: Thu Aug 9 15:36:02 2018 from 192.168.33.10
[vagrant@centos2 ~]$ 
```

You may think that you don't mind typing in your passphrase once or twice a day, and you'd be fine to think that, but if you're logging into a machine that infrequently, you're probably a very lucky system administrator. Where SSH agents excel is when you want to log into tens or hundreds of machines, or even if you're using a `ProxyJump` box, and don't feel like typing your passphrase any more times than is necessary.

要杀死正在运行的代理，请使用`-k`:

```sh
[vagrant@centos1 ~]$ ssh-agent -k
unset SSH_AUTH_SOCK;
unset SSH_AGENT_PID;
echo Agent pid 6694 killed;
```

I have seen cases where companies don't like the use of SSH agents, and mandate passwords or passphrases each time. Check you're not violating some obscure security policy to make your life easier.

然后，运行建议的 unset 命令删除我们之前设置的变量:

```sh
[vagrant@centos1 ~]$ unset SSH_AUTH_SOCK;
[vagrant@centos1 ~]$ unset SSH_AGENT_PID;
```

Simply logging out of your session won't stop the `ssh-agent` program from running. Be mindful of this if you choose to use it. Likewise, you shouldn't run an agent on a remote host shared between multiple people – it's best kept to your personal machine. If you plan on using an SSH agent, read up on current security practices.

# 它是如何工作的...

当我们最初运行`ssh-agent`时，代理本身是在后台启动的，我们得到了 SSH 所必需的环境变量。设置好之后，运行 SSH 会让它读取这些变量。

如果我们向 SSH 添加几个`-vv`标志，我们可以看到它在代理中找到我们的密钥:

```sh
debug2: key: /home/vagrant/.ssh/id_ed25519 (0x55b11351c410), agent
```

没有加载代理，但存在密钥，看起来像这样:

```sh
debug2: key: /home/vagrant/.ssh/id_ed25519 (0x55dea5015410)
```

SSH 环境变量也由`ssh-add`读取，我们用它将我们的密钥添加到代理中。引用手册页:

"The authentication agent must be running and the SSH_AUTH_SOCK environment variable must contain the name of its socket for ssh-add to work."

当您在代理中拥有一个或多个密钥时，SSH 将尝试使用这些密钥来针对远程主机进行身份验证，无需每次都键入密码。

# 还有更多...

如果您想将代理启动命令添加到脚本中(比如`.bashrc`)，您可能想自动评估提供给您的环境变量。`ssh-agent`假设你是这样开始的。

在`ssh-agent`的手册页，你甚至得到了这个提示。

"There are two main ways to get an agent set up: The first is that the agent starts a new sub‐command into which some environment variables are exported, eg ssh-agent xterm &. The second is that the agent prints the needed shell commands (either sh(1) or csh(1) syntax can be generated) which can be evaluated in the calling shell, eg eval 'ssh-agent -s' for Bourne-type shells such as sh(1) or ksh(1) and eval 'ssh-agent -c' for csh(1) and derivatives."

实际上，这意味着像这样启动代理是最简单的:

```sh
[vagrant@centos1 ~]$ eval $(ssh-agent)
Agent pid 6896
```

这里，我们使用一个 Bash 子Shell来启动和读取代理的输出。

# ssh-add

`ssh-add`有几个不错的选择，其中一些很容易了解。

`-l`将允许您看到加载的身份，以及他们的指纹:

```sh
[vagrant@centos1 ~]$ ssh-add -l
256 SHA256:P7FdkmbQQFoy37avbKBfzMpEhVUaBY0TljwYJyNxzUI vagrant@centos1 (ED25519)
```

`-D`将允许您移除所有身份(并且`-d`可用于移除特定身份):

```sh
[vagrant@centos1 ~]$ ssh-add -D
All identities removed.
```

`-x`将锁定一个代理，而`-X`将解锁它:

```sh
[vagrant@centos1 ~]$ ssh-add -l
256 SHA256:P7FdkmbQQFoy37avbKBfzMpEhVUaBY0TljwYJyNxzUI vagrant@centos1 (ED25519)
[vagrant@centos1 ~]$ ssh-add -x
Enter lock password: 
Again: 
Agent locked.
[vagrant@centos1 ~]$ ssh-add -l
The agent has no identities.
[vagrant@centos1 ~]$ ssh-add -X
Enter lock password: 
Agent unlocked.
[vagrant@centos1 ~]$ ssh-add -l
256 SHA256:P7FdkmbQQFoy37avbKBfzMpEhVUaBY0TljwYJyNxzUI vagrant@centos1 (ED25519)
```

# 添加密钥代理

使用代理时，您可能会喜欢 SSH 配置文件选项`AddKeysToAgent`，它会自动将使用过的密钥添加到您的`ssh-agent`中以备将来使用。

考虑以下几点；我们从我们的代理没有钥匙开始:

```sh
[vagrant@centos1 ~]$ ssh CentOS2-V4
Enter passphrase for key '/home/vagrant/.ssh/id_ed25519': 
Last login: Thu Aug  9 15:58:01 2018 from 192.168.33.10
[vagrant@centos2 ~]$ logout
Connection to 192.168.33.11 closed.
[vagrant@centos1 ~]$ ssh CentOS2-V4
Last login: Thu Aug  9 16:12:04 2018 from 192.168.33.10
[vagrant@centos2 ~]$ 
```

请注意，第一次，系统会提示我们输入密钥的密码。第二次，我们没有。

它现在已加载到我们的代理中:

```sh
[vagrant@centos1 ~]$ ssh-add -l
256 SHA256:P7FdkmbQQFoy37avbKBfzMpEhVUaBY0TljwYJyNxzUI vagrant@centos1 (ED25519)
```

所有这些都由一个配置选项处理:

```sh
[vagrant@centos1 ~]$ cat .ssh/config 
Host *
 Port 22
 AddKeysToAgent yes
```

# 请参见

除了 OpenSSH 提供的默认代理(我们在这里使用)之外，还有其他 SSH 代理。)也有一些系统使用更多的片段(比如大多数桌面发行版上的 PAM。)四处看看，看看你是否能找出你选择的发行版是如何运作的。

# 在一个盒子上运行多个 SSH 服务器

有时，可能需要在一个盒子上运行多个 SSH 服务器。您可能希望一台用于日常活动，另一台用于备份或自动化。

在这种情况下，一次运行 SSH 服务器的两个不同版本是完全可能的。

我们将为此使用`centos2`，在端口`2020`上设置一个辅助 SSH 服务器。

# 准备好

如果你还没有，我建议销毁你以前的流浪盒，并为此部署新的。

创建新的盒子后，连接到两个盒子:

```sh
$ vagrant ssh centos1
$ vagrant ssh centos2
```

在`centos2`上安装`policycoreutils-python`，稍后为`semanage`:

```sh
[vagrant@centos2 ~]$ sudo yum -y install policycoreutils-python
```

# 怎么做...

首先，我们将复制初始配置文件:

```sh
[vagrant@centos2 ~]$ sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config_2020
```

然后，我们要做一些改变:

```sh
[vagrant@centos2 ~]$ sudo sed -i 's#\#Port 22#Port 2020#g' /etc/ssh/sshd_config_2020
[vagrant@centos2 ~]$ sudo sed -i 's#\#PidFile /var/run/sshd.pid#PidFile /var/run/sshd_2020.pid#g' /etc/ssh/sshd_config_2020
```

现在，我们要复制我们的`systemd`单元文件:

```sh
[vagrant@centos2 ~]$ sudo cp /usr/lib/systemd/system/sshd.service  /etc/systemd/system/sshd_2020.service
```

然后，我们将在这里做一些改变:

```sh
[vagrant@centos2 ~]$ sudo sed -i 's#OpenSSH server daemon#OpenSSH server daemon on port 2020#g' /etc/systemd/system/sshd_2020.service
[vagrant@centos2 ~]$ sudo sed -i 's#EnvironmentFile=/etc/sysconfig/sshd#EnvironmentFile=/etc/sysconfig/sshd_2020#g' /etc/systemd/system/sshd_2020.service
```

将旧环境文件复制到新环境文件:

```sh
[vagrant@centos2 ~]$ sudo cp /etc/sysconfig/sshd /etc/sysconfig/sshd_2020
```

然后，将此环境文件指向我们的新配置文件:

```sh
[vagrant@centos2 ~]$ sudo sed -i 's#OPTIONS="-u0"#OPTIONS="-u0 -f /etc/ssh/sshd_config_2020"#g' /etc/sysconfig/sshd_2020
```

告诉 SELinux 我们将在`2020`上运行 SSH 守护程序:

```sh
[vagrant@centos2 ~]$ sudo semanage port -a -t ssh_port_t -p tcp 2020
```

告诉`systemd`我们已经做出了改变:

```sh
[vagrant@centos2 ~]$ sudo systemctl daemon-reload 
```

启动并启用我们的第二台服务器:

```sh
[vagrant@centos2 ~]$ sudo systemctl enable sshd_2020
Created symlink from /etc/systemd/system/multi-user.target.wants/sshd_2020.service to /etc/systemd/system/sshd_2020.service.
[vagrant@centos2 ~]$ sudo systemctl start sshd_2020
```

从`centos1`开始通过 SSH 检查运行情况:

```sh
[vagrant@centos1 ~]$ ssh 192.168.33.11
The authenticity of host '192.168.33.11 (192.168.33.11)' can't be established.
ECDSA key fingerprint is SHA256:I67oI3+08lhdO2ibnoC+z2hzYtvfi9NQAmGxyzxjsI8.
ECDSA key fingerprint is MD5:03:68:ed:a2:b5:5d:57:88:61:4e:86:28:c3:75:28:fa.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '192.168.33.11' (ECDSA) to the list of known hosts.
vagrant@192.168.33.11's password: 
Last login: Thu Aug  9 16:24:50 2018 from 10.0.2.2
[vagrant@centos2 ~]$ logout
Connection to 192.168.33.11 closed.
[vagrant@centos1 ~]$ ssh 192.168.33.11 -p2020
vagrant@192.168.33.11's password: 
Last login: Thu Aug  9 16:40:55 2018 from 192.168.33.10
[vagrant@centos2 ~]$ 
```

Remember when we were looking at host keys before? What we can see in the preceding code is that both the port `22` server and `2020` server are sharing host keys, as we were only asked to accept them once.

# 它是如何工作的...

我们在这里所做的只是复制一些文件，并做了一些合理的更改，以确保这两个进程不会相互影响。

首先，我们创建了以下文件:

```sh
/etc/ssh/sshd_config_2020
```

然后，我们运行了几个`sed`命令来更改一些值。具体来说，我们修改了服务器将监听的端口，以及它将使用的进程标识文件(PID 修改经常被忽略)。

接下来，我们复制了 CentOS 上 OpenSSH 服务器包附带的`systemd`单元文件，通过更改描述并将其指向不同的环境文件，对其进行了略微调整。

We put the resulting unit file (`sshd_2020.service`) in a different location to the original to differentiate it from a supplied default.

我们复制了环境文件，并做了修改，在 SSH 守护程序启动时向其传递了一个新选项。这个新选项是一个不同的配置文件(我们开始制作的文件):

```sh
OPTIONS="-u0 -f /etc/ssh/sshd_config_2020"
```

然后，我们更新了我们的 SELinux 策略，使其知道新服务器的意图，重新加载了 systemd 的运行配置，并启用和启动了我们的服务器。

Your milage may vary in terms of the standard location for configuration and environment files. This can change between major distro releases, and some settings frequently differ between different distributions.

# 还有更多...

如果您有兴趣看到两台服务器都在运行，有几种方法可以做到这一点。

在`centos2`上，从`ss`开始:

```sh
[vagrant@centos2 ~]$ sudo ss -tna -4
State       Recv-Q Send-Q     Local Address:Port                    Peer Address:Port 
LISTEN      0      128                    *:2020                               *:* 
LISTEN      0      128                    *:111                                *:* 
LISTEN      0      128                    *:22                                 *:* 
LISTEN      0      100            127.0.0.1:25                                 *:* 
ESTAB       0      0              10.0.2.15:22                          10.0.2.2:59594 
```

我们还可以使用 systemd 的内置命令:

```sh
[vagrant@centos2 ~]$ PAGER= systemctl | grep sshd
 sshd.service                                                                             loaded active running   OpenSSH server daemon
 sshd_2020.service                                                                        loaded active running   OpenSSH server daemon on port 2020
```

最后，我们可以用好的旧`ps`:

```sh
[vagrant@centos2 ~]$ ps aux | grep sshd
root       856  0.0  0.8 112796  4288 ?        Ss   16:52   0:00 /usr/sbin/sshd -D -u0 -f /etc/ssh/sshd_config_2020
root       858  0.0  0.8 112796  4292 ?        Ss   16:52   0:00 /usr/sbin/sshd -D -u0
```

# 摘要

虽然我在这一章描述了 SSH 能够做的一些出色的事情，并一直在赞美它，但值得强调的是，它仍然是软件，并且还在不断发展。因为它是软件，所以可能会有 bug 和意想不到的行为，尽管它背后的开发人员是最好的，因为它是 OpenBSD 软件套件的一部分。

如果你从这一章中拿走了什么，那就如下:

*   使用基于密钥的身份验证
*   通过 SSH 禁用超级用户登录
*   使用本地 SSH 配置文件连接到远程计算机

如果你和我一样有点难过，我强烈建议你注册各种 SSH 邮件列表，并留意可能会激发你想象力的新功能。`ProxyJump`出现时间不长，非常得心应手。

我确实记得 SSH 以某种形式伤害我的例子，比如我花了一两个小时把头撞在桌子上，试图弄清楚 SSH 为什么不读私有的 RSA 文件，却发现它需要公共的那一半也在本地机器上的同一个文件夹中。那是相当长的一段时间我不会回来了，但这是一个我不会再犯的错误。

也就是说，我还可以分享更多 SSH 给我留下深刻印象的例子，让我的生活变得更轻松。它基本上是系统管理的瑞士军刀，不仅仅是因为它通常是您连接到盒子的方式。

人们使用 SSH 进行管理、传输备份、在盒子之间移动文件、使用工具(如 Ansible)实现自动化、在内部包装其他连接等等。

I once saw an implementation of OpenSSH atop Windows, because the people running the Windows servers were Unix people, and distrusted RDP. They used to SSH to the box, local forwarding the RDP session on `127.0.0.1:3389` and connecting to RDP through the SSH session... it was slow...

它坚固、安全，使用起来很愉快。它可以在 Linux、macOS、BSDs、Solaris 甚至 Windows 上运行！

这里非常感谢 SSH，特别是 OpenSSH。

Some things we didn't discuss in this chapter were ciphers, message integrity codes, key exchange algorithms, and so on. Primarily, this is because these subjects are nearly a book in themselves, and are definitely out of scope for what we're doing here. I generally trust the maintainers of the various packages to choose sensible defaults, but there's no harm in reading up on security independently, should you feel compelled.