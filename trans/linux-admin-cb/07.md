# 监控和记录

本章将涵盖以下主题:

*   正在读取本地日志
*   在`systemd`系统上使用`journalctl`
*   集中测井
*   本地资源测量工具
*   本地监控工具
*   远程监控工具
*   弹性叠加集中测井

# 介绍

服务器工作时都很好，但我们并不生活在一个完美的世界里，很有可能会出现问题(要么是由人类创建的坏代码，要么是由人类引入的管理不善)。

理论上，简单地安装你想要的程序，让它运行，然后忘记它，这将是很棒的，但是这是真实的世界，而不是一些幻想的土地，在那里一切都 100%正确 100%的时间。这是日志记录和监控的亮点。

日志记录的存在是为了当某件事不可避免地出错时，你不必在试图找出出错的地方时让你的程序保持在一个坏的状态(尽管，在奇怪的情况下，这可能正是你必须做的；稍后对此进行更多描述)。你可以让你的系统重新上线，并开始解析日志文件，以准确地找出为什么你的网络服务器突然开始用小狗的图片替换你网站上的所有图片。

监控是保持生活简单的第二要素。在那里，为了确保您在使用软件时有一个流畅的体验，并密切关注您系统上的资源分配，监控可以在人类早上醒来之前发现问题(实际上这种情况经常发生；如果你是随叫随到，不要期待正常的睡眠模式)。

这两个系统结合在一起，可以让你在那些关注你一举一动的人面前显得神一样；就像 Morpheus 一样，你可以在会议中感觉到你的手表随着一个通知而震动，通知你公司网站负载很重，即将崩溃，然后冷静地通知你周围那些胡说八道的人，你感觉到了原力的干扰，然后为自己开脱，在客户注意到之前解决问题。

仔细想想，良好的日志记录和监控会让你的工作显得毫无意义 Futurama 是怎么说的？

"When you do things right, people won't be sure you've done anything at all." – Sentient gas cloud

# 技术要求

在这一章中，我们将使用两个 CentOS 盒子和两个 Debian 盒子，但是，我们讨论的原则在本质上是相当普遍的。

以下`Vagrantfile`应该足够让你入门了:

```
# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure("2") do |config|

 config.vm.define "centos1" do |centos1|
 centos1.vm.box = "centos/7"
 centos1.vm.box_version = "1804.02"
 centos1.vm.network "private_network", ip: "192.168.33.10"
 centos1.vm.hostname = "centos1"
 centos1.vm.provider "virtualbox" do |centos1p|
 centos1p.memory = 2048
 centos1p.cpus = 2
 end
 end

 config.vm.define "centos2" do |centos2|
 centos2.vm.box = "centos/7"
 centos2.vm.box_version = "1804.02"
 centos2.vm.network "private_network", ip: "192.168.33.11"
 centos2.vm.hostname = "centos2"
 end

 config.vm.define "debian1" do |debian1|
 debian1.vm.box = "debian/stretch64"
 debian1.vm.box_version = "9.5.0"
 debian1.vm.network "private_network", ip: "192.168.33.12"
 debian1.vm.hostname = "debian1"
 debian1.vm.provider "virtualbox" do |debian1p|
 debian1p.cpus = 1
 end
 end

 config.vm.define "debian2" do |debian2|
 debian2.vm.box = "debian/stretch64"
 debian2.vm.box_version = "9.5.0"
 debian2.vm.network "private_network", ip: "192.168.33.13"
 debian2.vm.hostname = "debian2"
 debian2.vm.provider "virtualbox" do |debian2p|
 debian2p.cpus = 1
 end
 end

end
```

# 正在读取本地日志

在本节中，我们将了解登录机器的默认位置。

日志记录非常棒，它可以告诉您系统的健康程度、繁忙程度、谁试图攻击它，以及谁在最后几分钟内成功获得了访问权限。

现在已经相当标准化了，除非你正在使用一个 Java 应用程序，如果你有耐心通读一个日志文件，你可能想在之后尝试一下*战争与和平*。

# 准备好了

登录您的`centos1`虚拟机:

```
$ vagrant ssh centos1
```

# 怎么做...

手动页面告诉我们，如果我们想找到杂项日志文件，我们应该从查看`/var/log/`开始:

/var/log
              Miscellaneous log files.

导航到`/var/log`并列出其内容，向我们展示了这种情况:

```
$ cd /var/log
$ ls -l
total 156
drwxr-xr-x. 2 root   root      219 May 12 18:55 anaconda
drwx------. 2 root   root       23 Oct  9 16:55 audit
-rw-------. 1 root   root        6 Oct  9 16:55 boot.log
-rw-------. 1 root   utmp        0 May 12 18:51 btmp
drwxr-xr-x. 2 chrony chrony      6 Apr 12 17:37 chrony
-rw-------. 1 root   root      807 Oct  9 17:01 cron
-rw-r--r--. 1 root   root    28601 Oct  9 16:55 dmesg
-rw-r--r--. 1 root   root      193 May 12 18:51 grubby_prune_debug
-rw-r--r--. 1 root   root   292292 Oct  9 17:21 lastlog
-rw-------. 1 root   root      198 Oct  9 16:55 maillog
-rw-------. 1 root   root    91769 Oct  9 17:23 messages
drwxr-xr-x. 2 root   root        6 Aug  4  2017 qemu-ga
drwxr-xr-x. 2 root   root        6 May 12 18:55 rhsm
-rw-------. 1 root   root     2925 Oct  9 17:21 secure
-rw-------. 1 root   root        0 May 12 18:52 spooler
-rw-------. 1 root   root        0 May 12 18:50 tallylog
drwxr-xr-x. 2 root   root       23 Oct  9 16:55 tuned
-rw-rw-r--. 1 root   utmp     1920 Oct  9 17:21 wtmp
```

在 CentOS 系统上，主日志文件是`messages`日志；在 Debian 和 Ubuntu 下，这被称为`syslog`，但实际上是一回事。

看一看这个日志文件的最后几行应该会显示系统上运行的一些程序的各种输出:

```
$ sudo tail -10 messages
Dec 28 18:37:18 localhost nm-dispatcher: req:11 'connectivity-change': start running ordered scripts...
Dec 28 18:37:22 localhost systemd-logind: New session 3 of user vagrant.
Dec 28 18:37:22 localhost systemd: Started Session 3 of user vagrant.
Dec 28 18:37:22 localhost systemd: Starting Session 3 of user vagrant.
Dec 28 18:38:13 localhost chronyd[567]: Selected source 95.215.175.2
Dec 28 18:39:18 localhost chronyd[567]: Selected source 178.79.155.116
Dec 28 18:39:35 localhost systemd-logind: Removed session 2.
Dec 28 18:39:46 localhost systemd: Started Session 4 of user vagrant.
Dec 28 18:39:46 localhost systemd-logind: New session 4 of user vagrant.
Dec 28 18:39:46 localhost systemd: Starting Session 4 of user vagrant.
```

这里我们可以看到`chronyd`有点抱怨，可以看到我登录的点，`systemd`好心给我创建了一个会话。

您还可以查看安全日志，例如`sshd`、`sudo`和`PAM`:

```
$ sudo tail -5 secure
Dec 28 18:39:46 localhost sshd[3379]: Accepted publickey for vagrant from 10.0.2.2 port 44394 ssh2: RSA SHA256:7EOuFLwMurYJNPkZ3e+rZvez1FxmGD9ZNpEq6H+wmSA
Dec 28 18:39:46 localhost sshd[3379]: pam_unix(sshd:session): session opened for user vagrant by (uid=0)
Dec 28 18:39:55 localhost sudo: vagrant : TTY=pts/0 ; PWD=/var/log ; USER=root ; COMMAND=/bin/tail -10 messages
Dec 28 18:40:19 localhost sudo: vagrant : TTY=pts/0 ; PWD=/var/log ; USER=root ; COMMAND=/bin/tail -10 secure
Dec 28 18:40:37 localhost sudo: vagrant : TTY=pts/0 ; PWD=/var/log ; USER=root ; COMMAND=/bin/tail -5 secure
```

以及`cron`的`cron`日志等文件:

```
$ sudo cat cron
Dec 28 18:36:57 localhost crond[612]: (CRON) INFO (RANDOM_DELAY will be scaled with factor 89% if used.)
Dec 28 18:36:58 localhost crond[612]: (CRON) INFO (running with inotify support)
```

因为这些文件只是文本，所以您可以使用您所掌握的任何标准工具来操作它们。

我可能想从消息日志中`grep`出`vagrant`的提及，然后只打印月份、时间戳和进行日志记录的程序:

```
$ sudo grep "vagrant." messages | cut -d" " -f 1,3,5
Dec 18:37:07 systemd:
Dec 18:37:07 systemd:
Dec 18:37:07 systemd:
Dec 18:37:07 systemd-logind:
Dec 18:37:07 systemd:
```

你为什么要这么做我不知道，但是人们有奇怪的爱好。

为了使日志文件不会变得太大，甚至成为打开的真正痛苦(真的，一百万行太多了)，我们还有`logrotate`，它会定期运行，将旧文件换成要写入的新文件。

在这里，我强制`logrotate`运行，所以我们可以看到输出:

```
$ sudo logrotate -f /etc/logrotate.conf
$ ls -lh
total 168K
drwxr-xr-x. 2 root root 219 May 12 18:55 anaconda
drwx------. 2 root root 23 Oct 9 16:55 audit
-rw-------. 1 root root 0 Oct 9 17:35 boot.log
-rw-------. 1 root root 6 Oct 9 17:35 boot.log-20181009
-rw-------. 1 root utmp 0 Oct 9 17:35 btmp
-rw-------. 1 root utmp 0 May 12 18:51 btmp-20181009
drwxr-xr-x. 2 chrony chrony 6 Apr 12 17:37 chrony
-rw-------. 1 root root 0 Oct 9 17:35 cron
-rw-------. 1 root root 807 Oct 9 17:01 cron-20181009
-rw-r--r--. 1 root root 28K Oct 9 16:55 dmesg
-rw-r--r--. 1 root root 193 May 12 18:51 grubby_prune_debug
-rw-r--r--. 1 root root 286K Oct 9 17:28 lastlog
-rw-------. 1 root root 0 Oct 9 17:35 maillog
-rw-------. 1 root root 198 Oct 9 16:55 maillog-20181009
-rw-------. 1 root root 145 Oct 9 17:35 messages
-rw-------. 1 root root 90K Oct 9 17:28 messages-20181009
drwxr-xr-x. 2 root root 6 Aug 4 2017 qemu-ga
drwxr-xr-x. 2 root root 6 May 12 18:55 rhsm
-rw-------. 1 root root 0 Oct 9 17:35 secure
-rw-------. 1 root root 5.3K Oct 9 17:35 secure-20181009
-rw-------. 1 root root 0 Oct 9 17:35 spooler
-rw-------. 1 root root 0 May 12 18:52 spooler-20181009
-rw-------. 1 root root 0 May 12 18:50 tallylog
drwxr-xr-x. 2 root root 23 Oct 9 16:55 tuned
-rw-rw-r--. 1 root utmp 0 Oct 9 17:35 wtmp
-rw-rw-r--. 1 root utmp 1.9K Oct 9 17:21 wtmp-20181009

```

请注意旧文件是如何移动和加盖日期戳的，新文件是如何命名的。

现在在消息文件中使用`cat`将显示一行，告诉我们`rsyslogd`守护进程是`HUPed`:

```
$ sudo cat messages
Dec 28 18:41:38 centos1 rsyslogd: [origin software="rsyslogd" swVersion="8.24.0" x-pid="898" x-info="http://www.rsyslog.com"] rsyslogd was HUPed
```

Personally, I think it should be HUP'd, but I can see the argument for `HUPed`.

# 它是如何工作的...

登录到文本文件的守护程序是`rsyslogd`(在一些较旧的系统上，可能是`syslog-ng`)。

这个可靠且扩展的 syslogd 程序写入从两个位置之一读取的消息:`imuxsock`(旧)和`imjournal`(新)；这直接来自`syslog(3)`系统调用手册页:

syslog() and vsyslog()
syslog() generates a log message, which will be distributed by syslogd(8).

注意`syslogd`(此处引用)是一个旧程序，被`rsyslogd`取代。

If there's more than one entry of the same name, in the man pages, you can specify the section by using the number. In this case, it would be `man 3 syslog` on the command line.

`rsyslogd`配置位于`/etc/rsyslog.conf`中，它为我们提供了特定日志如何写入的第一位信息。这是`RULES`一节:

```
#### RULES ####

# Log all kernel messages to the console.
# Logging much else clutters up the screen.
#kern.*                                                 /dev/console

# Log anything (except mail) of level info or higher.
# Don't log private authentication messages!
*.info;mail.none;authpriv.none;cron.none                /var/log/messages

# The authpriv file has restricted access.
authpriv.*                                              /var/log/secure

# Log all the mail messages in one place.
mail.*                                                  -/var/log/maillog

# Log cron stuff
cron.*                                                  /var/log/cron

# Everybody gets emergency messages
*.emerg                                                 :omusrmsg:*

# Save news errors of level crit and higher in a special file.
uucp,news.crit                                          /var/log/spooler

# Save boot messages also to boot.log
local7.*                                                /var/log/boot.log
```

这向我们展示了当某些消息到达日志位置时应用的各种规则:如果它们是邮件消息，它们会转到`/var/log/maillog`；如果它们不是邮件(T1 级或更高级别的)、`authpriv`或`cron`，它们会转到`/var/log/messages`。

`logger`命令可用于直接写入日志，对于测试目的和 shell 脚本来说非常方便，以展示其工作原理:

```
$ logger "So long, and thanks for all the fish." 
$ sudo tail -1 /var/log/messages
Oct 9 18:03:03 centos1 vagrant: So long, and thanks for all the fish.
```

`logger`命令还允许您指定设施和日志级别:

```
$ logger -p cron.err "I'M A PARADOXICAL LOG MESSAGE."
$ sudo tail -3 /var/log/cron
Oct  9 18:07:01 centos1 anacron[3373]: Job `cron.weekly' started
Oct  9 18:07:01 centos1 anacron[3373]: Job `cron.weekly' terminated
Oct  9 18:07:23 centos1 vagrant: I'M A PARADOXICAL LOG MESSAGE.
```

这看起来很吵，所以让我们为`cron`错误消息创建一个专用的日志文件。

我们需要一个规则，放置在`rsyslog.d`目录中，用于这样的事情:

```
$ cat <<HERE | sudo tee /etc/rsyslog.d/cronerr.conf
cron.err                                                  /var/log/cron.err
HERE
```

现在，我们重启`rsyslog`，再次发送我们的`logger`消息:

```
$ sudo systemctl restart rsyslog
$ logger -p cron.err "I'M A PARADOXICAL LOG MESSAGE."
$ sudo cat /var/log/cron.err 
Oct  9 18:17:32 centos1 vagrant: I'M A PARADOXICAL LOG MESSAGE.
```

这样干净多了；我们的定制规则看起来不错！

日志级别是以下之一，对于何时使用不同的级别，只有松散定义的指导原则，尽管通常不将琐碎事件记录为关键问题被认为是好的方式:

0              emerg
1              alert
2              crit
3              err
4              warning
5              notice
6              info
7              debug

这些数字是各个级别的数字名称。

# 还有更多...

当我们旋转日志和`syslog`守护进程时，我们实际上在`logrotate`中运行了这个脚本:

```
$ cat /etc/logrotate.d/syslog 
/var/log/cron
/var/log/maillog
/var/log/messages
/var/log/secure
/var/log/spooler
{
 missingok
 sharedscripts
 postrotate
 /bin/kill -HUP `cat /var/run/syslogd.pid 2> /dev/null` 2> /dev/null || true
 endscript
}
```

当然，应用程序没有理由使用`syslog(3)`调用来记录消息，它也可以很容易地向`/tmp`写入一个文本流，但这完全取决于相关的应用程序开发人员。

作为管理员，您需要知道的是，大多数日志最终可能会以文本格式出现在`/var/log`中，并且您通常可以逐个程序地配置日志文件位置。

伐木快乐！

# 在系统上使用 journalctl

现代 Linux 发行版不仅仅依赖`syslog`文件；事实上，他们根本不需要依赖`syslog`。Debian、Ubuntu 和 CentOS 都有`systemd`作为初始化系统，与`systemd`捆绑在一起的是一个名为`journald` ( `systemd-journald.service`)的服务。

此服务充当您系统的日志解决方案，并使用二进制日志而不是基于文本的日志。

While it's possible to ignore `syslog` entirely, and just use `journald`, a lot of systems now use both, to make the transition from one format to another easier. If you're using something like Arch or Gentoo, you may decide to dismiss `syslog` solutions entirely, in favour of `journald` alone.

# 准备好

对于本节，我们可以使用第一节中的`Vagrantfile`。

我们将只使用`centos1`。

SSH 到`centos1`:

```
$ vagrant ssh centos1
```

# 怎么做...

如前所述，journald 使用二进制日志格式，这意味着它不能用传统的文本解析器和编辑器打开。相反，我们使用`journalctl`命令来读取日志。

只需运行以下命令即可打开您的日志:

```
$ sudo journalctl
```

前面命令的输出如下所示:

![](assets/f41a5795-f1ce-4b8b-8be1-cd42c7b4aa36.png)

这对于任何看起来像普通旧`syslog`文件的人来说都是熟悉的；请注意，默认情况下格式是相同的。

这是相当嘈杂的，但在一个繁忙的系统，我们可能不想看到一切历史性的。

也许我们只想看着日志上写的内容？如果这是真的，我们可以用`-f`跟随它:

```
$ sudo journalctl -f
-- Logs begin at Tue 2018-10-09 18:43:07 UTC. --
Oct 10 17:07:03 centos1 chronyd[554]: System clock was stepped by 80625.148375 seconds
Oct 10 17:07:03 centos1 systemd[1]: Time has been changed
Oct 10 17:07:25 centos1 sshd[1106]: Accepted publickey for vagrant from 10.0.2.2 port 55300 ssh2: RSA SHA256:TTGYuhFa756sxR2rbliMhNqgbggAjFNERKg9htsdvSw
Oct 10 17:07:26 centos1 systemd[1]: Created slice User Slice of vagrant.
Oct 10 17:07:26 centos1 systemd[1]: Starting User Slice of vagrant.
Oct 10 17:07:26 centos1 systemd[1]: Started Session 1 of user vagrant.
Oct 10 17:07:26 centos1 systemd-logind[545]: New session 1 of user vagrant.
Oct 10 17:07:26 centos1 sshd[1106]: pam_unix(sshd:session): session opened for user vagrant by (uid=0)
Oct 10 17:07:26 centos1 systemd[1]: Starting Session 1 of user vagrant.
Oct 10 17:07:28 centos1 sudo[1131]:  vagrant : TTY=pts/0 ; PWD=/home/vagrant ; USER=root ; COMMAND=/bin/journalctl -f
```

无论何时写日志消息，它都会以流的形式出现在你面前(使用 *Ctrl* + *C* 退出)。

我们可以专门查看带有`-k`标志的`kernel`日志(好像我们正在运行`dmesg`):

```
$ sudo journalctl -k --no-pager | head -n8
-- Logs begin at Tue 2018-10-09 18:43:07 UTC, end at Wed 2018-10-10 17:09:08 UTC. --
Oct 09 18:43:07 localhost.localdomain kernel: Initializing cgroup subsys cpuset
Oct 09 18:43:07 localhost.localdomain kernel: Initializing cgroup subsys cpu
Oct 09 18:43:07 localhost.localdomain kernel: Initializing cgroup subsys cpuacct
Oct 09 18:43:07 localhost.localdomain kernel: Linux version 3.10.0-862.2.3.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC) ) #1 SMP Wed May 9 18:05:47 UTC 2018
Oct 09 18:43:07 localhost.localdomain kernel: Command line: BOOT_IMAGE=/vmlinuz-3.10.0-862.2.3.el7.x86_64 root=/dev/mapper/VolGroup00-LogVol00 ro no_timer_check console=tty0 console=ttyS0,115200n8 net.ifnames=0 biosdevname=0 elevator=noop crashkernel=auto rd.lvm.lv=VolGroup00/LogVol00 rd.lvm.lv=VolGroup00/LogVol01 rhgb quiet
Oct 09 18:43:07 localhost.localdomain kernel: e820: BIOS-provided physical RAM map:
Oct 09 18:43:07 localhost.localdomain kernel: BIOS-e820: [mem 0x0000000000000000-0x000000000009fbff] usable
```

请注意，在这里，我已经禁用了寻呼机(与在`systemctl-land`中完全相同)，并且我只转储了日志的前八行，因为`kernel`相当嘈杂，尤其是在启动时。

这也表明日志仍然可以在命令行上操作；你只需要先查询它们(增加一点开销)。

这并不是说你必须使用`journalctl`和其他命令的组合；光靠`journalctl`就很有可能得到自己需要的东西。在这里，我选择了一个非常具体的时间范围来查询日志:

```
$ sudo journalctl --since=17:07 --until=17:09
-- Logs begin at Tue 2018-10-09 18:43:07 UTC, end at Wed 2018-10-10 17:12:51 UTC. --
Oct 09 18:43:18 centos1 chronyd[554]: Selected source 188.114.116.1
Oct 09 18:43:18 centos1 chronyd[554]: System clock wrong by 80625.148375 seconds, adjustment started
Oct 10 17:07:03 centos1 chronyd[554]: System clock was stepped by 80625.148375 seconds
Oct 10 17:07:03 centos1 systemd[1]: Time has been changed
Oct 10 17:07:25 centos1 sshd[1106]: Accepted publickey for vagrant from 10.0.2.2 port 55300 ssh2: RSA SHA256:TTGYuhFa756sxR2rbliMhNqgbggAjFNERKg9htsdvSw
Oct 10 17:07:26 centos1 systemd[1]: Created slice User Slice of vagrant.
Oct 10 17:07:26 centos1 systemd[1]: Starting User Slice of vagrant.
Oct 10 17:07:26 centos1 systemd[1]: Started Session 1 of user vagrant.
Oct 10 17:07:26 centos1 systemd-logind[545]: New session 1 of user vagrant.
Oct 10 17:07:26 centos1 sshd[1106]: pam_unix(sshd:session): session opened for user vagrant by (uid=0)
Oct 10 17:07:26 centos1 systemd[1]: Starting Session 1 of user vagrant.
Oct 10 17:07:28 centos1 sudo[1131]:  vagrant : TTY=pts/0 ; PWD=/home/vagrant ; USER=root ; COMMAND=/bin/journalctl -f
Oct 10 17:08:08 centos1 chronyd[554]: Selected source 194.80.204.184
Oct 10 17:08:41 centos1 sudo[1145]:  vagrant : TTY=pts/0 ; PWD=/home/vagrant ; USER=root ; COMMAND=/bin/journalctl -k
Oct 10 17:08:52 centos1 sudo[1148]:  vagrant : TTY=pts/0 ; PWD=/home/vagrant ; USER=root ; COMMAND=/bin/journalctl -k
```

在 2 分钟内，我们得到 15 行日志，但这更容易筛选和消化(当然，假设你盒子上的时间是正确的！)

These timestamps are just examples; you could use a full date (`--since="2018-10-10 17:07:00"`) or even relative statements (`--since=yesterday --until=now`).

如果你追求的不是一个时间范围，而是一个特定的`systemd unit`的日志，`journalctl`也有你涵盖的:

```
$ sudo journalctl -u chronyd
-- Logs begin at Tue 2018-10-09 18:43:07 UTC, end at Wed 2018-10-10 17:18:58 UTC. --
Oct 09 18:43:09 centos1 systemd[1]: Starting NTP client/server...
Oct 09 18:43:09 centos1 chronyd[554]: chronyd version 3.2 starting (+CMDMON +NTP +REFCLOCK +RTC +PRIVDROP +SCFILTER +SECHASH +SIGND +ASYNCDNS +IPV6 +DEBUG)
Oct 09 18:43:09 centos1 chronyd[554]: Frequency -3.308 +/- 6.027 ppm read from /var/lib/chrony/drift
Oct 09 18:43:09 centos1 systemd[1]: Started NTP client/server.
Oct 09 18:43:18 centos1 chronyd[554]: Selected source 188.114.116.1
Oct 09 18:43:18 centos1 chronyd[554]: System clock wrong by 80625.148375 seconds, adjustment started
Oct 10 17:07:03 centos1 chronyd[554]: System clock was stepped by 80625.148375 seconds
Oct 10 17:08:08 centos1 chronyd[554]: Selected source 194.80.204.184
```

在这里，我使用`-u`(单位)标志只查看来自`chronyd`的日志，最大限度地减少了我必须处理的输出量。

在前面的例子中，我们还获得了与`chronyd`单元交互的`systemd`日志。但是如果我们只想要来自`chronyd`二进制的日志，我们也可以这样做:

```
$ sudo journalctl /usr/sbin/chronyd
-- Logs begin at Tue 2018-10-09 18:43:07 UTC, end at Wed 2018-10-10 17:21:08 UTC. --
Oct 09 18:43:09 centos1 chronyd[554]: chronyd version 3.2 starting (+CMDMON +NTP +REFCLOCK +RTC +PRIVDROP +SCFILTER +SECHASH +SIGND +ASYNCDNS +IPV6 +DEBUG)
Oct 09 18:43:09 centos1 chronyd[554]: Frequency -3.308 +/- 6.027 ppm read from /var/lib/chrony/drift
Oct 09 18:43:18 centos1 chronyd[554]: Selected source 188.114.116.1
Oct 09 18:43:18 centos1 chronyd[554]: System clock wrong by 80625.148375 seconds, adjustment started
Oct 10 17:07:03 centos1 chronyd[554]: System clock was stepped by 80625.148375 seconds
Oct 10 17:08:08 centos1 chronyd[554]: Selected source 194.80.204.184
```

说真的，这有多酷？

但是等等，还有更多！

`journald`命令可以更强大，因为它有消息解释的概念，或者消息上下文，如果你愿意的话。一些日志行可以以更详细的方式输出(使用`-x`)以更好地理解正在发生的事情。

举下面两个使用`sshd`单位的例子，有和没有`-x`标志:

```
$ sudo journalctl -u sshd
-- Logs begin at Tue 2018-10-09 18:43:07 UTC, end at Wed 2018-10-10 17:25:46 UTC. --
Oct 09 18:43:14 centos1 systemd[1]: Starting OpenSSH server daemon...
Oct 09 18:43:14 centos1 sshd[853]: Server listening on 0.0.0.0 port 22.
Oct 09 18:43:14 centos1 sshd[853]: Server listening on :: port 22.
Oct 09 18:43:14 centos1 systemd[1]: Started OpenSSH server daemon.
Oct 10 17:07:25 centos1 sshd[1106]: Accepted publickey for vagrant from 10.0.2.2 port 55300 ssh2: RSA SHA256:TTGYuhFa756sxR2rbliMhNqgbggAjFNERKg9htsdvSw
$ sudo journalctl -u sshd -x
-- Logs begin at Tue 2018-10-09 18:43:07 UTC, end at Wed 2018-10-10 17:26:04 UTC. --
Oct 09 18:43:14 centos1 systemd[1]: Starting OpenSSH server daemon...
-- Subject: Unit sshd.service has begun start-up
-- Defined-By: systemd
-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel
-- 
-- Unit sshd.service has begun starting up.
Oct 09 18:43:14 centos1 sshd[853]: Server listening on 0.0.0.0 port 22.
Oct 09 18:43:14 centos1 sshd[853]: Server listening on :: port 22.
Oct 09 18:43:14 centos1 systemd[1]: Started OpenSSH server daemon.
-- Subject: Unit sshd.service has finished start-up
-- Defined-By: systemd
-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel
-- 
-- Unit sshd.service has finished starting up.
-- 
-- The start-up result is done.
Oct 10 17:07:25 centos1 sshd[1106]: Accepted publickey for vagrant from 10.0.2.2 port 55300 ssh2: RSA SHA256:TTGYuhFa756sxR2rbliMhNqgbggAjFNERKg9htsdvSw
```

注意`systemd`具体的台词突然多了很多脉络。

我们已经介绍了一些好的基础知识，但是`journalctl`仍然可能更复杂。向输出传递选项后，我们可以向语句中添加特定的匹配项(格式为`FIELD=VALUE`)。

看看 SSH，我们可以看到这一点:

```
$ sudo journalctl --since=yesterday _SYSTEMD_UNIT=sshd.service _PID=853 
-- Logs begin at Tue 2018-10-09 18:43:07 UTC, end at Wed 2018-10-10 17:31:48 UTC. --
Oct 09 18:43:14 centos1 sshd[853]: Server listening on 0.0.0.0 port 22.
Oct 09 18:43:14 centos1 sshd[853]: Server listening on :: port 22.
```

在这里，我们已经说过，我们想要昨天的所有消息，由`systemd` `sshd`单元生成，但只想要那些来自 PID `853`(恰好是这个框中的服务器守护进程 PID)的消息。

关于比赛的更多信息，请看`systemd.journal-fields`手册页。

最后，和`syslog`一样，我们可以指定我们想要查看的消息的优先级。在这里，我们查看整个日志，但我们只是在`err`级消息之后:

```
$ sudo journalctl -p err
-- Logs begin at Tue 2018-10-09 18:43:07 UTC, end at Wed 2018-10-10 17:55:48 UTC. --
Oct 09 18:43:09 centos1 systemd[504]: Failed at step STDIN spawning /usr/libexec/selinux/selinux-policy-migrate-local-changes.sh: Inappropriate ioctl for device
Oct 09 18:43:09 centos1 systemd[1]: Failed to start Migrate local SELinux policy changes from the old store structure to the new structure.
Oct 09 18:43:14 centos1 rsyslogd[857]: imjournal: loaded invalid cursor, seeking to the head of journal  [v8.24.0 try http://www.rsyslog.com/e/2027 ]
```

# 它是如何工作的...

在`/etc/systemd/journald.conf`中配置，journald 是一个很棒的软件，但是，至少在 CentOS 7 上，它有点像二等公民，syslog 仍然是很多人关注日志的主要方法。

日志不会在重启过程中保持不变(稍后将详细介绍)，因此它仅适用于查询系统自启动以来的状态(这也足够了，10 次中有 9 次)。

正如我们所说的，该文件是二进制格式的，journal 拉入各种来源来创建其日志:

*   内核日志消息(`/dev/kmsg`)
*   简单日志消息(前面提到的`syslog` `libc`呼叫)
*   来自日志应用编程接口的结构化日志消息(通过`imjournal`模块导入`rsyslog`
*   服务单元文件的`stdout`和`stderr`
*   来自内核审计子系统的审计记录

像`syslog`一样，这意味着`logger`可以用来显示我们仍然可以手动填充日志，这里只显示从`syslog`传输机制接收到的消息:

```
$ logger -p cron.err "I'M ANOTHER PARADOXICAL LOG MESSAGE."
$ sudo journalctl -p err _TRANSPORT=syslog --since 18:00
-- Logs begin at Tue 2018-10-09 18:43:07 UTC, end at Wed 2018-10-10 18:11:15 UTC. --
Oct 10 18:08:18 centos1 vagrant[1736]: I'M ANOTHER PARADOXICAL LOG MESSAGE.
```

在未来，`syslog`很有可能会被放弃，`journald`将成为新的常态，但是考虑到`syslog`这个概念已经存在了很长时间，要成为现实还需要很长时间。

The fact `journald` logs in a binary way is something of a point of contention for a lot of traditionalists but, like Columbus, it didn't arrive on the scene first, it's just the one that got all the attention. Those of you who've ever used OpenBSD, and its firewall `pf`, will perhaps find the notion of binary logging a comfort.

# 还有更多...

需要注意的一点是日志将使用的空间。尺寸限制由`journald.conf`中的选项控制。

选项`SystemMaxUse`和`RuntimeMaxUse`控制日志可以使用的最大磁盘空间；这些默认为文件系统大小的 10%，上限为 4 GB。

`SystemKeepFree`和`RuntimeKeepFree`选项控制`journald`留出多少磁盘空间用于其他用途；这些默认为文件系统大小的 15%，上限也是 4 GB。

有各种各样的场景来控制大小，但是基本上，`journald`会尽力不成为文件系统被填满的原因，正是这种对细节的关注让我喜欢它。

# 请参见

在我们的 CentOS 系统上，日志文件是暂时的，在重新启动时会丢失。当它活着的时候，它存在于`/run/log/journal/`:

```
$ ls /run/log/journal/
4eabd6271dbf4ed0bc608378f4311df8
$ sudo ls -lh /run/log/journal/4eabd6271dbf4ed0bc608378f4311df8/
total 4.0M
-rwxr-x---+ 1 root systemd-journal 4.0M Oct  9 18:43 system.journal
```

We could actually change this behavior quite easily, by adding a `/var/log/` directory specifically for the journal, and using a one-liner to change the permissions: `sudo systemd-tmpfiles --create --prefix /var/log/journal`

您也可以从命令行列出`journalctl`知道的引导:

```
$ sudo journalctl --list-boots
 0 b4c3669c7a9841ba841c330a75125e35 Tue 2018-10-09 18:43:07 UTC—Wed 2018-10-10 18:13:27 UTC
```

# 集中测井

你不想登录你的庄园里的每一个盒子来查看日志，你就是不想。在这个云和自动调配基础架构的时代，这比它的价值高得多，这是将您的日志集中在一个(冗余)位置的一个很好的例子。

作为数据，我们的日志可以相对容易地操作和移动。`rsyslog`和`journald`都有能力做到这一点，在这一节中，我们将在这个地方流式传输我们的日志，展示这是多么有用。

我们在这里讨论的所有内容在各自的程序中都是可能的；这与弹性堆栈等软件提供的一些集中式日志解决方案不同。

For the purpose of these examples, we're not utilizing TLS, meaning logs will be streamed in a plain format. I would advise against doing this sort of thing in production, without investing in HTTPS setups or tunneled solutions.

# 准备好了

对于本节，我们可以使用第一节中的`Vagrantfile`。

我们将使用`centos1`和`centos2`作为第一部分，然后使用`debian1`和`debian2`作为第二部分，将日志从一个盒子发送到另一个盒子。

打开两个端子，连接到`centos1`和`centos2`；将`tcpdump`安装在两个箱子上:

```
$ vagrant ssh centos1
$ sudo yum install tcpdump -y

$ vagrant ssh centos2
$ sudo yum install tcpdump -y
```

对于第二部分(`journald`)，连接到`debian1`和`debian2`，并在两个箱子上安装`tcpdump`和`systemd-journal-remote`:

```
$ vagrant ssh debian1
$ sudo apt install tcpdump systemd-journal-remote -y

$ vagrant ssh debian2
$ sudo apt install tcpdump systemd-journal-remote -y
```

# 怎么做...

我们将依次检查这两个日志守护程序，从`rsyslog`开始，然后对`journald`执行相同的基本操作。

# rsyslog 的远程日志记录- UDP 示例

要使用`rsyslog`登录到远程机器，您需要在客户端启用流式传输到远程位置，并在服务器上启用接收。

为此，`centos1`将是我们的客户端，`centos2`将是我们的服务器。

在`centos1`上首先:

```
$ sudo sed -i 's/#*.* @@remote-host:514/*.* @192.168.33.11/g' /etc/rsyslog.conf
$ sudo systemctl restart rsyslog
```

现在开始`centos2`:

```
$ sudo sed -i 's/#$ModLoad imudp/$ModLoad imudp/g' /etc/rsyslog.conf
$ sudo sed -i 's/#$UDPServerRun 514/$UDPServerRun 514/g' /etc/rsyslog.conf
$ sudo systemctl restart rsyslog
```

我们可以在我们的`centos2`虚拟机上立即检查`tcpdump`是否正常工作；使用以下命令启动它:

```
$ sudo tcpdump port 514 -i eth1
```

现在，在`centos1`生成消息发送；在这里，我们正在欺骗一条`syslog.info`消息:

```
$ logger -p syslog.info "I'm a regular info message."
```

在`centos2`上，应该会看到如下内容:

![](assets/9bcab73d-8593-4302-b04f-d5628e1589ed.png)

当然，在我们的日志行将结束的`/var/log/messages`文件中，您将看到以下内容:

```
$ sudo tail -3 /var/log/messages
Oct 11 18:35:45 centos2 kernel: device eth1 entered promiscuous mode
Oct 11 18:35:48 centos1 vagrant: I'm a regular info message.
Oct 11 18:36:23 centos2 kernel: device eth1 left promiscuous mode
```

Here, we can also see `eth1` being put in promiscuous mode by `tcpdump`, prior to and after us delivering our `syslog` message.

# rsyslog 远程日志记录- TCP 示例

前面的例子涉及了 UDP，它只是一个信息流，没有确认另一端的服务器收到了噪音。通过 TCP 连接，`syslog`服务器相互通信，首先建立连接。

在您的`centos1`机器上，用两个`@@`标志替换您目的地地址中的单个`@`标志:

```
$ sudo sed -i 's/*.* @192.168.33.11/*.* @@192.168.33.11/g' /etc/rsyslog.conf
$ sudo systemctl restart rsyslog
```

我们的客户端现在已经设置好了，但是在连接建立之前不能发送日志。

在`centos2`上，我们设置`rsyslog`服务器接收 TCP 连接和数据:

```
$ sudo sed -i 's/#$ModLoad imtcp/$ModLoad imtcp/g' /etc/rsyslog.conf
$ sudo sed -i 's/#$InputTCPServerRun 514/$InputTCPServerRun 514/g' /etc/rsyslog.conf
$ sudo systemctl restart rsyslog
```

An `rsyslog` server can listen on UDP and TCP at the same time.

让我们来测试一下！在`centos2`上，再次设置您的`tcpdump`:

```
$ sudo tcpdump port 514 -i eth1
```

并从`centos1`发送日志消息:

```
$ logger -p syslog.err "I'm a confusing error message."
```

您的`tcpdump`输出应该如下所示:

![](assets/a65b5ffb-8f04-442c-8710-6abe1666f01b.png)

同样，您的消息文件应该有新的提醒:

```
$ sudo tail -3 /var/log/messages
Oct 11 18:39:09 centos1 vagrant: I'm a confusing error message.
Oct 11 18:39:15 centos2 kernel: device eth1 left promiscuous mode
Oct 11 18:39:27 centos1 systemd-logind: Removed session 3.
```

# 远程日志记录

`systemd-journal-remote`命令允许您通过网络接收日志消息。可悲的是，这是`systemd`套件的一个相当新的增加，在 CentOS 系统上还没有。

在您的第一个 Debian 系统(`debian1`)上，设置您的远程上传位置:

```
$ sudo sed -i 's/# URL=/URL=http:\/\/192.168.33.13/g' /etc/systemd/journal-upload.conf
```

在您的第二个框(`debian2`)中，使用`systemctl edit`开始编辑收听服务:

```
$ sudo systemctl edit systemd-journal-remote
```

当出现空编辑器时，添加以下三行:

```
[Service]
ExecStart=
ExecStart=/lib/systemd/systemd-journal-remote --listen-http=-3 --output=/var/log/journal/remote
```

它应该如下所示:

![](assets/341259df-619f-451b-be4d-55a805bae749.png)

保存并退出( *Ctrl* + *O* ，*进入*， *Ctrl* + *X* )。

现在，在最终重新启动服务之前，您需要确定远程文件夹的位置，并确保它具有适当的权限:

```
$ sudo mkdir -p /var/log/journal/remote
$ sudo chown systemd-journal-remote /var/log/journal/remote
$ sudo systemctl restart systemd-journal-remote
```

别忘了在`debian1`启动服务:

```
$ sudo systemctl restart systemd-journal-upload
```

按照你的登录`debian2`进行测试:

```
$ sudo journalctl -D /var/log/journal/remote/ -f
```

也可以使用我们信任的`debian1`上的`logger`命令进行测试:

```
$ logger -p syslog.err "Debian1 logs, on Debian2!"
```

运气好的话，你会看到以下内容:

![](assets/44ecbf30-a60f-4b80-a642-98f816521792.png)

# 它是如何工作的...

我们正在有效地做的是在`syslog`和`journald`解决方案中为日志打开一个监听器。我们的盒子上打开了一个网络端口，守护进程知道它可能被迫读取的数据源。在`syslog`的情况下，我们必须启用`rsyslog`守护程序中的特定模块来实现这一点；`systemd`和`journald`需要特定的包装。

显然，journald 的实现看起来有点笨拙，但这主要是因为它比较新。

从根本上来说，我们只是在处理流式日志数据，无论是`syslog`还是`journald`都不关心这些数据来自哪里，只要这些数据是他们能够理解的格式。

# 还有更多...

集中记录时，时间非常重要。想想看，在一个包含多台主机的日志文件中，发现穿插的时间跳跃是多么令人困惑。

它还会使日志解析变得困难，因为我们可以使用特定的时间戳来正确排列数据，如果我们的远程盒子时间错误，我们可能会错过一些关键的东西。

TLS 和安全传输也是需要考虑的事情，正如在本节的介绍中提到的。您可以将`systemd-journal-remote`配置为监听 HTTPS，而不是 HTTP，只要您正确排序您的证书。

对于 syslog，TLS 和加密可能有点棘手，但有更多的解决方案需要考虑，例如通过 SSH 隧道流式传输日志数据，或者使用`spipe`等程序来卸载 TLS 的繁重工作。

# 本地资源测量工具

有时候，知道一个盒子在这一秒钟里做了什么是非常方便的。通常，这将是在调试会话期间，当您试图弄清楚为什么网站响应慢了一个数量级，或者为什么在远程会话上键入 SSH 命令需要 5 分钟。

在这里，本地资源监视器派上了用场。我们已经简单介绍了这些工具，但是这一部分将稍微详细地介绍它们，并将介绍一些在远程连接到服务器时可能会有用的较为晦涩的工具。

我们先来看看`free`和`top`的经典，然后再来看看最近的新增内容，比如`netdata`和`htop`。

# 准备好

在本节中，我们将使用我们的`centos1`和`debian1`虚拟机。

我们看到的所有程序都将以这样或那样的形式普遍可用。

SSH 到您的`centos1`虚拟机，并确保启用了 EPEL 存储库:

```
$ vagrant ssh centos1 $ sudo yum install epel-release -y
$ sudo yum install htop -y
```

SSH 到您的`debian1`虚拟机，非常明确地说，转发端口`19999`到您的本地机器(稍后将详细介绍):

```
$ vagrant ssh debian1 -- -L 127.0.0.1:19999:127.0.0.1:19999
```

# 怎么做...

就像我们所看到的大多数软件一样，大约从 20 世纪 70 年代开始，就有这样或那样的软件的经典例子，那时大多数程序的名字只有两三个字符(ls、cp、mv)。其中一个是`top`，另一个是`free`，两个都还有自己的位置。

然后是更现代、更流畅、更漂亮的节目。单色阴极射线管设计的应用程序消失了，取而代之的是终端应用程序，甚至支持 256 种颜色！

最后是网络数据，我在这里提到它，因为它在地方管理领域掀起了一场风暴。

# 顶端

一个老朋友，保证安装在任何 Unix 或类似 Unix 的系统上，顶部是您的即时窗口，了解您的系统认为它在做什么:

```
$ top
```

前面命令的输出如下所示:

![](assets/6950a085-46bf-4316-99f4-fbe2499e2e44.png)

从一开始，我们就能看到几件事:

*   左上方的时间，以及箱子上升了多长时间–17:09:46 上升了 8 分钟
*   登录的用户数–1 个用户
*   平均负载–0.00、0.03、0.03
*   跑步、睡眠等任务的数量
*   中央处理器使用信息
*   易失性存储信息
*   交换信息(磁盘存储器)

分解这些，让我们看一些更详细的:

*   **负载平均值**:详细来说，负载平均值是系统在最近 1、5、15 分钟内的负载。该平均负载显示了正在运行的进程，或者等待资源(如中央处理器时间或磁盘输入/输出)的进程

The disk I/O element is important, as it's something that's pretty Linux-specific and that a lot of people forget. You can have a system that's completely free of load on the CPU, and yet has high load average values; this can be an indication that you need to upgrade that old and creaking HDD into a shiny new NVMe drive.

*   **任务** : 基本上，你可以把任务想象成现在正在运行的进程数，或者你系统上处于休眠/僵尸/停止状态的进程数。这和你用`ps aux`得到的数字是一样的。
*   **%CPU** :这个最好遵从手册页:

us, user    : time running un-niced user processes
           sy, system  : time running kernel processes
           ni, nice    : time running niced user processes
           id, idle    : time spent in the kernel idle handler
           wa, IO-wait : time waiting for I/O completion
           hi : time spent servicing hardware interrupts
           si : time spent servicing software interrupts
           st : time stolen from this vm by the hypervisor

*   **KiB 内存**:以数字表示，这是系统可用的内存量，分为总内存、可用内存、已用内存和缓冲区/缓存。

Buffers/caches are memory that's in use, but which can be annexed by any program that wishes to use it in an instant. Linux likes RAM, and unused RAM is wasted RAM, so it will do everything it can to use it.

*   **KiB 掉期**:同样是数字，这是可用的掉期金额，再次细分。

如果你想要一个更好的视图，通过点击几次 *M* 在选项中循环会给你视觉上的表现:

![](assets/5b48f441-143c-4040-a8f2-5ba586e05f16.png)

最后，我们有不断变化的进程列表和关于在您的系统上运行作业的信息:

![](assets/98d0b821-84f3-45b7-a9b8-3130314dadd0.png)

默认情况下，这是按 CPU 使用率(%CPU)组织的，但如果您愿意，您可以进行调整。

沿着顶部，我们有以下内容:

*   有问题的任务的 PID
*   运行流程的用户
*   PR，任务的优先级(优先级越高，越有可能获得优先级)
*   倪，任务的美好价值；负值具有更高的优先级
*   VIRT，任务使用的虚拟内存(所有内存，包括共享库之类的)
*   RES，任务正在使用的非交换物理内存
*   SHR，大部分是 RES，没有一些对本书来说过于技术性的部分

*   s，进程的状态(运行、睡眠、僵尸等)
*   %CPU，自上次刷新以来任务使用了多少 CPU 时间，占总可用 CPU 时间的百分比
*   %MEM，任务当前使用了多少可用物理内存
*   TIME+，TIME 的更新，它是任务自启动以来使用的总 CPU 时间；加号增加了粒度
*   命令，任务的名称

唷！

那是`top`，但远不止如此，在不同的系统上看起来可能略有不同。它也可以做彩色，但据我所知，只有一个发行版开箱即用。

装`top`打 *H* 还是*是个好主意？*了解`top`的功能。

# 自由的

`free`是一个一目了然地看到你的系统有多忙的好方法；更具体地说，这是找出盒子上使用了多少内存的最快方法。

谢天谢地，`free`的选择比`top`少。大多数情况下，这些标志只是为了改变命令的输出，使它更容易被人理解，如果你喜欢的话。

Personally, I use `-m` which outputs the value in mebibytes, but if your system has Gigs of memory, you might find `-g` more useful.

在下文中，您将在我们的`centos1` VM 上看到`free -ht`:`-h`用于人类可读的输出，给出了 mebibyte 和 gibibyte 值的良好混合；`-t`是添加一条`Total`线的标志，给出`Mem`和`Swap`值的总和:

![](assets/07d3d8d0-fa5b-47f7-a9dd-4aa68ed2ebdf.png)

重要的字段是`available`，因为它有效地告诉你在系统开始交换之前有多少物理内存可用；如果这是`0`，你将不断地读写磁盘，这可能会大大降低系统的速度。

# 快上来

`htop`像`top`，但是更漂亮。如果一个盒子在我的控制之下(并且提供了适当的批准)，你很可能会发现安装了`htop`。

在紧要关头，`top`没问题，你肯定会发现它预装在盒子上，但如果你想要一些感觉不像是上世纪 70 年代的东西，`htop`就非常有帮助了。

以下是我们的`centos1`虚拟机上的`htop`:

![](assets/38d52dde-947b-4aea-b1fe-8b652ba728c3.png)

请注意，我们仍然有`top`给我们的所有相同信息，只是现在我们已经利用了现代终端仿真器可以做的事情，默认情况下给我们颜色，并很好地将输出对齐到也支持鼠标输入的窗口中(试试看！).

进一步到`top`，我们有能力通过改变窗口的外观来快速轻松地格式化我们的输出；屏幕底部的`Tree`(*F5*)等选项在按下时可以提供非常有用的树状图(注意变为`Sorted`):

![](assets/444e082f-3db0-44a6-8277-d7a5f7e5743e.png)

与顶部一样，也有选项可以更改列和信息的显示内容，尽管与`top`不同，这些选项位于设置菜单( *F3* )下，更改以配置文件的形式保存在磁盘上，位于`~/.config/htop/htoprc`。

# NetData(净数据)

流行主要是因为能够有效地推销自己，网络数据是它所能获得的所有系统信息的聚合器。

This is not an advert nor an endorsement, merely an example of what third-party software can do. NetData does use a centralized server for logging some data, such as system hostnames, meaning you should check against your internal security policy if you intend to use this tool. See the NetData security page for more information:

[https://docs.netdata.cloud/docs/netdata-security/](https://docs.netdata.cloud/docs/netdata-security/)

As with everything, understand what the software you're installing does, before you blindly click Accept.

切换到我们的 Debian 虚拟机，我们将在这里安装 NetData，因为它在后端存储库中是可用的(在此之后，软件被添加到以前发布的 Debian 版本中)。

首先，我们需要启用`backports`存储库，然后我们可以安装我们的包:

```
$ echo "deb http://ftp.debian.org/debian stretch-backports main" | sudo tee -a /etc/apt/sources.list
$ sudo apt update
$ sudo apt install netdata -y
```

由于默认情况下 Debian 通常会启动服务，因此在安装之后，现在已经启用并启动了 NetData。

然而，默认情况下，它将只监听本地主机，这就是为什么我们需要在我们的*准备*部分转发该 IP 和端口。如果您还没有这样做，请从您的`debian1`虚拟机注销，并使用该部分的命令。

现在，在本地机器的网络浏览器中导航到`http://127.0.0.1:19999`会将该连接转发到您的虚拟机，您应该会看到网络数据图形用户界面:

![](assets/3754837c-4578-450f-8bc6-0380ed3c646a.png)

NetData Homepage

甚至我不得不承认，这个界面非常时髦。

请注意，在右侧，它甚至为您提供了有关 netdata 正在做什么以及从哪里获取信息的信息片段:`debian1`上的 NetData 每秒收集 686 个指标，呈现为 142 个图表，并由 41 个警报监控，使用 11 MB 的内存进行 1 小时 6 分 36 秒的实时历史记录。

# 它是如何工作的...

`top`查询内核以收集关于正在运行的系统的信息，这使得它能够非常快速地反映运行它的盒子的性质。它的重量也非常轻，这意味着除非盒子严重超载，否则`top`很有可能仍然会运行(如果它超载，你就有更大的问题)。从 20 世纪 80 年代就有了；已经试过了。

`free`查看`/proc/meminfo`中的可用值，这意味着虽然您可以自己查询这些文件(有些人会这样做)，`free`提供了一种更好的查看值的方式(并为您提供了定期刷新的选项，如果您想要的话)。

`htop`查询系统的方式与`top`基本相同(尽管这在操作系统(如 macOS 或 BSD 系列)中不一定相同)。与`htop`不同的是，它使用`ncurses`图书馆来展示自己，虽然它没有`top`那么古老，但在撰写本文时，它已经存在了大约 14 年。

NetData 使用各种来源(并且可以使用自定义插件)每秒收集数据；然后它向用户显示这些数据。

# 还有更多...

NetData 可能看起来很酷，而且，一眼看去，它可能是一种了解您的服务器在做什么的巧妙方法(尤其是如果您已经将它挂在办公室的墙上或其他地方)，但这不是广告，我建议在使用此类工具时要谨慎。不是因为它们很危险(尽管总是检查你的来源)，而是因为它们可能有点轻浮，只不过是管理层偶尔想在你的电脑显示器上看到的仪表板。

哦！我想到了网络数据的另一个很好的用途，也许是在一些俗气的 DC 或科幻电视节目中作为某种背景装扮；那也很好。

我们在这里看到的只是提供的工具的一个示例。默认设置对你来说永远都是可用的(世界之巅和自由之地)，但还有数百种选择，其中一些可能适合你的需求，而另一些可能适合办公室角落里的墙板，而其他人从未使用过。

四处看看，搜一下网，试一试。

这是 Linux，有一百种方法可以完成同样的事情。

# 本地监控工具

就像此时此地监视系统资源的工具一样，也有查看系统历史数据的工具。网络数据可以被认为是其中之一，这取决于您如何使用它，但是除此之外还有更多，我们将查看更多可以帮助您调试过去问题的信息。

我们将看一看以下内容:

*   `atop`
*   `sar`
*   `vmstat`

# 准备好

对于这一节，我们将继续使用本章第一节中的`Vagrantfile`。

登录`centos1`，我们将在本节中使用的虚拟机:

```
$ vagrant ssh centos1
```

安装我们将使用的工具:

```
$ sudo yum install epel-release -y
$ sudo yum install atop sysstat -y
```

# 怎么做...

安装好所有工具后，完成以下每个部分。

# 在顶上

top(高级系统和过程监控)

首先，正常运行`atop`:

```
$ atop
```

你应该看到这样的东西:

![](assets/7df27ac4-c1bd-4b8d-b33f-14e991620d90.png)

这给了我们一些好的信息，特别是系统和进程自启动以来的活动，然后它会滚动显示前 10 秒的活动。换句话说，10 秒后，它看起来是这样的:

![](assets/f4a44ad1-75f7-4fe3-8317-cf644e07bbb6.png)

此外，`atop`不仅可以用来存储当前引导的数据，还可以定期存储。

启用`atop`服务，如下所示:

```
$ sudo systemctl enable atop --now
```

您现在会发现历史日期以二进制格式记录到`/var/log/atop`中，然后这些相同的文件可以在将来的某个日期重播，以防您想知道半夜系统发生了什么导致了所有这些红色警报:

```
$ sudo ls /var/log/atop/
atop_20181013  daily.log
```

要再次读取文件，您可以指定完整的文件名，也可以指定之后的日期:

```
$ atop -r 20181013
```

因为我们在`18:56:14`启动了服务，这就是我们加载这个文件时看到的情况:

![](assets/3d14cc15-92ae-414f-9d77-50f4fd9d726d.png)

然后我们可以通过使用 *t* 和*T**T5】向前和向后移动来调整样本。*

`atop`在午夜由`cron`作业重新启动:

```
$ sudo cat /etc/cron.d/atop
# daily restart of atop at midnight
0 0 * * * root systemctl try-restart atop
```

# 特别行政区

`sar`是一种读取系统信息的方式，但也允许你读取历史信息。

它是通过`systemctl`命令启用的，该命令实际上会触发一个名为`sa1`的二进制文件在启动时启动:

```
$ sudo systemctl enable --now sysstat
```

通过`cron`作业运行，`sar`每 10 分钟执行一次，以获取系统信息。然后在`23:53`创建每日总结:

```
$ sudo cat /etc/cron.d/sysstat 
# Run system activity accounting tool every 10 minutes
*/10 * * * * root /usr/lib64/sa/sa1 1 1
# 0 * * * * root /usr/lib64/sa/sa1 600 6 &
# Generate a daily summary of process accounting at 23:53
53 23 * * * root /usr/lib64/sa/sa2 -A
```

要指定要打开和读取的`sar`文件，请使用`-f`标志:

```
$ sar -f /var/log/sa/sa13 
Linux 3.10.0-862.2.3.el7.x86_64 (centos1)     13/10/18     _x86_64_    (1 CPU)

18:50:01        CPU     %user     %nice   %system   %iowait    %steal     %idle
19:00:01        all      0.03      0.00      0.21      0.00      0.00     99.76
Average:        all      0.03      0.00      0.21      0.00      0.00     99.76

19:07:51          LINUX RESTART

19:10:01        CPU     %user     %nice   %system   %iowait    %steal     %idle
19:14:43        all      0.04      0.00      0.22      0.00      0.00     99.75
19:15:07        all      0.17      0.00      0.48      0.00      0.00     99.35
19:20:01        all      0.01      0.00      0.12      0.00      0.00     99.87
19:30:01        all      0.00      0.00      0.09      0.00      0.00     99.91
19:40:01        all      0.00      0.00      0.10      0.00      0.00     99.90
Average:        all      0.01      0.00      0.12      0.00      0.00     99.87
```

或者，如果您想要更精细，您可以指定开始和停止时间:

```
$ sar -f /var/log/sa/sa13 -s 19:10:00 -e 19:15:08
Linux 3.10.0-862.2.3.el7.x86_64 (centos1) 13/10/18 _x86_64_ (1 CPU)

19:10:01 CPU %user %nice %system %iowait %steal %idle
19:14:43 all 0.04 0.00 0.22 0.00 0.00 99.75
19:15:07 all 0.17 0.00 0.48 0.
00 0.00 99.35
Average: all 0.05 0.00 0.24 0.00 0.00 99.72
```

# vmstat

`vmstat`是报告内存统计的绝佳方式；默认情况下，它的输出如下所示:

```
$ vmstat
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0   1544  65260      0 367336    0    0    57    78   45   47  0  0 100  0  0
```

`vmstat`的优势在于它的初始报告(前面的输出)是自引导以来的信息，您可以在命令的末尾添加一个数字，以获得滚动摘要:

```
$ vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 2  0   1544  65140      0 367336    0    0    57    77   45   47  0  0 100  0  0
 0  0   1544  65140      0 367336    0    0     0     0   49   48  0  0 100  0  0
 0  0   1544  64768      0 367336    0    0     0     0   51   54  0  0 100  0  0
 0  0   1544  64768      0 367336    0    0     0     0   48   48  0  0 100  0  0
 0  0   1544  64768      0 367336    0    0     0     1   46   46  0  0 100  0  0
 0  0   1544  64768      0 367336    0    0     0     0   47   46  0  0 100  0  0
 0  0   1544  64588      0 367336    0    0     0     0   49   53  0  0 100  0  0
 0  0   1544  64784      0 367336    0    0     0     0   49   51  0  0 100  0  0
 0  0   1544  64784      0 367336    0    0     0     0   48   48  0  0 100  0  0
 1  0   1544  64784      0 367336    0    0     0     0   46   48  0  0 100  0  0
```

同样，像网络数据一样，`vmstat`可以归入任何一个类别(本节或前一节)，因此，由用户决定如何做。例如，你可以写一个`systemd-timer`来运行`vmstat` 10 次，每小时一次，然后将结果输出到一个文件中，供你以后阅读。这比开箱即用的解决方案(如`sar`和`atop`)更加手动，但对于更大的项目来说，这将是一个很好的实践。

# 它是如何工作的...

与我们的前一部分一样，开箱即用的`atop`和`sar`设置已经为您完成，但是可以在流程的相关配置文件中进行进一步的配置更改。

在 CentOS 下，这些生活在`/etc/sysconfig`中，这是传统:

```
$ cat /etc/sysconfig/atop 
# sysconfig atop
#

# Current Day format
CURDAY=`date +%Y%m%d`
# Log files path
LOGPATH=/var/log/atop
# Binaries path
BINPATH=/usr/bin
# PID File
PIDFILE=/var/run/atop.pid
# interval (default 10 minutes)
INTERVAL=600
$ cat /etc/sysconfig/sysstat
# sysstat-10.1.5 configuration file.
# How long to keep log files (in days).
# If value is greater than 28, then log files are kept in
# multiple directories, one for each month.
HISTORY=28
# Compress (using gzip or bzip2) sa and sar files older than (in days):
COMPRESSAFTER=31
# Parameters for the system activity data collector (see sadc manual page)
# which are used for the generation of log files.
SADC_OPTIONS="-S DISK"
# Compression program to use.
ZIP="bzip2"
```

当`atop`启动(使用`systemd`)时，使用`sysconfig`中的选项，触发`/usr/share/atop/atop.daily`脚本。

当`systemd`启用`sysstat`时，它特别告诉`sar`从一个虚拟记录开始，表示新的引导。这是对我们之前看到的`cron`条目的补充，这些条目由`/etc/sysconfig`中的配置文件规定。

使用这些工具有点复杂，但是如果你善于解释和使用它们提供的信息，你很快就会发现这些数据对你来说是无价的。

# 远程监控工具

能够在本地查询服务器并找出它在做什么是很好的，但是在现实世界中很少这样做(在你可能为个人项目维护的单个盒子之外)。在公司场景中，更有可能的是，您会有某种监控解决方案，可能在您的盒子上有代理，它会监视您所护理的机器的健康状况。

Nagios 是全球无可争议的监控安装之王，这并不是因为它是最好的，或者是最华而不实的，而仅仅是因为它是最古老的之一，一旦监控解决方案到位，您会发现团队对于切换到新的解决方案非常犹豫。

它导致了几个克隆体被创建，以及各种分支(一些使用原始源代码，一些不使用)，但是它们都将以类似的方式运行。

在这一部分，我们将在`centos1`上安装 **Nagios** ，并让它监控自身和`debian1`，而在`centos2`上安装 **Icinga2** ，并让它监控`debian2`。

# 准备好

对于本节，第一节的`Vagrantfile`就足够了。我们将使用所有四个虚拟机。

我们将首先运行 Nagios 设置，然后进入 Icinga2。

连接到您的每个箱子，或者从`centos1`和`debian1`开始，然后继续到`centos2`和`debian2`后面。

当连接到`centos1`进行`Nagios`安装时，您将希望向前使用以下端口:

```
$ vagrant ssh centos1 -- -L 127.0.0.1:8080:127.0.0.1:80
```

# 怎么做...

如上所述，我们将首先运行 Nagios，然后运行 Icinga2。

# Nagios

在`centos1`上，让我们安装来自 EPEL 的 Nagios:

```
$ sudo yum install -y epel-release
$ sudo yum install -y httpd nagios nagios-plugins-all nagios-plugins-nrpe
```

现在已经完成了(这可能需要一些时间，因为有很多插件)，我们应该启动并启用我们的服务，以及`httpd`，默认情况下应该安装:

```
$ sudo systemctl enable --now nagios
$ sudo systemctl enable --now httpd
```

开箱即用，你会得到一个不安全的 nagios-web 设置。如果您已经按照前面的建议连接到了您的游民虚拟机，现在您应该能够导航到转发端口(`http://127.0.0.1:8080/nagios`)上的 web 界面:

![](assets/efaaa137-c30d-43e7-a502-2599e0146020.png)

我们实际上还没有设置我们的`nagiosadmin`密码(对于基本的`http auth`提示)，所以现在让我们这样做:

```
$ sudo htpasswd /etc/nagios/passwd nagiosadmin
New password: 
Re-type new password: 
Updating password for user nagiosadmin
```

设置密码后，请尝试在提示框中输入密码:

![](assets/2679b5a7-8afe-4834-ac9d-8a7a4a7f2f74.png)

您应该会看到 Nagios 登录页面:

![](assets/5d9f6303-81eb-43cb-af2c-4ed92bdaf02a.png)

As I've mentioned in other places, I wouldn't recommend using basic HTTP authentication in this manner, as it's insecure. If you can't use HTTPS/TLS to secure the web page, you should block it so that it can only be accessed on the box locally, and use something like SSH forwarding to encrypt connections to the portal. Ideally, though, get a certificate from LetsEncrypt and make life easy for yourself.

现在点击左侧的服务；这是您最想去的地方，因为它显示了 Nagios 当前监控的主机和主机上的服务:

![](assets/151f78e9-dd19-4412-8878-0017c16ed4d0.png)

默认情况下，您可以看到我们只监控本地主机，这目前还可以，但是我们想将`debian1`添加到混合中。回到命令行，让我们开始工作，首先指向 Nagios 配置文件中的`debian1`文件:

```
$ echo "cfg_file=/etc/nagios/objects/debian1.cfg" | sudo tee -a /etc/nagios/nagios.cfg
```

现在我们需要创建`debian1.cfg`:

```
$ sudo cp /etc/nagios/objects/localhost.cfg /etc/nagios/objects/debian1.cfg
```

目前我们已经获得了与`localhost`机器相同的配置，因此我们将使用`debian1`特定值替换这些配置。我们还将专门为远程虚拟机创建一个新的主机组，并将本地检查更改为首先使用`check_nrpe`:

```
$ sudo sed -i 's/localhost/debian1/g' /etc/nagios/objects/debian1.cfg
$ sudo sed -i 's/127.0.0.1/192.168.33.12/g' /etc/nagios/objects/debian1.cfg
$ sudo sed -i 's/linux-servers/remote-vms/g' /etc/nagios/objects/debian1.cfg
$ sudo sed -i 's/check_local/check_nrpe!check_client/g' /etc/nagios/objects/debian1.cfg
```

有了这些，我们必须定义`check_nrpe`命令:

```
$ cat <<HERE | sudo tee -a /etc/nagios/objects/commands.cfg
define command{
 command_name    check_nrpe
 command_line    \$USER1\$/check_nrpe -H \$HOSTADDRESS\$ -c \$ARG1\$ 
 }
HERE
```

完成后，我们可以重新开始安装 Nagios:

```
$ sudo systemctl restart nagios
```

再次查看您的服务页面，您现在会看到`debian1`，可能有许多检查失败。

这是因为`debian1`上没有设置 NRPE，所以现在就让我们 SSH 到`debian1`去做吧！

首先，我们需要安装各种零件:

```
 $ sudo apt install monitoring-plugins nagios-nrpe-server -y
```

现在，我们需要允许我们的`centos1`盒子与`debian1`对话(通过端口`5666`):

```
$ sudo sed -i 's/allowed_hosts=127.0.0.1/allowed_hosts=127.0.0.1,192.168.33.10/g' /etc/nagios/nrpe.cfg
```

我们还需要定义服务器将请求在客户机上运行的客户机命令:

```
$ cat <<HERE | sudo tee /etc/nagios/nrpe_local.cfg 
command[check_client_load]=/usr/lib/nagios/plugins/check_load -w 5.0,4.0,3.0 -c 10.0,6.0,4.0
command[check_client_users]=/usr/lib/nagios/plugins/check_users -w 20 -c 50
command[check_client_disk]=/usr/lib/nagios/plugins/check_disk -w 20% -c 10% -p /
command[check_client_swap]=/usr/lib/nagios/plugins/check_swap -w 20 -c 10
command[check_client_procs]=/usr/lib/nagios/plugins/check_procs -w 250 -c 400 -s RSZDT
HERE
```

最后，我们可以在`debian1`上重新启动`nrpe`服务:

```
$ sudo systemctl restart nagios-nrpe-server
```

现在，回顾一下 Nagios 网络界面(如果您断开连接，不要忘记再次 SSH 到`centos1`虚拟机)，我们应该看到我们的服务被正确检查:

![](assets/3a5cc6d4-73b8-40be-9a85-27543929882a.png)

Nagios Services Page with ‘debian1’

请注意，我们有一个失败的检查(HTTP)，因为`debian1`没有安装和运行网络服务器。

If your checks haven't cycled through yet, you can force all services on a host to be checked by clicking on the host's name and then selecting the Schedule a check of all services on this host command.

# Icinga2

像 Nagios 一样(这是它最初的来源)，Icinga2 有一个中央服务器的概念，它可以监视其他主机上的代理。

我们将在我们的`centos2`虚拟机上安装`Icinga2`，然后从我们的第一台主机监控我们的`debian2`虚拟机。

开始，跳到`centos2`并安装`Icinga2`:

```
$ vagrant ssh centos2 -- -L 127.0.0.1:8181:127.0.0.1:80
```

注意转发部分；这将用于稍后的图形用户界面设置(端口`8181`):

```
$ sudo yum install epel-release -y
$ sudo yum install centos-release-scl -y
$ sudo yum install https://packages.icinga.com/epel/icinga-rpm-release-7-latest.noarch.rpm -y
$ sudo yum install httpd icinga2 icinga2-ido-mysql nagios-plugins-all icinga2-selinux mariadb-server mariadb icingaweb2 icingacli icingaweb2-selinux rh-php71-php-mysqlnd -y
$ sudo systemctl enable --now icinga2
$ sudo systemctl enable --now mariadb
```

运行`mariadb`安装脚本(根密码默认为空；将其设置为您会记住的内容):

```
$ mysql_secure_installation

NOTE: RUNNING ALL PARTS OF THIS SCRIPT IS RECOMMENDED FOR ALL MariaDB
      SERVERS IN PRODUCTION USE!  PLEASE READ EACH STEP CAREFULLY!

In order to log into MariaDB to secure it, we'll need the current
password for the root user.  If you've just installed MariaDB, and
you haven't set the root password yet, the password will be blank,
so you should just press enter here.

Enter current password for root (enter for none): 
OK, successfully used password, moving on...

Setting the root password ensures that nobody can log into the MariaDB
root user without the proper authorisation.

Set root password? [Y/n] Y
New password: 
Re-enter new password: 
Password updated successfully!
Reloading privilege tables..
 ... Success!

By default, a MariaDB installation has an anonymous user, allowing anyone
to log into MariaDB without having to have a user account created for
them.  This is intended only for testing, and to make the installation
go a bit smoother.  You should remove them before moving into a
production environment.

Remove anonymous users? [Y/n] Y
 ... Success!

Normally, root should only be allowed to connect from 'localhost'.  This
ensures that someone cannot guess at the root password from the network.

Disallow root login remotely? [Y/n] Y
 ... Success!

By default, MariaDB comes with a database named 'test' that anyone can
access.  This is also intended only for testing, and should be removed
before moving into a production environment.

Remove test database and access to it? [Y/n] Y
 - Dropping test database...
 ... Success!
 - Removing privileges on test database...
 ... Success!

Reloading the privilege tables will ensure that all changes made so far
will take effect immediately.

Reload privilege tables now? [Y/n] Y
 ... Success!

Cleaning up...

All done!  If you've completed all of the above steps, your MariaDB
installation should now be secure.

Thanks for using MariaDB!
```

现在为`icinga`设置`mariadb`。该信息可在《Icinga2 *入门*指南》[https://icinga . com/docs/icinga 2/latest/doc/02-入门/#设置-icinga-web-2](https://icinga.com/docs/icinga2/latest/doc/02-getting-started/#setting-up-icinga-web-2) 中找到:

```
$ mysql -u root -p<The Password You Set Above>

MariaDB [(none)]> CREATE DATABASE icinga;
Query OK, 1 row affected (0.00 sec)

MariaDB [(none)]> GRANT SELECT, INSERT, UPDATE, DELETE, DROP, CREATE VIEW, INDEX, EXECUTE ON icinga.* TO 'icinga'@'localhost' IDENTIFIED BY 'icinga';
Query OK, 0 rows affected (0.06 sec)

MariaDB [(none)]> quit
Bye
```

最后，导入提供的`schema`数据库:

```
$ mysql -u root -p icinga < /usr/share/icinga2-ido-mysql/schema/mysql.sql
```

在`icinga2`和`restart`服务中启用实际插件:

```
$ sudo icinga2 feature enable ido-mysql
$ sudo systemctl restart icinga2
```

一旦数据库设置完成，我们就可以进行实际的 web 安装了。

我们在本节的安装步骤中包含了`httpd` (apache)，因为这是 Icinga2 推荐的，尽管也可以使用 NGINX(这确实是 FreeBSD 上的默认设置)。

首先启动并启用它:

```
$ sudo systemctl enable --now httpd
```

接下来，启用`icinga2``restart`的`api`功能:

```
$ sudo icinga2 api setup
$ sudo systemctl restart icinga2
```

将在`api-users.conf`中添加根用户和随机密码:

```
$ sudo cat /etc/icinga2/conf.d/api-users.conf
/**
 * The ApiUser objects are used for authentication against the API.
 */
object ApiUser "root" {
 password = "40ebca8aaaf1eba0"
 // client_cn = ""

 permissions = [ "*" ]
}
```

Icinga2 web 还需要启用 **FastCGI 流程管理器** ( **FPM** )，因此请执行以下操作:

```
$ sudo sed -i 's/;date.timezone =/date.timezone = UTC/g' /etc/opt/rh/rh-php71/php.ini
$ sudo systemctl enable --now rh-php71-php-fpm.service
```

完成后，您应该可以在浏览器中点击安装的 Icinga2 网页设置(使用我们的转发连接)，`http://127.0.0.1:8181/icingaweb2/setup`:

![](assets/418175ed-c6da-4386-8a55-aa12020cc694.png)

要找到您的设置代码，请返回到您的`centos2`命令行并运行以下命令:

```
$ sudo icingacli setup token create
The newly generated setup token is: 052f63696e4dc84c
```

输入您的代码并点击下一步完成安装(确保需求页面上没有*红色*；黄色对于 Imagick PHP 模块来说是可以的):

![](assets/a85453fc-6c09-4b90-abb3-576789240e6b.png)

当提示输入身份验证类型时，选择数据库:

![](assets/4f809e92-2931-4edc-ba1d-18a8af575535.png)

在下一页，将提示您提供数据库名称、数据库用户名和数据库密码。选择合适的值(如果还没有创建，请不要担心，我们接下来会这样做):

![](assets/e6709c08-24cb-40e8-a811-5d75f20457ae.png)

在这里，你可以看到我选择了`icinga2web`作为数据库名称和用户名。单击下一步。

在接下来的屏幕上，您将被要求输入可以访问 MariaDB 的用户的凭据，以创建新的数据库；我选择使用我们之前设置的 MariaDB 根用户:

![](assets/7a186994-1e24-489e-8d15-c669d52da5c2.png)

系统会提示您选择后端名称，这是一个美观的决定，以便您以后可以识别后端:

![](assets/b08dae41-6c95-4f48-9e16-6b20dc7b490b.png)

你会被要求创建一个网络用户；我跟`icingaweb`去了:

![](assets/59edf32f-5a7b-4aac-8a9b-5fa4503253bd.png)

我将应用程序配置保留为默认值:

![](assets/b5fd06f3-1308-4536-9d4d-c47d17209882.png)

最后，系统会提示您确认已输入的设置；在继续之前，快速浏览一下。

再单击几次“下一步”将进入监控后端设置(IcingaWeb2 会在其中查找监控数据库):

![](assets/18c564de-06cb-4320-9e00-1facfbeefb88.png)

系统会提示您添加可用于查询 icinga 数据库的连接详细信息(我们在本章中使用 MariaDB 命令行界面进行了设置)。我们设置了以下默认值:用户名`icinga`，密码`icinga`:

![](assets/89952058-3cfb-4e43-9896-63d30c8459fc.png)

使用“验证配置”按钮验证您的配置。

在命令传输屏幕上，将提示您输入我们创建的应用编程接口用户的详细信息。我们只添加了 root，所以我们现在就使用它(来自前面的 api-users.conf 文件):

![](assets/519a6afc-0555-457b-bb4a-d6e3c6a6ad72.png)

单击下一步，直到您到达最后，您应该会看到一个绿色的快乐横幅:

![](assets/74efcfd9-db3e-42a3-8718-e5260453aefc.png)

继续进入提示的登录页面，使用我们创建的 web 用户登录:

![](assets/794eaac0-b52c-4c84-8368-878e5ea5e0f5.png)

Icinga2 Login Page

当你有时间阅读这本书时，设计可能已经发生了一些变化，但希望你有一些接近以下 Icinga2 仪表板的东西:

![](assets/453460db-87ee-45ac-96ee-d234bab7e2ad.png)

在进入下一部分之前，先四处看看，我们将在这里添加另一个主机。

首先，在客户端安装`icinga2`之前，我们必须将第一台服务器建立为`master`。

您可以使用安装脚本来完成此操作；我把唯一需要的改变用粗体表示:

```
$ sudo icinga2 node wizard
Welcome to the Icinga 2 Setup Wizard!

We will guide you through all required configuration details.

Please specify if this is a satellite/client setup ('n' installs a master setup) [Y/n]: n

Starting the Master setup routine...

Please specify the common name (CN) [centos2]: 
Reconfiguring Icinga...
Checking for existing certificates for common name 'centos2'...
Certificate '/var/lib/icinga2/certs//centos2.crt' for CN 'centos2' already existing. Skipping certificate generation.
Generating master configuration for Icinga 2.
'api' feature already enabled.

Master zone name [master]: 

Default global zones: global-templates director-global
Do you want to specify additional global zones? [y/N]: 
Please specify the API bind host/port (optional):
Bind Host []: 
Bind Port []: 

Do you want to disable the inclusion of the conf.d directory [Y/n]: 
Disabling the inclusion of the conf.d directory...
Checking if the api-users.conf file exists...

Done.

Now restart your Icinga 2 daemon to finish the installation!
```

照建议做，重启`icinga2`:

```
$ sudo systemctl restart icinga2
```

生成一个令牌供我们的客户端在连接时使用:

```
$ sudo icinga2 pki ticket --cn debian2
8c7ecd2c04e6ca73bb0d1a6cc62ae4041bf2d5d2
```

现在 SSH 到你的`debian2`盒，安装`icinga2`:

```
$ sudo apt install icinga2 -y
```

运行节点安装，这次指定我们是代理，并在出现提示时传入之前的令牌:

```
$ sudo icinga2 node wizard
Welcome to the Icinga 2 Setup Wizard!

We'll guide you through all required configuration details.

Please specify if this is a satellite setup ('n' installs a master setup) [Y/n]: 
Starting the Node setup routine...
Please specify the common name (CN) [debian2]: 
Please specify the master endpoint(s) this node should connect to:
Master Common Name (CN from your master setup): centos2
Do you want to establish a connection to the master from this node? [Y/n]: 
Please fill out the master connection information:
Master endpoint host (Your master's IP address or FQDN): 192.168.33.11
Master endpoint port [5665]: 
Add more master endpoints? [y/N]: 
Please specify the master connection for CSR auto-signing (defaults to master endpoint host):
Host [192.168.33.11]: 
Port [5665]: 
information/base: Writing private key to '/etc/icinga2/pki/debian2.key'.
information/base: Writing X509 certificate to '/etc/icinga2/pki/debian2.crt'.
information/cli: Fetching public certificate from master (192.168.33.11, 5665):

Certificate information:

 Subject:     CN = centos2
 Issuer:      CN = Icinga CA
 Valid From:  Oct 13 22:34:30 2018 GMT
 Valid Until: Oct  9 22:34:30 2033 GMT
 Fingerprint: B5 0B 00 5D 5F 34 14 08 D7 48 8E DA E1 83 96 35 D9 0F 54 1F 

Is this information correct? [y/N]: y
information/cli: Received trusted master certificate.

Please specify the request ticket generated on your Icinga 2 master.
 (Hint: # icinga2 pki ticket --cn 'debian2'): 8c7ecd2c04e6ca73bb0d1a6cc62ae4041bf2d5d2
information/cli: Requesting certificate with ticket '8c7ecd2c04e6ca73bb0d1a6cc62ae4041bf2d5d2'.

information/cli: Created backup file '/etc/icinga2/pki/debian2.crt.orig'.
information/cli: Writing signed certificate to file '/etc/icinga2/pki/debian2.crt'.
information/cli: Writing CA certificate to file '/etc/icinga2/pki/ca.crt'.
Please specify the API bind host/port (optional):
Bind Host []: 
Bind Port []: 
Accept config from master? [y/N]: y
Accept commands from master? [y/N]: y
information/cli: Disabling the Notification feature.
Disabling feature notification. Make sure to restart Icinga 2 for these changes to take effect.
information/cli: Enabling the Apilistener feature.
Enabling feature api. Make sure to restart Icinga 2 for these changes to take effect.
information/cli: Created backup file '/etc/icinga2/features-available/api.conf.orig'.
information/cli: Generating local zones.conf.
information/cli: Dumping config items to file '/etc/icinga2/zones.conf'.
information/cli: Created backup file '/etc/icinga2/zones.conf.orig'.
information/cli: Updating constants.conf.
information/cli: Created backup file '/etc/icinga2/constants.conf.orig'.
information/cli: Updating constants file '/etc/icinga2/constants.conf'.
information/cli: Updating constants file '/etc/icinga2/constants.conf'.
Done.

Now restart your Icinga 2 daemon to finish the installation!
```

在`debian2`上重启`icinga2`:

```
$ sudo systemctl restart icinga2
```

现在，我们需要配置主机来实际检查客户端；我们已经建立了连接，可以通过`ss`查看:

```
$ ss -t
State      Recv-Q Send-Q                                     Local Address:Port                                                      Peer Address:Port                
ESTAB      0      0                                              10.0.2.15:ssh                                                           10.0.2.2:44828                
ESTAB 0 0 192.168.33.13:5665 192.168.33.11:49398 
```

现在，回到`centos2`，添加以下配置:

```
$ cat <<HERE | sudo tee -a /etc/icinga2/zones.conf
object Endpoint "debian2" {
 host = "192.168.33.13"
}
object Zone "debian2" {
 endpoints = [ "debian2" ]
 parent = "master"
}
HERE
```

为有问题的区域创建`hosts`目录:

```
$ sudo mkdir -p /etc/icinga2/zones.d/master
```

并添加适当的`hosts`配置:

```
$ cat <<HERE | sudo tee /etc/icinga2/zones.d/master/hosts.conf
object Host "debian2" {
 check_command = "hostalive"
 address = "192.168.33.13"
 vars.client_endpoint = name
 vars.os = "Linux"
}
HERE
```

重启`icinga2`:

```
$ sudo systemctl restart icinga2
```

此时，您应该会在 Icinga2 网络图形用户界面中看到您的客户端:

![](assets/bcfba0b9-6f14-4d09-8c93-4f6085eb250d.png)

Icinga2 Hosts page with pending checks

只让 ping 检查一个主机有点没用(嗯，大部分；ping 警报以前曾救过我)，所以让我们也添加一些推荐的服务检查:

```
$ cat <<HERE | sudo tee /etc/icinga2/zones.d/master/services.conf
apply Service "ping4" {
 check_command = "ping4"
 assign where host.address
}
apply Service "ssh" {
 check_command = "ssh" 
 assign where host.vars.os == "Linux"
}
apply Service "disk" {
 check_command = "disk"
 command_endpoint = host.vars.client_endpoint
 assign where host.vars.client_endpoint
}
apply Service "icinga" {
 check_command = "icinga"
 command_endpoint = host.vars.client_endpoint
 assign where host.vars.client_endpoint
}
apply Service "ntp_time" {
 check_command = "ntp_time"
 command_endpoint = host.vars.client_endpoint
 assign where host.vars.client_endpoint
}
HERE
```

再次重新启动服务。

```
$ sudo systemctl restart icinga2
```

回顾我们的图形用户界面，现在将显示我们的`debian2`框，其中包含一些服务检查(五个检查之一失败):

![](assets/3ac8e7f5-d3a1-4f26-958d-562a904cbfb2.png)

Icinga2 Hosts page with ‘debian2’

# 它是如何工作的...

通过让主服务器能够看到一个区域中的其他服务器，您可以让自己知道什么时候出现了需要您立即关注的问题。

像 Nagios 和 Icinga2 这样的监控工具通常通过与远程机器交互、通过使用盒子上的脚本或远程自定义命令查询其状态以及报告这些命令的输出来工作。这可以通过多种方式完成，包括但不限于 NRPE 代理、远程 SSH 命令或从 SNMP 守护程序查询的 SNMP 结果。

通过对您的基础设施状态创建单一的真实来源，您可以在您的房地产出现问题时立即了解情况，甚至可以根据看到的多个症状关联数据。

Icinga2、Nagios、Zabbix 和 Sensu 都以相对相似的方式表现，最终都是这项工作的好工具，但通常这取决于实施团队(或个人)对采用哪种方式的个人偏好。

安装 Nagios 并玩它不会出错，因为它很容易是我在野外遇到最多的一个，它的孩子/堂兄弟目前统治着这个场景。

# 还有更多...

在这里，我们快速构建了一个 Nagios 和 Icinga2 安装，用几个简单的命令展示了两者的功能。这些配置还没有为生产做好准备，应该考虑一些事情，例如用于监控检查的可重用模式，以及安全性(例如图形用户界面上的 TLS，以及利用主服务器和客户端之间的安全通信方法)。

与本书中的许多软件一样，您现在应该很好地了解如何开始，但是在为自己的系统实施解决方案时，应该考虑所有选项。如果您有一个相对较小的池要监控，并且它不太可能增长，您可能会认为基于 Nagios 文件的监控设置是合适的；如果你有一个更大的、跨区域的庄园，你可能会发现 Icinga2 和它的区域更合你的胃口。

我们也没有涉及电子邮件和警报，只提到了 Nagios 和 Icinga2 产生的视觉警报。有多种方法可以将警报插入这两种解决方案(如短信警报或房间角落的闪光灯)，但是，开箱即用，它们都可以相对较好地处理电子邮件(假设您有一个功能正常的电子邮件服务器来传递警报)。

最后，这只是一个入门指南，还有很多方法可以设置 Icinga2 和 Nagios。从很多方面来说，它们更多地被认为是框架，而不是软件，是开箱即用的空白画布，并且仍然使您能够以您希望的复杂或简单的方式构建生产系统。

我遇到过 Icinga2 的安装，在那里我对自己非常自信和自信(比平时更自信)，但在 5 分钟后，当我试图解开留给我的糟糕的手摇配置时，我开始挠头。

# 请参见

我们在这里使用的监控插件很有趣，因为几年前有一个激烈的争论，当时旧的`nagios-plugins.org`域从一个独立维护的服务器被重新打印到一个由 Nagios 企业控制的服务器上。

接下来是一场争论和分裂，导致`monitoring-plugins`和`nagios-plugins`成为独立的实体。值得一提的是，在撰写本文时，`nagios-plugins`是 Debian 系统上`monitoring-plugins`的别名。

更多信息可以在这篇博文中找到:[https://www . monitoring-plugins . org/news/new-project-name . html](https://www.monitoring-plugins.org/news/new-project-name.html)。

Debian bug 报告可以在这里找到:[https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=736331](https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=736331)。

这里是红帽 bug 报告，增加了剧情(不要参与):[https://bugzilla.redhat.com/show_bug.cgi?id=1054340](https://bugzilla.redhat.com/show_bug.cgi?id=1054340)。

# 弹性叠加集中测井

前面，我们提到了远程日志记录的解决方案，包括将我们的日志记录解决方案(`syslog`和`journald`)转发到运行相同或相似软件的其他主机，以便日志可以聚集在一个位置。

这是一个很好的解决方案，在小环境中也能很好地工作，但是它没有太多的花哨功能，如果说在 it 中有什么我们喜欢的东西，那就是我们可以向管理层展示的闪闪发光的东西，然后就再也不用了。

弹性叠层就是这样一种产品；用他们自己的话说:

Built on an open source foundation, the Elastic Stack lets you reliably and securely take data from any source, in any format, and search, analyze, and visualize it in real time.

大胆的主张，但肯定有后盾。弹性堆栈现在是大多数中型以上企业事实上的聚合日志解决方案，也许在企业级别有一些竞争者。

我们将在`centos1`上设置一个小的解决方案，并将我们的日志从`centos2`、`debian1`和`debian2`转发给它。

I've spent the day wrestling with X-Pack and Elastic Stack, so if anything I write sounds sarcastic or mean spirited, it's probably intentional.

# 准备好

在本节中，我们将使用所有虚拟机，首先将它们全部`vagrant destroy`和`vagrant up`放在一起可能是个好主意。

请注意，在本节中，我们将安装某些弹性堆栈组件的版本 6 版本。配置发生了历史性的变化，到你读这本书的时候可能会再次发生变化；如果有任何事情不像您期望的那样工作，请参考您的版本的弹性文档来填补空白。

在本节中，我们将在`centos1`上运行初始设置，然后跳转到其他虚拟机并配置它们的日志记录目的地。

大多数情况下，我并不建议这样做，但是将您的虚拟机重置到一个新的起点可能是个好主意:

```
$ vagrant destroy -f
$ vagrant up
$ vagrant ssh centos1 -- -L127.0.0.1:5601:127.0.0.1:5601
```

为了方便起见，并且因为这不是一本关于安装和配置弹性堆栈的书，我们将非常快速地完成弹性搜索、基巴纳和日志存储的安装。

首先，我们需要 Java:

```
$ sudo yum install java-1.8.0-openjdk -y
```

# 怎么做...

在`centos1`上，让我们抓取弹性库:

```
$ cat <<HERE | sudo tee /etc/yum.repos.d/elasticsearch.repo
[elasticsearch-6.x]
name=Elasticsearch repository for 6.x packages
baseurl=https://artifacts.elastic.co/packages/6.x/yum
gpgcheck=1
gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearch
enabled=1
autorefresh=1
type=rpm-md
HERE
```

现在我们需要安装各种组件:

```
$ sudo yum install elasticsearch kibana logstash -y
```

我们需要通过一些配置调整来启动它们:

```
$ sudo systemctl daemon-reload
$ sudo systemctl enable --now elasticsearch
$ sudo systemctl enable --now kibana
```

我们将使用弹性`syslog`示例(来自[https://www . Elastic . co/guide/en/log stash/6.4/config-examples . html # _ processing _ syslog _ messages](https://www.elastic.co/guide/en/logstash/6.4/config-examples.html#_processing_syslog_messages))来配置我们的`Logstash`设置:

```
$ cat <<HERE | sudo tee /etc/logstash/conf.d/logstash-syslog.conf
input {
 tcp {
 port => 5000
 type => syslog
 }
 udp {
 port => 5000
 type => syslog
 }
}

filter {
 if [type] == "syslog" {
 grok {
 match => { "message" => "%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{DATA:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" }
 add_field => [ "received_at", "%{@timestamp}" ]
 add_field => [ "received_from", "%{host}" ]
 }
 date {
 match => [ "syslog_timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
 }
 }
}

output {
 elasticsearch { hosts => ["localhost:9200"] }
 stdout { codec => rubydebug }
}
HERE
```

This configuration sets an input method for data, in this case `tcp` and `udp` ports `5000`. It then sets a filter up for `syslog` content, and finally sets up an output to Elasticsearch (the backend, if you will).

现在我们可以开始`Logstash`了:

```
$ sudo systemctl enable --now logstash
```

您应该会看到各种端口正在监听您的机箱(这可能需要一些时间，因为各种组件正在启动):

```
$ ss -tunal '( src :5601 or src :9200 or src :5000 )'
Netid  State      Recv-Q Send-Q                                        Local Address:Port                                                       Peer Address:Port 
udp    UNCONN     0      0                                                         *:5000                                                                  *:* 
tcp    LISTEN     0      128                                               127.0.0.1:5601                                                                  *:* 
tcp    LISTEN     0      128                                                      :::5000                                                                 :::* 
tcp    LISTEN     0      128                                        ::ffff:127.0.0.1:9200                                                                 :::* 
tcp    LISTEN     0      128                                                     ::1:9200                                                                 :::*       
```

现在，我们可以配置我们的其他机器指向`centos1`上的`Logstash`。

# centos2

使用以下`rsyslog`更改开始将`centos2`日志转发到`centos1`实例的`Logstash`:

```
$ sudo sed -i 's/#*.* @@remote-host:514/*.* @192.168.33.10:5000/g' /etc/rsyslog.conf
$ sudo systemctl restart rsyslog
```

I recommended rebuilding the VMs earlier, but if you haven't, the preceding command may need tweaking if you followed the earlier sections about remote `syslog` configuration. Open the file and confirm the line looks as you expect.

您可以在`centos2`上使用以下命令测试您的配置:

```
$ logger -p syslog.err "Digimon was better than Pokemon."
```

# debian1 和 debian2

对于 Debian 配置，请使用以下几行:

```
$ echo "*.* @192.168.33.10:5000" | sudo tee -a /etc/rsyslog.conf
$ sudo systemctl restart rsyslog
$ logger -p syslog.err "Digimon was better than Pokemon."
```

# 姆纳人

我们在`Logstash`中有数据，但是除非你稍微提前一点，否则你还看不到它。

如果您已经将您的连接转发到`centos1`，如本节开头所示，您应该能够在您选择的浏览器中导航到`http://localhost:5601`，并受到 Kibana 起始页的欢迎(假设您的安装没有问题):

![](assets/678d1175-46d4-4ed6-8e6b-4e1ec995cb75.png)

如果您以前使用过 Kibana，您可能希望单击“发现”并查看您的日志，但是您会被踢到“管理”:

![](assets/4e3e7767-5499-4753-a139-9c29b664d3e9.png)

输入`*`作为索引模式的通配符条目，然后单击右侧的下一步:

![](assets/efc2e6ad-9dbf-44e6-b2aa-2903645d7a83.png)

在下一节中，从提供的下拉列表中选择@timestamp，然后单击右侧的创建索引模式:

![](assets/9245b99d-c040-4309-91b7-ad23d2510abe.png)

创建索引后，再次单击左侧的发现；这一次，你应该有一个正确的看法:

![](assets/8ac19d25-18ed-40f8-a86d-914f25a3e7ba.png)

显然，我们想过滤掉，只是为了确保我们已经得到了一切。

将以下筛选查询放在顶部的搜索框中:

```
(host:192.168.33.13 OR host:192.168.33.12 OR host:192.168.33.11) AND message:"Pokemon*"
```

你应该看到这样的东西:

![](assets/d7a019b9-e10a-473d-8869-d80ec1afdaf2.png)

Kibana Discover Page If there's no data visible in Kibana, it's possible that Logstash wasn't fully started before you sent logs from the other hosts. Try sending your logs again using the  `logger` commands above.

# 它是如何工作的...

我们正在有效地做的是建立三件事:

*   **弹性搜索**:充当我们想要传输到盒子中的所有数据的存储点
*   **基巴纳**:作为我们数据的前端和仪表板，这意味着我们可以在闲暇时查询和阅读它
*   **Logstash** :创建一个监听器，就像我们在本章前面设置的`syslog`接收器一样

当所有这三个组件都启用时，它们创建了一种方法来集中我们可能希望在解决方案中使用的任何日志(或其他数据)。

这基本上是制作`syslog`接收器的一种很好的方法，除此之外，它还能做更多的事情。

我们在这里没有做的一件事是将我们的日志从`centos1`转发到它自己的`Logstash`监听器；这是可以做到的，但确实需要一些调整，以确保您不会意外地创建一个日志风暴，当它自己的日志消息反馈到它自己时，它会呈指数级增长。我可能做过，也可能没做过。

# 还有更多...

弹性堆栈不仅仅是弹性搜索、基巴纳和日志存储，还有更多完全模块化的工具和功能，可以根据您的需要集成到您的安装中。

它们包括但不限于以下内容:

*   心跳–用于正常运行时间监控
*   file beat–用于从远程机器发送日志
*   机器学习能力

我们还在这里设置了一个非常难的解决方案，我肯定不会在生产中使用。它缺乏对传输数据的安全性，将普通日志流式传输到我们的接收器，也没有登录提示来保护 Kibana 仪表板或浏览器中的安全 TLS。

X-Pack 是解决这些问题的一种方法，可以在默认安装中试用，也可以通过许可证获得，但这需要花费您的成本。它允许您在安装中设置安全性，包括节点通信和登录安全性(使用 Kibana 用户登录之类的东西)。

Elastic Stack 也是一个非常需要资源的软件套件，您可能希望在直接进入并将其安装到橱柜中的中型盒子上之前，适当地设计您的解决方案。

# 综述-监控和记录

虽然这不是任何人最喜欢的主题(除了我认识的一些非常奇怪的人，其中一个是本书的技术编辑)，但日志记录和监控是任何安装的关键部分，无论大小。

你想知道你的盒子什么时候死了，或者更好的是，它们什么时候就要死了，你还想追溯到为什么它们会在一开始就坏了。

监控和日志记录可以是复杂的，也可以是简单的。有些公司雇佣特定的个人来处理思洛存储器中的这些组件，但是，在较小的组织中，最终管理和配置一切的很可能是您。如果是这种情况，那么我目前建议设置 Icinga2 和某种弹性堆栈实现，但是您的需求和预算可能会有所不同。

我们需要讨论的一个问题是随叫随到，以及你可能会在职业生涯的某个时候做这件事的事实(除非你已经到了可以说“我已经完成了我的时间”并把它留给次要的人去承担的地步)。

总的来说，在做随叫随到的事情时，监控是你的朋友，虽然在理想的世界里，你永远不会因为一个问题而被叫出去，但你至少可以设置一些事情，比如自动打电话叫醒你，以免一些事情变成一个更广泛的问题，被公司以外的人注意到。你不会希望自己的公司网站整个周末都瘫痪，你会损失几千英镑的销售额。

随着时间的推移，日志和长期监测数据也有助于突出那些你没有意识到是重复出现的问题，因为事件之间的时间间隔是几周甚至几个月；这是在基巴纳的仪表板上设置历史警报和模式匹配的一个很好的理由。

如果有人不得不每 5 周清理一次日志，每次都是团队中不同的人，你可能没有意识到有一个更大的潜在问题需要解决，或者你可能会发现你已经为一个可以用简单的`systemd`计时器解决的问题损失了数百个小时。

总的来说，我讨厌监控，也不愿意在日志中搜寻，但它们在我们的工作中是必要的，而且有很多聪明的人在制作非常时髦的工具，你可以用它们来让你的生活变得更轻松。

当你不得不向首席执行官炫耀一个仪表板，而他们被漂亮的小部件和哨子分散注意力时，这也没什么坏处。