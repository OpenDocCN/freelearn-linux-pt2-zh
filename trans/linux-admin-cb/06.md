# 安全性、更新和包管理

本章将涵盖以下主题:

*   检查包版本
*   检查操作系统版本
*   检查更新
*   自动更新
*   检查邮件列表和勘误表页面
*   使用快照
*   使用 Flatpak
*   使用 Pip、RubyGems 和其他包管理器
*   依赖地狱(一个简短的词)
*   从来源编译
*   添加其他存储库

# 介绍

你的系统在有生之年会有一次(也许两次)处于完美状态。

第一次它是完美的、未被污染的、未被污染的，是在它被安装的时候(前提是你已经勾选了在安装过程中更新软件包的选项)。你的系统将永远不会再处于如此原始的状态，因为它没有肮脏的人类手去干预它的内脏。

第二次完美是在最后一次关闭时，工作做得很好，参观废品厂赚得盆满钵满(或者，在云计算的情况下，快速飘渺的硅天堂之旅)。

在本节中，您将了解不同的软件包来源，如何查找和安装新软件，以及保持系统安全和最新的重要性(以免您最终成为注册中心的头条新闻)。

这并不是这项工作最有趣的部分，你可能会发现自己几次撞到最近的墙上，但如果你做得对，你会发现你必须处理的由基础设施中不匹配的软件引起的问题要少得多。

我遇到的最好的安装会定期自动重建它们的映像，然后以一致且可测试的方式在整个基础架构中推广它们。这需要时间来完成，在这里，我们将看看让您开始的构件。

# 技术要求

本章将讨论不同的包管理器和做同样事情的多种方法(这基本上概括了 Linux)。

因此，我们将在`Vagrantfile`中使用三个不同的框，如下所示:

```sh
# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure("2") do |config|

 config.vm.define "centos7" do |centos7|
   centos7.vm.box = "centos/7"
   centos7.vm.box_version = "1804.02"
 end

 config.vm.define "debian9" do |debian9|
   debian9.vm.box = "debian/stretch64"
   debian9.vm.box_version = "9.5.0"
 end

 config.vm.define "ubuntu1804" do |ubuntu1804|
   ubuntu1804.vm.box = "ubuntu/bionic64"
   ubuntu1804.vm.box_version = "20180927.0.0"
 end

end
```

旋转这些盒子(使用`vagrant up`)将为您提供一个 CentOS 安装、一个 Debian 安装和一个 Ubuntu 安装:

![](assets/9f597ee6-7597-406c-a1a4-f664640a9382.png)

我们将在某个时候使用这些。

# 检查包版本

在本节中，我们将查看安装在我们系统上的软件包列表，并获取这些软件包的版本号。

如果你听说了标志着世界末日的最新漏洞，并且你的老板大声要求你修复它，修复它，修复它，这通常会很有用。

There are a considerable number of vulnerabilities out there; it just so happens that a few of the bigger ones bleed through to the mainstream media on occasion. These are arguably the most dangerous, as they make people panic, and if there's one thing worse than a bad situation, it's being in a bad situation while everyone around you is losing their heads.

您通常还应该保持您的系统是最新的，因为跳过几个版本版本(当您不可避免地必须升级时)比增量地改变东西要尴尬得多。

# 准备好

确保您的所有盒子都旋转起来，并尝试连接到前两个(CentOS 和 Debian):

```sh
$ vagrant ssh centos7
$ vagrant ssh debian9
```

在你的 Debian 盒子里，一定要安装`aptitude`，因为它是我们将在本节后面使用的前端之一；虽然默认情况下它安装在一些发行版上，但这种 Debian 安装不是其中之一:

```sh
$ sudo apt install aptitude
```

# 怎么做...

每个操作系统的方法都是相似的，但是我们将依次使用它们。

# CentOS

CentOS(和红帽)有两个包管理器，另一个很快将被添加到等式中。

从顶部开始，我们有 **RPM 包管理器** ( **RPM** 是递归首字母缩略词)，这是基于红帽的系统中包管理的基础。从原始的意义上来说，它可能是您认为的原始包管理器，您可能不会每天直接使用它。

每分钟转数做以下四件事:

*   挑选
*   询问
*   核实
*   安装

这些选项都有参数，我发现自己最常使用的是查询。

要列出系统上安装的所有软件包，请使用`-qa`，如下所示:

```sh
$ rpm -qa
kernel-tools-libs-3.10.0-862.2.3.el7.x86_64
grub2-common-2.02-0.65.el7.centos.2.noarch
dmidecode-3.0-5.el7.x86_64
grub2-pc-modules-2.02-0.65.el7.centos.2.noarch
firewalld-filesystem-0.4.4.4-14.el7.noarch
<SNIP>
gssproxy-0.7.0-17.el7.x86_64
dbus-glib-0.100-7.el7.x86_64
python-slip-dbus-0.4.0-4.el7.noarch
python-pyudev-0.15-9.el7.noarch
plymouth-scripts-0.8.9-0.31.20140113.el7.centos.x86_64
```

要列出一个特定的包，您可以命名它(没有完整的版本信息)，如下所示:

```sh
$ rpm -q dmidecode
dmidecode-3.0-5.el7.x86_64
```

要获取包装信息，您可以使用`-i`:

```sh
$ rpm -qi dmidecode
Name        : dmidecode
Epoch       : 1
Version     : 3.0
Release     : 5.el7
Architecture: x86_64
Install Date: Sat 12 May 2018 18:52:07 UTC
Group       : System Environment/Base
Size        : 247119
License     : GPLv2+
Signature   : RSA/SHA256, Thu 10 Aug 2017 15:38:00 UTC, Key ID 24c6a8a7f4a80eb5
Source RPM  : dmidecode-3.0-5.el7.src.rpm
Build Date  : Thu 03 Aug 2017 23:53:58 UTC
Build Host  : c1bm.rdu2.centos.org
Relocations : (not relocatable)
Packager    : CentOS BuildSystem <http://bugs.centos.org>
Vendor      : CentOS
URL         : http://www.nongnu.org/dmidecode/
Summary     : Tool to analyse BIOS DMI data
Description :
dmidecode reports information about x86 & ia64 hardware as described in the
system BIOS according to the SMBIOS/DMI standard. This information
typically includes system manufacturer, model name, serial number,
BIOS version, asset tag as well as a lot of other details of varying
level of interest and reliability depending on the manufacturer.

This will often include usage status for the CPU sockets, expansion
slots (e.g. AGP, PCI, ISA) and memory module slots, and the list of
I/O ports (e.g. serial, parallel, USB).
```

我发现有用的一个技巧是以伪 YAML 的方式输出特定的信息。这可以方便地记录包的版本，并且可以通过`--queryformat`选项来完成:

```sh
$ rpm -q --queryformat "---\nName: %{NAME}\n  Version: %{VERSION}\n  Release: %{RELEASE}\n" dmidecode
---
Name: dmidecode
 Version: 3.0
 Release: 5.el7
```

I joke about how RPM is old hat, but there are a considerable number of areas in which it excels, and in a lot of cases it's much quicker to run a package query using the `rpm` command than any of its available frontends, meaning that it is great for scripts. Just be aware that using both RPM and YUM together (to install things) can cause problems.

如果你想使用更近一点的东西，RPM 的 nice 前端的当前化身叫做**黄狗更新器修改版** ( **YUM** )，最初是为黄狗 Linux 开发的。

YUM 通常被使用，因为它处理依赖项解析(自动下载和安装依赖包)以及从配置的远程存储库安装。

Those of you that had a Playstation 3 in the mid-2000s might be interested to know that Yellow Dog was targeted to run on those consoles, during the brief period that Sony allowed for the installation of third-party operating systems alongside its own Orbis OS (based on FreeBSD.)

要列出所有安装了 YUM 的软件包，请使用`list installed`:

```sh
$ yum list installed
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirror.vorboss.net
 * extras: mirror.econdc.com
 * updates: mirror.cwcs.co.uk
Installed Packages
GeoIP.x86_64                                                                      1.5.0-11.el7                                                                  @anaconda 
NetworkManager.x86_64                                                             1:1.10.2-13.el7                                                               @anaconda 
NetworkManager-libnm.x86_64                                                       1:1.10.2-13.el7                                                               @anaconda 
NetworkManager-team.x86_64                                                        1:1.10.2-13.el7                                                               @anaconda 
NetworkManager-tui.x86_64                                                         1:1.10.2-13.el7                                                               @anaconda 
<SNIP> 
yum-plugin-fastestmirror.noarch                                                   1.1.31-45.el7                                                                 @anaconda 
yum-utils.noarch                                                                  1.1.31-45.el7                                                                 @anaconda 
zlib.x86_64                                                                       1.2.7-17.el7                                                                  @anaconda 
```

您也可以使用`yum`来查询单个信息，就像我们对 RPM 所做的那样，如下所示:

```sh
$ yum info zlib
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirror.vorboss.net
 * extras: mirror.econdc.com
 * updates: mirror.cwcs.co.uk
Installed Packages
Name        : zlib
Arch        : x86_64
Version     : 1.2.7
Release     : 17.el7
Size        : 181 k
Repo        : installed
From repo   : anaconda
Summary     : The compression and decompression library
URL         : http://www.zlib.net/
Licence     : zlib and Boost
Description : Zlib is a general-purpose, patent-free, lossless data compression
 : library which is used by many different programs.

Available Packages
Name        : zlib
Arch        : i686
Version     : 1.2.7
Release     : 17.el7
Size        : 91 k
Repo        : base/7/x86_64
Summary     : The compression and decompression library
URL         : http://www.zlib.net/
Licence     : zlib and Boost
Description : Zlib is a general-purpose, patent-free, lossless data compression
 : library which is used by many different programs.
```

请注意，我们默认情况下也会获得可用的包，那些目光敏锐的人会注意到，这两个包之间的唯一区别是，可用的包是 32 位版本。

DNF (which doesn't stand for did not finish) is the newest of the frontend package managers to take on the task of unifying Red Hat installations. It has been the default in Fedora (a good distribution, and also Red Hat's testing ground) for a while, which means that there is a good chance it'll make it into the next version of CentOS and Red Hat itself. For the most part, it's a drop-in replacement, with a couple of newer features to justify its existence.

# 一种自由操作系统

在引擎盖下，Debian 使用`dpkg`包管理器来安装和管理包。也有各种各样的前端可用，如`apt`和`aptitude`，这使得管理更加用户友好。

从基础开始，您可以使用`dpkg-query`查询系统上安装的软件包:

```sh
$ dpkg-query -W
adduser    3.115
apt    1.4.8
apt-listchanges    3.10
apt-utils    1.4.8
base-files    9.9+deb9u5
base-passwd    3.5.43
bash    4.4-5
<SNIP>
xauth    1:1.0.9-1+b2
xdg-user-dirs    0.15-2+b1
xkb-data    2.19-1+deb9u1
xml-core    0.17
xxd    2:8.0.0197-4+deb9u1
xz-utils    5.2.2-1.2+b1
zlib1g:amd64    1:1.2.8.dfsg-5
```

您无疑会注意到，默认情况下，包和版本由制表符分隔。我个人认为这很可怕(因为两个空格是上级选项)，但谢天谢地，我们可以使用`showformat`自定义输出:

```sh
$ dpkg-query -W --showformat='${Package} - ${Version}\n'
adduser - 3.115
apt - 1.4.8
apt-listchanges - 3.10
apt-utils - 1.4.8
base-files - 9.9+deb9u5
base-passwd - 3.5.43
<SNIP>
xml-core - 0.17
xxd - 2:8.0.0197-4+deb9u1
xz-utils - 5.2.2-1.2+b1
zlib1g - 1:1.2.8.dfsg-5
```

这对于脚本来说特别方便！

在`dpkg-query`之上，我们还有`apt`:

```sh
$ apt list --installed
Listing... Done
adduser/stable,now 3.115 all [installed]
apt/stable,now 1.4.8 amd64 [installed]
apt-listchanges/stable,now 3.10 all [installed]
apt-utils/stable,now 1.4.8 amd64 [installed]
<SNIP>
xdg-user-dirs/stable,now 0.15-2+b1 amd64 [installed,automatic]
xkb-data/stable,now 2.19-1+deb9u1 all [installed,automatic]
xml-core/stable,now 0.17 all [installed,automatic]
xxd/stable,now 2:8.0.0197-4+deb9u1 amd64 [installed]
xz-utils/stable,now 5.2.2-1.2+b1 amd64 [installed]
zlib1g/stable,now 1:1.2.8.dfsg-5 amd64 [installed]
```

这种默认输出可能更适合您。

`apt`是与系统上的包交互的较新方式，尽管你们中的传统主义者(或从传统主义者那里学到的人)可能更熟悉`apt-get`和`apt-cache`工具套件。

最后，这一部分还有`aptitude`。

Aptitude is the first package manager that I can remember using, and I also remember it being a pain to use, because occasionally, it would drop me into a TUI (textual or text-based user interface), and I wouldn't know what was happening.

可以在命令行上使用`aptitude`，如下所示:

```sh
$ aptitude search  ~i --display-format '%p%v'
adduser                                                                  3.115 
apt                                                                      1.4.8 
apt-listchanges                                                          3.10 
apt-utils                                                                1.4.8 
aptitude                                                                 0.8.7-1 
aptitude-common                                                          0.8.7-1 
base-files                                                               9.9+deb9u5 
base-passwd                                                              3.5.43 
<SNIP>
xdg-user-dirs                                                            0.15-2+b1 
xkb-data                                                                 2.19-1+deb9u1 
xml-core                                                                 0.17 
xxd                                                                      2:8.0.0197-4+d
xz-utils                                                                 5.2.2-1.2+b1 
zlib1g                                                                   1:1.2.8.dfsg-5
```

也可以自行输入`aptitude`，进入 TUI:

![](assets/e2ff4e45-f9fc-4d94-8b34-f025f8bf7b76.png)

这个界面可以通过键盘上的箭头键或鼠标来导航。

然而，我们马上就能看到列出的`Security Updates`和`Installed Packages`，它们组成了我们在命令行上得到的`369`包:

```sh
$ aptitude search  ~i --display-format '%p%v'  | wc -l
369
```

我们可以双击深入`aptitude`界面。

在下面的截图中，我展示了安装在我们虚拟机中的两个内核(`4.9.0-6`和`4.9.0-7`):

![](assets/38ac4bfb-6dfc-4ec3-bb56-3d5ff56bf5c2.png)

You might also notice `linux-image-amd64`, which is a meta-package, as opposed to a package in its own right.

我们也可以在命令行上查找这些内核:

```sh
$ aptitude search  '~i linux-image' --display-format '%p%v' 
linux-image-4.9.0-6-amd64                                                                                                                                         4.9.88-1+deb9u
linux-image-4.9.0-7-amd64                                                                                                                                         4.9.110-1 
linux-image-amd64                                                                                                                                                 4.9+80+deb9u5 
```

# 它是如何工作的...

您正在有效地做的事情(在这两种情况下)是查询系统上的包数据库。

在您的 CentOS 系统上，RPM 和 YUM 都在查看`/var/lib/rpm`内部，以确定您系统的状态。

同样，在您的 Debian 系统上，您的包状态保持在`/var/lib/dpkg`内。

建议不要在用于管理这些文件夹的应用程序之外弄乱它们，因为修改系统上安装的包的性质(在包管理器之外)会导致奇怪的、有时是破坏性的行为。

# 还有更多...

请记住，您不必使用系统的包管理器来列出版本；如果你更愿意相信应用程序本身的输出，大多数应用程序都有一些`-v`、`--version`标准的变体。

`bash`举例如下:

```sh
$ bash --version
GNU bash, version 4.2.46(2)-release (x86_64-redhat-linux-gnu)
Copyright (C) 2011 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>

This is free software; you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
```

以下为`ssh`的代码，使用`-V`(大写):

```sh
$ ssh -V
OpenSSH_7.4p1, OpenSSL 1.0.2k-fips  26 Jan 2017
```

而且，为了方便起见，游民使用`-v`(小写):

```sh
$ vagrant -v
Vagrant 2.0.2
```

You may have noticed the distinct lack of Ubuntu in the preceding examples; this is because anything that works on a Debian system is extremely likely to work on an Ubuntu system.

# 检查操作系统版本

我们将使用与上一节相同的`Vagrantfile`。

在本节中，我们将列出操作系统的规范版本，以及内核版本。

我们还将了解 LSB 合规性的概念。

# 怎么做...

我们将把这一部分分成不同的操作系统。

# CentOS

我们可以通过打印`centos-release`文件的内容来确定我们的`CentOS`安装版本，如下所示:

```sh
$ cat /etc/centos-release
CentOS Linux release 7.5.1804 (Core)
```

这里有一个有趣的事实(在特定类型的人群中):如果你`cat`你盒子上`redhat-release`的内容，你会得到同样的信息，因为`CentOS`和红帽系统是如此紧密地联系在一起:

```sh
$ cat /etc/redhat-release 
CentOS Linux release 7.5.1804 (Core)
```

`cat` (derived from concatenate) is a program that was historically used to print the contents of multiple files to standard out.

同样，`system-release`是`centos-release`的符号链接:

```sh
$ cat /etc/system-release
CentOS Linux release 7.5.1804 (Core)
```

如果你想要更详细的信息，你甚至可以打印`os-release`文件的内容:

```sh
$ cat /etc/os-release 
NAME="CentOS Linux"
VERSION="7 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="7"
PRETTY_NAME="CentOS Linux 7 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:7"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"

CENTOS_MANTISBT_PROJECT="CentOS-7"
CENTOS_MANTISBT_PROJECT_VERSION="7"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="7"
```

这些命令告诉您操作系统的发布；他们没有给你提供的是内核版本，是分开的(回想一下[第 1 章](01.html)、*简介和环境设置* )。

要确定内核版本，可以查询`dmesg`，如下所示:

```sh
$ dmesg | grep "Linux version"
[    0.000000] Linux version 3.10.0-862.2.3.el7.x86_64 (builder@kbuilder.dev.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-28) (GCC) ) #1 SMP Wed May 9 18:05:47 UTC 2018
```

或者，对于不依赖于日志文件的命令，您可以使用`-a`运行`uname`，以便打印关于系统的所有信息:

```sh
$ uname -a
Linux localhost.localdomain 3.10.0-862.2.3.el7.x86_64 #1 SMP Wed May 9 18:05:47 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux
```

仅内核发布信息，使用`-r`，如下:

```sh
$ uname -r
3.10.0-862.2.3.el7.x86_64
```

`uname` is definitely not a Linux-specific command; it'll work on most Unix and Unix-like derivatives. Take a look at what it prints out on your FreeBSD or OpenBSD systems (or your macOS box, if you're not that sad).

您也可以使用 YUM，如前所列:

```sh
$ yum -q info installed kernel 
Installed Packages
Name        : kernel
Arch        : x86_64
Version     : 3.10.0
Release     : 862.2.3.el7
Size        : 62 M
Repo        : installed
From repo   : koji-override-1
Summary     : The Linux kernel
URL         : http://www.kernel.org/
Licence     : GPLv2
Description : The kernel package contains the Linux kernel (vmlinuz), the core of any
 : Linux operating system.  The kernel handles the basic functions
 : of the operating system: memory allocation, process allocation, device
 : input and output, etc.
```

如果你是一个真正的叛逆者，你甚至可以看看你在`/boot`安装了哪些内核:

```sh
$ ls -l /boot
total 25980
-rw-r--r--. 1 root root   147823 May  9 18:19 config-3.10.0-862.2.3.el7.x86_64
drwxr-xr-x. 3 root root       17 May 12 18:50 efi
drwxr-xr-x. 2 root root       27 May 12 18:51 grub
drwx------. 5 root root       97 May 12 18:54 grub2
-rw-------. 1 root root 16506787 May 12 18:55 initramfs-3.10.0-862.2.3.el7.x86_64.img
-rw-r--r--. 1 root root   304926 May  9 18:21 symvers-3.10.0-862.2.3.el7.x86_64.gz
-rw-------. 1 root root  3409102 May  9 18:19 System.map-3.10.0-862.2.3.el7.x86_64
-rwxr-xr-x. 1 root root 6225056 May 9 18:19 vmlinuz-3.10.0-862.2.3.el7.x86_64
```

很有可能最新的版本(在前面的代码中得到鼓励)就是您正在运行的版本，尽管这听起来并不总是正确的。

# 一种自由操作系统

在 Debian 世界中，情况大致相同，尽管需要担心的操作系统版本文件较少。

在 Debian 中，我们可以查看我们正在运行的版本的`/etc/debian_version`的内容:

```sh
$ cat /etc/debian_version 
9.5
```

或者，我们可以在`/etc/os-release`中查看，就像用`CentOS`一样:

```sh
$ cat /etc/os-release 
PRETTY_NAME="Debian GNU/Linux 9 (stretch)"
NAME="Debian GNU/Linux"
VERSION_ID="9"
VERSION="9 (stretch)"
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"
```

也像在`CentOS`中一样，我们可以`grep``dmesg`日志为我们的内核版本:

```sh
$ sudo dmesg | grep "Linux version"
[    0.000000] Linux version 4.9.0-7-amd64 (debian-kernel@lists.debian.org) (gcc version 6.3.0 20170516 (Debian 6.3.0-18+deb9u1) ) #1 SMP Debian 4.9.110-1 (2018-07-05)
```

或者，我们可以使用`uname`，如下所示:

```sh
$ uname -r
4.9.0-7-amd64
```

Yes, Debian has a much more recent version of the kernel at the time of writing this book; this is a mixture of `CentOS`  backporting fixes and features into their older kernels (literally taking improvements from upstream and applying them to older releases,) and the Debian distribution having a much shorter release cycle.

您可以使用前面列出的任何方法列出已安装的版本；以下是`dpkg-query`的例子:

```sh
$ dpkg-query -W  linux-image*
linux-image-4.9.0-6-amd64    4.9.88-1+deb9u1
linux-image-4.9.0-7-amd64    4.9.110-1
linux-image-amd64    4.9+80+deb9u5
```

还有值得信赖的老`/boot`，如下:

```sh
$ ls -l /boot
total 50264
-rw-r--r-- 1 root root   186567 May  7 22:38 config-4.9.0-6-amd64
-rw-r--r-- 1 root root   186568 Jul  5 01:29 config-4.9.0-7-amd64
drwxr-xr-x 5 root root     4096 Jul 17 01:50 grub
-rw-r--r-- 1 root root 18117609 Jul 17 01:48 initrd.img-4.9.0-6-amd64
-rw-r--r-- 1 root root 18125878 Jul 17 01:50 initrd.img-4.9.0-7-amd64
-rw-r--r-- 1 root root  3190138 May  7 22:38 System.map-4.9.0-6-amd64
-rw-r--r-- 1 root root  3192069 Jul  5 01:29 System.map-4.9.0-7-amd64
-rw-r--r-- 1 root root  4224800 May  7 22:38 vmlinuz-4.9.0-6-amd64
-rw-r--r-- 1 root root  4224800 Jul  5 01:29 vmlinuz-4.9.0-7-amd64
```

# 人的本质

像所有好的发行版一样，Ubuntu 也让你`cat`一个文件获取信息；但是，与其他一些不同，它还会在您登录时告诉您(默认情况下)。

下载到我们的 Ubuntu 盒子应该会打印出如下内容:

```sh
$ vagrant ssh ubuntu1804
Welcome to Ubuntu 18.04.1 LTS (GNU/Linux 4.15.0-34-generic x86_64)

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Sun Sep 30 14:55:26 UTC 2018

  System load:  0.0              Processes:             95
  Usage of /:   9.8% of 9.63GB   Users logged in:       0
  Memory usage: 12%              IP address for enp0s3: 10.0.2.15
  Swap usage:   0%

 * Read about Ubuntu updates for L1 Terminal Fault Vulnerabilities (L1TF).
   - https://ubu.one/L1TF

 * Having fun with some surprising Linux desktop apps... Alan keeps
   the family entertained over the summer/winter holidays.
   - https://bit.ly/top_10_entertainment_apps

 * Want to make a highly secure kiosk, smart display or touchscreen?
   Here's a step-by-step tutorial for a rainy weekend, or a startup.
   - https://bit.ly/secure-kiosk

  Get cloud support with Ubuntu Advantage Cloud Guest:
    http://www.ubuntu.com/business/services/cloud

0 packages can be updated.
0 updates are security updates.

Last login: Sun Sep 30 14:15:35 2018 from 10.0.2.2
```

请注意加粗的行，它会在您登录运行的 Ubuntu 版本时告诉您。

这一天的**消息** ( **MOTD** )其实是从几个文件中构建出来的；表头为`00-header`:

```sh
$ cat /etc/update-motd.d/00-header
```

该文件中有一些行，如下所示:

```sh
[ -r /etc/lsb-release ] && . /etc/lsb-release

if [ -z "$DISTRIB_DESCRIPTION" ] && [ -x /usr/bin/lsb_release ]; then
    # Fall back to using the very slow lsb_release utility
    DISTRIB_DESCRIPTION=$(lsb_release -s -d)
fi

printf "Welcome to %s (%s %s %s)\n" "$DISTRIB_DESCRIPTION" "$(uname -o)" "$(uname -r)" "$(uname -m)"
```

在这里，我们可以检查`lsb-release`文件是否存在(并且可读)，然后再为该版本获取(`. /etc/lsb-release`)。

然后，我们有一个`if`语句，它说如果`DISTRIB_DESCRIPTION`变量是空的，并且`lsb_release`二进制文件是可执行的，那么我们回到使用该实用程序来确定发布版本(`lsb_release -s -d`)。

然后我们打印输出，这就是我们在登录消息顶部看到的。

如果 MOTD 失败了，我们可以使用以下命令自己:

```sh
$ cat /etc/lsb-release 
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=18.04
DISTRIB_CODENAME=bionic
DISTRIB_DESCRIPTION="Ubuntu 18.04.1 LTS"
```

或者，我们可以再次使用`os-release`，如下:

```sh
$ cat /etc/os-release 
NAME="Ubuntu"
VERSION="18.04.1 LTS (Bionic Beaver)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 18.04.1 LTS"
VERSION_ID="18.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic
```

对于内核来说，和前面的动作差不多；检查`uname`，如下:

```sh
$ uname -r
4.15.0-34-generic
```

检查安装的版本，如下所示:

```sh
$ dpkg-query -W  linux-image*
linux-image 
linux-image-4.15.0-34-generic    4.15.0-34.37
linux-image-unsigned-4.15.0-34-generic 
linux-image-virtual    4.15.0.34.36
```

或者，看一下`/boot`，如下:

```sh
$ ls -l /boot
total 32720
-rw------- 1 root root  4044038 Aug 27 14:45 System.map-4.15.0-34-generic
-rw-r--r-- 1 root root  1537610 Aug 27 14:45 abi-4.15.0-34-generic
-rw-r--r-- 1 root root   216905 Aug 27 14:45 config-4.15.0-34-generic
drwxr-xr-x 5 root root     4096 Sep 21 12:13 grub
-rw-r--r-- 1 root root 19423451 Sep 21 12:00 initrd.img-4.15.0-34-generic
-rw-r--r-- 1 root root        0 Aug 27 14:45 retpoline-4.15.0-34-generic
-rw------- 1 root root  8269560 Aug 27 15:06 vmlinuz-4.15.0-34-generic
```

The `vmlinuz` object, as seen previously, is the compressed executable of the Linux kernel.

# 它是如何工作的...

当您查询这些文件时，您会询问操作系统认为它是什么版本。

这在从安全性到编写脚本的所有方面都很有用。您不仅想知道您运行的操作系统版本何时不安全，您还可能想在任何脚本的顶部添加一个健全性检查，以确保它们只在它们设计的系统上运行，也就是说，您可以为 CentOS 系统编写一个脚本，第一步可以是“检查我们实际上是在 CentOS 系统上执行的。”

`uname` (Unix 名称)更有意思，因为我们实际上做的不是查询操作系统版本的文件，而是查询正在运行的内核的信息。

`uname`使用`uname`系统调用(迷惑了没有？)，它不仅符合 POSIX，而且可以追溯到 20 世纪 70 年代和 PWB/Unix。

# 还有更多...

你可能已经注意到`lsb_release`的 Ubuntu 用法抓取它的 OS 版本；在`CentOS`上也可以这样做，但是首先需要安装`lsb_release`:

```sh
$ sudo yum install redhat-lsb-core
```

现在，我们可以运行与 Ubuntu 相同的命令来获取操作系统信息:

```sh
$ lsb_release -s -d
"CentOS Linux release 7.5.1804 (Core) "
```

在`Debian`上也可以这样做，默认情况下不需要安装任何东西:

```sh
$ lsb_release -s -d
Debian GNU/Linux 9.5 (stretch)
```

**Linux 标准库** ( **LSB** )基本上是多个发行版签约的标准。它指定了一个**文件系统层次标准** ( **FHS** )以及 Linux 系统的各种其他组件。

The LSB also suggests the package format of RPM, although Debian and Ubuntu obviously don't use this by default, opting for `.deb` instead. To get around this, Debian offers the `alien` package, which is used to transform `.rpm` files into `.deb` files prior to installation. It is something of a dirty hack, and it doesn't guarantee compliance; it is more a sort of courtesy nod.

# 请参见...

看看旧的 Unix 程序和惯例，你会惊讶于它们中有多少一直延续到了现代。

不过 GNU 不是 Unix，那为什么 Linux 系统也有`uname`？答案是，因为它类似于 Unix，而 Unix 首创的很多命令和约定都被 GNU 操作系统和自由软件运动改写了，为了方便大家熟悉。

# 检查更新

在这一部分，我们将使用第一部分中使用的`Vagrantfile`。现在我们知道了与我们的系统相关的软件版本(软件包、操作系统和内核)，我们将看看有哪些更新可供我们使用，以及我们如何安装它们。

我们将检查具体的软件包更新和所有软件包的更新。

# 怎么做...

在这一节中，我们将进入我们的`CentOS`和`Debian`框，跳过 Ubuntu，因为来自 Debian 的相同规则将适用。

我们将在这些示例中使用内核，尽管您系统上的任何包都可以替换。

# CentOS

在`CentOS`中，检查包更新的最简单方法是使用 YUM，如下所示:

```sh
$ yum -q info kernel
Installed Packages
Name : kernel
Arch : x86_64
Version : 3.10.0
Release : 862.2.3.el7
Size : 62 M
Repo : installed
From repo : koji-override-1
Summary : The Linux kernel
URL : http://www.kernel.org/
Licence : GPLv2
Description : The kernel package contains the Linux kernel (vmlinuz), the core of any
 : Linux operating system. The kernel handles the basic functions
 : of the operating system: memory allocation, process allocation, device
 : input and output, etc.

Available Packages
Name : kernel
Arch : x86_64
Version : 3.10.0
Release : 862.14.4.el7
Size : 46 M
Repo : updates/7/x86_64
Summary : The Linux kernel
URL : http://www.kernel.org/
Licence : GPLv2
Description : The kernel package contains the Linux kernel (vmlinuz), the core of any
 : Linux operating system. The kernel handles the basic functions
 : of the operating system: memory allocation, process allocation, device
 : input and output, etc.
```

请注意，我们没有将输出限制在已安装的包中；相反，我们正在检查我们安装了什么，以及有什么可用的。

输出告诉我们，虽然版本号没有变化，但是内核的版本已经更新，可以从`updates/7/x86_64` repo 获得。

为了更新我们的内核，我们只需运行一个`yum upgrade`命令，如下所示:

```sh
$ sudo yum upgrade -y kernel
```

We've previously mentioned the list of packages-that-will-change when running YUM commands. With '-y' we auto-accept these changes, but if you're unsure, it's a good idea to omit the '-y' flag and sanity-check manually by reading the presented list.

所以，具体的软件包非常简单，但是我们如何检查我们系统上所有安装的软件包呢？

当然是和 YUM！

我们可以使用`update`或`upgrade`，它们在现代装置上基本相同:

```sh
$ sudo yum upgrade 
```

Using `upgrade` (rather than `update`) should technically be different, as it also uses logic to obsolete and replace obsoleted programs, but because this is behavior that most people desire, `obsoletes=1` is also set in `yum.conf`, making `update` and `upgrade` functionally the same by default.

我们前面的命令应该会生成如下所示的屏幕:

![](assets/1b99277c-c53c-46ff-9896-1180817c89da.png)

Note that without flags added to the command, the update will stop here, with a prompt for you to choose `y/d/N` (with `N` being the default).

如果您准备升级，传递`y`到这个命令将更新和安装前面的软件包。

如果还没准备好升级，通过`d`只会下载包。

As we've said before, typically, the only programs that require a reboot to update are the kernel and `systemd` (the `init` system), as these are the soul of your installation, and you're basically killing the old program to make way for the new (which will be selected by default on most systems, following an upgrade).

运行我们的`yum info`命令现在将显示两个已安装的内核，没有可用的内核，如下所示:

```sh
$ yum -q info kernel
Installed Packages
Name        : kernel
Arch        : x86_64
Version     : 3.10.0
Release     : 862.2.3.el7
Size        : 62 M
Repo        : installed
From repo   : koji-override-1
Summary     : The Linux kernel
URL         : http://www.kernel.org/
Licence     : GPLv2
Description : The kernel package contains the Linux kernel (vmlinuz), the core of any
 : Linux operating system.  The kernel handles the basic functions
 : of the operating system: memory allocation, process allocation, device
 : input and output, etc.

Name        : kernel
Arch        : x86_64
Version     : 3.10.0
Release     : 862.14.4.el7
Size        : 62 M
Repo        : installed
From repo   : updates
Summary     : The Linux kernel
URL         : http://www.kernel.org/
Licence     : GPLv2
Description : The kernel package contains the Linux kernel (vmlinuz), the core of any
 : Linux operating system.  The kernel handles the basic functions
 : of the operating system: memory allocation, process allocation, device
 : input and output, etc.
```

# 一种自由操作系统

在 Debian 上，我们将使用`apt`，这是最新的，在我看来，也是最友好的工具。

与 YUM 不同，我们可以轻松独立地更新可用软件包列表:

```sh
$ sudo apt update
Ign:1 http://deb.debian.org/debian stretch InRelease
Hit:2 http://deb.debian.org/debian stretch Release
Hit:4 http://security.debian.org/debian-security stretch/updates InRelease
Reading package lists... Done
Building dependency tree 
Reading state information... Done
15 packages can be upgraded. Run 'apt list --upgradable' to see them.
```

请注意，它只更新它的列表，而不是程序本身。

现在，我们可以使用建议的命令来查找特定信息:

```sh
$ apt list --upgradable linux-image*
Listing... Done
linux-image-4.9.0-7-amd64/stable 4.9.110-3+deb9u2 amd64 [upgradable from: 4.9.110-1]
linux-image-amd64/stable 4.9+80+deb9u6 amd64 [upgradable from: 4.9+80+deb9u5]
```

在最后不添加`regex-matched`包的情况下，该命令将列出所有为`upgradable`的包:

```sh
$ apt list --upgradable 
Listing... Done
libcurl3-gnutls/stable 7.52.1-5+deb9u7 amd64 [upgradable from: 7.52.1-5+deb9u6]
libfuse2/stable 2.9.7-1+deb9u1 amd64 [upgradable from: 2.9.7-1]
libpython2.7-minimal/stable 2.7.13-2+deb9u3 amd64 [upgradable from: 2.7.13-2+deb9u2]
libpython2.7-stdlib/stable 2.7.13-2+deb9u3 amd64 [upgradable from: 2.7.13-2+deb9u2]
libpython3.5-minimal/stable 3.5.3-1+deb9u1 amd64 [upgradable from: 3.5.3-1]
libpython3.5-stdlib/stable 3.5.3-1+deb9u1 amd64 [upgradable from: 3.5.3-1]
linux-image-4.9.0-7-amd64/stable 4.9.110-3+deb9u2 amd64 [upgradable from: 4.9.110-1]
linux-image-amd64/stable 4.9+80+deb9u6 amd64 [upgradable from: 4.9+80+deb9u5]
openssh-client/stable 1:7.4p1-10+deb9u4 amd64 [upgradable from: 1:7.4p1-10+deb9u3]
openssh-server/stable 1:7.4p1-10+deb9u4 amd64 [upgradable from: 1:7.4p1-10+deb9u3]
openssh-sftp-server/stable 1:7.4p1-10+deb9u4 amd64 [upgradable from: 1:7.4p1-10+deb9u3]
python2.7/stable 2.7.13-2+deb9u3 amd64 [upgradable from: 2.7.13-2+deb9u2]
python2.7-minimal/stable 2.7.13-2+deb9u3 amd64 [upgradable from: 2.7.13-2+deb9u2]
python3.5/stable 3.5.3-1+deb9u1 amd64 [upgradable from: 3.5.3-1]
python3.5-minimal/stable 3.5.3-1+deb9u1 amd64 [upgradable from: 3.5.3-1]
```

和 YUM 一样，我们可以使用`apt`升级单个套餐:

```sh
$ sudo apt install linux-image-amd64
Reading package lists... Done
Building dependency tree 
Reading state information... Done
The following additional packages will be installed:
 linux-image-4.9.0-8-amd64
Suggested packages:
 linux-doc-4.9 debian-kernel-handbook
The following NEW packages will be installed:
 linux-image-4.9.0-8-amd64
The following packages will be upgraded:
 linux-image-amd64
1 upgraded, 1 newly installed, 0 to remove and 14 not upgraded.
Need to get 39.1 MB of archives.
After this operation, 193 MB of additional disk space will be used.
Do you want to continue? [Y/n] 
```

请注意，我们特别使用了`install`选项而不是`upgrade`，因为`upgrade`会尝试做所有的包，而不仅仅是`linux-image-amd64`。

如果我们想升级一切，我们会使用`upgrade`或`full-upgrade`:

```sh
$ sudo apt full-upgrade
Reading package lists... Done
Building dependency tree 
Reading state information... Done
Calculating upgrade... Done
The following NEW packages will be installed:
 linux-image-4.9.0-8-amd64
The following packages will be upgraded:
 libcurl3-gnutls libfuse2 libpython2.7-minimal libpython2.7-stdlib libpython3.5-minimal libpython3.5-stdlib linux-image-4.9.0-7-amd64 linux-image-amd64 openssh-client
 openssh-server openssh-sftp-server python2.7 python2.7-minimal python3.5 python3.5-minimal
15 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.
Need to get 88.3 MB of archives.
After this operation, 193 MB of additional disk space will be used.
Do you want to continue? [Y/n] 
```

我使用`full-upgrade`的原因是因为仅使用`upgrade`会导致包无法升级(如果升级需要删除另一个包)。

There may be moments when `upgrade` is preferable to `full-upgrade`, so I would advocate checking the output of your `upgrade` command prior to confirming that it is what you want to do.

# 它是如何工作的...

当您运行前面的包管理器命令时，您所做的是查询它们被配置为与之对话的上游服务器，并询问是否有任何更新版本的已安装包可用。

已配置的存储库位于`CentOS`和`/etc/apt/sources.list.d`(或`sources.list.conf`)上的`/etc/yum.repos.d/`中。

如果您的软件有更新的版本，您可以选择稍后安装或下载。一般来说，确保您的所有软件保持最新是一个好主意，但是对于面向公共的服务来说尤其如此，例如网络服务器和 SSH 守护程序。

# 还有更多...

一些流行而棘手的软件存在于感觉之外(就这个固执己见的作者而言)。

特别值得注意的是 Hashicorp 工具套件，它检查调用时是否有新版本的工具可用。这意味着当你运行`Terraform`时，有机会它会通知你它已经过时了，你应该下载一个更新的版本:

```sh
$ terraform --version
Terraform v0.11.7

Your version of Terraform is out of date! The latest version
is 0.11.8\. You can update by downloading from www.terraform.io/downloads.html
```

发行版的包维护者通常不会掌握这一点，这不是他们自己的错，相当多的人甚至不会费心去打包做这件事的软件。这意味着人们经常会在他们的包管理器之外添加 Terraform、Packer 和其他一些很酷的软件，使你需要跟踪的包管理系统的数量翻了一番(一个是你的系统，另一个是你的系统)。

# 自动更新

在这一部分，我们将使用第一部分中使用的`Vagrantfile`。

有点含糊不清，“自动更新”对许多系统管理员来说是一个棘手的问题，因为从历史上看，更新经常会阻塞一个系统。

这种情况现在越来越少了，有一些方法可以让你的盒子自动更新而不用担心(尽管我个人在生产中仍然不会这么做)。

我们还将讨论以编程方式重建系统。

# 怎么做...

在这一部分，依次跳到你的每个盒子里。

需要注意的是，您可能根本不想自动安装更新，尤其是在机器被定期销毁和重建的环境中。

也可能有内部程序束缚了你的手脚，这意味着无论你在技术上有能力做什么，官僚主义总是会阻碍你。

# CentOS

在`CentOS`系统上，我们有一个叫做`yum-cron`的便捷工具:

```sh
$ sudo yum install yum-cron -y
```

它带有两个配置文件，位于`/etc/yum/`。

默认情况下，将使用`/etc/yum/yum-cron.conf`文件，其中有一个随机睡眠，我们将禁用:

```sh
$ sudo sed -i "s/random_sleep = 360/random_sleep = 0/g" /etc/yum/yum-cron.conf
```

现在，这意味着当调用`yum-cron`时，它将自动运行，应用`yum-cron.conf`的默认设置:

```sh
$ sudo yum-cron 
$ 
```

如果没有更新，`yum-cron`将不会显示任何输出(如前所述)。

如果有更新，默认情况下，您将收到更新已成功下载的通知:

![](assets/8890cd95-2e9f-4e8d-9c5e-31674b585dbd.png)

如果您想自动应用更新，这将涉及另一个配置文件更改，如下所示:

```sh
$ sudo sed -i "s/apply_updates = no/apply_updates = yes/g" /etc/yum/yum-cron.conf
```

再次运行`yum-cron`将应用下载的更新:

![](assets/b337a448-b86e-440d-8b61-1908e95298e3.png)

我们之前已经提到过(但值得再说一遍)，这并不一定意味着服务会立即被修复，或者会有新的特性。

这就是命令`needs-restarting`出现的地方。

您也可以使用计时器(或者`cron`，如果您必须的话)来运行它，以列出更新后需要重新启动的进程，或者它们使用的组件具有:

```sh
$ sudo needs-restarting 
2617 : /usr/lib/systemd/systemd-udevd 
1082 : qmgr -l -t unix -u 
603 : /usr/sbin/crond -n 
609 : /sbin/agetty --noclear tty1 linux 
574 : /usr/sbin/chronyd 
397 : /usr/lib/systemd/systemd-journald 
851 : /usr/sbin/sshd -D -u0 
1070 : /usr/libexec/postfix/master -w 
1 : /usr/lib/systemd/systemd --system --deserialize 21 
2155 : sshd: vagrant [priv] 
<SNIP>
```

如果想要更好的输出，可以指定服务，如下所示:

```sh
$ sudo needs-restarting -s
rpcbind.service
chronyd.service
systemd-logind.service
NetworkManager.service
postfix.service
dbus.service
getty@tty1.service
crond.service
lvm2-lvmetad.service
sshd.service
gssproxy.service
systemd-udevd.service
systemd-journald.service
polkit.service
```

或者仅当需要重新启动时，使用以下命令:

```sh
$ sudo needs-restarting -r
Core libraries or services have been updated:
 kernel -> 3.10.0-862.14.4.el7
 systemd -> 219-57.el7_5.3
 linux-firmware -> 20180220-62.2.git6d51311.el7_5

Reboot is required to ensure that your system benefits from these updates.

More information:
https://access.redhat.com/solutions/27943
```

一个真正简单的开始`yum-cron`的方法是用下面的一行:

```sh
$ sudo systemctl enable --now yum-cron
```

# 一种自由操作系统

在 Debian(和 Ubuntu)世界中，我们使用一个名为`unattended-upgrades`的包。它已经存在了很长时间，通常是人们用来自动更新基于 Debian 的发行版的选项。

跳到您的拉伸盒中，快速运行包的`install`，如下所示:

```sh
$ sudo apt install unattended-upgrades
```

如果你现在`ls`到`/etc/apt/apt.conf.d/`目录，你会看到几个新文件:

```sh
$ ls -l /etc/apt/apt.conf.d/
total 44
-rw-r--r-- 1 root root   49 Jul 17 01:48 00aptitude
-rw-r--r-- 1 root root   82 Jul 17 01:46 00CDMountPoint
-rw-r--r-- 1 root root   40 Jul 17 01:46 00trustcdrom
-rw-r--r-- 1 root root  769 Sep 13  2017 01autoremove
-r--r--r-- 1 root root 1768 Jul 17 01:49 01autoremove-kernels
-rw-r--r-- 1 root root   80 Dec 11  2016 20auto-upgrades
-rw-r--r-- 1 root root  202 Apr 10  2017 20listchanges
-rw-r--r-- 1 root root 4259 Oct  1 16:49 50unattended-upgrades
-rw-r--r-- 1 root root  182 May 21  2017 70debconf
-rw-r--r-- 1 root root   27 Jul 17 01:49 99translations
```

这些都是`unattended-upgrades`套餐的症结所在。

如果我们看一下`50unattended-upgrades`配置文件中处理要引入哪些更新的块，我们将看到以下内容:

```sh
Unattended-Upgrade::Origins-Pattern {
 // Codename based matching:
 // This will follow the migration of a release through different
 // archives (e.g. from testing to stable and later oldstable).
// "o=Debian,n=jessie";
// "o=Debian,n=jessie-updates";
// "o=Debian,n=jessie-proposed-updates";
// "o=Debian,n=jessie,l=Debian-Security";

 // Archive or Suite based matching:
 // Note that this will silently match a different release after
 // migration to the specified archive (e.g. testing becomes the
 // new stable).
// "o=Debian,a=stable";
// "o=Debian,a=stable-updates";
// "o=Debian,a=proposed-updates";
 "origin=Debian,codename=${distro_codename},label=Debian-Security";
};
```

请注意，唯一没有注释的行是最下面的一行(在右大括号之前)。

我们将取消它前面的行的注释，如下所示:

```sh
$ sudo sed -i 's/\/\/      "o=Debian,a=stable";/      "o=Debian,a=stable";/g' /etc/apt/apt.conf.d/50unattended-upgrades
$ sudo sed -i 's/\/\/      "o=Debian,a=stable-updates";/      "o=Debian,a=stable-updates";/g' /etc/apt/apt.conf.d/50unattended-upgrades
$ sudo sed -i 's/\/\/      "o=Debian,a=proposed-updates";/      "o=Debian,a=proposed-updates";/g' /etc/apt/apt.conf.d/50unattended-upgrades
```

您可以通过在调试模式下启动命令来运行和测试配置:

```sh
$ sudo unattended-upgrade -d
```

它可能看起来如下所示:

![](assets/41e2ddc7-898d-4023-845e-e646e015438a.png)

注意到升级是如何实际安装的，并创建了一个日志文件。

# 它是如何工作的...

`yum-cron`实际上只是在 cron 工作中使用 YUM 的一种简单方法(我们在前面讨论`systemd`计时器时轻蔑地提到了这一点)。因此，您会发现很容易将它合并到自定义计时器(参见前面的章节)或夜间运行的 cron 作业中。

一般来说，您可以每晚将所有更新应用于开发环境，然后可能在一周内错开更新到其他(更高)环境，将生产升级到下周二。这完全取决于你，作为全能的系统管理员。

如果您已经采纳了启用`yum-cron`作为服务的建议，您现在应该会发现存在以下文件:

```sh
$ ls /var/lock/subsys/yum-cron 
/var/lock/subsys/yum-cron
```

这将启用两个`cron`作业，如下所示:

```sh
$ ls /etc/cron.daily/0yum-daily.cron 
/etc/cron.daily/0yum-daily.cron
$ ls /etc/cron.hourly/0yum-hourly.cron 
/etc/cron.hourly/0yum-hourly.cron
```

这些将使用我们提到的配置文件。

就 Debian 的`unattended-upgrades`而言，和大多数现代系统一样，`systemd`用于每天运行这项工作。

列出您的`systemd`计时器，如下所示:

```sh
$ sudo systemctl list-timers
NEXT                         LEFT          LAST                         PASSED    UNIT                         ACTIVATES
Mon 2018-10-01 20:34:32 GMT  3h 16min left Mon 2018-10-01 16:48:00 GMT  30min ago apt-daily.timer              apt-daily.service
Tue 2018-10-02 06:56:19 GMT  13h left      Mon 2018-10-01 16:48:00 GMT  30min ago apt-daily-upgrade.timer      apt-daily-upgrade.service
Tue 2018-10-02 17:03:03 GMT  23h left      Mon 2018-10-01 17:03:03 GMT  15min ago systemd-tmpfiles-clean.timer systemd-tmpfiles-clean.service

3 timers listed.
Pass --all to see loaded but inactive timers, too.
```

请注意两个`apt`作业，第一个作业运行以下内容:

```sh
[Service]
Type=oneshot
ExecStart=/usr/lib/apt/apt.systemd.daily update
```

第二个运行以下内容:

```sh
[Service]
Type=oneshot
ExecStart=/usr/lib/apt/apt.systemd.daily install
KillMode=process
TimeoutStopSec=900
```

# 还有更多...

像 Debian 上的无人值守升级一样，`yum-cron`只能通过特定类型的升级工作。默认情况下，它被设置为`default`，如下面的片段所示，这就是为什么我们没有在前面修改它:

```sh
$ cat /etc/yum/yum-cron.conf 
[commands]
#  What kind of update to use:
# default                            = yum upgrade
# security                           = yum --security upgrade
# security-severity:Critical         = yum --sec-severity=Critical upgrade
# minimal                            = yum --bugfix update-minimal
# minimal-security                   = yum --security update-minimal
# minimal-security-severity:Critical =  --sec-severity=Critical update-minimal
update_cmd = default
```

没有什么能阻止你改变这一点，也许指定只有安全升级应该自动应用？

# 自动供应

在序言中，我建议我们触及这一点，这绝对值得讨论。

曾经，有这样一种情况:物理机器在地球上漫游，捕食那些敢于进入它们的沼泽和服务器笼子的毫无戒心的系统管理员。

如今，服务器仍然存在，但它们被赋予了一个对技术更不友好、更熟悉媒体的名字，被通俗地称为**云**，并且变得足够透明，以至于系统管理员不再知道他们最喜欢的潮人发行版是在戴尔、HPE 还是 IBM 机器上运行。

这导致了短暂的服务器，或者说服务器在晚上周期性地停止存在，但在第二天早上又重新诞生。

除了给你一个关于你晚上睡觉时是否停止存在的生存危机，这可能会开始给你关于永远不更新你的机器的想法，而不是简单地确保它们回来时已经应用了所有的更新。

根据时间表自动配置基础架构的概念越来越受欢迎，它可以归结为在上传和/或将其移动到虚拟基础架构的不同部分之前以编程方式创建一个映像(使用 Packer 之类的程序)，在那里另一个程序(Terraform)可以使用新映像来创建许多闪亮的新盒子。

显然，这一点一直适用于没有问题的生产网络，因为在您的`dev`实例上没有客户(我希望——我真的真的希望)。它确实在生产中带来了问题，但是然后你开始考虑一些疯狂的事情，比如蓝色/绿色部署。

# 检查邮件列表和勘误表页面

除了我们的系统之外，我们还将看看您一般会去哪里获取有关您的操作系统性能的新闻。他们健康吗？他们需要一些空间吗？他们会很快内爆吗？

养成这个习惯是很好的做法，因为有时候，系统和行为的改变可能需要系统管理员的手动干预，即使您自动处理掉了所有其他问题。

服务器–谁需要它们？

# 准备好

在本节中，我们将使用我们的虚拟机和万能的互联网。

# 怎么做...

我们将稍微看一下我们的虚拟机，但我们将主要关注新闻的在线位置。

有各种各样的方法和地方，你可能会去获取信息，所以让我们来看看一些更受欢迎的方法和地方。

# 包更改日志

如果你想要一个包的信息，你可能会喜欢的一件事是`changelog`，通过一个简单的 RPM 命令就可以从你的系统中访问。

首先，找到你要检查的包裹；我们将抓取最近安装的`kernel`:

```sh
$ rpm -q kernel --last
kernel-3.10.0-862.14.4.el7.x86_64             Sun 30 Sep 2018 16:40:08 UTC
kernel-3.10.0-862.2.3.el7.x86_64              Sat 12 May 2018 18:51:56 UTC
```

现在，打开`kernel`的`changelog`(很长):

```sh
$ rpm -q --changelog kernel-3.10.0-862.14.4.el7.x86_64 | less
```

您将获得如下内容:

![](assets/5c52aa6a-0e84-407e-bbb1-47fb7cf93c5d.png)

这可能是检查特定更改的好方法，但有时也会有点棘手(取决于日志的性质)。

为了表明它也适用于其他包，这里有`lsof`，它要稀疏得多:

![](assets/2045bc58-7d52-49e0-8c00-f75af20d7d20.png)

在 Debian 和 Ubuntu 下，我们可以使用`apt`来完成同样的事情，如下所示:

```sh
$ apt changelog linux-image-amd64
```

诚然，输出并不冗长，如下图所示:

![](assets/8d5a288e-3d68-47b4-ae2f-82800af7bf82.png)

# 官方来源和邮件列表

红帽，借着他们集体的善良之心，提供一页参考勘误表和更新消息:[https://access.redhat.com/security/updates/advisory](https://access.redhat.com/security/updates/advisory)

本页有一些重要且非常有用的链接，例如红帽**常见漏洞和暴露** ( **CVE** )数据库的链接:[https://access.redhat.com/security/security-updates/#/cve](https://access.redhat.com/security/security-updates/#/cve)

If you have a Red Hat login, there's also a link to their own errata page on the customer portal.

邮件列表是这个世界的一大部分，有些可以追溯到几十年前，你也可以收到太多的电子邮件(其中大部分你永远不会阅读)！

大多数大型项目都有邮件列表(有时有几个)，订阅所有邮件列表几乎毫无意义(例如，当你在 2000 年代中期淘汰了新世界麦金塔电脑时，为什么要为内核注册 PowerPC 邮件列表？)

选择你感兴趣的，可能对管理有用的。安全列表通常是一个很好的起点:

*   红帽在[https://www.redhat.com/mailman/listinfo](https://www.redhat.com/mailman/listinfo)保持几个在下面。
*   CentOS 在 https://lists.centos.org/mailman/listinfo/有自己的邮件列表。
*   Debian 在 https://lists.debian.org/有他们的邮件列表。(它包括方便的文档，您可能会发现这些列表很有用。)
*   当然，乌班图的名单在 https://lists.ubuntu.com/。(它的格式也很好，比如 Debian。)

Good lists to sign up to include announcement lists; for example, the `CentOS-announce` list covers general and security information.

官方来源列表中应该包括各种公开可见的项目来源树，以及它们相关的*问题*部分(在 GitHub 等地方)。一定要留意任何你喜欢的宠物项目，或者那些可能支撑你的基础设施的项目(地形等等)。

# 其他来源

BBC、HackerNews、The Register 和 Reddit 之前都通知过我一些问题，在热门新闻网站的首页上读到这些问题之前，我应该已经意识到这些问题；说到想招徕恐慌，不要低估主流媒体。

# 它是如何工作的...

这些项目是公开的，当有问题时，参与的人都很清楚其中的利害关系。人们只需看一看大漏洞被发现时引起的恐慌，就能理解为什么通知途径被如此广泛地使用和欣赏。

如果一个项目没有办法与用户沟通关键问题，它会很快发现自己被关心的人淹没，只想知道他们使用的软件是最新的。

在这场对抗安全问题和突发变化的战斗中，我们所能做的就是随时了解情况，并在需要时迅速采取行动。

# 还有更多...

还有很多，真的；查看博客，如 CentOS([https://blog.centos.org/](https://blog.centos.org/))以及其他包和项目的个人邮件列表。

例如，OpenSSL 是一个值得关注的好工具([https://www.openssl.org/community/mailinglists.html](https://www.openssl.org/community/mailinglists.html))，我不会因为任何与心脏健康相关的特殊原因而这么说。

一个大的是内核邮件列表选择，可通过[https://lkml.org/](https://lkml.org/)查看；在这里，内核消息一般都是先坏了再说。

# 使用快照

在本节中，我们将使用我们的 Ubuntu 虚拟机。

**快照**(由 Canonical 拍摄)是附近两个新来的孩子之一。它们是一种以通用方式打包软件的方法，因此一个包可以部署到任何支持快照的操作系统。

在写这本书的时候，Ubuntu 可能对快照有最好的支持，但是 Canonical 自豪地在他们的网站上列出了相当多发行版的安装说明(尽管其中三个只是下游的 Ubuntu 发行版)，[https://docs.snapcraft.io/core/install](https://docs.snapcraft.io/core/install)。

我通常对 Canonical 很苛刻，所以我只能说我为这种努力鼓掌。一段时间以来，Linux 上不同的打包方法确实是一些开发人员远离的众多原因之一，任何旨在缩小这一差距的东西都是社区中受欢迎的补充。

# 怎么做...

跳到我们之前创建的 Ubuntu 机器上，如下所示:

```sh
$ vagrant ssh ubuntu1804
```

在我们的虚拟机上，`snapd`服务将已经启动并运行(或者应该是；用`systemctl`检查)。

# 搜索快照

要搜索快照，我们使用`snap`命令行工具。在本例中，我将寻找另一个 Canonical 产品(`lxd`):

```sh
$ snap search lxd
Name             Version        Publisher       Notes  Summary
lxd-demo-server  0+git.f3532e3  stgraber        -      Online software demo sessions using LXD
lxd              3.5            canonical       -      System container manager and API
nova             ocata          james-page      -      OpenStack Compute Service (nova)
satellite        0.1.2          alanzanattadev  -      Advanced scalable Open source intelligence platform
nova-hypervisor  ocata          james-page      -      OpenStack Compute Service - KVM Hypervisor (nova)
```

我们得到了一些结果，由 Canonical 和其他一些名字发表。

它也不限于守护进程；在下面的代码中，我正在搜索`aws-cli`工具:

```sh
$ snap search aws-cli
Name     Version  Publisher  Notes    Summary
aws-cli  1.15.71  aws√       classic  Universal Command Line Interface for Amazon Web Services
```

Note the tick next to the publisher's name; this means that the package is from a verified account (in this case, Amazon Web Services).

# 安装卡扣

我们想要的快照名为`lxd`，使我们的安装变得容易:

```sh
$ sudo snap install lxd
```

您将看到类似于以下内容的进度条:

![](assets/64973e8c-5fab-46ff-a99f-1f945a0ab60d.png)

一旦完成，您将通过快照安装`lxd`容器管理器。

# 列出已安装的快照

我们可以用`snap list`列出我们安装的快照，如下所示:

```sh
$ snap list
Name  Version    Rev   Tracking  Publisher   Notes
core  16-2.35.2  5548  stable    canonical√  core
lxd   3.5        8959  stable    canonical√  -
```

# 与守护程序快照交互

因为 LXD 是守护进程，我们可以再次使用`snap`命令行工具启用它；首先，我们应该检查服务的活动状态，如下所示:

```sh
$ sudo snap services
Service Startup Current
lxd.activate enabled inactive
lxd.daemon enabled inactive
```

它是不活动的，但我们可以激活它(我们有技术)，如下所示:

```sh
$ sudo snap start lxd
Started.
```

再次检查服务，我们可以看到它已经启动:

```sh
$ sudo snap services
Service       Startup  Current
lxd.activate  enabled  inactive
lxd.daemon    enabled  active
```

Under `systemd`, the service is called `snap.lxd.daemon.service`, if you want to use traditional tools to check its status.

为了证明它已经启动并且我们可以与守护进程交互，我们可以使用捆绑的`lxc`包，如下所示:

```sh
$ lxd.lxc list
Error: Get http://unix.socket/1.0: dial unix /var/snap/lxd/common/lxd/unix.socket: connect: permission denied
```

您可以看到它尝试与套接字通信；虽然在前面的代码片段中它给了我们一个权限被拒绝的错误，但是这确实突出了套接字存在于`/var/snap/`目录中。

我们再试一次，用`sudo`:

```sh
$ sudo lxd.lxc list
+------+-------+------+------+------+-----------+
| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |
+------+-------+------+------+------+-----------+
```

太棒了。

# 移除快照

最后，我们可以使用我们的工具不带偏见地移除`lxd`:

```sh
$ sudo snap remove lxd
lxd removed
```

# 它是如何工作的...

快照的工作方式与任何其他包管理器一样，安装和管理从系统上的存储库中引入的包。

您还会注意到我们已安装快照列表中的核心安装；这实际上是快照工作的基础平台。

`snapd`是支撑快照的守护进程；它是管理已安装快照的环境，处理旧版本的安装、更新和删除。

安装快照时，实际下载的是位于`/var/lib/snapd/snaps/`的只读`squashfs`文件:

```sh
$ ls
core_5548.snap  lxd_8959.snap  partial
```

The numbers are snap revision numbers.

当这些`squashfs`图像被`snapd`挂载时，你可以看到它们被`df`拟人化为环形装置:

```sh
$ df -h | grep loop
/dev/loop0 67M 67M 0 100% /snap/lxd/8959
/dev/loop1 88M 88M 0 100% /snap/core/5548
```

也可以用`mount`查看具体的`mount`信息:

```sh
$ mount | grep snap
/var/lib/snapd/snaps/lxd_8959.snap on /snap/lxd/8959 type squashfs (ro,nodev,relatime,x-gdu.hide)
/var/lib/snapd/snaps/core_5548.snap on /snap/core/5548 type squashfs (ro,nodev,relatime,x-gdu.hide)
tmpfs on /run/snapd/ns type tmpfs (rw,nosuid,noexec,relatime,size=100896k,mode=755)
nsfs on /run/snapd/ns/lxd.mnt type nsfs (rw)
```

请注意，我们可以导航到安装这些快照的位置，如下所示:

```sh
$ cd /snap/lxd/8959/bin/
```

但是，因为文件系统是只读的，所以我们不能在其中写入任何内容:

```sh
$ touch test
touch: cannot touch 'test': Read-only file system
```

很整洁，对吧？

我们可以使用我们的快照，而无需直接调用二进制文件，因为我们的`$PATH`中有各种`snap`条目:

```sh
$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:/var/lib/snapd/snap/bin:/snap/bin:/var/lib/snapd/snap/bin
```

The `PATH` is the list of defined locations where your shell will look for binaries; when you run `ls`, you're locating is the binary somewhere within your `PATH`.

快照也是独立的，这意味着库和运行时被捆绑到包中(这使得发行版之间的可移植性变得容易)。

# 还有更多...

如果你想要一个快照的详细信息，还有`snap info`命令。

以下是对`lxd`包运行命令时的输出:

```sh
$ snap info lxd
name:      lxd
summary:   System container manager and API
publisher: Canonical√
contact:   https://github.com/lxc/lxd/issues
license:   unset
description: |
 LXD is a container manager for system containers.

 It offers a REST API to remotely manage containers over the network, using an image based workflow
 and with support for live migration.

 Images are available for all Ubuntu releases and architectures as well as for a wide number of
 other Linux distributions.

 LXD containers are lightweight, secure by default and a great alternative to virtual machines.
commands:
 - lxd.benchmark
 - lxd.buginfo
 - lxd.check-kernel
 - lxd.lxc
 - lxd
 - lxd.migrate
services:
 lxd.activate: oneshot, enabled, inactive
 lxd.daemon:   simple, enabled, inactive
snap-id:      J60k4JY0HppjwOjW8dZdYc8obXKxujRu
tracking:     stable
refresh-date: today at 16:44 UTC
channels: 
 stable:        3.5         (8959) 69MB -
 candidate:     3.5         (8959) 69MB -
 beta:          ↑ 
 edge:          git-47f0414 (8984) 69MB -
 3.0/stable:    3.0.2       (8715) 65MB -
 3.0/candidate: 3.0.2       (8715) 65MB -
 3.0/beta:      ↑ 
 3.0/edge:      git-d1a5b4d (8957) 65MB -
 2.0/stable:    2.0.11      (8023) 28MB -
 2.0/candidate: 2.0.11      (8023) 28MB -
 2.0/beta:      ↑ 
 2.0/edge:      git-92a4fdc (8000) 26MB -
installed:       3.5         (8959) 69MB -
```

这应该告诉你关于任何特定快照你需要知道的大部分。

# 请参见...

如果你生活在 21 世纪，你不必在命令行上搜索快照。

您也可以在【https://snapcraft.io/】使用`snapcraft.io`网站:

![](assets/b8015e11-f633-4c93-881d-a8456cc0132f.png)

在商店部分，你会发现一个视觉搜索，它可以帮助你以一种友好的点击按钮的方式找到你想要的东西。在下面的截图中，我已经搜索了`aws`:

![](assets/fa26d151-e0a0-4776-be9c-0f612b263d75.png)

# 使用 Flatpak

Flatpak(由 Alex Larsson 和 Flatpak 团队)是全套解决方案经理中的第二个。这也是一种打包软件的好方法，这样一个包就可以部署到支持 Flatpak 安装的任何操作系统上。听起来熟悉吗？

然而，实际上，我们也陷入了相互冲突的技术发展(又一次)和圣战(又一次)。

首先，我应该指出 Flatpak 确实强调桌面应用程序而不是服务器应用程序，从它们复杂的运行命令到它们主要是图形工具。快照无疑是两个世界的混合体。

Obviously if you want to install a GUI on your server, there's nothing stopping you, you could even use VNC for management! However, it's not really done, like fish fingers and custard.

# 准备好

在这一节中，我们将继续使用我们的 Ubuntu 虚拟机(主要是因为这是我在写完最后一节后仍然打开的那个)。

我们没有理由不能使用我们的 Debian 或者 CentOS 盒子。还支持许多其他发行版，包括(但不限于)以下发行版:

*   拱门
*   一种男式软呢帽
*   巴布亚企鹅
*   Solus
*   阿尔卑斯山的
*   openSUSE

要为 Flatpak 设置我们的虚拟机，我们必须安装它，尽管它在默认的存储库中是可用的(可能是在升级之后，这取决于您何时阅读本文；如果你在 2017 年之前阅读这篇文章，我对你的时间位移能力印象深刻，但你应该知道未来是黑暗的，充满了柠檬):

```sh
$ sudo apt update && sudo apt upgrade -y
$ sudo apt install flatpak -y
```

接下来，我们需要从[https://flathub.org](https://flathub.org)启用远程`flathub`回购:

```sh
$ sudo flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
```

现在，我们可以安装东西了！

# 怎么做...

出于本节的目的，我选择了相对轻量级的`vim`包来从 Flathub 安装。

# 正在搜索包

首先，让我们寻找包:

```sh
$ sudo flatpak search vim
Application ID            Version   Branch Remotes Description 
org.vim.Vim               v8.1.0443 stable flathub Edit text files 
net.mediaarea.AVIMetaEdit 1.0.2     stable flathub Embed, validate, and export AVI files metadata 
org.gnome.Devhelp                   stable flathub A developer tool for browsing and searching API documentation 
org.openshot.OpenShot     2.4.3     stable flathub An easy to use, quick to learn, and surprisingly powerful video editor
org.gnome.Builder         3.30.1    stable flathub An IDE for GNOME   
```

同样，我们有一些结果，但最重要的是我们所追求的。

# 安装我们的软件包

我们可以用一个小命令安装这个包，如下所示:

```sh
$ flatpak install flathub org.vim.Vim -y
```

This can take quite some time to download, and it takes up more space than you might expect (despite being a relatively lightweight package).

# 运行我们的包

安装完成后，您可以运行新版本的`Vim`:

```sh
$ flatpak run org.vim.Vim
```

The package identifier is in three parts: usually `org/com.<company or team>.<app name>`.

这不是最漂亮的命令，但它会将您放入可靠的文本编辑器，如下所示:

![](assets/27891bc3-c8ac-4b71-84bf-9f2e391b7522.png)

如果我们看看 Flatpak 安装和原生`Vim`安装的版本，我们可以看到区别:

```sh
$ flatpak run org.vim.Vim --version | head -n3
VIM - Vi IMproved 8.1 (2018 May 18, compiled Oct  1 2018 10:15:08)
Included patches: 1-443
Compiled by buildbot
$ vim --version | head -n3
VIM - Vi IMproved 8.0 (2016 Sep 12, compiled Apr 10 2018 21:31:58)
Included patches: 1-1453
Modified by pkg-vim-maintainers@lists.alioth.debian.org
```

# 列出已安装的软件包

现在我们有东西要实际展示，我们可以列出我们安装的`flatpak`包:

```sh
$ flatpak list
Ref                                        Options 
org.vim.Vim/x86_64/stable                  system,current
org.freedesktop.Platform.ffmpeg/x86_64/1.6 system,runtime
org.freedesktop.Platform/x86_64/1.6        system,runtime
```

请注意，它还告诉我们，该包是`system`包，而不是每个用户的包。

# 用户安装

Flatpak 还有本地用户安装的概念，这意味着我们也可以作为用户安装软件包:

```sh
$ flatpak --user remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo
$ flatpak --user install flathub org.vim.Vim -y
```

# 删除包

当您不可避免地对`Vim`感到厌烦，回到使用`ed`来满足日常编辑需求时(因为`ed`是标准的文本编辑器)，您可以轻松地移除您的包，如下所示:

```sh
$ sudo flatpak uninstall org.vim.Vim --user -y
```

Here, we're specifically removing the user-installed version; the system one will remain.

# 它是如何工作的...

当您使用 Flatpak 安装软件包时，它会出现在两个位置之一:

*   系统包在`/var/lib/flatpak`结束。
*   用户包结束于`~/.local/share/flatpak/`。

查看这些位置，我们可以找到一个`app`目录，在其中，我们的包:

```sh
$ pwd
/home/vagrant/.local/share/flatpak/app
$ ls
org.vim.Vim
```

在这个目录中，还有更多的层，这些层包含当前版本的包和各种二进制文件。

包是在运行时基础上构建的，就像您在前面列出已安装的包时看到的那样。这些运行时与发行版无关，这意味着它们可以安装在世界上所有的 Ubuntu、CentOS 和 Fedora 系统上。

如果应用程序运行需要一些额外的东西，比如一个特定的库，你也可以把它打包到你的包中。

# 还有更多...

写这本书的时候，有`585`包可以从`flathub`安装，数量每天都在增长:

```sh
$ flatpak remote-ls flathub | wc -l
585
```

您也可以使用一个命令更新应用程序，如下所示:

```sh
$ flatpak update
Looking for updates...
```

# 请参见...

对于那些怀着激情讨厌`Vim`的人来说，尽管它有着明显的优越性，Flathub 已经覆盖了你们:

```sh
$ flatpak search emacs
Application ID    Version Branch Remotes Description 
org.gnu.emacs     26.1    stable flathub An extensible text editor 
org.gnome.Devhelp         stable flathub A developer tool for browsing and searching API documentation
```

还有很多可用的软件包，但是，正如我之前所说的，你实际上不太可能发现自己在服务器上使用 Flatpak，仅仅因为它是一项专注于桌面的工作。

不过，在你自己的电脑上，快照和 Flatpak 软件包可以并排安装。

I once tried to use `Solus` as my daily driver, but wanted to ensure that I did nothing out of the ordinary with my installation. At the time, `Solus` had its own packages, snap support, and Flatpak support. This actually resulted in me using specific snaps for managing a Kubernetes setup, Flatpak to install `Slack`, and the system's own package manager for everything else; it was a bit of a mess by the end, but a consistent mess!

# 使用 Pip、RubyGems 和其他包管理器

除了 YUM、Apt、snaps 和 Flatpak，还有许多其他的包管理系统。Pip 和 RubyGems 是与编程语言相关的向系统分发包的方法；不止这两个，但它们是目前最受欢迎的。

**P****ip installs packages** (**Pip**) is included by default in recent Python installations. Gem is just a play on the fact that it is for packaging Ruby elements; it, too, is included in recent Ruby installations.

我们将使用这些包管理器来安装软件。

# 准备好了

在本节中，我们将继续使用我们的 Ubuntu 虚拟机。

在你的 Ubuntu 机器上安装 Pip 和 RuByGems(Python 已经安装好了，但是在这个例子中它是 Pip 的一个单独的包)，如下所示:

```sh
$ sudo apt update && sudo apt upgrade -y
$ sudo apt install libgmp3-dev make gcc ruby ruby-dev python3-setuptools -y 
```

Python2 and Python3 are both widely used, although these days, you really shouldn't be writing anything new in Python2 (which will be going out of support in 2020).

我们现在要安装`pip`，使用`easy_install3`脚本:

```sh
$ sudo python3 /usr/lib/python3/dist-packages/easy_install.py pip
```

There is a way to install `python3-pip` using `apt`, but this version will be frequently out of date, and the whole point of using Pip is that you get the latest version of everything; hence why we use `easy_install`. Together with that, if you try to upgrade the system-installed version of Pip, it might very well work, but you'll be changing system-controlled packages outside of the system-method-of-control... phew.

# 怎么做...

我们现在将介绍一些基本的事情，您可以使用这些包管理器中的每一个来做。

# 点

从 Pip 开始，您可以使用`--version`参数检查正在运行的版本:

```sh
$ pip3 --version
pip 18.1 from /usr/local/lib/python3.6/dist-packages/pip-18.1-py3.6.egg/pip (python 3.6)
```

您可以用`list`列出您安装了哪些软件包(及其版本)，如下所示:

```sh
$ pip3 list
Package             Version 
------------------- ---------
asn1crypto          0.24.0 
attrs               17.4.0 
Automat             0.6.0 
blinker             1.4 
certifi             2018.1.18
chardet             3.0.4 
click               6.7 
cloud-init          18.3 
colorama            0.3.7 
```

您可以搜索所需的包；在这里，我正在检查 Ansible:

```sh
$ pip3 search ansible
ovirt-ansible (0.3.2) - oVirt Ansible utility
polemarch-ansible (1.0.5) - Wrapper for Ansible cli.
kapellmeister-ansible (0.1.0) - Ansible Playbook manager.
ansible-alicloud (1.5.0) - Ansible provider for Alicloud.
ansible-kernel (0.8.0) - An Ansible kernel for Jupyter
ansible-roles (0.1.4) - Manage ansible roles.
ansible-shell (0.0.5) - Interactive shell for ansible
ansible-toolkit (1.3.2) - The missing Ansible tools
ansible-toolset (0.7.0) - Useful Ansible toolset
...
```

There are a lot of packages in the **Python package index** (**PyPI**), so you might get a lot of results from your search; this is where learning some `regex` and invoking `grep` can be useful.

找到后，我们还可以安装软件包，如下所示:

```sh
$ pip3 install ansible --user
```

注意`sudo`的缺失；这是因为我们希望以用户的身份安装它，这意味着该包最终位于主目录(`~`)中的`.local`目录中:

```sh
$ ls .local/bin/
ansible         ansible-connection  ansible-doc     ansible-inventory  ansible-pull   easy_install
ansible-config  ansible-console     ansible-galaxy  ansible-playbook   ansible-vault  easy_install-3.6
```

默认情况下，`.local/bin`目录在我们的`PATH`中(如果我们注销并重新登录):

```sh
$ echo $PATH
/home/vagrant/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin
```

这意味着我们可以从我们的外壳中运行`ansible`:

```sh
$ ansible --version
ansible 2.7.0
 config file = None
 configured module search path = ['/home/vagrant/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']
 ansible python module location = /home/vagrant/.local/lib/python3.6/site-packages/ansible
 executable location = /home/vagrant/.local/bin/ansible
 python version = 3.6.6 (default, Sep 12 2018, 18:26:19) [GCC 8.0.1 20180414 (experimental) [trunk revision 259383]]
```

在我们的包安装好之后，我们可能会发现我们实际上需要一个旧版本；谢天谢地，Pip 让您可以轻松地指定这一点，如下所示:

```sh
$ pip3 install ansible==2.5.0 --user
```

并且，在稍后的日期，如果我们决定需要最新版本(因为旧的行动手册最终已经更新，没有不推荐使用的功能)，我们可以升级，如下所示:

```sh
$ pip3 install ansible --upgrade --user
```

# RubyGems

像 Pip 一样，我们可以用一个简单的`gem`命令来检查我们安装了哪个版本的 RubyGems:

```sh
$ gem --version
2.7.6
```

要列出安装的宝石，我们可以使用`list`，说来好笑:

```sh
$ gem list

*** LOCAL GEMS ***

bigdecimal (default: 1.3.4)
cmath (default: 1.0.0)
csv (default: 1.0.0)
date (default: 1.0.0)
dbm (default: 1.0.0)
did_you_mean (1.2.0)
...
```

如果我们想搜索一个包，我们使用`gem search`(我们在 RubyGems 中也有`--exact`选项，这是 Pip 所缺少的):

```sh
$ gem search -e chef

*** REMOTE GEMS ***

chef (14.5.33 ruby universal-mingw32, 12.3.0 x86-mingw32)
```

我们也可以用`gem install`安装(作为用户):

```sh
$ gem install chef --user-install
```

请注意，默认情况下`.local`宝石安装位置不会在您的`PATH`中，但我们可以从我们的主目录中调用它的完整路径(稍后将添加到我们的`PATH`:

```sh
$ ~/.gem/ruby/2.5.0/bin/chef-client --version
Chef: 14.5.33
```

与 Pip 一样，我们可以安装其他版本的软件包:

```sh
$ gem install chef -v14.2.0 --user-install
$ ~/.gem/ruby/2.5.0/gems/chef-14.2.0/bin/chef-client --version
Chef: 14.2.0
```

请注意，我们在这里使用了不同的路径，进入安装目录的`/gems/`部分，根据包的版本来调用包。

如果你去`uninstall`包，你现在有一个选择，如下:

```sh
$ gem uninstall chef

Select gem to uninstall:
 1\. chef-14.2.0
 2\. chef-14.5.33
 3\. All versions
> 
```

选择卸载`14.5.33`(选项`2`)。

我们现在安装了一个版本的`chef`，如下所示:

```sh
$ gem list -e chef

*** LOCAL GEMS ***

chef (14.2.0)
```

也像使用 Pip 一样，我们可以升级它，如下所示:

```sh
$ gem update chef --user-install $ gem list -e chef

*** LOCAL GEMS ***

chef (14.5.33, 14.2.0)
```

请注意，默认情况下，它还会保留旧版本。

# 它是如何工作的...

Pip 和 RubyGems 试图相对独立，但它们仍然是包管理器，这意味着它们实际上所做的只是向上游存储库查询包，然后将其下载到您的系统上。

当您更新您的`PATH`来更新新的可执行文件所在的二进制位置时，您可以运行您刚刚安装的包。

# 还有更多...

Pip 和 RubyGems 是巨大的话题，每一个都有很大的空灵博客帖子潜力，所以有意义的是，它们还有很多我们没有涉及到的内容。下面几节将介绍几个需要提及的更明显的事情。

# 何时使用编程语言包管理器

事情是这样的。

Ansible 和 Chef 可以在 Ubuntu 存储库中找到，它们是为世界各地的 Ubuntu 系统精心定制和打包的。

那么，为什么我要用 Pip 来代替安装呢？

很简单；在撰写本文时，Ubuntu 存储库中的 Ansible 版本是 2.5.1，PyPI 存储库中的版本是 2.7.0，这是一个相当显著的提升。

如果你想要一个程序的最新和最棒的特性，或者比你的发行版更新的库，你很可能会发现自己很想安装在 Apt 之外，这不一定是个问题。问题是记住所有这些包是如何安装的，并确保您知道如何保持每个包都是最新的。

# -用户/系统(pip)和-用户安装(gem)

与 Flatpak 一样，我们可以选择在用户级别或系统级别安装软件包。对于所使用的例子，我选择在本地安装东西，这意味着默认情况下这些包通常只对我的用户可用。

```sh
$ pip3 install ansible==2.5.0 --user
```

# Python virtualenv

Python 有一个固有的问题——相互冲突的包版本——正因为如此，virtualenv 是一个问题。实际上，virtualenv 是一种隔离安装的方法，这样它们就不会冲突，并且您可以(潜在地)轻松安装同一个包的多个版本。

这方面的一个用例可能是 Molecule，一个为 Ansible 角色设计的测试框架。Molecule 的第 1 版和第 2 版互不兼容，但是在为第 1 版编写的基础架构中，您肯定可以有一些可翻译的角色(没有人会很快更新它，因为有更紧迫的问题...总是有更紧迫的问题。)不过我们有 virtualenv，所以我们可以同时安装 Molecule 1 和 Molecule 2，而不用担心它们相互冲突。

# 请参见

与任何其他包管理器一样，Pip 和 RubyGems 管理包。

你们中的一些人会发现这个问题，这是一个人们很少意识到的问题。如果您在一个系统上有多个包管理器，每个管理器都维护自己的包并调整您的`PATH`，您可能会发现从系统的包管理器安装的包和从第三方包管理器安装的包相互冲突。

在某些情况下，你会遇到名字冲突。

我曾经看到一个木偶二进制文件`factor`与另一个同名二进制文件冲突的例子，在机器上引起了奇怪而奇妙的问题——这很有趣。

# 依赖地狱(一个简短的词)

我们现在将沿着记忆的车道旅行；具体来说，作者将蜷缩成一团，呆上几个小时，同时回忆起几个小时以来他对着服务员大喊大叫，因为他们太笨了。

依赖地狱是这样一个概念，一个包可以依赖于与你已经安装的依赖包或库的其他版本冲突的东西，或者可以尝试使用不兼容的版本，不管出于什么原因。

在 Python 和 Pip 的例子中，我们已经讨论了 virtualenv 的概念，但是从历史上看，这在其他包管理器中也是一个问题。基于 RPM 的发行版因这些问题而臭名昭著，开发了术语 **RPM Hell** 来专门指代它们的问题。

在安装软件时，您也可能遇到依赖项有几个选项的情况；像 Apt 这样的程序试图通过向用户呈现几个选项，并要求他们选择他们想要使用的选项来缓解这种情况。

# 准备好了

在本节中，我们将只在虚拟机上运行几个命令，以便查看输出。

跳到您的 Debian 9 盒子中，确保 Pip 已经安装并且是最新的:

```sh
$ vagrant ssh debian9
$ sudo apt install gcc python3-dev python3-setuptools -y
$ sudo easy_install3 pip
$ pip --version
pip 18.1 from /usr/local/lib/python3.5/dist-packages/pip-18.1-py3.5.egg/pip (python 3.5)
```

现在，跳到我们的 Ubuntu 盒子里，使用`apt`安装`pip`:

```sh
$ sudo apt update
$ sudo apt install python3-pip -y
```

检查`version`，如下:

```sh
$ pip3 --version
pip 9.0.1 from /usr/lib/python3/dist-packages (python 3.6)
```

然后，`upgrade`它(只在 Ubuntu 盒子上)，如下所示:

```sh
$ pip3 install pip --upgrade
```

注销(重要步骤)并再次检查`version`:

```sh
$ pip3 --version
pip 18.1 from /home/vagrant/.local/lib/python3.6/site-packages/pip (python 3.6)
```

# 怎么做...

要可视化依赖关系问题可能是什么样子，请看下面的内容。

# Pip 的系统安装版本和第三方安装版本

在我们的 Ubuntu 盒子里，我们通过使用系统包管理器(`apt`)来安装`pip`，然后只使用 Pip 来升级自己。

这意味着`apt`认为包裹是这样的:

```sh
$ apt list python3-pip -a
Listing... Done
python3-pip/bionic-updates,now 9.0.1-2.3~ubuntu1 all [installed]
```

我们当地的会议认为`pip`是这样的:

```sh
$ pip3 --version
pip 18.1 from /home/vagrant/.local/lib/python3.6/site-packages/pip (python 3.6)
```

这是一个问题，因为未来的软件包可能会依赖 Pip 9，并期望它能正确安装在盒子上，尽管版本不同。

In this case, what we've actually done is use the system-installed version of Pip to install and upgraded the version locally; hence, the reason that the version string comes from our `.local` directory, but it's still not an ideal scenario.

# 冲突 Pip 包中的依赖问题

为了更好地理解为什么 virtualenv 是一个东西，我们可以看看 Molecule 的安装。

在您的 Debian 实例中，安装 Molecule 测试框架(具体来说，`2.15.0`):

```sh
$ pip install molecule==2.15.0 --user
```

一切正常，安装应该会顺利，您将能够检查您的 Molecule 版本:

```sh
$ .local/bin/molecule --version
molecule, version 2.15.0
```

但是，我们现在要用`install ansible-lint`(最新版本，写这本书的时候):

```sh
$ pip install ansible-lint==3.4.23 --user
```

我们的安装工作正常，但是在安装过程中，我们收到了一个严重的警告:

```sh
molecule 2.15.0 has requirement ansible-lint==3.4.21, but you'll have ansible-lint 3.4.23 which is incompatible.
```

如果我们检查安装的`version`，`ansible-lint`看起来不错:

```sh
$ .local/bin/ansible-lint --version
ansible-lint 3.4.23
```

但是，如果我们再次运行我们的 Molecule 安装，我们会得到通知，它已经为我们有益地降级了`ansible-lint`:

```sh
Installing collected packages: ansible-lint
 Found existing installation: ansible-lint 3.4.23
 Uninstalling ansible-lint-3.4.23:
 Successfully uninstalled ansible-lint-3.4.23
 Running setup.py install for ansible-lint ... done
Successfully installed ansible-lint-3.4.21
```

这显然是一个简单的例子，因为只涉及两个包；想象一下，如果有五个、十个、甚至二十个由皮普管理的包裹，这将会是多么的忙碌和紧张。

# Apt 的冲突解决方案

以下是 Apt 检测依赖关系问题并拒绝继续安装的示例:

```sh
$ sudo apt install postfix exim4-base
Reading package lists... Done
Building dependency tree 
Reading state information... Done
Some packages could not be installed. This may mean that you have
requested an impossible situation or if you are using the unstable
distribution that some required packages have not yet been created
or been moved out of Incoming.
The following information may help to resolve the situation:

The following packages have unmet dependencies:
 exim4-base : Depends: exim4-config (>= 4.82) but it is not going to be installed or
 exim4-config-2
E: Unable to correct problems, you have held broken packages.
```

请注意，如果您随后自行安装`postfix`并尝试安装`exim`，您将得到以下结果:

```sh
$ sudo apt install exim4-base
Reading package lists... Done
Building dependency tree       
Reading state information... Done
The following packages were automatically installed and are no longer required:
  postfix-sqlite ssl-cert
Use 'sudo apt autoremove' to remove them.
The following additional packages will be installed:
  exim4-config exim4-daemon-light guile-2.0-libs libgsasl7 libkyotocabinet16v5 libltdl7 liblzo2-2
  libmailutils5 libmariadbclient18 libntlm0 libpython2.7 libpython2.7-minimal libpython2.7-stdlib
  mailutils mailutils-common mysql-common psmisc python2.7 python2.7-minimal
Suggested packages:
  eximon4 exim4-doc-html | exim4-doc-info spf-tools-perl swaks mailutils-mh mailutils-doc
  python2.7-doc binfmt-support
The following packages will be REMOVED:
 postfix
The following NEW packages will be installed:
  exim4-base exim4-config exim4-daemon-light guile-2.0-libs libgsasl7 libkyotocabinet16v5 libltdl7
  liblzo2-2 libmailutils5 libmariadbclient18 libntlm0 libpython2.7 mailutils mailutils-common
  mysql-common psmisc
The following packages will be upgraded:
  libpython2.7-minimal libpython2.7-stdlib python2.7 python2.7-minimal
4 upgraded, 16 newly installed, 1 to remove and 7 not upgraded.
Need to get 13.2 MB of archives.
After this operation, 27.5 MB of additional disk space will be used.
Do you want to continue? [Y/n]  
```

告诉你如果你继续的话`postfix`将被从你的系统中移除的那一行是粗体的。

# 潜在的解决方案

尽管有这些恼人的(有时是乏味的)问题，但还是有一些解决这些问题的方法。

我们已经提到了 virtualenv，现在，我们将再次提到它，只是为了强调这一点。走出去，寻求关于它的知识，因为它可以拯救你一个严重的头痛在未来。

Docker 是另一个潜在的解决方案，尽管将应用程序禁锢在它们自己的小环境中的想法并不新鲜(参见 Solaris Zones 和 FreeBSD jails)，但 Docker 提供了一个快速简单的界面来利用 Linux 内核特性来隔离应用程序和依赖关系。

多个虚拟机也可能是您前进的方向。过去的情况是，我们需要购买一台、两台或者三台服务器，并且在每台服务器上使用多个包；如今，情况并非如此，虽然您可能仍然有一些物理盒，但您更有可能在每个物理盒上使用虚拟机，这为完全隔离整个操作系统提供了一个很好的方法。

# 它是如何工作的...

包管理之所以有效，是因为勤奋的人让它发挥作用。依赖性问题仍然是一个问题，尽管现在它们对用户来说基本上是透明的。随着您支持的包越来越多，这就变成了一个问题，这意味着拥有成千上万个包的 Debian 有一项艰巨的工作，即确保每个包都将始终工作，或者在冲突导致问题之前检测到冲突。

让我们向每一个发行版中辛勤工作的包维护人员大声疾呼，感谢他们为确保我们的系统不会试图安装彼此不兼容的包和库所做的不懈努力。

如果你必须自己做一个包裹，祝你好运！

# 从源代码编译

*“哦，是 Linux 当你重新编译完你的内核后给我打电话！”*这是每一个不知情的技术人员的声明。

软件包不是在系统上安装软件的唯一方法；如果你有源代码(你想安装的软件的配方)，你可以自己编译程序，用你自己的方式！

如今，除了内部软件之外，这种工作不太频繁，因为编译软件可能是一项耗时且耗费资源的任务。世界上像 Gentoo 这样的用户可能会喜欢它，也有人认为它可以加快安装速度并减少安装，但这些在现代硬件上通常是微不足道的好处。

# 准备好了

在这里，我们将抓取`htop`的源代码，这是一个流行的交互式过程监视器。

This isn't a sales pitch, but I do happen to like `htop`, and I make a point of installing it on my personal systems, as well as systems I manage, when I get the chance.

你将需要访问源代码的 GitHub 页面，在[https://github.com/hishamhm/htop](https://github.com/hishamhm/htop)。

您还将使用您的 CentOS 虚拟机。

登录您的 CentOS 虚拟机并安装`unzip`和`wget`，如下所示:

```sh
$ vagrant ssh centos7
$ sudo yum install unzip wget -y
```

按照惯例，导航到`/usr/local/src`，我们将在这里放置本地安装软件的源代码:

```sh
$ cd /usr/local/src
```

下载最新版本的`htop`资源库(这里，我用的是`https`):

```sh
$ sudo wget https://github.com/hishamhm/htop/archive/master.zip
```

# 怎么做...

现在您的目录中应该有一个`master.zip`文件:

```sh
$ ls -lha
total 248K
drwxr-xr-x.  2 root root   24 Oct  7 03:34 .
drwxr-xr-x. 12 root root  131 May 12 18:50 ..
-rw-r--r--.  1 root root 248K Oct  7 03:34 master.zip
```

我们需要`unzip`这个，为了方便，换个归属，往里面跳:

```sh
$ sudo unzip master.zip
$ sudo chown -R vagrant:vagrant htop-master/
$ cd htop-master
```

在这个目录中，你会发现一大堆文件，大部分是各种各样的，但也有一些其他的。您几乎总能在源目录中找到的一个文件是`README`，这是一个很好的起点:

```sh
$ less README
```

READMEs 总是不同的，但我还没有找到一个严肃的项目，它们并不好。请参见以下示例:

![](assets/4a8ac1c9-cdf3-427e-8972-e25735b0540f.png)

简单地说，这个文件将告诉您需要安装的任何依赖项，以及安装软件包本身的适当方法。

当我们下载源代码时，我们需要前面截图中的`autogen.sh`行。如果我们尝试运行该脚本，我们将得到一个错误:

```sh
$ ./autogen.sh 
./autogen.sh: line 3: autoreconf: command not found
```

这是因为`autoconf`包没有安装；继续这样做，然后再次尝试脚本:

```sh
$ sudo yum install autoconf -y
$ ./autogen.sh
Can't exec "aclocal": No such file or directory at /usr/share/autoconf/Autom4te/FileUtils.pm line 326.
autoreconf: failed to run aclocal: No such file or directory
```

另一个`yum`告诉我们`automake`包没有安装，那我们就安装吧！

```sh
$ sudo yum install automake -y
$ ./autogen.sh 
configure.ac:23: installing './compile'
configure.ac:16: installing './config.guess'
configure.ac:16: installing './config.sub'
configure.ac:18: installing './install-sh'
configure.ac:18: installing './missing'
Makefile.am: installing './INSTALL'
Makefile.am: installing './depcomp
```

很好！这一次，成功了。

`README`建议检出`INSTALL`文件；那么，让我们来看下一个:

![](assets/8044d85a-5a3a-4292-8e74-7f3e46a84a0e.png)

用相当多的话来说，这给了我们大多数以这种方式打包的包的安装过程。

回到`README`文件，我们将尝试安装步骤的下一步，如下所示:

```sh
$ ./configure 
checking build system type... x86_64-unknown-linux-gnu
checking host system type... x86_64-unknown-linux-gnu
checking target system type... x86_64-unknown-linux-gnu
checking for a BSD-compatible install... /usr/bin/install -c
checking whether build environment is sane... yes
checking for a thread-safe mkdir -p... /usr/bin/mkdir -p
checking for gawk... gawk
checking whether make sets $(MAKE)... yes
checking whether make supports nested variables... yes
checking for gcc... no
checking for cc... no
checking for cl.exe... no
configure: error: in `/usr/local/src/htop-master':
configure: error: no acceptable C compiler found in $PATH
See `config.log' for more details
```

我们还少了一些东西；在这种情况下，错误告诉我们没有找到 C 编译器。

大多数系统默认的 C 编译器是 GCC，但也有其他的可能工作也可能不工作(比如`musl`):

```sh
$ sudo yum install gcc -y
$ ./configure
<SNIP>
checking for strdup... yes
checking whether gcc -std=c99 option works... yes
checking if compiler supports -Wextra... yes
checking for addnwstr in -lncursesw6... no
checking for addnwstr in -lncursesw... no
checking for addnwstr in -lncurses... no
configure: error: You may want to use --disable-unicode or install libncursesw.
```

我们现在可以更进一步，但是当脚本检查需求时，我们可以看到我们找不到`libncursesw`安装。

它给了我们两个选择:禁用 unicode，或者安装`libncursesw`。为了完整起见，让我们安装`ncurses-devel`包:

```sh
$ sudo yum install ncurses-devel -y
$ ./configure
<SNIP>
checking that generated files are newer than configure... done
configure: creating ./config.status
config.status: creating Makefile
config.status: creating htop.1
config.status: creating config.h
config.status: executing depfiles commands
```

现在，我们到达配置脚本的末尾，不再有错误。万岁！

最后，我们`make`包，这是将源代码编译成可用程序的实际步骤:

```sh
$ make
```

可能会有噪音，如下图截图所示:

![](assets/435c0c82-a066-4420-8155-5fc1f79637df.png)

在我们的目录中，我们现在有一个`htop`二进制，如下所示:

```sh
$ ls -lah htop
-rwxrwxr-x. 1 vagrant vagrant 756K Oct  7 03:51 htop
```

试一试:

```sh
$ ./htop --version
htop 2.2.0 - (C) 2004-2018 Hisham Muhammad
Released under the GNU GPL.
```

最后，我们需要将程序安装到适当的位置；这是通过`make install`命令完成的。这确实需要`sudo`，因为我们要把东西从本地文件夹移到文件系统的其余部分:

```sh
$ sudo make install
make  install-am
make[1]: Entering directory `/usr/local/src/htop-master'
make[2]: Entering directory `/usr/local/src/htop-master'
 /usr/bin/mkdir -p '/usr/local/bin'
 /usr/bin/install -c htop '/usr/local/bin'
 /usr/bin/mkdir -p '/usr/local/share/applications'
 /usr/bin/install -c -m 644 htop.desktop '/usr/local/share/applications'
 /usr/bin/mkdir -p '/usr/local/share/man/man1'
 /usr/bin/install -c -m 644 htop.1 '/usr/local/share/man/man1'
 /usr/bin/mkdir -p '/usr/local/share/pixmaps'
 /usr/bin/install -c -m 644 htop.png '/usr/local/share/pixmaps'
make[2]: Leaving directory `/usr/local/src/htop-master'
make[1]: Leaving directory `/usr/local/src/htop-master'
```

现在，我们可以运行一个`whereis`并找出它的安装位置(虽然我们也可以在前面的代码片段中看到):

```sh
$ whereis htop
htop: /usr/local/bin/htop
```

# 它是如何工作的...

对于大多数 Linux 程序(当然是 C 语言版本)，这种模式是相当标准的。复制源代码，用它的缺省值配置它(或者做任何你想做的改变)，编译软件，并在文件系统上安装它。

`INSTALL`文件很好地概述了不同的步骤，但简而言之，它们看起来如下:

*   `configure`:根据您的环境，创建包含系统特定选项的`Makefile`。这些可以相当长；`htop`文件共 1422 行。
*   `make`:这个被调用来正确编译任何需要它的源代码，创建二进制文件并补充可能需要的文件。
*   `make install`:这将文件放入它们适当的位置。

很简单，对吧？

# 还有更多...

内核之类的东西也可以编译，但是考虑到必须考虑的部件和子系统的数量，编译时间会更长。长编译时间是目前人们和项目默认使用预编译二进制 blobs 的主要原因(因为很少有人愿意等待他们的代码编译，除非他们故意避免工作。)

即使是以允许可定制性(以牺牲安装时间为代价)而闻名的 Gentoo，也有预编译的二进制文件，如果你不想花一周时间等待代码编译，你可以为更大的程序安装。

还有交叉编译，这是为不同的架构编译软件的行为。例如，我可能想在我的`x86_64`虚拟机上为`aarch64`硬件编译`htop`，因为它有 32 个内核，而我的`aarch64`板是树莓 Pi 3。

# 请参见...

根据所使用的语言，还有其他编译软件的方法。例如，Go 将为您提供您想要编译的包源代码`go get`，但是它使用`make`命令来执行实际的构建，而 Rust 编程语言使用名为`cargo`的工具。

# 技术要求

在本节中，我们将使用所有三个虚拟机，并为每个虚拟机添加额外的存储库。这是为了展示不同的包管理系统如何做不同的事情。

# 添加其他存储库

创建系统时会安装默认存储库；也有更多更狂野的存储库可能包含你真正需要的一个软件(或者懒得自己编译)。

一些常见的存储库如下:

*   埃佩尔
*   rpm 合并
*   Remi
*   ZFS，在 Linux 上

在这里，我们将看看添加额外的存储库，以及这样做的后果。

# 准备好

您可以按任何顺序浏览这一部分，但从开始处开始，到结束处结束可能是明智的。

# 怎么做...

登录到您的虚拟机。我们将从 CentOS 开始。首先，让我们看看我们必须使用的默认存储库，使用`yum repolist`命令:

```sh
$ yum repolist
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.melbourne.co.uk
 * extras: repo.uk.bigstepcloud.com
 * updates: centos.mirroring.pulsant.co.uk
repo id                                       repo name                                        status
base/7/x86_64                                 CentOS-7 - Base                                  9,911
extras/7/x86_64                               CentOS-7 - Extras                                  432
updates/7/x86_64                              CentOS-7 - Updates                               1,540
repolist: 11,883
```

我们看到三个默认启用的存储库:`Base`、`Extras`和`Updates`。

# CentOS -添加带有 epel 版本的 EPEL 存储库

**企业 Linux 的额外软件包** ( **EPEL** )是 CentOS/红帽领域中比较流行的附加存储库之一。

正因为如此，它实际上有一个非常简单的安装方法，从给定的存储库:

```sh
$ sudo yum install epel-release -y
```

在我们的`repo`目录中，您将看到两个新文件:

```sh
$ ls -lha /etc/yum.repos.d/epel*
-rw-r--r--. 1 root root  951 Oct  2  2017 /etc/yum.repos.d/epel.repo
-rw-r--r--. 1 root root 1.1K Oct  2  2017 /etc/yum.repos.d/epel-testing.repo
```

`yum repolist`也会显示出来:

```sh
$ yum repolist
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
epel/x86_64/metalink                                                          |  31 kB  00:00:00 
 * base: mirrors.melbourne.co.uk
 * epel: anorien.csc.warwick.ac.uk
 * extras: mirrors.melbourne.co.uk
 * updates: anorien.csc.warwick.ac.uk
epel                                                                          | 3.2 kB  00:00:00 
(1/3): epel/x86_64/group_gz                                                   |  88 kB  00:00:00 
(2/3): epel/x86_64/updateinfo                                                 | 948 kB  00:00:00 
(3/3): epel/x86_64/primary                                                    | 3.6 MB  00:00:01 
epel                                                                                     12721/12721
repo id                         repo name                                                      status
base/7/x86_64                   CentOS-7 - Base                                                 9,911
epel/x86_64                     Extra Packages for Enterprise Linux 7 - x86_64                 12,721
extras/7/x86_64                 CentOS-7 - Extras                                                 432
updates/7/x86_64                CentOS-7 - Updates                                              1,540
repolist: 24,604
```

注意`epel-testing`没有列出；这是因为默认情况下它是禁用的。

我们可以使用这个存储库来搜索可能不在默认值中的包(例如`htop`):

```sh
$ yum whatprovides htop
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.melbourne.co.uk
 * epel: mirror.bytemark.co.uk
 * extras: mirrors.melbourne.co.uk
 * updates: centos.mirroring.pulsant.co.uk
htop-2.2.0-1.el7.x86_64 : Interactive process viewer
Repo        : epel
```

# CentOS -通过文件添加电子报告存储库

正如上一节所建议的，包安装所做的只是为其他存储库添加适当的 GPG 密钥和 YUM 配置文件；没有什么能阻止你手动做同样的事情。

ELRepo 是一个流行的 Repo，主要是因为它提供了更多最新版本的 Linux 内核，适用于那些喜欢 CentOS 的布局和风格，但又真正想要内核能够提供的最新驱动程序和功能的人。

首先，我们需要导入存储库的公钥，如下所示:

```sh
$ sudo rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
```

It's a good idea to make sure that the key you're installing is legitimate; there are various ways of doing this, including checking that TLS certificates are legitimate, comparing it with other systems, or ringing up the owner of the key and pestering them until they read the whole thing out to you.

此时，我们可以从`elrepo`网站下载并`yum install``rpm`文件，或者我们自己下载并提取内容，这样我们就可以看一看它是做什么的:

```sh
$ wget https://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm
$ rpm2cpio elrepo-release-7.0-3.el7.elrepo.noarch.rpm | cpio -id
```

The `rpm2cpio` command does what it suggests, and allows us to use `cpio` to extract the archive.

如果我们现在`cat`我们刚刚取消归档的目录，我们可以看到它将要放入我们系统的文件:

```sh
$ cat etc/yum.repos.d/elrepo.repo 
### Name: ELRepo.org Community Enterprise Linux Repository for el7
### URL: http://elrepo.org/

[elrepo]
name=ELRepo.org Community Enterprise Linux Repository - el7
baseurl=http://elrepo.org/linux/elrepo/el7/$basearch/
 http://mirrors.coreix.net/elrepo/elrepo/el7/$basearch/
 http://mirror.rackspace.com/elrepo/elrepo/el7/$basearch/
 http://repos.lax-noc.com/elrepo/elrepo/el7/$basearch/
 http://mirror.ventraip.net.au/elrepo/elrepo/el7/$basearch/
mirrorlist=http://mirrors.elrepo.org/mirrors-elrepo.el7
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-elrepo.org
protect=0
...
```

还有更多，因为在这个文件中有多个回购指定。让我们复制`elrepo`块并将其输出到我们自己制作的文件中，如下所示:

```sh
$ cat <<HERE | sudo tee /etc/yum.repos.d/elrepocustom.repo
[elrepo]
name=ELRepo.org Community Enterprise Linux Repository - el7
baseurl=http://elrepo.org/linux/elrepo/el7/$basearch/
 http://mirrors.coreix.net/elrepo/elrepo/el7/$basearch/
 http://mirror.rackspace.com/elrepo/elrepo/el7/$basearch/
 http://repos.lax-noc.com/elrepo/elrepo/el7/$basearch/
 http://mirror.ventraip.net.au/elrepo/elrepo/el7/$basearch/
mirrorlist=http://mirrors.elrepo.org/mirrors-elrepo.el7
enabled=1
gpgcheck=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-elrepo.org
protect=0
HERE
```

请注意，回购设置了`enabled=1`，这意味着我们现在可以运行一个`yum update`来确保我们的系统同步并知道上游存储库(尽管如果我们想永久禁用该回购，我们可以将其更改为`0`，而`yum`会忽略它):

```sh
$ sudo yum update
```

现在，如果我们愿意，我们还可以列出我们刚刚添加的回购中的所有包:

```sh
$ yum list available --disablerepo=* --enablerepo=elrepo 
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * elrepo: www.jules.fm
Available Packages
CAENVMELib.x86_64                              2.50-2.el7.elrepo                               elrepo
VirtualGL.x86_64                               2.3.3-4.el7.elrepo                              elrepo
VirtualGL-devel.x86_64                         2.3.3-4.el7.elrepo                              elrepo
VirtualGL-libs.i686                            2.3.3-4.el7.elrepo                              elrepo
bumblebee.x86_64                               3.2.1-10.el7.elrepo                             elrepo
bumblebee-selinux.x86_64                       1.0-1.el7.elrepo                                elrepo
drbd84-utils.x86_64                            9.3.1-1.el7.elrepo                              elrepo
...
```

# Debian -添加额外的存储库

Debian 以向最终用户提供大量软件包而闻名。如果你能想到一个软件包，很有可能它可以开箱即用地安装，或者某个地方的某个人正在研究如何为你维护这个软件包。

FreeBSD is probably the only OS that springs to mind that might have more packages available in its base installation.

因为这个著名的事实，很有可能你永远不需要安装额外的存储库，但是永远不要说永远不(尽管我只是这么做)。

寻找一些非官方存储库的好地方是在 https://wiki.debian.org/DebianRepository/Unofficial 维护的非官方页面。

在这里，我们可以找到各种存储库，包括一个谷歌 Chrome 的存储库，我们将添加它。

首先，我们将查看图像附带的默认`sources.list`文件:

```sh
$ cat /etc/apt/sources.list
# 

# deb cdrom:[Debian GNU/Linux 9.4.0 _Stretch_ - Official amd64 NETINST 20180310-11:21]/ stretch main

#deb cdrom:[Debian GNU/Linux 9.4.0 _Stretch_ - Official amd64 NETINST 20180310-11:21]/ stretch main

deb http://deb.debian.org/debian stretch main
deb-src http://deb.debian.org/debian stretch main

deb http://security.debian.org/debian-security stretch/updates main
deb-src http://security.debian.org/debian-security stretch/updates main
```

它看起来相当稀疏，只启用了`stretch main`和`stretch/updates main`存储库。

与百胜一样，我们需要确保我们有一个合法的 GPG 密钥；谷歌是这样安装的:

```sh
$ wget https://dl.google.com/linux/linux_signing_key.pub
$ sudo apt-key add linux_signing_key.pub 
OK
```

现在，我们需要添加存储库——在本例中，是谷歌 Chrome:

```sh
$ cat <<HERE | sudo tee -a /etc/apt/sources.list
deb http://dl.google.com/linux/chrome/deb/ stable main
HERE
```

运行`sudo apt update`以确保您的可用包列表是最新的:

```sh
$ sudo apt update
Ign:1 http://deb.debian.org/debian stretch InRelease
Hit:2 http://deb.debian.org/debian stretch Release
Hit:4 http://security.debian.org/debian-security stretch/updates InRelease                          
Ign:5 http://dl.google.com/linux/chrome/deb stable InRelease
Get:6 http://dl.google.com/linux/chrome/deb stable Release [1,189 B]
Get:7 http://dl.google.com/linux/chrome/deb stable Release.gpg [819 B]
Get:8 http://dl.google.com/linux/chrome/deb stable/main amd64 Packages [1,381 B]
Fetched 3,389 B in 1s (2,285 B/s) 
Reading package lists... Done
Building dependency tree       
Reading state information... Done
11 packages can be upgraded. Run 'apt list --upgradable' to see them.
```

然后，搜索 Chrome:

```sh
$ sudo apt search google-chrome
Sorting... Done
Full Text Search... Done
google-chrome-beta/stable 70.0.3538.45-1 amd64
 The web browser from Google

google-chrome-stable/stable 69.0.3497.100-1 amd64
 The web browser from Google

google-chrome-unstable/stable 71.0.3569.0-1 amd64
 The web browser from Google
```

给你！

This is not a Chrome advertisement, either, and actually, the open source version of Chrome (Chromium) is already available in the default repositories. I would probably advise installing that, instead. Mostly, you'll probably be adding the `contrib` repository, which contains non-free software:

```sh
deb http://ftp.debian.org/debian stable main contrib non-free
```

# 添加 PPAs

有趣的是，这是 Ubuntu 和 Debian 世界不同的一个重要地方。在 Ubuntu-land 中，有**个人包档案** ( **PPAs** )的概念，可以用来安装第三方软件。

你也可以安装常规的存储库，但是 PPAs 可以说更有针对性。请记住，几乎没有什么能阻止任何人创建 PPA，所以在添加任何东西之前，请确保遵循尽职调查。

PPAs 可以在典范网站上找到，在[https://launchpad.net/ubuntu/+ppas](https://launchpad.net/ubuntu/+ppas)。

我们将添加新 PPA 图书馆作为示例:

```sh
$ sudo add-apt-repository ppa:libreoffice/ppa
```

只需按下*进入*，系统可能会提示您接受额外的存储库。

您刚刚添加的存储库配置在`apt sources.list.d`目录中:

```sh
$ cat /etc/apt/sources.list.d/libreoffice-ubuntu-ppa-bionic.list 
deb http://ppa.launchpad.net/libreoffice/ppa/ubuntu bionic main
# deb-src http://ppa.launchpad.net/libreoffice/ppa/ubuntu bionic main
```

这意味着您现在可以安装 LibreOffice 的出血边缘版本！你最终会成为文字处理界的酷孩子。

# 它是如何工作的...

存储库通常只是存放您可能想要安装的包的地方。它们没有什么特别之处，因为它们通常是网络服务器，可以做出任何反应，在您请求时为您提供内容(包)。

添加额外的存储库是一个相当常见的 sysadmin 活动，通常是因为您正在添加您的内部代理(目前通常是 Artifactory)，或者您的开发人员确实需要最新版本的 NodeJS。

无论添加存储库的原因是什么，只要记住基本的安全性会有很大的帮助(毕竟，你相信上游不会有任何恶意)，并且意识到如果存储库消失了，你可以为自己制造问题(这已经发生了，并将继续发生)。

# 综述-安全、更新和包管理

忘记更新很容易。让一个系统达到稳定的状态是令人欣慰的，在这种状态下，无论它受到多大的打击，它都会继续突突前进，做你让它做的事情，仅此而已。令人不舒服的是打破这种完美和平的想法，这就是更新的来源。

软件不会静止不动；有正在开发的功能，正在修补的安全漏洞，以及正在实施的更严格的加密方法，所有这些都需要由您，sysadmin 来解决。

包维护者可以做很多事情，他们确实做了，但是这取决于您确保您正在更新的内容经过测试，它不会破坏您环境中的任何其他东西，并且那些使用漏洞让他们的代码在您的平台上工作的开发人员已经被彻底斥责。

归根结底，事情很可能会出错，但这就是为什么开发和测试环境应该存在的原因。

是的，在过去执行更新是很伤脑筋的，这就是为什么我们在周末进来，在半夜更新，如果它坏了一点，没有人会注意到。这些破裂仍然会发生，但是现在，我们已经从中吸取了教训；我们有警告和勘误表，如果您的网站不得不离线几个小时以确保他们的信用卡信息不会因恶意利用而泄露，普通公众会理解的。

说到底，软件是愚蠢的，它是由容易出错的人类组装起来的。让你的系统保持最新，确保你检查了你的来源(换句话说，不要从互联网上未被访问的角落安装随机的可执行文件)，并确保你让你的上级知道是的，你可能不得不让网站离线一会儿，或者关闭他们的电话系统，但这比第二天出现在英国广播公司网站的头版要好。

当然，如果你真的对复杂的发行版是如何构建的，软件包是如何组合在一起的，以及它们为什么以这样的方式构建或安装感兴趣，那么有一些工具可以帮助你学习。

*Linux 从零开始*就是这样一个工具，实际上是一本关于构建自己版本的 Linux 的来龙去脉的书。它不适合初学者，有时可能会令人沮丧(或者随着软件的发展而略微过时)，但这是一个了解事情为什么会这样的好方法，我鼓励每个人在职业生涯中至少执行一次 Linux 从头安装。