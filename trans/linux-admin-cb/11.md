# 网络服务器、数据库和邮件服务器

在本章中，我们将研究以下主题:

*   安装和理解网络服务器
*   基本 Apache 配置
*   基本 Nginx 配置
*   SSL、TLS 和 LetsEncrypt
*   基本 MySQL 或 MariaDB 安装
*   基本 PostgreSQL 安装
*   本地 MTA 用法和配置(后缀)
*   本地 MTA 用法和配置(Exim)
*   NoSQL 文档(MongoDB 示例)
*   NoSQL KV (Redis 示例)
*   消息代理和队列(RabbitMQ 示例)

# 介绍

在你作为系统管理员或开发人员的职业生涯中，很有可能会遇到一些网站。

网站是存在于互联网上的东西，人们去那里找东西(技术描述)。大部分网页都运行在 Linux 上，Windows 等人的网页有分段和较暗的角落。

对于许多人来说，开始他们的 Linux 职业生涯通常是为互联网服务提供商或某种网络主机工作，这意味着许多新进入这个领域的人会陷入必须立即管理非常公共的网站的困境。这并不是一件坏事，因为你倾向于在有各种问题的环境中快速学习，当你被一大群日复一日都在经历同样挫折的人包围时，这可能是一次很好的学习经历。

That's not to say that everyone goes the route of a web host or ISP. I started working with Linux properly when I joined a small telecoms company, meaning my exposure to web technologies was minimal, and my exposure to **private branch exchange** (**PBX**) phone systems was considerably greater. 

不用说，如果你真的走上了为别人管理网站或维护网站的路线，你会有一个好的伙伴。你在不同层次上遇到的大多数工程师将会在战壕里度过他们的时间，操作电话，并且在早上的所有时间与全球的开发者打交道。

我不会说使用网站很有趣，但是在排除故障的同时不断刷新一个损坏的网页，最终让它像从未离开过一样重新出现在生活中，这是一种地狱般的宣泄体验，即使是凌晨三点。

网络有许多不同的组成部分，尽管静态 HTML 网站的全盛时期已经过去(尽管由于亚马逊的 S3 等地托管的自动生成网站，它最近看起来有点复兴)，但有许多有趣的技术让你着迷。

从最简单的开始，我们将查看实际的 web 服务器(提供 web 内容)、数据库(保存 web 内容)和 TLS(对传输中的 web 内容进行加密)。

我们还将研究一些你可能会在某个时候遇到的其他技术(同样，如果你为托管提供商工作，肯定会遇到)。这些是:

*   (e)邮件传输代理(如 Postfix 和 Exim)
*   NoSQL 数据库(如蒙古数据库)
*   快速**键值(KV)** 存储(如 Redis)
*   消息代理(如 RabbitMQ)

不要让这些吓到你——它们只是纸上谈兵。

# 技术要求

在本节中，我们将同时使用 CentOS 和 Debian。这是因为，虽然 Linux 世界中的软件相当通用，但有些发行版会为诸如网络和邮件服务器之类的东西选择特定的默认值。

本章请随意使用以下`Vagrantfile`:

```sh
# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure("2") do |config|

  config.vm.define "centos1" do |centos1|
    centos1.vm.box = "centos/7"
    centos1.vm.network "private_network", ip: "192.168.33.10"
    centos1.vm.hostname = "centos1"
    centos1.vm.box_version = "1804.02"
  end

  config.vm.define "debian1" do |debian1|
    debian1.vm.box = "debian/stretch64"
    debian1.vm.network "private_network", ip: "192.168.33.11" 
    debian1.vm.hostname = "debian1"
    debian1.vm.box_version = "9.5.0"
    debian1.vm.provider "virtualbox" do |debian1p|
      debian1p.cpus = 1
    end
  end

end
```

# 安装和理解网络服务器

web 服务器是当您访问网站时直接与之交互的组件。它传统上监听端口`80`(针对**超文本传输协议** ( **HTTP** ))或 **`443`** (针对**超文本传输协议安全** ( **HTTPS** ))。

当您在浏览器中键入网址时，除非明确定义，否则这些端口通常是隐藏的；例如，在 Chrome 或 Firefox 中点击[https://duckduckgo.com](https://duckduckgo.com)会加载网站，但它不会告诉你它正在连接端口`443`。以类似的方式，如果你去[https://duckduckgo.com:443](https://duckduckgo.com:443)，应该加载完全相同的页面。

此外，如果您尝试使用 HTTPS ( `https://duckduckgo.com:80/`)访问端口`80`，您通常会收到一条错误消息，称该站点无法提供安全连接:

![](assets/574d2dc8-72bf-40b2-9c43-1dae98bc0184.png)

这是因为您试图使用安全协议(HTTPS)与不安全的端口(`80`)对话。

网络服务器实际上是为网络服务的，但它们通常只是其他技术的前端。例如，Wordpress 安装上的博客文章可能存储在幕后的数据库中，而它们是由网络服务器前端呈现给最终用户的。

web 服务器的工作是确定如何向发出请求的客户端显示页面内容。

Different clients send different "user agents," which tell the web server what type of pages it'll be able to display to you. Think of it in terms of a desktop and phone internet browser: if sites are coded to understand the different user agents of your devices, the exact same website can look completely different on different devices. 

# 准备好

我们将使用两个虚拟机，并在每个虚拟机上设置一个网络服务器:

```sh
$ vagrant ssh centos1 -- -L 127.0.0.1:8080:127.0.0.1:80
$ vagrant ssh debian1 -- -L 127.0.0.1:8181:127.0.0.1:80
```

# 怎么做...

从我们的 CentOS 盒子开始，我们将安装官方存储库中提供的默认 web 服务器。

# 在 CentOS 上安装 httpd (Apache)

正如标题所示，CentOS 将 Apache HTTP 服务器重新标记为`httpd`，我怀疑这是为了便于理解而将产品通用化(尽管我遇到过相当多不喜欢这种重新标记的系统管理员，包括我)。

像这样安装`httpd`:

```sh
$ sudo yum install httpd -y
```

现在让我们开始吧，因为这是 CentOS:

```sh
$ sudo systemctl enable --now httpd
```

当我们登录到我们的游民箱时，我们转发了端口，现在我们应该能够在本地浏览器中导航到我们转发的地址和端口(`http://127.0.0.1:8080`):

![](assets/2b8e128b-6908-405e-8ef5-b3c64775ab9a.png)

这是 CentOS 上 Apache 的默认`splash`页面，开箱即用。

# 在 Debian 上安装 Nginx

现在，在我们的 Debian 盒子上，让我们改为安装 Nginx:

```sh
$ sudo apt install nginx -y
```

一旦安装，由于它是 Debian，服务可能会自动启动:

```sh
$ systemctl status nginx --no-pager
● nginx.service - A high performance web server and a reverse proxy server
 Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)
 Active: active (running) since Sun 2018-12-02 11:54:11 GMT; 21s ago
 Docs: man:nginx(8)
 Process: 1936 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS)
 Process: 1933 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=0/SUCCESS)
 Main PID: 1938 (nginx)
 Tasks: 2 (limit: 4915)
 CGroup: /system.slice/nginx.service
 ├─1938 nginx: master process /usr/sbin/nginx -g daemon on; master_process on;
 └─1939 nginx: worker process
```

由于我们已经将一个不同的端口(`http://127.0.0.1:8181`)转发给了我们的 Debian 机器，我们应该也能够在我们的浏览器中访问它:

![](assets/374712e8-1ae9-442a-b680-3d3eeb67da55.png)

好吧，那就少了很多开箱即用...

# 它是如何工作的...

我们在这里所做的是安装两个不同的网络服务器，尽管它们完成了同样的事情。

可以说，没有比网络更好的同时也是最差的标准遵从场所，这意味着，无论您选择使用哪种网络服务器(Apache、Nginx)，您都应该能够以一致的方式提供内容。

Standards compliance is the term we use to refer to the agreed standards for computer systems. A **Request for Comments** (**RFC**) might dictate anything from which IP ranges are to be used for private use, to how two systems wishing to securely communicate over HTTPS go about doing that. The **Internet Engineering Task Force** (**IETF**) is one of the bodies that manages RFCs. 

我们安装的第一台服务器是 Apache，多年来它一直是“go to”web 服务器，并且仍然被许多传统管理员认为是“久经沙场”的服务器。这显然是 CentOS 安装的默认设置，这意味着安装基数仍然很大。

在撰写本文时，Apache 仍然被视为更大的玩家，但 Nginx 近年来已经声名鹊起，并且看起来将接管(稍后将对此进行更多介绍)。

然后我们在我们的 Debian 盒子上安装了 Nginx(尽管 Apache 也是可用的)。Debian 声称有数千个可用的包，这一点在这里变得非常突出，因为它也有许多不同的网络服务器，你可能会喜欢尝试(我只选择了 Apache 和 Nginx 作为最大的两个)。

无论您安装哪一个，这两个系统现在都能够向互联网提供静态的 HTTP 内容(或者至少是您的一小部分网络，因为它不能公开访问)。

如果我们查看 Debian 盒子上的`ss`输出，我们会看到以下内容:

```sh
$ ss -tuna
Netid State Recv-Q Send-Q Local Address:Port Peer Address:Port 
udp UNCONN 0 0 *:68 *:* 
tcp LISTEN 0 128 *:80 *:* 
tcp LISTEN 0 128 *:22 *:* 
tcp ESTAB 0 0 10.0.2.15:22 10.0.2.2:40136 
tcp ESTAB 0 0 127.0.0.1:56490 127.0.0.1:80 
tcp ESTAB 0 0 127.0.0.1:80 127.0.0.1:56490 
tcp LISTEN 0 128 :::80 :::* 
tcp LISTEN 0 128 :::22 :::* 
```

我们可以看到端口`80`，监听所有可用的 IP，我们可以看到已建立的通信，它实际上来自我们转发的网络连接和火狐。这和 CentOS 盒子上的故事完全一样。

所有这些都很棒，这意味着当我们的客户端(在这个例子中是火狐)从网络服务器(Apache)请求内容时，该服务器能够以客户端能够理解的方式和风格交付所请求的内容。

然后，Firefox 可以以最终用户理解的方式向他们显示内容，比如猫的图片，或者他们可能在互联网上搜索的任何其他信息(尽管应该总是猫)。

# 还有更多...

我提到了其他的网络服务器，确实有很多。

在 OpenBSD 的土地上，你可能会发现自己正在安装`httpd`，它并不是一个重新标记的 Apache(就像 CentOS 上的情况一样)，而是一个完全不同的软件，只是碰巧共享同一个名字，并且执行类似的功能...

或者，您可能会喜欢 Tomcat 的想法，它不太像传统的 web 服务器，因为它充当 Java servlets(通常是某种 web 应用程序)的前端。

还有`lighttpd`，它(顾名思义)应该是一个轻量级的网络服务器，没有 Nginx 或 Apache 提供的许多功能。

在 Windows 世界(一个我不喜欢去的可怕的地方)，你会得到 IIS，它更像是一套在 Windows 服务器上可用的互联网服务。

# 基本 Apache 配置

我们已经在我们的 CentOS 机器上安装了`httpd`，这意味着我们有一个运行在端口`80`上的网络服务器，我们可以从主机上的火狐安装中找到它。

在本节中，我们将了解我们的服务器如何知道显示什么，以及我们可以做些什么来建立自己的网站，以便人们在访问我们的 IP 时不会受到默认 Apache 页面的欢迎。

# 准备好了

对于本节，我们将使用上一节中的`Vagrantfile`。如果您还没有在 CentOS 虚拟机上安装 Apache，请现在就安装。

连接到您的 CentOS 盒子:

```sh
$ vagrant ssh centos1 -- -L 127.0.0.1:8080:127.0.0.1:80
```

# 怎么做...

首先，我们应该快速了解一下默认配置是从哪里加载的。在默认页面上，我们可以看到以下部分:

![](assets/bdbc51d2-a871-4335-97e0-1d846a0ceba6.png)

事实证明，我们实际上是管理者。考虑到这一点，让我们看看我们能做些什么。

首先，我们可以`ls`这个消息中列出的目录，看看已经有什么:

```sh
$ ls /var/www/html/
$ 
```

什么都没有...奇怪。

让我们在这个目录中放一个基本的`index.html`页面，看看会发生什么:

```sh
$ cat <<HERE | sudo tee -a /var/www/html/index.html
WE APOLOGISE FOR THE INCONVENIENCE.
HERE
```

现在让我们再次访问我们的网站:

![](assets/57a6abff-98b9-4fb5-aa07-fe1265af11e9.png)

它变了！

好吧，很明显这个目录是用来做什么的，但是它没有解释显示什么的配置在哪里。

让我们来看看建议的`welcome`文件:

```sh
$ cat /etc/httpd/conf.d/welcome.conf 
# 
# This configuration file enables the default "Welcome" page if there
# is no default index page present for the root URL. To disable the
# Welcome page, comment out all the lines below. 
#
# NOTE: if this file is removed, it will be restored on upgrades.
#
<LocationMatch "^/+$">
 Options -Indexes
 ErrorDocument 403 /.noindex.html
</LocationMatch>

<Directory /usr/share/httpd/noindex>
 AllowOverride None
 Require all granted
</Directory>

Alias /.noindex.html /usr/share/httpd/noindex/index.html
Alias /noindex/css/bootstrap.min.css /usr/share/httpd/noindex/css/bootstrap.min.css
Alias /noindex/css/open-sans.css /usr/share/httpd/noindex/css/open-sans.css
Alias /images/apache_pb.gif /usr/share/httpd/noindex/images/apache_pb.gif
Alias /images/poweredby.png /usr/share/httpd/noindex/images/poweredby.png
```

重要的外卖如下:

"This configuration file enables the default "Welcome" page if there is no default index page present for the root URL."

好吧，所以我们现在不要担心这个，而是专注于我们自己的文件。

首先，因为您可以在一台 web 服务器(虚拟主机)上拥有大量不同的网站，所以让我们在文件夹结构中创建少量隔离，以保持不同网站文件的隔离:

```sh
$ sudo mkdir /var/www/god-to-marvin
$ sudo mv /var/www/html/index.html /var/www/god-to-marvin/
```

At this point, our web server will go back to showing the default Apache page, as we've moved our only `index.html` file. 

接下来，添加读取该目录所需的配置:

```sh
$ cat <<HERE | sudo tee -a /etc/httpd/conf.d/god-to-marvin.conf
<VirtualHost 127.0.0.1:80>
 ServerAdmin thebestsysadmin@example.com
 DocumentRoot "/var/www/god-to-marvin/"
 ServerName 127.0.0.1
 ServerAlias 127.0.0.1
</VirtualHost>
HERE
```

然后，我们需要重新加载配置:

```sh
$ sudo systemctl reload httpd
```

接下来，回到我们的火狐窗口，尝试访问`http://127.0.0.1:8080/`。您应该会再次看到您的消息:

![](assets/20b57421-2868-4e98-835e-f3309c46d30a.png)

有了这一点，虽然表面上没有什么变化，但这意味着你可以在未来添加更多的网站和更多来自心爱的科幻特许经营的引用。

# 它是如何工作的...

我们之所以能够将文件放入`/var/www/html/`并在浏览器中查看，是因为主 Apache 配置文件中的`DocumentRoot`设置，如下所示:

```sh
$ cat /etc/httpd/conf/httpd.conf | grep ^DocumentRoot
DocumentRoot "/var/www/html"
```

我们之所以使用`index.html`作为文件名，除了它是约定之外，是因为下面的一行:

```sh
$ cat /etc/httpd/conf/httpd.conf | grep "^ DirectoryIndex"
 DirectoryIndex index.html
```

这决定了在请求目录时加载哪个文件。

虽然`/etc/httpd/conf/httpd.conf`文件是默认的配置文件，但是我们也可以在`/etc/httpd/conf.d/`目录下为网站添加额外的配置，就像我们在本例中所做的那样。

我们为自己的配置使用了一个非常具体的小节，如下所示:

```sh
<VirtualHost 127.0.0.1:80>
 ServerAdmin thebestsysadmin@example.com
 DocumentRoot "/var/www/god-to-marvin/"
 ServerName 127.0.0.1
 ServerAlias 127.0.0.1
</VirtualHost>
```

这一节意味着，虽然我们可以继续在我们的网站上托管与以前相同的内容，但我们也可以托管具有不同`DocumentRoots`的其他内容。

当我们第二次访问我们的站点时，我们没有被指向`/var/www/html`作为`DocumentRoot`，而是被指向`/var/www/god-to-marvin`，因为前面的配置是这样规定的。

我们还有一个`ServerName`和一个`ServerAlias`指令，尽管在这种情况下别名什么也不做。

`ServerName`是最终用户在浏览器中键入的域或 IP 地址。别名可以是与该名称相关联的其他别名。

例如，您可以拥有以下内容:

```sh
 ServerName example.com
 ServerAlias www.example.com fish.example.com europe.example.com
```

所有这些都会击中同一个`DocumentRoot`。

# 还有更多...

只有当多个域名指向一台服务器时，虚拟主机才会真正发挥作用。实际上，您可以有数百个不同的域名指向一个框，但是因为 Apache 知道您用来连接的域，所以它只会服务于您请求的确切站点。

在多租户情况下，多个客户端共存于一台服务器上，只操作和更新自己的文件，而忽略了与其他公司和用户共享一个盒子的事实，这种情况并不少见。

如果一家托管公司每月花费几英镑来建立一个网络服务器，并且他们可以向他们的客户收取托管网站的费用，该公司可以很快收回他们的钱。

# 请参见

在测试环境中，你倾向于一次在一个盒子上看到多个网站，因为它们通常是轻量级的，几个可以并行运行。这给域名解析测试带来了一个问题，因为将公共域名服务用于测试和临时网站既昂贵又耗时。

这个问题的一个解决方案是使用`/etc/hosts`文件(在 Linux 和 Unix 系统上)来代替。

默认的`/etc/hosts`文件可能如下所示:

```sh
$ cat /etc/hosts
127.0.0.1 centos1 centos1
127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4
::1 localhost localhost.localdomain localhost6 localhost6.localdomain6
```

您可以在此文件中添加一行，如下所示:

```sh
192.168.33.11 mysupersite.com
```

现在当你在浏览器中进入`mysupersite.com`时，名字会被解析为你指定的 IP 地址，而不是出去到外部 DNS 服务器进行名字解析。

通过这种方式，您可以在您的 Apache 网络服务器上拥有多个“虚拟主机”，并且由于您的浏览器正在请求命名站点(即使它们都在同一个 IP 地址上)，您将根据您连接的名称获得不同的内容。

The only issue with people mucking around with their `/etc/hosts` file is when they forget to change them back and get confused when they can't connect to the "real" site anymore. 

# 基本 Nginx 配置

现在前往我们的 Debian 服务器，我们将查看默认的 Nginx 页面，当我们访问`http://127.0.0.1:8181/`时，我们可以看到该页面，我们将用我们自己的消息替换该文本。

正如我们之前所说，Nginx 越来越受欢迎。它之所以成为热门的网络服务器，是因为它的易用性和在需要时的灵活性——而不是因为这是一个营销宣传；它们都是开源和免费的。

# 准备好了

对于本节，我们将使用第一节中的`Vagrantfile`。如果您还没有在 Debian 虚拟机上安装 Nginx，现在就安装吧。

连接到您的 Debian 盒子:

```sh
$ vagrant ssh debian1 -- -L 127.0.0.1:8181:127.0.0.1:80
```

# 怎么做...

我们默认的 Nginx 页面没有任何关于在哪里查找配置更改的指示，只向您指出官方文档(非常值得一读)和商业支持服务。

这个默认页面实际上位于与我们刚刚在 CentOS 上检查的页面非常相似的位置:

```sh
$ cat /var/www/html/index.nginx-debian.html 
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
 body {
 width: 35em;
 margin: 0 auto;
 font-family: Tahoma, Verdana, Arial, sans-serif;
 }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```

请注意，这个文件被称为`index.nginx-debian.html`，它是`/var/www/html`中唯一一个开始的文件。

和 Apache 一样，Nginx 也有虚拟主机的概念，我们将在`/etc/nginx/conf.d/`中进行配置。

让我们从创建一些内容开始:

```sh
$ sudo mkdir /var/www/fenchurch
$ cat <<HERE | sudo tee -a /var/www/fenchurch/index.html
How come I'm in one book, then I just disappear?
HERE
```

现在，我们可以添加到我们选择的虚拟主机目录:

```sh
$ cat <<HERE | sudo tee /etc/nginx/conf.d/fenchurch.conf
server {
listen 80;
listen [::]:80;

root /var/www/fenchurch;
index index.html;

server_name 127.0.0.1;

location / {
try_files \$uri \$uri/ =404;
}
}
HERE
```

然后，我们需要加载 Nginx:

```sh
$ sudo systemctl reload nginx
```

现在，当指向我们设置的转发端口时，我们应该能够在浏览器中看到我们的问题:

![](assets/f209f3e9-6460-4ea9-8e6e-774c67f0a3fb.png)

酷！

# 它是如何工作的...

我们默认的 Nginx 配置文件位于`/etc/nginx/nginx.conf`处，它在这个 Debian 安装中设置了进程 ID 位置，以及 Nginx 将作为(这里是`www-data`运行的用户:

```sh
$ head /etc/nginx/nginx.conf
user www-data;
worker_processes auto;
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;

events {
 worker_connections 768;
 # multi_accept on;
}
```

在该文件中，还存在以下配置块:

```sh
 ##
 # Virtual Host Configs
 ##

 include /etc/nginx/conf.d/*.conf;
 include /etc/nginx/sites-enabled/*;
```

请注意，顶部目录是我们选择用于配置的目录。

当我们将`fenchurch.conf`配置放入`/etc/nginx/conf.d/`目录时，我们指示 Nginx 加载这个配置，以及它在启动时加载的所有其他内容。

让我们看看我们的配置:

```sh
server {
listen 80;
listen [::]:80;

root /var/www/fenchurch;
index index.html;

server_name 127.0.0.1;

location / {
try_files $uri $uri/ =404;
}
}
```

`listen`指令相当简单，但是如果您在一个盒子上有多个 IP 地址，它们可能会扩展到包括一个特定的条目。

接下来，我们的`root`条目是网站文件的根位置。在这里，它被设置为我们选择为我们的伟大问题创建的。

`index`是 Nginx 进入目录时要加载的文件的名称。这里使用的是标准`index.html`。

和 Apache 一样，`server_name`是最终用户希望接收内容的域名或 IP 地址。它可能是一串名字，正如在别处看到的:

```sh
server_name example.com herring.example.com dwarf.example.com;
```

最后，`location`块中的`try_files`行意味着将搜索给定链接的文件，如果没有找到，将给出一个`404`。

您可以通过尝试转到浏览器中不存在的文件来测试这一点，例如`http://127.0.0.1:8181/prefect`:

![](assets/4a496d98-0ae6-4b81-af14-cc6d6361a9ee.png)

但是，我们可以将`404`更改为`403`并重新加载 Nginx 配置:

```sh
$ sudo sed -i 's/404/403/g' /etc/nginx/conf.d/fenchurch.conf 
$ sudo systemctl reload nginx
```

如果我们这样做，我们会得到一个`403 Forbidden`:

![](assets/0c35b3a2-6221-4e1e-b58b-1373342dd2fc.png)

`404` is perhaps the most common code that web servers return, but you should be aware that there are more, and they do actually mean different things (provided they've been configured to return correctly). `200` is OK, `401` means unauthorized, and so on.

# 还有更多...

你可能会对使用`systemctl reload`感到疑惑，为什么我选择使用那个而不是`restart`。

当我们【Nginx 的系统单位文件时，答案会变得更加清晰:

```sh
$ systemctl cat nginx | grep Reload
ExecReload=/usr/sbin/nginx -g 'daemon on; master_process on;' -s reload
```

有一条特定的`ExecReload`线带有`-s reload`标志。

这会将`reload`信号发送到 Nginx(`SIGHUP`)；也就是说，它对运行过程的干扰较小。

# 请参见

在 Debian 和类似 Debian 的发行版中，`sites-enabled`和`sites-available`目录的概念已经变得司空见惯。

理论上，你盒子上的任何站点都可以进入`sites-available`目录，一旦你对它们满意，你就创建一个到`sites-enabled`目录的符号链接。

就我个人而言，我觉得这个设置对于自动化世界来说有点混乱和过时，但是如果这是你的困境，那么也许 Debian 的做事方式是适合你的。我不会评判。

# SSL、TLS 和 LetsEncrypt

我们还没有谈到 HTTP 等式的“S”部分。具体来说，S 代表安全，不像超人的 S，显然不是 S，实际上是 El 之家的徽章。

不像超人，网络服务器可能在骗你。

当你访问一个网站时，你想知道你访问的网站是由你认为是合法的公司合法拥有和运营的。如果你去亚马逊、苹果或贝宝，你想在你交出你的数字现金之前知道他们是他们所说的那个人。

然而，你也希望网站能够以安全的方式获取你的信用卡信息，这样那些数字和秘密就不会以纯文本格式在互联网上传播给任何人阅读。

当心挂锁:

![](assets/c46c495d-10e3-4b82-80ab-54d45287107e.png)

当你访问一个安全的网站时，大多数浏览器(如果不是全部的话)应该显示一个小挂锁，只要这个网站不是欺诈性的，你就不应该得到关于潜在问题的警告。

HTTPS is absolutely not perfect, as has been displayed previously by security researchers. It's possible to get legitimate certificates for companies you've set up that just happen to have the same or similar name to existing brands. Be absolutely sure that who you're sending your credit card information to is the real deal. 

你可以点击这个挂锁，获取网站用来与你交流的`Certificate`的信息，详细说明证书的所有者、相关网站以及验证它的互联网机构:

![](assets/5ef2be1a-cca1-4043-bf61-12064a2ecf5a.png)

在本节中，我们将设置我们的站点来监听 HTTPS 连接，而不是 HTTP，我们将讨论一个名为`Let's Encrypt`的实体。

# 准备好

在本节中，我们将使用我们的 Debian 虚拟机。

如果您还没有这样做，最好按照前面几节所述设置 Nginx，包括您的虚拟主机条目。

如果您还没有这样做，请使用 Nginx 在您的 Debian 虚拟机上设置您的虚拟主机。

我们在这一部分所做的一切在 Apache 中也是可能的，尽管配置不同。

确保您正在将连接转发到虚拟机，这次使用新端口:

```sh
$ vagrant ssh debian1 -- -L 127.0.0.1:8484:127.0.0.1:443
```

# 怎么做...

假设您的站点当前在虚拟机内部的端口`80`上启动并运行，您应该能够对文件进行以下更改以启用 HTTPS 通信:

```sh
$ sudo sed -i 's/listen 80/listen 443 ssl/g' /etc/nginx/conf.d/fenchurch.conf
$ sudo sed -i '4iinclude snippets/snakeoil.conf;' /etc/nginx/conf.d/fenchurch.conf
```

使用`cat`确保您的文件看起来类似于以下内容:

```sh
$ cat /etc/nginx/conf.d/fenchurch.conf 
server {
listen 443 ssl;
listen [::]:80;
include snippets/snakeoil.conf;

root /var/www/fenchurch;
index index.html;

server_name 127.0.0.1;

location / {
try_files $uri $uri/ =404;
}
}
```

现在通过安装`ssl-cert`包确保`snake oil`证书可用:

```sh
$ sudo apt install ssl-cert -y
```

然后，重新加载我们的配置:

```sh
$ sudo systemctl reload nginx
```

您现在应该能够访问浏览器中的`https://127.0.0.1:8484`地址，并有望看到如下警告:

![](assets/1a774ac2-01c3-4754-a0af-b8f3da9f9d4d.png)

这意味着，虽然服务器被配置为侦听 HTTPS，并且您可以连接到它，但浏览器认为证书不合法(因为它不合法)，因此在您尝试进一步操作之前，它会警告您:

![](assets/c1ba3410-c6c0-4362-bfb3-c094650b3772.png)

此时，您可以按添加例外...并信任自签名证书，使您能够访问网站。然而，除非你绝对确定你应该看到这个警告，并且你对它没意见(因为你正在测试)，否则养成这个习惯并不好。

# 它是如何工作的...

以下是一个超级大警告:

这里使用的证书只是举例，因此得名“蛇油”。它们永远不应该被任何人用于生产，哪怕是开玩笑。您应该只对您设置的任何服务器使用合法证书(除了测试和开发之外，反正不应该面向公众)。

现在，让我们来看看这里有什么:

```sh
server {
listen 443 ssl;
listen [::]:80;
include snippets/snakeoil.conf;

root /var/www/fenchurch;
index index.html;

server_name 127.0.0.1;

location / {
try_files $uri $uri/ =404;
}
}
```

我们使用了几个`sed`命令来更改这个文件，但是如果我们愿意，我们可以将内容复制到文件中。

我们将`listen`端口改为`443`(来自`80`)并增加了`ssl`指令。我们还包括一个片段示例文件，在本例中为`snakeoil.conf`:

```sh
$ cat /etc/nginx/snippets/snakeoil.conf 
# Self signed certificates generated by the ssl-cert package
# Don't use them in a production server!

ssl_certificate /etc/ssl/certs/ssl-cert-snakeoil.pem;
ssl_certificate_key /etc/ssl/private/ssl-cert-snakeoil.key;
```

因此，我们的小虚拟主机可以访问 SSL 证书和证书密钥。

重新加载我们的配置意味着应用了这些设置，然后我们可以在火狐内部的`443`上访问我们的网站。

然后，我们得到了关于证书是伪造的可怕消息，但我们预计会发生这种情况。

在这个职业中，我们也经常互换使用 SSL 和 TLS 这两个术语(甚至我也为此感到内疚)，这在技术上是不正确的(最糟糕的一种不正确)。

**安全套接字层** ( **SSL** )是一个长期被否决的协议，已经被**传输层安全性** ( **TLS** )所取代，后者现在是标准协议，通常是为传输中的数据提供安全性的默认协议。

这两种协议都有几个版本:

*   SSL 1.0:从未发布
*   SSL 2.0: 1995 年
*   SSL 3.0: 1996
*   TLS 1.0: 1999 年
*   TLS 1.1: 2006
*   TLS 1.2: 2008
*   TLS 1.3: 2018

现实地说，这些天你应该只使用 TLS 1.2，当 1.3 变得无处不在时，我也建议转向它。

有很多关于各种攻击的文章，这些攻击可以用来对抗这些协议中的一些，我总是建议您在设置网络服务器时阅读当天的建议。

心流血通常是开始阅读 SSL/TLS 漏洞的好地方。

Some older operating systems don't support newer protocols, meaning that you sometimes get websites using long-dead and insecure protocols just to appease the XP users of the world. If your boss demands you use SSL (any version) or a TLS earlier than 1.2, I would suggest a nice sit-down over a cup of tea so that you can explain why that would be a bad idea.

# 还有更多...

还有其他一些事情，只是为了确保你有一个好的起点。

# 让我们加密

如果您不想使用自己的证书颁发机构，您可以考虑使用“让我们加密”，一个提供免费证书的证书颁发机构。

通常，证书是要花钱的——在某些情况下是一大笔钱(比如扩展验证证书)——所以能够使用免费的产品来保护你的网站是件好事。

证书的有效期只有 90 天，这是一个缺点，但是完全可以实现自动续订来解决这个问题。

部署和更新可以通过许多发行版中提供的各种工具来完成。在 Debian boxes 上，您可以考虑安装`certbot`包，并尝试配置自己的网络服务器。

# 工作环境证书

值得注意的是，传统意义上让证书“可信”的唯一一点是，你知道是谁签的。一些浏览器和大多数操作系统都带有一个“受信任的”证书颁发机构列表，用于验证证书是否合法。

工作场所也是如此:你倾向于看到的(尤其是在大公司)是内部认证机构，其完整性检查证书安装在公司拥有的每台笔记本电脑和台式机上。这样做的最终结果是，公司更容易签署内部使用的证书，但是如果从外部访问这些系统中的任何一个，它们仍然会显示警告(因为外部设备不会安装公司的证书颁发机构)。

你可能会发现，你自己的雇主在你公司的笔记本电脑上有一个认证中心，安装在美国、中国和一些政府的要人旁边。

# 请参见

抽象地谈论安全性很好，但简单的事实是，这实际上是一个相当令人困惑的话题，普通公众对此并不熟悉。

你可能会想，当一个终端用户看到一个巨大的、可怕的横幅，告诉他们他们试图点击的网站是不合法的，他们会尽快点击离开...但这在很多情况下不会发生。

实际上，不健康数量的终端用户只是因为必须在到达他们想要的站点(或者假装他们想要的站点的站点)之前点击几个警告而感到恼火。

近年来，当用户盲目接受伪造证书时，出现了各种各样的损害限制尝试，例如浏览器让网站添加异常变得稍微更烦人，但这种情况仍然发生。

这凸显了一个作为系统管理员你会一次又一次遇到的问题，那就是用户教育，确保你的用户对网站安全有一个基本的了解。

# 基本 MySQL 或 MariaDB 安装

数据库很棒——它们让数据库管理员(T2 数据库管理员)保持工作状态，并且它们提供了一种在系统上存储数据的便捷方式，而不是在一个目录中存储一系列随机大小的平面文件。

传统上，数据库是存储特定类型和大小的有序数据的好地方，这意味着您可以获得支持各种事物的数据库，从银行交易记录到网站库存编号。

SQL 数据库是人们最熟悉的(稍后将详细介绍 NoSQL 数据库)，其中最常见的是 MariaDB，它是 MySQL 的一个分支。

MariaDB was forked from MySQL after the acquisition of the latter by Oracle. This is perhaps an understandable concern, as a lot of people in the open source space view Oracle as evil, though naturally I have no strong feelings one way or the other.

如果你运行一个 Wordpress 网站，你可能已经遇到了 MariaDB 或 MySQL，因为它们是大多数人在建立特定博客平台时选择的数据库。

# 准备好

在本节中，我们将使用我们的 CentOS 虚拟机。

我们暂时离开 web 服务器，这意味着您不必担心已经完成了前面的部分才能继续。

让我们跳到我们的 CentOS 虚拟机:

```sh
$ vagrant ssh centos1
```

# 怎么做...

在尝试与软件交互之前安装软件被认为是一种好的做法。考虑到这一点，`install mariadb-server`:

```sh
$ sudo yum install mariadb-server -y
```

接下来，确保它已启动并配置为在启动时启动(这可能需要几秒钟):

```sh
$ sudo systemctl enable --now mariadb
Created symlink from /etc/systemd/system/multi-user.target.wants/mariadb.service to /usr/lib/systemd/system/mariadb.service.
```

在我们继续之前，运行`mysql_secure_installation`脚本:

```sh
$ mysql_secure_installation
```

这会给你一系列提示。回答如下:

*   输入根用户的当前密码(输入无):`<BLANK, HIT ENTER>`
*   设置根密码？`Y`
*   新密码:`examplerootpassword`
*   删除匿名用户？`Y`
*   不允许根用户远程登录？`Y`
*   删除测试数据库并访问它？`Y`
*   现在重新加载特权表吗？`Y`

Remember: these are just examples for this book. There may be reasons why you need some of these settings, and you should always set a secure root password in the real world.

接下来，登录您的数据库:

```sh
$ mysql -uroot -pexamplerootpassword
Welcome to the MariaDB monitor. Commands end with ; or \g.
Your MariaDB connection id is 10
Server version: 5.5.60-MariaDB MariaDB Server
Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others.
Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.
MariaDB [(none)]> 
```

We gave the password directly on the command line here, for display purposes, however you can omit the actual password entirely, and instead have MariaDB prompt you for the password (this way it won't show up in your Bash history).

# 列出、创建和选择数据库和表

从您的新提示符中，您现在可以列出`MariaDB`中的数据库(我知道这很混乱，但是数据库服务器(`MariaDB`)可以管理多个数据库):

```sh
MariaDB [(none)]> show databases;
+--------------------+
| Database |
+--------------------+
| information_schema |
| mysql |
| performance_schema |
+--------------------+
3 rows in set (0.00 sec)
```

我们想看一下内置的`mysql`数据库，那么我们来看看:

```sh
MariaDB [(none)]> use mysql;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
```

一旦我们使用了这个数据库，我们就可以列出其中的表:

```sh
MariaDB [mysql]> show tables;
+---------------------------+
| Tables_in_mysql |
+---------------------------+
| columns_priv |
| db |
| event |
| func |
| general_log |
| help_category |
| help_keyword |
| help_relation |
| help_topic |
| host |
| ndb_binlog_index |
| plugin |
| proc |
| procs_priv |
| proxies_priv |
| servers |
| slow_log |
| tables_priv |
| time_zone |
| time_zone_leap_second |
| time_zone_name |
| time_zone_transition |
| time_zone_transition_type |
| user |
+---------------------------+
24 rows in set (0.00 sec)
```

现在我们可以获得关于特定表的信息。这里，我们从`user`表中获取`Host`、`User`和`Password`:

```sh
MariaDB [mysql]> select Host,User,Password from user;
+-----------+------+-------------------------------------------+
| Host | User | Password |
+-----------+------+-------------------------------------------+
| localhost | root | *F61E89B5042AB6D880D5BA79586B46BA93FABF09 |
| 127.0.0.1 | root | *F61E89B5042AB6D880D5BA79586B46BA93FABF09 |
| ::1 | root | *F61E89B5042AB6D880D5BA79586B46BA93FABF09 |
+-----------+------+-------------------------------------------+
3 rows in set (0.00 sec)
```

除此之外，我们还可以创建自己的数据库和表。

让我们创建`exampledb`作为数据库:

```sh
MariaDB [mysql]> create database exampledb;
Query OK, 1 row affected (0.00 sec)
```

然后我们可以`use`这个数据库并添加一个表:

```sh
MariaDB [mysql]> use exampledb;
Database changed
MariaDB [exampledb]> create table exampletable (food varchar(10), goodbad char(1));
Query OK, 0 rows affected (0.00 sec)
```

让我们看看刚刚创建的表，看看我们的字段:

```sh
MariaDB [exampledb]> describe exampletable;
+---------+-------------+------+-----+---------+-------+
| Field | Type | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| food | varchar(10) | YES | | NULL | |
| goodbad | char(1) | YES | | NULL | |
+---------+-------------+------+-----+---------+-------+
2 rows in set (0.00 sec)
```

接下来，用一些数据填充它:

```sh
MariaDB [exampledb]> insert into exampletable values ('strawberries','b');
Query OK, 1 row affected, 1 warning (0.00 sec)
```

现在我们可以通过`selecting`内容看到我们刚刚放入表中的内容:

```sh
MariaDB [exampledb]> select * from exampletable;
+------------+---------+
| food | goodbad |
+------------+---------+
| strawberri | b |
+------------+---------+
1 row in set (0.00 sec)
```

要退出数据库，请键入`exit`(或点击 *CTRL* + *D* ):

```sh
MariaDB [exampledb]> exit
Bye
$
```

# 它是如何工作的...

我们在系统上安装了 MariaDB 并启动了它。因此，我们在`/var/lib/mysql`目录中创建了几个数据库和相关数据:

```sh
$ ls /var/lib/mysql
aria_log.00000001 exampledb ib_logfile0 mysql performance_schema
aria_log_control ibdata1 ib_logfile1 mysql.sock
```

运行完`secure setup`脚本后，我们使用刚刚设置的密码进入数据库:

```sh
$ mysql -uroot -pexamplerootpassword
```

这让我们进入了一个完全不同的外壳，一个在`MariaDB`程序中的外壳，它使我们能够操纵`MariaDB`控制的数据库。

我们创建了一个数据库，并在其中创建了一个表。

```sh
MariaDB [mysql]> create database exampledb;
MariaDB [exampledb]> create table exampletable (food varchar(10), goodbad char(1));
```

我们专门创建的表名为`exampletable`。我们给了它两个字段:一个`food`字段和一个`goodbad`字段。

然后我们将一些数据插入数据库:

```sh
MariaDB [exampledb]> insert into exampletable values ('strawberries','b');
```

碰巧的是，因为我们将`food`字段设置为`10`的 varchar，草莓条目太长，导致它被切断:

```sh
MariaDB [exampledb]> select * from exampletable;
+------------+---------+
| food | goodbad |
+------------+---------+
| strawberri | b |
+------------+---------+
1 row in set (0.00 sec)
```

这突出了传统 SQL 数据库的一个优点，即可以非常精确地确定每个字段中存储的数据类型以及可以存储多少数据。

这个数据库现在存在于我们的文件系统中，正如我们之前列出`mysql`目录时看到的:

```sh
$ sudo ls /var/lib/mysql/exampledb/
db.opt exampletable.frm
```

当您重新启动系统时，您对数据库所做的更改将继续存在。

# 还有更多...

正如开篇导语中所暗示的，MariaDB 是 MySQL 的一个分叉，这就是为什么我们在这里安装`MariaDB`的同时，还使用了`mysql`系列命令与之交互。这是为了确保向后兼容。

# 请参见

还有一些数据库权限，我们没有涉及到，它们和常规文件系统权限一样重要。您不希望同一台主机上的两个 Wordpress 安装能够读取彼此的数据库，因此您应该为每个安装创建一个专用用户，并在 Maria 中为他们提供自己的数据库。

# 基本 PostgreSQL 安装

还有另一个流行的 SQL 数据库，我说的不是 MSSQL(这是可以的，这几天它甚至在 Linux 上工作！).

PostgreSQL(想怎么念就怎么念；其他人都知道)从 1996 年就已经出现了，许多人发誓它是一个比 MySQL 或 MariaDB 优越得多的产品。

就我个人而言，我对数据库不太感兴趣，所以这种对话通常会让我感到困惑，不知道我的下一杯咖啡会从哪里来。

像 MySQL 和 MariaDB 一样，Postgres 在很多默认的存储库中都有，很多流行的软件会给你提供使用 Postgres 作为后端而不是 MariaDB 的选项。

# 准备好

在本节中，我们将再次使用我们的 CentOS 机器。

跳上我们的 CentOS 虚拟机(如果您已经在那里，请继续使用):

```sh
$ vagrant ssh centos1
```

# 怎么做...

和 Maria 一样，我们实际上必须首先安装软件:

```sh
$ sudo yum install postgresql-server -y
```

与玛丽亚不同，我们必须先设置 Postgres，然后才能使用它:

```sh
$ sudo postgresql-setup initdb
Initializing database ... OK
```

但是，完成后，您可以启动并启用服务器:

```sh
$ sudo systemctl enable --now postgresql 
```

现在，登录您的数据库(方式与 Maria 略有不同):

```sh
$ sudo -u postgres psql 
psql (9.2.24)
Type "help" for help.

postgres=# 
```

# 列出、创建和选择数据库和表

有些人发现，与 MariaDB 和 MySQL 相比，Postgres 命令和语法更容易记住。就我个人而言，我总是要查找它们，这导致了`\?`的自由使用，这将您带入`help`菜单。

从基础开始，使用`\l`列出 Postgres 管理的所有数据库:

```sh
postgres-# \l
 List of databases
 Name | Owner | Encoding | Collate | Ctype | Access privileges 
-----------+----------+----------+-------------+-------------+-----------------------
 postgres | postgres | UTF8 | en_GB.UTF-8 | en_GB.UTF-8 | 
 template0 | postgres | UTF8 | en_GB.UTF-8 | en_GB.UTF-8 | =c/postgres +
 | | | | | postgres=CTc/postgres
 template1 | postgres | UTF8 | en_GB.UTF-8 | en_GB.UTF-8 | =c/postgres +
 | | | | | postgres=CTc/postgres
(3 rows)
```

要创建数据库，我们将复制两个可用模板中的一个:

```sh
postgres=# create database exampledb template template1;
CREATE DATABASE
```

要更改到我们的新数据库，请使用`\c`:

```sh
postgres=# \c exampledb
You are now connected to database "exampledb" as user "postgres".
```

你可能认为要列出表格，我们会使用`\t`或者`\lt`，但你可能不正确。

要列出当前数据库中的表，请使用`\dt`:

```sh
exampledb=# \dt
No relations found.
```

这个数据库中没有，所以让我们创建一个:

```sh
exampledb=# create table prime_ministers(firstname varchar(10), lastname varchar(10));
CREATE TABLE
```

我们还需要填充它:

```sh
exampledb=# insert into prime_ministers (firstname, lastname) values ('Lord', 'Rosebury'), ('George', 'Canning'), ('Tony', 'Blair');
INSERT 0 3
```

然后，我们需要描述它:

```sh
exampledb=# \d prime_ministers
 Table "public.prime_ministers"
 Column | Type | Modifiers 
-----------+-----------------------+-----------
 firstname | character varying(10) | 
 lastname | character varying(10) |
```

最后，我们需要从中进行选择:

```sh
exampledb=# select * from prime_ministers;
 firstname | lastname 
-----------+----------
 Lord | Rosebury
 George | Canning
 Tony | Blair
(3 rows)
```

用`\q`或 *CTRL* + *D* 退出 Postgres:

```sh
exampledb=# \q
$ 
```

# 它是如何工作的...

安装 Postgres 后，我们在`/var/lib/pgsql`中得到数据，如下所示:

```sh
$ sudo ls /var/lib/pgsql/
backups data initdb.log
```

然后，我们使用在安装过程中为我们创建的用户登录到我们的数据库:

```sh
$ sudo -u postgres psql 
$ cat /etc/passwd | grep postgres
postgres:x:26:26:PostgreSQL Server:/var/lib/pgsql:/bin/bash
```

一旦进入，我们就开始创建自己的数据库，使用`template1`作为模板:

```sh
postgres=# create database exampledb template template1;
```

`template1` can be modified so that you can have a consistent starting point for new systems, though, again, I find that this is easier to store in `infrastructure as code` repositories nowadays. 

我们在数据库中创建了一个表(更改后):

```sh
exampledb=# create table prime_ministers(firstname varchar(10), lastname varchar(10));
```

请注意，我们再次定义了特定的字段，关联的类型(`varchar`是一种非常灵活的数据类型，但将其用于所有情况并不是一个好主意。对希望与字段关联的数据类型使用适当的类型对性能更好)。

我们在表中填充了内容，并对其进行了描述和选择:

```sh
exampledb=# insert into prime_ministers (firstname, lastname) values ('Lord', 'Rosebury'), ('George', 'Canning'), ('Tony', 'Blair');
exampledb=# \d prime_ministers
exampledb=# select * from prime_ministers;
```

希望您已经注意到，我们在本节中使用的许多语法与 MariaDB 安装中使用的语法完全相同。这是有原因的，这是因为这两个数据库都有名字`SQL`。

结构化查询语言是相当一致的，但是在一个数据库中使用的命令不能复制并传递到另一个数据库中。可悲的是，这在很大程度上是一个白日梦。

除了表和数据库操作命令(`\l`、`\dt`等)，混淆 Postgres 和 Maria 语法也是情有可原的，但有时它的不同足以令人讨厌。

我们也没有将 MSSQL 添加到这个组合中。

If you ever hear someone refer to SQL as seeqwel, instead of S.Q.L., there's a good chance they've picked up the name from a Windows DBA, or someone old enough to remember SQL was originally the "Structured English Query Language". It no longer has an "e" in the name, but some people insist on creating this ephemeral "e" when they pronounce the acronym.

Holy wars...

# 本地 MTA 用法和配置(后缀)

电子邮件仍然存在，虽然这本身是一种嘲弄，但它也为我们提供了一个机会，让我们看看为什么你会发现自己在日常工作中与邮件服务器交互。

传统上，服务器有时每晚或每周运行一系列检查，然后将结果编译成文档并发送给系统管理员，系统管理员可以仔细阅读报告并发现异常或意外行为。大多数情况下，这是一门被遗忘的艺术，很少有人会费心将他们系统上的默认邮寄位置配置为`root@localhost`以外的任何位置。

正是因为这个原因，你偶尔会在登录控制台时看到`you have new mail`或者类似的通知。那里的邮件通常是你不太关心的东西，来自一个程序，它通知你它在五天前以不同的方式被破坏了。

这并不是说邮件不重要——它仍然被监控系统作为第一个“警报”方法积极使用，而且，尽管听起来令人惊讶，但有些人确实仍然运行自己的邮件服务器(尽管，这些天来，你更有可能发现一家公司使用现成的解决方案，如质子化邮件，配置了自己的域记录)。

Email has issues, even when used as an alerting method in a monitoring system. I've lost count of the number of places I've been who've had a Nagios, Icinga2, or Zabbix set up, configured to email out when there's a problem, but also when the problem goes away, or when there might possibly be a problem that someone should look at. An alert email can mount up fast, resulting in alert fatigue when engineers simply pipe their email to a `junk` folder and never check it (except when it gets too full and they occasionally empty it out). Text messages are a much more annoying method of alerting—try those.

# 准备好

在本节中，我们将使用我们的 CentOS 虚拟机，主要是因为默认情况下，Postfix 安装在 CentOS 盒子上。

登录到您的 CentOS 框，并确保 Postfix 正在运行:

```sh
$ vagrant ssh centos1
$ systemctl status postfix
● postfix.service - Postfix Mail Transport Agent
 Loaded: loaded (/usr/lib/systemd/system/postfix.service; enabled; vendor preset: disabled)
 Active: active (running) since Sun 2018-12-02 11:35:12 UTC; 21h ago
 Main PID: 1125 (master)
 CGroup: /system.slice/postfix.service
 ├─ 1125 /usr/libexec/postfix/master -w
 ├─ 1129 qmgr -l -t unix -u
 └─10453 pickup -l -t unix -u
```

如果没有安装也没有运行，可以简单安装`postfix`包:

```sh
$ sudo yum install postfix -y
```

# 怎么做...

大多数情况下，您会发现 Postfix 已经安装并配置好了，所以让我们浏览一下开箱即用的东西，看看一些常见的实用程序。

首先，我们通过使用`alternatives`命令来检查您的系统配置为使用哪个 MTA:

```sh
$ alternatives --list | grep mta
mta auto /usr/sbin/sendmail.postfix
```

这告诉我们，系统正在利用后缀发送邮件。

尝试发送一些邮件到一个示例地址。为此，我们首先需要安装一个小命令行，即`mailx`:

```sh
$ sudo yum install mailx -y
```

现在，您可以运行以下邮件命令，将您想要的内容写入新行(并在最后一行用一个`.`结束邮件):

```sh
$ mail -s "Example Subject" packt@example.co
This is an example email.
We end emails written in this way, using the '.' symbol.
That way, the client knows when the email has come to a close.
.
EOT
$ 
```

如果我们现在再次输入`mail`，我们会进入邮件外壳:

```sh
$ mail 
Heirloom Mail version 12.5 7/5/10\. Type ? for help.
"/var/spool/mail/vagrant": 1 message 1 unread
>U 1 Mail Delivery System Mon Dec 3 09:35 76/2632 "Undelivered Mail Returned to Sender"
&
```

注意我们被告知有一条消息，其中一条是未读的，下面是加粗的一行，主题用引号括起来。

要打开邮件，请键入与问题邮件对应的号码:

![](assets/0f6609d1-30b9-40b0-97de-f17a22a38e87.png)

你被放入一个寻呼机，它允许你滚动你的信息。

你可以在这条消息中看到一些重要的东西，第一个是响应系统是`MAILER-DAEMON@centos1.localdomain`(邮件传递系统)，这表明我们的消息并没有走得很远。

然后邮件会建议一些你可以做的事情来帮助缓解你的问题，首先是联系`the postmaster`，就像同名电影中的页面大师一样，他们往往有某种飘渺的品质。

在底部，你会看到你的电子邮件的片段。

这告诉我们什么？首先，它告诉我们你的邮件服务器不能发送你刚刚试图发送的邮件。

接下来，它告诉我们 Postfix 的功能足以处理邮件，因为退回仍然是邮件。

# main.cf

后缀在`/etc/postfix/main.cf`使用一个主配置文件。

这个文件包含许多配置选项，但是开箱即用，它没有被配置为做任何事情(例如，它不会接受来自另一个系统的传入邮件)。

# /etc/别名

这是接收特定邮件的帐户的数据库或地图。

通常，该文件中唯一的配置更改是根邮件的目的地。在本地系统上，您可以将其映射到您的用户:

```sh
# Person who should get root's mail
root: vagrant
```

然后，运行`newaliases`应用该更改:

```sh
$ sudo newaliases
```

同样，这并不经常发生，但有些人仍然喜欢抓取邮件，这些邮件是为 root 用户准备的，只是为了确保随机程序不会像收割者声称的那样死亡和尖叫。

# 它是如何工作的...

要获得更多关于消息发送失败时的详细输出，您通常可以查看`/var/log/maillog`:

```sh
$ sudo cat /var/log/maillog 
Dec 2 11:35:12 localhost postfix/postfix-script[1120]: starting the Postfix mail system
Dec 2 11:35:12 localhost postfix/master[1125]: daemon started -- version 2.10.1, configuration /etc/postfix
Dec 3 09:35:43 localhost postfix/pickup[11157]: 8E9A1206B117: uid=1000 from=<vagrant>
Dec 3 09:35:43 localhost postfix/cleanup[11317]: 8E9A1206B117: message-id=<20181203093543.8E9A1206B117@centos1.localdomain>
Dec 3 09:35:43 localhost postfix/qmgr[1129]: 8E9A1206B117: from=<vagrant@centos1.localdomain>, size=601, nrcpt=1 (queue active)
Dec 3 09:35:43 localhost postfix/smtp[11319]: 8E9A1206B117: to=<packt@example.co>, relay=none, delay=0.12, delays=0.04/0.01/0.06/0, dsn=5.4.4, status=bounced (Host or domain name not found. Name service error for name=example.co type=AAAA: Host not found)
Dec 3 09:35:43 localhost postfix/cleanup[11317]: A88F7206B118: message-id=<20181203093543.A88F7206B118@centos1.localdomain>
Dec 3 09:35:43 localhost postfix/qmgr[1129]: A88F7206B118: from=<>, size=2545, nrcpt=1 (queue active)
Dec 3 09:35:43 localhost postfix/bounce[11320]: 8E9A1206B117: sender non-delivery notification: A88F7206B118
Dec 3 09:35:43 localhost postfix/qmgr[1129]: 8E9A1206B117: removed
Dec 3 09:35:43 localhost postfix/local[11321]: A88F7206B118: to=<vagrant@centos1.localdomain>, relay=local, delay=0.02, delays=0/0.02/0/0, dsn=2.0.0, status=sent (delivered to mailbox)
Dec 3 09:35:43 localhost postfix/qmgr[1129]: A88F7206B118: removed
```

在这里，我们得到了一点关于发生了什么的细节，如果我们找到了我们想要的消息，我们可以通过消息的线索来跟随`message-id`。

首先，我们可以看到 Postfix 接收到的消息:

```sh
Dec 3 09:35:43 localhost postfix/pickup[11157]: 8E9A1206B117: uid=1000 from=<vagrant>
```

接下来，守护程序在将消息传递到邮件队列之前对其进行处理:

```sh
Dec 3 09:35:43 localhost postfix/cleanup[11317]: 8E9A1206B117: message-id=<20181203093543.8E9A1206B117@centos1.localdomain>
```

我们得知消息在队列中，等待发送:

```sh
Dec 3 09:35:43 localhost postfix/qmgr[1129]: 8E9A1206B117: from=<vagrant@centos1.localdomain>, size=601, nrcpt=1 (queue active)
```

最后(对于此邮件)，SMTP 尝试处理邮件:

```sh
Dec 3 09:35:43 localhost postfix/smtp[11319]: 8E9A1206B117: to=<packt@example.co>, relay=none, delay=0.12, delays=0.04/0.01/0.06/0, dsn=5.4.4, status=bounced (Host or domain name not found. Name service error for name=example.co type=AAAA: Host not found)
```

它会立即失败，因为该域不是真实的。

创建退回消息，即`A88F7206B118`，并对其进行处理(同时删除原始消息`8E9A1206B117`):

```sh
Dec 3 09:35:43 localhost postfix/cleanup[11317]: A88F7206B118: message-id=<20181203093543.A88F7206B118@centos1.localdomain>
Dec 3 09:35:43 localhost postfix/qmgr[1129]: A88F7206B118: from=<>, size=2545, nrcpt=1 (queue active)
Dec 3 09:35:43 localhost postfix/bounce[11320]: 8E9A1206B117: sender non-delivery notification: A88F7206B118
Dec 3 09:35:43 localhost postfix/qmgr[1129]: 8E9A1206B117: removed
```

这是在发送给本地用户之前完成的，本地用户首先发起了邮件尝试:

```sh
Dec 3 09:35:43 localhost postfix/local[11321]: A88F7206B118: to=<vagrant@centos1.localdomain>, relay=local, delay=0.02, delays=0/0.02/0/0, dsn=2.0.0, status=sent (delivered to mailbox)
Dec 3 09:35:43 localhost postfix/qmgr[1129]: A88F7206B118: removed
```

它降落在`/var/spool/mail/vagrant`中，如这条友好的信息所示:

```sh
You have mail in /var/spool/mail/vagrant
```

这里的每个步骤都是由 Postfix 完成的，一个主守护进程负责许多小守护进程，每个小守护进程都有特定的工作。

如果我们运行`ps`并寻找`postfix`守护进程，您会发现如下内容:

```sh
 1125 ? Ss 0:00 /usr/libexec/postfix/master -w
 1129 ? S 0:00 \_ qmgr -l -t unix -u
11157 ? S 0:00 \_ pickup -l -t unix -u
```

`qmgr`，顾名思义，就是队列管理器，取货是为了本地邮件取货。

要查看队列，可以使用`postqueue`命令:

```sh
$ postqueue -p
-Queue ID- --Size-- ----Arrival Time---- -Sender/Recipient-------
D71FD206B117 458 Mon Dec 3 10:04:18 vagrant@centos1.localdomain
 (connect to nasa.com[192.64.147.150]:25: Connection refused)
 contact@nasa.com

-- 0 Kbytes in 1 Request.
```

在这里，你可以看到我发给`contact@nasa.com`的一条信息。这不起作用，因为我们的连接尝试被拒绝。

另外，注意端口`25`，一个传统的邮件接收端口。

如果你想清空队列，你可以使用`postsuper`，比如:

```sh
$ sudo postsuper -d D71FD206B117
postsuper: D71FD206B117: removed
postsuper: Deleted: 1 message
```

You can also `flush` mail queues, which attempts redelivery of the mail in them. Generally, though, unless you've fixed the problem that caused undeliverable mail in the first place, you've just caused the mail to fail again. What's more, you've probably ground your server to a halt in the process.

# 还有更多...

后缀是一个**邮件传输代理** ( **MTA** )。

可悲的是，这不是一本关于配置邮件服务器的书，因为已经有很多很多关于这个主题的书了。如果你在野外遇到默认的 Postfix 安装，你只需要知道如何与它交互。

如果你想了解更多关于 Postfix 的知识，或者想运行你自己的邮件服务器，我建议你不要这样做。然而，如果你回来说你真的，真的想运行自己的邮件服务器，我会建议和 Postfix 坐下来过一个周末，阅读最佳实践(例如，不要创建开放中继)，并努力不要立即放弃。所有的权力都给你。

Really, though, most companies these days either use some form of Exchange server, or they're just using Google, ProtonMail, FastMail, and so on instead.

# 请参见

阅读电子邮件是值得的，因为有一天你很有可能会打开一封电子邮件来查看邮件头。在这种情况下，理解为什么电子邮件以它的方式工作(也就是说，将消息传递给链中的下一个邮件服务器，直到它最终到达最终用户)可能非常有价值。

如果运行你自己的电子邮件服务器的想法看到一些奇迹般的复苏，我可能会在未来扩展这一部分。

# 本地 MTA 用法和配置(Exim)

像 Postfix 一样，我们有 Exim，这是另一个 MTA。

在 Postfix 功能强大且专注于安全性的领域，Exim 以极其可定制而闻名，其历史可以追溯到 1995 年(落后 Postfix 三年)。多年来，它一直是 Debian 项目的最爱，因此，许多关于设置邮件服务器的文档都引用了 Exim。

此外，像 Postfix 一样，这不会是一个关于完全配置 Exim 的很长的部分，因为如果做得好，这将需要比一节、一章或实际上一本书长得多的东西。相反，我们将查看一些配置、Exim 日志文件，以及当您尝试从本地系统发送消息时会发生什么。

# 准备好了

在本节中，我们将使用我们的 Debian 机器。

要确保您的系统上安装了 Exim，请运行以下命令:

```sh
$ sudo apt install exim4 -y
```

Exim 套件中有相当多的包，可能需要一些时间才能全部运行完。

用`systemctl status`检查其运行情况:

```sh
$ systemctl status exim4
● exim4.service - LSB: exim Mail Transport Agent
 Loaded: loaded (/etc/init.d/exim4; generated; vendor preset: enabled)
 Active: active (running) since Wed 2018-12-05 17:38:01 GMT; 1min 29s ago
 Docs: man:systemd-sysv-generator(8)
 Process: 5402 ExecStart=/etc/init.d/exim4 start (code=exited, status=0/SUCCESS)
 Tasks: 1 (limit: 4915)
 CGroup: /system.slice/exim4.service
 └─5649 /usr/sbin/exim4 -bd -q30m
```

# 怎么做...

安装后，让我们快速测试一下开箱即用的邮件服务器。

从发送示例邮件开始:

```sh
$ mail -s "Example Subject" packt@example.co
Cc: 
This is another piece of example mail.
In this case we need to end with Ctrl-D.
Like so!
$ 
```

如果我们现在再次运行`mail`，我们将看到被退回的消息:

```sh
$ mail
"/var/mail/vagrant": 1 message 1 new
>N 1 Mail Delivery Syst Wed Dec 5 17:46 56/1737 Mail delivery failed: returnin
? 
```

再次点击`1`*进入*会加载第一条信息:

![](assets/04855435-4d86-411b-8732-5c892f134641.png)

在这里，我们实际上获得了有用的信息`Mailing to remote domains not supported`，因为有问题的服务器无法做到这一点。

借助 Exim，您还可以测试它如何使用`address testing mode`将邮件路由到给定的地址。当给出前面的地址时，它会打印一条熟悉的消息:

```sh
$ sudo exim -bt packt@example.co
R: nonlocal for packt@example.co
packt@example.co is undeliverable: Mailing to remote domains not supported
```

它甚至告诉您它不是本地的，而如果我们给出相同的命令，用本地用户替换假电子邮件，我们会得到以下结果:

```sh
$ sudo exim -bt vagrant@localhost
R: system_aliases for vagrant@localhost
R: userforward for vagrant@localhost
R: procmail for vagrant@localhost
R: maildrop for vagrant@localhost
R: lowuid_aliases for vagrant@localhost (UID 1000)
R: local_user for vagrant@localhost
vagrant@localhost
 router = local_user, transport = mail_spool
```

使用的运输工具是当地`mail_spool`，没有邮件无法投递的消息。

我们也可以使用`ss`来确认我们的邮件服务器只在本地(`127.0.0.1 & ::1`)的端口`25`上监听:

```sh
$ ss -tna '( sport = :smtp )'
State Recv-Q Send-Q Local Address:Port Peer Address:Port 
LISTEN 0 20 127.0.0.1:25 *:* 
LISTEN 0 20 ::1:25 :::* 
```

# 它是如何工作的...

Exim 配置位于我们 Debian 主机上的`/etc/exim4`文件夹中。列出该文件如下所示:

```sh
$ ls /etc/exim4/
conf.d exim4.conf.template passwd.client update-exim4.conf.conf
```

正在使用的配置文件是`update-exim4.conf.conf`文件(是的，那是`.conf`两次)。

该文件开箱后如下所示:

```sh
# /etc/exim4/update-exim4.conf.conf
#
# Edit this file and /etc/mailname by hand and execute update-exim4.conf
# yourself or use 'dpkg-reconfigure exim4-config'
#
# Please note that this is _not_ a dpkg-conffile and that automatic changes
# to this file might happen. The code handling this will honor your local
# changes, so this is usually fine, but will break local schemes that mess
# around with multiple versions of the file.
#
# update-exim4.conf uses this file to determine variable values to generate
# exim configuration macros for the configuration file.
#
# Most settings found in here do have corresponding questions in the
# Debconf configuration, but not all of them.
#
# This is a Debian specific file

dc_eximconfig_configtype='local'
dc_other_hostnames='debian1'
dc_local_interfaces='127.0.0.1 ; ::1'
dc_readhost=''
dc_relay_domains=''
dc_minimaldns='false'
dc_relay_nets=''
dc_smarthost=''
CFILEMODE='644'
dc_use_split_config='false'
dc_hide_mailname=''
dc_mailname_in_oh='true'
dc_localdelivery='mail_spool'
```

但是，正如文件所建议的，可以通过使用`sudo dpkg-reconfigure exim4-config`进行修改:

```sh
$ sudo dpkg-reconfigure exim4-config
```

这将使您进入 TUI，如下所示:

![](assets/ab2b9dcd-4a4f-4ae3-a584-717ccb099dda.png)

在这里，您可以根据自己的喜好重新配置邮件服务器，包括将其设置为互联网邮件服务器。

一旦完成您喜欢的操作，您会发现配置文件已经更新以反映这些设置。

如果想知道某些配置设置是否生效，可以使用`exiwhat`命令，如下:

```sh
$ sudo exiwhat
 3280 daemon(4.89): -q30m, listening for SMTP on [127.0.0.1]:25 [::1]:25
```

Exim 和 Postfix 一样，也提供了一个有用的`maillog`，尽管在 Exim 的情况下，它被称为`mainlog`，并且它通常位于特定的`exim`目录中:

```sh
$ sudo ls /var/log/exim4/
mainlog
```

内容比较熟悉:

```sh
$ sudo cat /var/log/exim4/mainlog
<SNIP>
2018-12-05 19:03:15 1gUcS3-0000xe-Ps <= vagrant@debian1 U=vagrant P=local S=466
2018-12-05 19:03:15 1gUcS3-0000xe-Ps ** packt@example.co R=nonlocal: Mailing to remote domains not supported
2018-12-05 19:03:15 1gUcS3-0000xg-SC <= <> R=1gUcS3-0000xe-Ps U=Debian-exim P=local S=1645
2018-12-05 19:03:15 1gUcS3-0000xe-Ps Completed
2018-12-05 19:03:15 1gUcS3-0000xg-SC => vagrant <vagrant@debian1> R=local_user T=mail_spool
2018-12-05 19:03:15 1gUcS3-0000xg-SC Completed
```

我们可以在这里看到一些非常明显的线条，我们也可以进一步扩展:

```sh
2018-12-05 19:03:15 1gUcS3-0000xe-Ps <= vagrant@debian1 U=vagrant P=local S=466
```

以下消息已到达`from vagrant@debian1` ( `<=`):

```sh
2018-12-05 19:03:15 1gUcS3-0000xe-Ps ** packt@example.co R=nonlocal: Mailing to remote domains not supported
```

邮件传递失败，因为地址被退回(`**`):

```sh
2018-12-05 19:03:15 1gUcS3-0000xg-SC <= <> R=1gUcS3-0000xe-Ps U=Debian-exim P=local S=1645
```

从 Debian-exim 收到了一条新消息:

```sh
2018-12-05 19:03:15 1gUcS3-0000xe-Ps Completed
```

原始信息的旅程已经结束:

```sh
2018-12-05 19:03:15 1gUcS3-0000xg-SC => vagrant <vagrant@debian1> R=local_user T=mail_spool
```

新消息已发给流浪用户(`=>`):

```sh
2018-12-05 19:03:15 1gUcS3-0000xg-SC Completed
```

新信息的旅程现在也结束了。

# 还有更多...

我要在这里向一个必不可少的 Exim 故障排除网站大声疾呼:http://bradthemad.org/tech/notes/exim_cheatsheet.php。

如果你发现自己被困在你知道 Exim 能做的一件事上，或者你确定你想收集的信息有一个特定的查询，看看布拉德的 Exim 备忘单——你不会是第一个。

感谢布拉德，帮助各地的管理员。

# NoSQL 文档(MongoDB 示例)

我们之前看了一下**结构化查询语言** ( **SQL** )服务，形式是 MariaDB 和 PostgreSQL。现在我们来看看以 NoSQL 方式在数据库中存储数据的“更新”方式。

与更传统的数据库中基于表的关系不同，NoSQL 数据库以其他方式存储数据(如键值存储、元组存储或文档存储)。近年来，由于大数据产品突然涌入市场，它们变得越来越突出，这些产品在很大程度上依赖于此类数据库进行存储。

如前所述，NoSQL 数据库可以有几种不同的形式，我们将在下一节(Redis)中查看一个例子。

当考虑为什么可能使用 NoSQL 数据库代替传统数据库时，您可能会考虑可伸缩性、灵活性和速度等方面，所有这些都是优秀的 NoSQL 设置的特征。

术语**数据库**可能更宽松、更准确地应用于 NoSQL 系统，它可以作为数据的基础，但可能不需要对其包含的数据使用结构化存储。

在本节中，我们将安装 MongoDB，并查看数据在其数据库中的存储方式。

LARGE DISCLAIMER: 
MongoDB is perhaps infamous for being a target for unscrupulous members of hacking society. This is because MongoDB can be installed with default settings that let it listen on the internet, on an open port, without any sort of access requirements enabled. THIS IS BAD, and you should always consider the security implications of what you're doing, prior to doing them. As with any application, security is primarily the responsibility of the administrator doing the installation and management. I go on and on about security in certain sections of this book, but it's important to hammer the point home. Too often, I've seen lackadaisical approaches to deploying servers (of all kinds) that result in a great big hole in your network. When given free reign, I've seen some very intelligent people do very silly things without thinking about it (such as leaving default admin credentials set on a public-facing build server), and Hanlon's razor always applies:
"Never attribute to malice that is adequately explained by stupidity."

# 准备好了

在本节中，我们将使用我们的 CentOS 机器，对其进行 SSH:

```sh
$ vagrant ssh centos1
```

安装 EPEL 存储库，然后安装 MongoDB:

```sh
$ sudo yum install epel-release -y
$ sudo yum install mongodb mongodb-server -y
```

We're using the EPEL repository for convenience here, but there are more ways to install MongoDB. Specifically, using the official repositories is the recommended approach for production systems.

# 怎么做...

安装完成后，您可以使用`mongod`守护程序启动并启用 MongoDB:

```sh
$ sudo systemctl enable --now mongod
```

默认情况下，MongoDB 将在本地主机端口 27017 上启动，但请使用`ss`或其他工具确认这一点:

```sh
$ ss -a '( sport = :27017 )'
State Recv-Q Send-Q Local Address:Port Peer Address:Port 
LISTEN 0 128 127.0.0.1:27017 *:* 
```

启动后，您可以使用`mongo`命令行工具连接到您的数据库:

```sh
$ mongo
```

前面命令的输出如下:

![](assets/f758a9d2-40e5-4b76-b3f2-de17647abac0.png)

注意，我们默认连接到`test`。我们可以使用`db`命令确认我们连接到了哪个数据库(如果我们错过了通知):

```sh
> db
test
```

我们可以通过使用`use`轻松地(以熟悉的方式)更改数据库:

```sh
> use local
switched to db local
```

在我们当前的数据库中，我们可以看到集合。因为我们已经切换到`local`，这些看起来如下:

```sh
> show collections
startup_log
system.indexes
```

使用集合的语法是`db.<collection name>.<blah>`，因此如果我们想要查询`startup_log`集合中的所有内容，我们可以执行以下操作:

```sh
> db.system.indexes.find()
{ "v" : 1, "key" : { "_id" : 1 }, "name" : "_id_", "ns" : "local.startup_log" }
```

显然，这有点乱，所以我们可以用`.pretty()`让它读起来更好看:

```sh
> db.system.indexes.find().pretty()
{
 "v" : 1,
 "key" : {
 "_id" : 1
 },
 "name" : "_id_",
 "ns" : "local.startup_log"
}
```

您应该已经看到了与 SQL 数据库的相似之处，尽管在许多情况下语法大相径庭。

让我们返回到我们的`test`数据库，创建一个我们自己的集合:

```sh
> use test
switched to db test
> db.distributions.insert( { name: "Ubuntu", developer: "Canonical Ltd.", initial_year: 2004 } )
WriteResult({ "nInserted" : 1 })
```

现在，通过对该集合执行查找，我们应该会看到刚刚插入的数据:

```sh
> db.distributions.find().pretty()
{
 "_id" : ObjectId("5c081ba9832e06b5d1b64d50"),
 "name" : "Ubuntu",
 "developer" : "Canonical Ltd.",
 "initial_year" : 2004
}
```

让我们添加另一行，这次添加了更多字段:

```sh
> db.distributions.insert( { name: "Alpine Linux", developer: "Alpine Linux development team", initial_year: 2010, first_version: 2.0, forked_from: "LEAF Project" } )
WriteResult({ "nInserted" : 1 })
```

让我们再次执行我们的查找:

```sh
> db.distributions.find().pretty()
{
 "_id" : ObjectId("5c081ba9832e06b5d1b64d50"),
 "name" : "Ubuntu",
 "developer" : "Canonical Ltd.",
 "initial_year" : 2004
}
{
 "_id" : ObjectId("5c081c31832e06b5d1b64d51"),
 "name" : "Alpine Linux",
 "developer" : "Alpine Linux development team",
 "initial_year" : 2010,
 "first_version" : 2,
 "forked_from" : "LEAF Project"
}
```

请注意，虽然我们的插入很好，但是`first_version`字段中的`2.0`已经被简化为一个整数。

如果我们想缩小搜索范围，我们可以专门用 Ubuntu 的`name`来搜索条目:

```sh
> db.distributions.find({"name": "Ubuntu"}).pretty()
{
 "_id" : ObjectId("5c081ba9832e06b5d1b64d50"),
 "name" : "Ubuntu",
 "developer" : "Canonical Ltd.",
 "initial_year" : 2004
}
```

或者，如果我们只想打印特定的值(这里只有名称)，我们可以使用以下内容:

```sh
> db.distributions.find( {}, {"name": 1, "_id": 0} ).pretty()
{ "name" : "Ubuntu" }
{ "name" : "Alpine Linux" }
```

注意这个查询的奇怪结构，我们指定了`1`来包含名称，但是`0`省略了`_id`，默认情况下是包含的。

您还可以做很多其他的事情，包括通过特定的查询进行搜索(在本例中，查找所有`initial_year`大于`2004`的条目):

```sh
> db.distributions.find({"initial_year": { $gt: 2004}}).pretty()
{
 "_id" : ObjectId("5c081c31832e06b5d1b64d51"),
 "name" : "Alpine Linux",
 "developer" : "Alpine Linux development team",
 "initial_year" : 2010,
 "first_version" : 2,
 "forked_from" : "LEAF Project"
}
```

但是，具体来说，我们对这种存储数据的方法和传统方法之间的差异感兴趣。

# 它是如何工作的...

由于我们使用的是`documents`并且事物是动态创建的(而不是用严格的数据集填充的表)，我们前面的命令看起来比传统的数据库要特别得多。

当我们创建我们的收藏时，我们不需要定义任何东西。我们只是开始在测试数据库中写入数据:

```sh
> db.distributions.insert( { name: "Ubuntu", developer: "Canonical Ltd.", initial_year: 2004 } )
```

从那里，我们能够添加更多的数据，然后才开始查询我们刚刚写的内容。

我们随后添加的数据并不重要，虽然我们编写的文档中存在相关性，例如名称、开发人员和`initial_year`字段，但有些字段是我们第二次插入时独有的。数据库不在乎。

由于这种将数据存储在数据库中的方法，NoSQL 系统在输入方面可以被视为更加灵活。

这些数据现在存储在 MongoDB 中，任何想要查询它的程序(通常是 Node.js 应用程序)都可以快速轻松地访问这些数据。

使用另一个查询，我们可以准确地看到`dbPath`值在哪里:

```sh
> use local
switched to db local
> db.startup_log.find( {}, {"cmdLine.storage": 1} ).pretty()
{
 "_id" : "centos1-1544033443006",
 "cmdLine" : {
 "storage" : {
 "dbPath" : "/var/lib/mongodb"
 }
 }
}
```

这意味着我们还可以在主机系统上查看它:

```sh
$ sudo ls -l /var/lib/mongodb/
total 163844
drwxr-xr-x. 2 mongodb mongodb 29 Dec 5 18:40 journal
-rw-------. 1 mongodb mongodb 67108864 Dec 5 18:10 local.0
-rw-------. 1 mongodb mongodb 16777216 Dec 5 18:10 local.ns
-rwxr-xr-x. 1 mongodb mongodb 6 Dec 5 18:10 mongod.lock
-rw-------. 1 mongodb mongodb 67108864 Dec 5 18:42 test.0
-rw-------. 1 mongodb mongodb 16777216 Dec 5 18:42 test.ns
drwxr-xr-x. 2 mongodb mongodb 6 Dec 5 18:40 _tmp
```

# 还有更多...

我建议 EPEL 版的 MongoDB 是旧的。在撰写本文时，这是真的，所以如果您想在自己的系统中使用 MongoDB，尝试上游存储库的最新版本是个好主意。

同样，我想强调的一点是，如果您计划在生产中使用它，那么在您的系统上启用某种安全性也是必须的。

此外，如果你还在考虑 NoSQL 数据库可能比传统的 PostgreSQL 或 MySQL 更有用的情况，可以考虑一些事情，比如日志记录。

您希望日志文件是一致的，每个文件中有相同的字段和相同类型的数据。但是，日志文件可能会改变，它们的顺序可能会不同，类型可能会突然改变，字段数量可能会增加。

如果您使用传统数据库作为这些日志的后端(完全有可能)，那么在最好的情况下您必须添加新的表，或者在最坏的情况下使用完全不同的数据库。

将这些相同的日志传送到一个 NoSQL 系统中，这个系统是专门为处理文档而设计的，根本不应该影响系统的运行，因为收集的日志只会适应您提供的新信息。

# NoSQL KV (Redis 示例)

我们已经了解了一种类型的 NoSQL 数据库，它的形式是 MongoDB(一个特定于文档的实例)。现在我们来看一个不同类型的 NoSQL 数据库，特别是 Redis，它是一个**键值** ( **KV** )产品。

它的独特卖点是它是一个完全在内存中的数据库(如果需要的话，还会定期写入磁盘)。这意味着 Redis 不仅是存储您正在操作或使用的数据的绝佳缓存，而且速度极快。

由于 Redis 的设计，它是网络堆栈设置中常见的组件，其中速度对于有效处理请求很重要。

值得注意的是对 NoSQL 数据库的一个批评，该数据库用于 Redis 和其他数据库，在特定场景下数据很容易丢失。因为 Redis 主要将其数据存储在内存中，偶尔会写入磁盘，所以节点的灾难性故障有可能导致数据丢失，即使它只值几秒钟。

# 准备好

在本节中，我们将再次使用我们的 CentOS 虚拟机。

SSH 到您的 CentOS 机器:

```sh
$ vagrant ssh centos1
```

安装 EPEL 存储库，然后安装 MongoDB:

```sh
$ sudo yum install epel-release -y
$ sudo yum install redis -y
```

Again, we're using EPEL for convenience, but more up-to-date offerings are out there, and one of the most preferred ways of running Redis is in Docker containers.

# 怎么做...

开箱后，systemd 将使用`/etc/redis.conf`配置文件启动 redis-server 二进制文件。让我们现在就开始做吧:

```sh
$ sudo systemctl enable --now redis
Created symlink from /etc/systemd/system/multi-user.target.wants/redis.service to /usr/lib/systemd/system/redis.service.
```

正在使用的默认端口是`6379`，我们可以使用`ss`再次检查:

```sh
$ ss -a '( sport = :6379 )'
State Recv-Q Send-Q Local Address:Port Peer Address:Port 
LISTEN 0 128 127.0.0.1:6379 *:* 
```

这里，我们正在监听本地主机端口`6379`:

The same warning as ever applies: If you start opening any of your installed services, make sure they're secure and aren't about to let bad actors steal your data.

从命令行使用`redis-cli`连接到一个实例，简单地调用它应该会让您进入 Redis shell:

```sh
$ redis-cli
127.0.0.1:6379> 
```

Redis 建议使用`ping`查看 Redis 是否响应正常:

```sh
127.0.0.1:6379> ping
PONG
```

因为 Redis 是一个 KV 存储，与之交互的语法可以非常简单。以下示例使用字符串值创建一个键:

```sh
127.0.0.1:6379> set distro centos
OK
```

要检索这些数据，我们使用`get`:

```sh
127.0.0.1:6379> get distro
"centos"
```

如果我们想设置一个整数值，我们只需指定它:

```sh
> set number_of_linux_distros 20
OK
```

然后，每当创建一个新的 Linux 发行版时，我们就可以增加它:

```sh
127.0.0.1:6379> incr number_of_linux_distros
(integer) 21
127.0.0.1:6379> incr number_of_linux_distros
(integer) 22
127.0.0.1:6379> incr number_of_linux_distros
(integer) 23
127.0.0.1:6379> incr number_of_linux_distros
(integer) 24
127.0.0.1:6379> incr number_of_linux_distros
(integer) 25
127.0.0.1:6379> get number_of_linux_distros
"25"
```

你也不局限于一次得到一个`mget`:

```sh
127.0.0.1:6379> mget distro number_of_linux_distros
1) "centos"
2) "25"
```

你可能想知道这有什么用。我的意思是，当然，这很快，但它真的这么好，以至于它成为任何像样的网络堆栈不可或缺的一部分吗？

Redis 可以做得更多，包括将二进制数据(如图像)存储为键值；它可以创建生存时间短的密钥，这意味着它可以用于临时缓存；它可以聚集在一起。

如何使用它通常取决于应用程序的程序员，而不是负责设置它的管理员。然而，这并不意味着如果您的开发人员都围坐在桌子旁摸不着头脑，试图想出一个内存中的键值存储来作为网站数据的缓存，您就不能建议这样做。

# 它是如何工作的...

我们将 Redis 作为服务启动，使用`/etc/redis.conf`作为配置文件(默认)。

在编写本文时，EPEL 版本附带的默认设置意味着当它启动时，它位于本地主机地址(`127.0.0.1`)和端口`6379`:

```sh
$ sudo cat /etc/redis.conf | grep "port 6379\|^bind 127.0.0.1"
bind 127.0.0.1
port 6379~
```

此处的设置还设置了模式(默认情况下受保护)，该模式规定了 Redis 在侦听其他端口时如何启动:

```sh
# By default protected mode is enabled. You should disable it only if
# you are sure you want clients from other hosts to connect to Redis
# even if no authentication is configured, nor a specific set of interfaces
# are explicitly listed using the "bind" directive.
protected-mode yes
```

懂事！

我们知道 Redis 在内存中，但是它偶尔也会写到磁盘上。

该数据库转储可在配置文件的给定目录中查看:

```sh
$ sudo ls /var/lib/redis
dump.rdb
```

除非设置`appendonly`值，否则这个数据库文件会稍微落后于正在运行的实例，这意味着如果 Redis 或服务器崩溃，您可能会丢失几秒钟的数据。

How robust you want your data to be is generally up to the application developers. If they don't mind the possibility that you might lose a second or two of data, meaning a value might not be cached or similar, then you might want to not take the performance impact of writing everything to disk as fast as you can.

# 消息代理和队列(RabbitMQ 示例)

从各种形状和大小的数据库开始，在这一节中，我们将看一些非常不同的东西，以一个名为 RabbitMQ 的消息传递软件的形式。

像 Redis 一样，RabbitMQ 是许多现代网络应用程序的主要部分，因为它是开源的，并且是众所周知的。

”*但是什么是消息队列呢？*”

我知道你会问这个问题，除非你已经知道了，在这种情况下，这个部分对你来说可能有点没用。

通常利用**高级消息队列协议** ( **AMQP** )的**消息队列**是消息代理的一部分，消息代理是作为应用程序堆栈的一部分用于发送和接收消息的软件。

这些消息通常是从不同的组件发送的，这些组件可以以不同的方式交谈和收听。消息传递代理可以促进这些组件之间的对话。

您通常会发现消息代理和队列开始进入关于“解耦”的对话，这是一种暗示应用程序堆栈的不同元素不应该如此相互依赖的奇特方式。

想象一个网络服务器，与一个数据处理应用程序对话。在旧世界中，web 服务器会直接与处理应用程序对话，在等待响应的同时来回发送消息。这在平面设计中可能是好的，但是你会冒前端网站被锁定的风险，而后端处理应用程序会被一个棘手的任务卡住。

可以使用消息代理来代替这种直接通信，虽然它确实依赖于 web 开发人员编写不依赖于来自后端的直接或即时响应的代码，但它有效地解除了后端应用程序工作(或根本不在那里)的硬依赖。

理论上。你可以从队列中取出一个数据库，替换它，而前端网站不会知道。

You also tend to see RabbitMQ (and others) in designs for distributed and redundant setups, instead of one website talking to one processing the backend, several frontends, and several backends just talk to the queue, taking and processing messages as they see fit.

# 准备好

在本节中，我们将使用我们的 Debian 盒子...只是为了改变一下。

连接到`debian1`，如是:

```sh
$ vagrant ssh debian1 -- -L 127.0.0.1:15672:127.0.0.1:15672
```

记下转发的端口，以便以后访问管理界面。

A word of warning: RabbitMQ starts on all interfaces by default in this setup, so you should ensure that you have a firewall keeping those ports inaccessible from the outside. If you're just working on the Vagrant test VM for this, then it should only be set up for a local network anyway.

从默认存储库中安装`rabbitmq-server`:

```sh
$ sudo apt install rabbitmq-server -y
```

# 怎么做...

一旦安装，兔子应该会自动启动(啊，Debian)。这意味着我们可以立即看到`ps`在运行什么(以及它运行的默认用户，`rabbitmq`):

```sh
$ ps -fu rabbitmq
UID PID PPID C STIME TTY TIME CMD
rabbitmq 5085 1 0 14:25 ? 00:00:00 /bin/sh /usr/sbin/rabbitmq-server
rabbitmq 5094 5085 0 14:25 ? 00:00:00 /bin/sh -e /usr/lib/rabbitmq/bin/rabbitmq-server
rabbitmq 5244 1 0 14:25 ? 00:00:00 /usr/lib/erlang/erts-8.2.1/bin/epmd -daemon
rabbitmq 5307 5094 0 14:25 ? 00:00:02 /usr/lib/erlang/erts-8.2.1/bin/beam -W w -A 64 -P 1048576 -t 5000000 -stbt db -zdbbl 32000 -K true -B i -- -root /usr/lib/erlang
rabbitmq 5417 5307 0 14:25 ? 00:00:00 erl_child_setup 65536
rabbitmq 5442 5417 0 14:25 ? 00:00:00 inet_gethost 4
rabbitmq 5443 5442 0 14:25 ? 00:00:00 inet_gethost 4
```

由此，我们可以立即看到 RabbitMQ 使用了 Erlang，并且使用了`/usr/lib/rabbitmq/bin/rabbitmq-server`脚本来启动服务器。

首先，让我们设置 RabbitMQ 管理界面:

```sh
$ sudo rabbitmq-plugins enable rabbitmq_management
The following plugins have been enabled:
 mochiweb
 webmachine
 rabbitmq_web_dispatch
 amqp_client
 rabbitmq_management_agent
 rabbitmq_management

Applying plugin configuration to rabbit@debian1... started 6 plugins.
```

现在，您应该能够在本地机器上点击这个界面。

导航到`http://127.0.0.1:15672`，您应该会看到如下内容:

![](assets/37c2bcb0-4b83-4b26-a031-781ac6aaa53f.png)

默认用户名和密码为`guest` / `guest`。

Going back to my security point from earlier, this highlights the need to set up and configure software in a secure testing environment, with absolutely no production data, prior to going anywhere near a live environment.

登录后，您应该会看到:

![](assets/35e8c3a8-5a34-497f-a19f-5b5c79edb94c.png)

RabbitMQ overview page

通常，我会建议从命令行界面开始，但碰巧这是一个可视化兔子是什么以及它在做什么的好方法。

在这个屏幕的顶部，我们有我们的总计，它是兔子当前知道的消息的细分(它现在是空闲的)。

在节点部分，我们可以直接看到我们有一个名为`rabbit@debian1`的单个节点，并且我们有它当前使用情况的细分。

我们还有一个 Rabbit 查找的相关路径列表，包括配置文件(当前不在那里)和实际的数据库目录。还有各种日志文件的信息。

点击一下这个界面(虽然你可能会发现它有点稀疏)。

回到命令行，让我们看看如何在没有启用 web 界面的远程服务器上查询信息。

首先列出队列:

```sh
$ sudo rabbitmqctl list_queues
Listing queues ...
```

这是空的，正如我们在图形用户界面上看到的(如果您单击了队列选项卡)。

默认情况下，我们有一个`vhost`，这是一种分割 RabbitMQ 的方法(就像 Apache 和 Nginx 中的 vhosts 一样):

```sh
$ sudo rabbitmqctl list_vhosts
Listing vhosts ...
/
```

我们可以看看配置的用户:

```sh
$ sudo rabbitmqctl list_users
Listing users ...
guest [administrator]
```

我们还可以创建用户:

```sh
$ sudo rabbitmqctl add_user exampleUser examplePassword
Creating user "exampleUser" ...
```

让我们创建一个`vhost`来配合它:

```sh
$ sudo rabbitmqctl add_vhost exampleVhost
Creating vhost "exampleVhost" ...
```

现在让我们给我们的用户访问所说的`vhost`:

```sh
$ sudo rabbitmqctl set_permissions -p exampleVhost exampleUser ".*" ".*" ".*"
Setting permissions for user "exampleUser" in vhost "exampleVhost" ...
```

# 它是如何工作的...

我们所做的大部分应该是不言自明的，除了权限行:

```sh
$ sudo rabbitmqctl set_permissions -p exampleVhost exampleUser ".*" ".*" ".*"
```

在这里，我们特别授予用户`configure`、`write`和`read`访问权限。这意味着在`exampleVhost vhost`内，我们的用户将完全可以随心所欲。

Access is granted here by way of Regex, meaning that you can have more fine-grained control over what a user can and can't access within a `vhost`.

像 Redis 一样，RabbitMQ 在没有设置和没有应用程序与之对话的情况下真的做不了什么。

各种语言都有与 RabbitMQ 接口的方式。通常由您公司的开发人员来决定他们将如何写入队列，他们将写入哪些队列，一旦完成，他们将如何从这些队列中读取，以及他们将使用什么语言。

可悲的是，从管理员的角度来看，您很少会与 RabbitMQ 的实际请求和操作有任何关系。您的大部分工作将围绕确保安全性到位(TLS、用户身份验证等)和确保集群保持一致展开。

我强烈建议浏览一下兔子文档，看看他们的一些快速入门指南，以便与兔子互动。如果你有开发人员的思维模式，或者你只是喜欢用 Python 脚本进行黑客攻击，这可能是一个深入了解这个消息传递代理和一般消息传递代理的好方法。

# 综述-网络服务器、数据库和邮件服务器

在这一章中，我有意尝试谈论一些目前市场上最受欢迎的技术，包括我知道事实上拥有很大头脑和市场份额的程序。其中一些软件已经存在了很长时间，接近几十年，但最近更多的软件加入了这一领域，这在很大程度上归功于 2010 年代后半期云计算的爆炸式发展。

当我们谈论网络服务器、邮件服务器和数据库时，它们有各种形状和大小，这意味着很难提出绝对适合所有用例的合理默认值。我能给出的唯一普遍的建议是，不要为了简单而牺牲安全性。(最近几个月和几年，您可能已经阅读了足够多的关于漏洞和安全漏洞的信息，您希望确保自己的名字不会与此类灾难性事件联系在一起。)

这并不是说这东西不好玩。人们对 NoSQL 数据库、消息经纪人甚至邮件服务器所做的奇怪而奇妙的事情对很多人来说都非常有趣，其中一个人可能就是你！

我也不想让你放弃自己运行这些东西的想法，尤其是现在这些东西大部分都可以从各种云提供商和第三方“作为服务”获得。当你自己安装和配置这些东西时，它可以是一个很好的学习体验，教你某些程序的好与坏。

还有一件事需要注意，在我看来，伙计。

我不喜欢在同一个基础设施中混合类似的技术。如果您需要一个 SQL 数据库，并且您以前从未在您的基础架构中使用过，那么在决定使用 MariaDB 或 PostgreSQL 之前，考虑一下它是很好的。大多数现代软件只想要某种 SQL 后端，它不在乎什么软件提供它。

你安装的那个 GitLab 服务器？也许您已经决定使用 PostgreSQL。

现在你有一个 WordPress 实例要设置了？再次使用 PostgreSQL。

你需要连接 Icinga2 的东西吗？请尝试 PostgreSQL。

想象一下，如果你决定一方面使用 MariaDB，另一方面使用 MySQL，第三方面使用 PostgreSQL，你会有多头疼。除非有一个非常好的理由使用一个而不是另一个，否则我非常喜欢让您的基础架构尽可能简单。这样，当您必须学习一点 SQL 来正确管理数据库时，您只需要担心某个 SQL 提供程序的复杂性，而不是三个不同的提供程序。

这也是全面的——如果你必须为某个东西设置一个邮件服务器，我总是倾向于在 Debian 和 CentOS 机器上设置 Postfix，这样我就知道在日志和配置指令方面该去哪里找了，而不管我使用的是什么操作系统。

事实上，划一下！更进一步，选择单个操作系统进行部署，摒弃任何混合 Debian、CentOS 和 Ubuntu 部署的想法。

从逻辑上讲，这不仅可以让您在管理组件时保持理智，还可以大幅减少基础架构，因为您需要维护代码、镜像存储库以及订阅安全邮件列表。

但是在你自己的时间里？嗯，这取决于你——去疯，玩，学。

# 超级个人喜好时间！

如果你把我绑在椅子上，说我必须选择我更喜欢的软件，我会说:

*   Postfix > Exim
*   nginx > apache
*   MariaDB > PostgreSQL

注:这是半开玩笑；不要把这些放在心上。