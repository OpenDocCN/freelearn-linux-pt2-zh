# 十七、执行管理安全任务

在最后一章中，我们介绍了 IPv4、IPv6、客户端 DNS 和网络故障排除。我们使用了 IPv4 并讨论了 IPv4 路由，然后，我们对 IPv6 做了同样的事情。这导致客户端 DNS 和网络故障排除；我们介绍了许多命令行工具，这些工具有助于排除潜在的网络连接问题。

在本章中，我们将重点讨论安全性:主机安全性、SSH 和加密。首先，我们将涵盖主机安全；`/etc/sudoers`、`/etc/hosts.allow`和`/etc/.hosts.deny`文件将是我们的主要关注点。接下来，我们将使用 SSH。我们将重点介绍设置 SSH 所涉及的步骤，以及生成密钥的步骤。我们还将研究使用 SSH 登录到远程系统。此外，我们将使用我们可用的各种 SSH 文件。加密将是我们的下一个焦点；我们将研究加密和解密文件的方法。就保护 Linux 系统而言，这将是重要的一章。

我们将在本章中讨论以下主题:

*   主机安全性
*   嘘
*   加密

# 主机安全性

在 Linux 中，我们可以执行一系列安全任务来保护我们的系统。到目前为止，我们已经作为根用户执行了大部分管理任务。相反，我们可以作为普通用户执行其中一些任务吗？好吧，我们可以使用一个常规用户帐户，并赋予它一定的 root 权限，而不必以 root 用户的身份登录。这可以通过`/etc/sudoers`文件来实现。在这个演示中，我们将使用 Fedora 28 系统。如果我们试图查看`/boot/grub2/`内部的引导文件，我们将看到以下内容:

```sh
[philip@localhost ~]$ ls /boot/grub2/
ls: cannot open directory '/boot/grub2/': Permission denied
[philip@localhost ~]$
```

基于前述信息，用户没有足够的权限查看`/boot/grub2`的内容；我们收到了一条`Permission denied`消息。此外，如果我们尝试进行更改(例如添加一个 IP 地址)，我们将看到以下内容:

```sh
[philip@localhost ~]$ ip a s ens33
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
 link/ether 00:0c:29:04:35:bd brd ff:ff:ff:ff:ff:ff
 inet 172.16.175.129/24 brd 172.16.175.255 scope global dynamic noprefixroute ens33
 valid_lft 1700sec preferred_lft 1700sec
 inet 172.16.11.0/23 scope global ens33
 valid_lft forever preferred_lft forever
 inet6 2001:db8:0:f101::3/64 scope global
 valid_lft forever preferred_lft forever
 inet6 fe80::413:ea63:2e8a:5f2b/64 scope link noprefixroute
 valid_lft forever preferred_lft forever
[philip@localhost ~]$ ip a a 10.20.1.1/24 dev ens33
RTNETLINK answers: Operation not permitted
[philip@localhost ~]$
```

根据前面的信息，我们将执行第一个命令-`IP`命令，带有`a`和`s`选项(`a`代表地址，`s`代表显示)—但是当我们尝试添加一个 IP 地址时，我们会收到一条`Operation not permitted`消息。消息会有所不同，这取决于您是否试图查看，因为这是`ls`命令的情况，而不是在后一个演示中进行更改。

# 苏军司令部

解决标准用户权限问题的一种方法是使用`su`命令；`su`是指**的替代用户**。`su`命令的基本语法如下:

```sh
su <option>
```

基于前面的命令，我们也可以在不使用任何选项的情况下使用`su`命令，如下命令所示:

```sh
[philip@localhost ~]$ su
Password:
[root@localhost philip]#
```

太棒了。当我们在没有任何选项的情况下使用`su`命令时，它会提示我们输入 root 密码，然后以 root 用户身份登录。然而，出于安全考虑，这可能并不理想。一个更好的方法是我们执行一个命令，但不作为根用户登录；这可以通过传递期望用户帐户名称的`-l`选项和期望命令的`-c`选项来实现。下面的命令显示了我们如何使用`su`命令有效地显示`/boot/grub2/`目录的内容，同时保持作为标准用户登录:

```sh
[philip@localhost ~]$ su -l root -c 'ls /boot/grub2/'
Password:
device.map  fonts  grub.cfg  grubenv  i386-pc  locale  themes
[philip@localhost ~]$
```

太棒了！现在将显示`/boot/grub2/`目录的内容。但是，内容将显示为没有任何颜色(除了白色)；我们可以通过`--color`选项指示`ls`命令显示颜色，就像我们以 root 用户身份登录一样。如下所示:

![](img/00164.jpeg)

太棒了。当我们省略`--color`选项时，我们可以看到区别，而不是将其包含在`ls`命令中。此外，当命令之间有空格时，我们必须用单引号(`'`)将整个命令括起来。另一个有用的选项是`-s`选项；这告诉`su`命令使用用户提供的指定 shell，如下图所示:

![](img/00165.jpeg)

太棒了！当我们使用`-s`选项并指定 shell(在我们的例子中为`/usr/sbin/sh`)时，我们不需要使用`ls`命令来指定`--color`选项。

使用`su`命令的另一种方法是传递`-`选项，该选项暗示根用户，如下所示:

```sh
[philip@localhost ~]$ su - -c 'ls /boot/grub2/' -s /usr/bin/sh
Password:
device.map  fonts  grub.cfg  grubenv  i386-pc  locale  themes
[philip@localhost ~]$
```

完美！显示内容，我们没有指定登录`root`。通过查看`/etc/shells`文件内部，我们可以看到一个Shell列表，如下所示:

```sh
[philip@localhost ~]$ cat /etc/shells
/bin/sh
/bin/bash
/sbin/nologin
/usr/bin/sh
/usr/bin/bash
/usr/sbin/nologin
/usr/bin/tmux
/bin/tmux
[philip@localhost ~]$
```

太棒了。我们可以看到可以与`su`命令的`-s`选项一起使用的各种Shell。到目前为止，我们只查看了`su`命令的内容，但是我们也可以对其进行更改。以下命令显示了如何使用`su`命令进行更改:

```sh
[philip@localhost ~]$ su - -c 'ip a a 172.20.1.1/24 dev ens33'
Password:
[philip@localhost ~]$ ip a s ens33 | grep inet
 inet 172.16.175.129/24 brd 172.16.175.255 scope global dynamic noprefixroute ens33
 inet 172.16.11.0/23 scope global ens33
 inet 172.20.1.1/24 scope global ens33
 inet6 2001:db8:0:f101::3/64 scope global
 inet6 fe80::413:ea63:2e8a:5f2b/64 scope link noprefixroute
[philip@localhost ~]$
```

太棒了！已成功添加 IP 地址。

使用`su`命令的一个主要缺点是每个用户都必须知道根密码才能执行它。

# 苏多司令部

`sudo`命令解决了标准用户需要根密码的困境，只要用户的账号驻留在`/etc/sudoers`配置文件中即可。`sudo`命令的基本语法如下:

```sh
sudo <command>
```

除了前面的命令，我们只需指定要执行的命令，这通常需要 root 权限。让我们尝试如下`sudo`命令:

```sh
[philip@localhost ~]$ sudo ls /boot/grub2/
[sudo] password for philip:
device.map  fonts  grub.cfg  grubenv  i386-pc  locale  themes
[philip@localhost ~]$
```

太棒了！当我们执行`sudo`命令并传递需要 root 权限的命令时，系统会提示我们输入标准用户的密码，而不是 root 用户的密码。之后，我们可以用`sudo`命令传递另一个命令，并且不会提示我们输入密码，如下面的代码片段所示:

```sh
[philip@localhost ~]$ sudo ip a a 192.168.5.5/24 dev ens33
[philip@localhost ~]$ ip a | grep inet
 inet 127.0.0.1/8 scope host lo
 inet6 ::1/128 scope host
 inet 172.16.175.129/24 brd 172.16.175.255 scope global dynamic noprefixroute ens33
 inet 172.16.11.0/23 scope global ens33
 inet 172.20.1.1/24 scope global ens33
 inet 192.168.5.5/24 scope global ens33
 inet6 2001:db8:0:f101::3/64 scope global
 inet6 fe80::413:ea63:2e8a:5f2b/64 scope link noprefixroute
[philip@localhost ~]$
```

太棒了。该命令成功执行，不需要用户密码。这是可能的，因为存在保存用户密码的超时设置；时间过去后，系统会提示我们再次输入用户密码。但是，在用户打开另一个终端的情况下，情况并非如此，如下图所示:

![](img/00166.jpeg)

太棒了。我们可以看到超时值不会影响新的终端，因为系统会提示用户输入密码。

可能有些时候我们更喜欢增加超时值，尤其是当我们要工作很长一段时间的时候。放心；我们可以通过在`/etc/sudoers`文件中搜索`env_reset`并在旁边附加`timestamp_timeout`选项来增加超时值。`/etc/sudoers`文件的内容如下:

```sh
## Sudoers allows particular users to run various commands as
## the root user, without needing the root password.
## This file must be edited with the 'visudo' command.
## Host Aliases
## Groups of machines. You may prefer to use hostnames (perhaps using
## wildcards for entire domains) or IP addresses instead.
# Host_Alias     FILESERVERS = fs1, fs2
# Host_Alias     MAILSERVERS = smtp, smtp2
## User Aliases
## These aren't often necessary, as you can use regular groups
## (ie, from files, LDAP, NIS, etc) in this file - just use %groupname
## rather than USERALIAS
# User_Alias ADMINS = jsmith, mikem
## Command Aliases
## These are groups of related commands...
## Networking
# Cmnd_Alias NETWORKING = /sbin/route, /sbin/ifconfig, /bin/ping, /sbin/dhclient, /usr/bin/net, /sbin/iptables, /usr/bin/rfcomm, /usr/bin/wvdial, /sbin/iwconfig, /sbin/mii-tool
## Installation and management of software
Defaults    env_reset
Defaults    env_keep =  "COLORS DISPLAY HOSTNAME HISTSIZE KDEDIR LS_COLORS"
## Allow root to run any commands anywhere
root       ALL=(ALL)            ALL
## Allows people in group wheel to run all commands
%wheel                ALL=(ALL)            ALL
## Same thing without a password
# %wheel            ALL=(ALL)            NOPASSWD: ALL
#includedir /etc/sudoers.d
[philip@localhost ~]$
```

在前面的代码中，为了简洁起见，省略了一些输出。我们可以改变许多选择。例如，要增加超时值，我们可以使用 visudo 编辑器编辑`/etc/sudoers`；强烈建议不要使用 visudo 以外的任何编辑器，如下所示:

```sh
[philip@localhost ~]$ sudo cat /etc/sudoers | grep env_reset
Defaults    env_reset,timestamp_timeout=60
[philip@localhost ~]$
```

太棒了！我们添加了`timestamp_timeout=60`；这告诉`sudo`保存用户密码 60 分钟。另一个有用的设置选项是在我们键入用户密码时看到输出；可以为用户键入的每个键显示星号(`*`)。这可以通过在`env_reset`选项旁边附加`pwfeedback`选项来实现，如下所示:

```sh
[philip@localhost ~]$ sudo cat /etc/sudoers | grep env_reset
Defaults    env_reset,timestamp_timeout=60,pwfeedback
[philip@localhost ~]$
```

根据前面的命令，当用户第一次尝试使用`sudo`命令时，密码将用星号表示，如下所示:

```sh
[philip@localhost ~]$ sudo ls /boot/grub2/
[sudo] password for philip: *******
device.map  fonts  grub.cfg  grubenv  i386-pc  locale  themes
[philip@localhost ~]$
```

太棒了！我们现在可以看到代表键入密码的星号。

当我们添加新用户时，新用户不会自动添加到`/etc/sudoers`文件中。我们必须手动添加用户，如下所示:

```sh
[philip@localhost ~]$ sudo useradd teddy
[philip@localhost ~]$ sudo passwd teddy
Changing password for user teddy.
New password:
BAD PASSWORD: The password fails the dictionary check - it is based on a dictionary word
Retype new password:
passwd: all authentication tokens updated successfully.
[philip@localhost ~]$
```

现在，我们可以通过在计算机上注销和重新登录，或者使用`su`命令来切换用户，如下所示:

```sh
[philip@localhost ~]$ su teddy
Password:
[teddy@localhost philip]$
```

我们已作为新用户成功登录；现在，当我们尝试发出`sudo`命令时，结果将如下:

```sh
[teddy@localhost philip]$ sudo ls /boot/grub2/
We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:
 #1) Respect the privacy of others.
 #2) Think before you type.
 #3) With great power comes great responsibility.
[sudo] password for teddy:
teddy is not in the sudoers file.  This incident will be reported.
[teddy@localhost philip]$
```

我们会收到一条通知消息，但是当我们输入新用户的密码时，我们会收到可怕的`teddy is not in the sudoers file`消息以及`This incident will be reported`。这基本上告诉我们必须将新用户添加到`/etc/sudoer`文件中。这可以通过多种方式实现；一种可能是最简单的方法是将新用户添加到`wheel`组。`wheel`组可以执行所有命令，如`/etc/sudoer`文件所示:

```sh
[philip@localhost ~]$ sudo cat /etc/sudoers | grep wheel
## Allows people in group wheel to run all commands
%wheel                ALL=(ALL)            ALL
# %wheel            ALL=(ALL)            NOPASSWD: ALL
[philip@localhost ~]$
```

可以看到，`wheel`组存在，拥有完全访问权限；我们可以使用`usermod`命令并传递`-a`和`-G`选项(`a`用于追加，`G`用于组)，如下所示:

```sh
[philip@localhost ~]$ usermod -aG wheel teddy
usermod: Permission denied.
usermod: cannot lock /etc/passwd; try again later.
[philip@localhost ~]$
```

我们需要 root 权限来修改另一个用户的属性；我们可以使用`sudo`命令，如下所示:

```sh
[philip@localhost ~]$ sudo usermod -aG wheel teddy
[philip@localhost ~]$ su teddy
Password:
 [teddy@localhost philip]$ sudo ls /boot/grub2/
[sudo] password for teddy: 
device.map  fonts  grub.cfg  grubenv  i386-pc  locale  themes
[teddy@localhost philip]$
```

太棒了！新用户现在可以使用`sudo`命令。让我们检查一下在`/etc/sudoer`内部添加条目的语法，如下所示:

```sh
[teddy@localhost philip]$ sudo cat /etc/sudoers | grep %
%wheel                ALL=(ALL)           ALL
[teddy@localhost philip]$
Based on the above, the syntax for an entry is as follows:
<user/group> <system/ALL> = <effective user/ALL> <command(s)>
```

我们可以为一个特定的用户或组定义一个条目(我们必须在一个组的名称前面加上一个`%`)；然后，我们可以指定我们想要哪个系统的条目，我们想要允许哪个用户执行命令，最后是实际的命令。让我们试一试；我们将从新用户中删除`wheel`组，并为新用户创建一个条目，如下所示:

```sh
[philip@localhost ~]$ sudo usermod -G "" teddy
[philip@localhost ~]$ groups teddy
teddy : teddy
[philip@localhost ~]$ sudo cat /etc/sudoers | grep teddy
teddy ALL=(ALL) /usr/sbin/ls
[philip@localhost ~]$
```

太棒了！我们已经限制新用户只能执行`ls`和`cat`命令；这可以证明如下:

```sh
[philip@localhost ~]$ su teddy
Password:
[teddy@localhost philip]$ sudo ls /boot/grub2/
device.map  fonts  grub.cfg  grubenv  i386-pc  locale  themes
[teddy@localhost philip]$ sudo cat /etc/resolv.conf
Sorry, user teddy is not allowed to execute '/usr/bin/cat /etc/resolv.conf' as root on localhost.localdomain.
[teddy@localhost philip]$
```

太棒了！新用户只能使用具有 root 权限的`ls`命令，不能使用`sudo`命令进行任何其他更改。此外，我们可以授予新用户执行指定数量的命令的能力，如下所示:

```sh
[philip@localhost ~]$ sudo cat /etc/sudoers | grep teddy
teddy    ALL=(ALL)            /usr/bin/ls,         /usr/bin/cat
[philip@localhost ~]$
[teddy@localhost philip]$ sudo ls /boot/grub2/
device.map  fonts  grub.cfg  grubenv  i386-pc  locale  themes
[teddy@localhost philip]$ sudo cat /etc/resolv.conf
# Generated by NetworkManager
nameserver 8.8.8.8
[teddy@localhost philip]$
[teddy@localhost philip]$ sudo ip a a 172.16.20.1/24 dev ens33
Sorry, user teddy is not allowed to execute '/usr/sbin/ip a a 172.16.20.1/24 dev ens33' as root on localhost.localdomain.
[teddy@localhost philip]$
```

太棒了。我们为新用户添加了`cat`命令，使得新用户可以以 root 权限执行`cat`命令。要记住的是，将多个命令并排放置时，您必须通过在命令之间按下*选项卡*键来放置选项卡。我们可以使用`sudo`命令的另一个选项是`-l`选项；这将列出当前用户的权限，如下所示:

```sh
[philip@localhost ~]$ sudo -l
Matching Defaults entries for philip on localhost:
 !visiblepw, env_reset, timestamp_timeout=60, pwfeedback, env_keep="COLORS DISPLAY HOSTNAME HISTSIZE KDEDIR LS_COLORS", env_keep+="MAIL PS1 PS2
 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE", env_keep+="LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES", env_keep+="LC_MONETARY LC_NAME
 LC_NUMERIC LC_PAPER LC_TELEPHONE", env_keep+="LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY",
secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin
User philip may run the following commands on localhost:
 (ALL) ALL
[philip@localhost ~]$
```

可以看到，用户`philip`可以用`sudo`命令运行所有的命令。但是，如果我们对另一个用户`teddy`使用`-l`运行`sudo`命令，我们将看到该用户的访问权限，如下所示:

```sh
[teddy@localhost philip]$ sudo -l
[sudo] password for teddy: 
Matching Defaults entries for teddy on localhost:
 !visiblepw, env_reset, timestamp_timeout=60, pwfeedback, env_keep="COLORS DISPLAY HOSTNAME HISTSIZE KDEDIR LS_COLORS", env_keep+="MAIL PS1 PS2
 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE", env_keep+="LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES", env_keep+="LC_MONETARY LC_NAME
 LC_NUMERIC LC_PAPER LC_TELEPHONE", env_keep+="LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY",
secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin
User teddy may run the following commands on localhost:
 (ALL) /usr/bin/ls, /usr/bin/cat
[teddy@localhost philip]$
```

太棒了。我们只能看到`teddy`可以以 root 权限执行的两个命令。也可以通过`-u`选项传递用户名，并指定使用`sudo`执行哪个命令，如下所示:

```sh
[philip@localhost ~]$ sudo -u teddy cat /etc/resolv.conf
# Generated by NetworkManager
nameserver 8.8.8.8
[philip@localhost ~]$ sudo -u teddy ip a a 10.10.10.10/24 dev ens33
RTNETLINK answers: Operation not permitted
[philip@localhost ~]$
```

太棒了！另一个有用的选项是`-v`，它为用户重置认证超时，如下所示:

```sh
[philip@localhost ~]$ sudo -v
[philip@localhost ~]$
```

同样，通过将`-k`选项与`sudo`一起传递，可以立即终止身份验证会话，如下所示:

```sh
[philip@localhost ~]$ sudo -k
[philip@localhost ~]$ sudo ls /boot/grub2/
[sudo] password for philip: 
device.map  fonts  grub.cfg  grubenv  i386-pc  locale  themes
[philip@localhost ~]$
```

太棒了。在前面的代码中，当用户试图使用`-k`选项执行`sudo`命令时，必须提供他们的密码。

到目前为止，我们已经在第一次执行`sudo`时提供了用户的密码；无需输入密码即可运行`sudo`。我们在为新用户添加的条目中添加了`NOPASSWD`选项，如下所示:

```sh
[philip@localhost ~]$ sudo cat /etc/sudoers | grep teddy
teddy    ALL=(ALL)            NOPASSWD:/usr/bin/ls,               /usr/bin/cat
[philip@localhost ~]$
[philip@localhost ~]$ su teddy
Password:
[teddy@localhost philip]$ sudo cat /etc/resolv.conf
# Generated by NetworkManager
nameserver 8.8.8.8
[teddy@localhost philip]$ sudo ls /boot/grub2/
device.map  fonts  grub.cfg  grubenv  i386-pc  locale  themes
[teddy@localhost philip]$
```

太棒了！每当用户`teddy`试图执行`sudo`命令时，将不再提示他们输入密码。

# TCP 包装器

我们可以通过使用 TCP 包装器在 Linux 系统中增加另一层安全性。 **TCP 包装器**过滤进入系统的流量。TCP 包装器根据两个文件检查流量:`/etc/hosts.allow`和`/etc/hosts.deny`。这些规则以自上而下的方式应用，这意味着第一个规则总是在所有其他规则之前应用。我们可以如下查看`/etc/hosts.allow`的内容:

```sh
[philip@localhost ~]$ cat /etc/hosts.allow
#
# hosts.allow  This file contains access rules which are used to
# allow or deny connections to network services that
# either use the tcp_wrappers library or that have been
# started through a tcp_wrappers-enabled xinetd.
# See 'man 5 hosts_options' and 'man 5 hosts_access'
# for information on rule syntax.
# See 'man tcpd' for information on tcp_wrappers
#
[philip@localhost ~]$
```

文件只包含以`#`开头的注释。创建规则的基本语法如下:

```sh
<daemon>:        <client list> [:<option>: <option>:…]      
```

我们可以使用文本编辑器添加规则，如 vi 或 nano，如下所示:

```sh
[philip@localhost ~]$ sudo cat /etc/hosts.allow
#
vsftpd:                  172.16.175.
[philip@localhost ~]$
```

在前面的命令中，我们为`vsftpd`添加了一个规则；这是 FTP 的安全版本。然后我们指定了客户端列表——子网`172.16.175.`。`.`意味着该子网内的任何 IP 地址都可以访问`vsftpd`。定义规则的另一种方法是指定一个域，如下所示:

```sh
[philip@localhost ~]$ sudo cat /etc/hosts.allow
#
vsftpd:                  .packtpub.com
[philip@localhost ~]$
```

太棒了！来自`.packtpub.com`内的任何人都可以访问本地系统上的`vsftpd`。除此之外，我们可以在规则中使用关键字`ALL`；这与所有内容都匹配，可以放在守护程序或客户端列表部分，如下所示:

```sh
[philip@localhost ~]$ sudo cat /etc/hosts.allow
vsftpd:                  .packtpub.com
in.telnetd:           ALL
[philip@localhost ~]$
```

太棒了。每个人都可以访问本地系统上的远程登录服务。也可以通过传递`spawn`选项来执行另一个命令。当我们想要记录谁试图访问本地系统上的给定服务时，这很有用。我们使用`spawn`选项如下:

```sh
[philip@localhost ~]$ sudo cat /etc/hosts.allow
vsftpd:                  .packtpub.com: spawn /bin/echo `/bin/date` from %h>>/var/log/vsftp.log : allow
in.telnetd:           ALL
[philip@localhost ~]$
```

太棒了！`spawn`选项会创建一条包含当前日期(`/bin/date`)的消息，然后该消息会附加试图访问`vsftpd`的系统的主机名(`%h`)；然后这被附加到`/var/log/vsftp.log`里面。然后我们可以看一下`/etc/hosts.deny`文件，如下:

```sh
[philip@localhost ~]$ sudo cat /etc/hosts.deny
# hosts.deny   This file contains access rules which are used to
#              deny connections to network services that either use
#              the tcp_wrappers library or that have been
#              The rules in this file can also be set up in
#              /etc/hosts.allow with a 'deny' option instead.
#              See 'man 5 hosts_options' and 'man 5 hosts_access'
#              for information on rule syntax.
#              See 'man tcpd' for information on tcp_wrappers
 [philip@localhost ~]$
```

在前面的命令中，`/etc/hosts.deny`只包含注释(`#`)。建议拒绝该文件中的所有内容，如下所示:

```sh
[philip@localhost ~]$ sudo cat /etc/hosts.deny
ALL:ALL
[philip@localhost ~]$
```

太棒了。我们指定了`ALL:ALL:`，除了`/etc/hosts.allow`中列出的规则外，拒绝一切。

# 嘘

我们主要使用 SSH 来安全地登录远程系统。默认情况下，大多数 Linux 发行版都带有 SSH 包。为了验证 SSH 当前是否正在运行，我们使用`systemctl`命令；我们通过`status`选项，如下所示:

![](img/00167.jpeg)

SSH 守护程序`ssh.service`当前正在运行(特别是安全Shell服务器)。我们可以用来验证 SSH 服务正在运行的另一种方法是`netstat`命令；我们传递`ntlp`选项(`n`用于显示端口号，`t`用于 TCP 协议，`l`用于当前监听，`p`用于程序标识/程序名称)，如下所示:

```sh
root@Linuxplus:/home/philip# netstat -ntlp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address Foreign Address State       PID/Program name 
tcp  0   0  0.0.0.0:514     0.0.0.0:*  LISTEN  519/rsyslogd 
tcp  0   0  127.0.0.53:53   0.0.0.0:*  LISTEN  431/systemd-resolve
tcp  0   0  0.0.0.0:22      0.0.0.0:*  LISTEN  1152/sshd 
tcp  0   0  127.0.0.1:631   0.0.0.0:*  LISTEN  2638/cupsd 
tcp6 0   0  :::514          :::*       LISTEN  519/rsyslogd 
tcp6 0   0  :::22           :::*       LISTEN  1152/sshd 
tcp6 0   0  ::1:631         :::*       LISTEN  2638/cupsd 
root@Linuxplus:/home/philip#
```

如您所见，SSH 服务器守护程序当前正在 TCP 端口`22`上运行。与远程系统建立连接的基本语法如下:

```sh
ssh <remote system>
```

我们可以简单的运行`ssh`命令，只传递远程系统；我们将使用来自 Fedora 28 系统的`ssh`命令，并尝试连接到 Ubuntu 18 系统，如下所示:

```sh
 [philip@localhost ~]$ ssh 172.16.175.130
The authenticity of host '172.16.175.130 (172.16.175.130)' can't be established.
ECDSA key fingerprint is SHA256:SfI3vfS3yRRWSGN2jgAG7K5aQc65c/zVt/lz+D8mQBQ.
ECDSA key fingerprint is MD5:a2:03:c5:38:b3:83:88:fa:85:b5:5f:e6:91:eb:87:c1.
Are you sure you want to continue connecting (yes/no)?yes
Warning: Permanently added '172.16.175.130' (ECDSA) to the list of known hosts.
philip@172.16.175.130's password:
Welcome to Ubuntu 18.04 LTS (GNU/Linux 4.15.0-20-generic x86_64)
 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage
Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.
philip@Linuxplus:~$
```

在前面的命令中，为了简洁起见，省略了一些输出。如果您在没有任何选项的情况下指定该命令，SSH 程序将使用当前用户`philip`，并显示识别服务器的指纹。这将用户`philip`添加到了软呢帽 28 系统的`~/.ssh/known_hosts`中。我们可以看一下文件，如下所示:

```sh
[philip@localhost ~]$ cat .ssh/known_hosts
172.16.175.130 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBPhEHNo6YSOE+ZZ9vHVmQqBPFQd8WtAUFoGYAJe3VPQJlhjhc9bxy+vwsetQiEIKTyMgnfrOC7LNbhxxmJ4IX8w=
[philip@localhost ~]$
```

太棒了。在 Fedora 28 系统上，我们在`~/.ssh/known_hosts`里面为用户`philip`提供了 Ubuntu 的系统信息。也可以在`ssh`命令中使用不同的用户名；我们指定`-l`选项，如下所示:

```sh
[philip@localhost ~]$ ssh -l hacker 172.16.175.130
hacker@172.16.175.130's password:
Welcome to Ubuntu 18.04 LTS (GNU/Linux 4.15.0-20-generic x86_64)
$ exit
Connection to 172.16.175.130 closed.
[philip@localhost ~]$
```

我们能够通过 SSH 使用不同的用户登录。另外，请注意，我们看到了前面的消息，它标识了服务器的指纹。这是因为信息之前存储在`~/.ssh/known_hosts`中。如果我们使用文本编辑器(如 vi 或 nano)删除内容，我们将再次看到身份信息，如下所示:

```sh
[philip@localhost ~]$ cat .ssh/known_hosts
[philip@localhost ~]$
[philip@localhost ~]$ ssh -l hacker 172.16.175.130
The authenticity of host '172.16.175.130 (172.16.175.130)' can't be established.
ECDSA key fingerprint is SHA256:SfI3vfS3yRRWSGN2jgAG7K5aQc65c/zVt/lz+D8mQBQ.
ECDSA key fingerprint is MD5:a2:03:c5:38:b3:83:88:fa:85:b5:5f:e6:91:eb:87:c1.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '172.16.175.130' (ECDSA) to the list of known hosts.
hacker@172.16.175.130's password:
Welcome to Ubuntu 18.04 LTS (GNU/Linux 4.15.0-20-generic x86_64)
[philip@localhost ~]$
```

太棒了！我们删除了内容，我们再次收到了身份信息。

到目前为止，每当我们尝试启动 SSH 会话时，都会提示我们输入密码。但是，可以绕过密码提示，毫无阻碍地登录系统。我们使用 SSH 密钥进行身份验证；这就是所谓的**基于密钥的认证**。基于密钥的身份验证包括创建一对密钥:私钥和公钥。私钥存储在客户端系统上，公钥存储在目标系统上。特别是，我们在目标系统上使用`ssh-keygen`命令生成一个 SSH 密钥。接下来，我们复制客户端系统；我们使用`ssh-copy-id`命令来复制按键。当您首次使用基于密钥的身份验证进行连接时，服务器使用公钥将消息传输到客户端系统，然后可以使用驻留在客户端系统上的私钥对消息进行解释。

让我们在需要登录的客户端系统上使用`ssh-keygen`命令生成 SSH 密钥；它将是 Fedora 28 系统，如下所示:

```sh
[philip@localhost ~]$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/philip/.ssh/id_rsa):
```

默认情况下，算法为`rsa`，存储密钥对的位置在当前用户的主目录(`~/.ssh/id_rsa`)内。我们接受默认值并按*进入*，如下所示:

```sh
[philip@localhost ~]$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/philip/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
```

我们必须指定一个`passphrase`；我们将使用一个超级秘密`passphrase`，然后按*进入*，如下:

```sh
[philip@localhost ~]$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/home/philip/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/philip/.ssh/id_rsa.
Your public key has been saved in /home/philip/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:BwdFiHu2iEyvnnXhnY+1tNpZmlaZZdL1Zugwda9PJ7g philip@localhost.localdomain
The key's randomart image is:
+---[RSA 2048]----+
|       ..+o      |
|      . ..    . o|
|       .. .  . ++|
|    . . oo  o o O|
|   o o +S..  = X |
|    o o..+ .. B o|
|     .. o o oo.+.|
|    .o .   *EB  .|
|   .o     ooO    |
+----[SHA256]-----+
[philip@localhost ~]$
```

太棒了！密钥是使用 2，048 位密钥大小生成的。现在，我们可以在用户的主目录上运行`ls`命令并查看`~/.ssh`内部，如下所示:

```sh
[philip@localhost ~]$ ls -a .ssh
.  ..  id_rsa  id_rsa.pub  known_hosts
[philip@localhost ~]$
```

太棒了！除了前面提到的`known_hosts`文件，我们现在还有另外两个文件:`id_rsa`(这是私钥)和`id_rsa.pub`(这是公钥)。我们可以使用`cat`命令查看内容:

```sh
[philip@localhost ~]$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDNvsCDZaUs6mralW+c1QnQ9cMeUqW0c/4IF8DThVK0Bi4CPnQApafJZrOyeQeJbLxORCJf+YLkE+DWREwJw0EU21PkiZeij0DEIlspqToo6BkKDPfXXCl35OQxSUXERlAhGQQpVSbEJLy0WZsbs6iAy4ohmKcCWeEdHLz/3p0VUyd3NHvXaLsyno/Qa2ZOBOOZgwUeHUA/p0zykUff7M4kIyGYatt1/vYKDH+UOC5fyB/nLtvrq7P1MrlfMGyEjtc7nFDEHz4VeAP1iUItKEzsyrqEH/KbAa3/ZeSoSfaFxoKvEtSKF5tnICyVp6uiUTNfi/cN74dmiDfG+vtcF0nt philip@localhost.localdomain
[philip@localhost ~]$
```

太棒了。下一步是使用`ssh-copy id`命令将公钥从客户端系统复制到目的服务器；在我们的例子中，服务器是 Ubuntu 系统。在运行`ssh-copy-id`命令之前，让我们检查一下 Ubuntu 系统上的`~/.ssh`目录，如下所示:

```sh
philip@Linuxplus:~$ ls -a ~/.ssh
.  ..
philip@Linuxplus:~$
```

可以看到，`~/.ssh`当前为空。现在，让我们在客户端系统上执行`ssh-copy-id`命令，如下所示:

```sh
[philip@localhost ~]$ ssh-copy-id philip@172.16.175.130
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "/home/philip/.ssh/id_rsa.pub"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys
philip@172.16.175.130's password:
Number of key(s) added: 1
Now try logging into the machine, with:   "ssh 'philip@172.16.175.130'"
and check to make sure that only the key(s) you wanted were added.
[philip@localhost ~]$
```

太棒了！公钥`~/.ssh/id_rsa.pub`被安全地传输到服务器的系统中。现在，让我们再次检查 Ubuntu 系统上的`~/.ssh`目录，如下所示:

```sh
philip@Linuxplus:~$ ls -a ~/.ssh
.  ..  authorized_keys
philip@Linuxplus:~$
```

太棒了。我们现在有一个`authorized_keys`文件，位于`~/.ssh`目录中。我们可以使用`cat`命令来验证公钥确实与客户端系统上的公钥相同，如下所示:

```sh
philip@Linuxplus:~$ cat ~/.ssh/authorized_keys
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDNvsCDZaUs6mralW+c1QnQ9cMeUqW0c/4IF8DThVK0Bi4CPnQApafJZrOyeQeJbLxORCJf+YLkE+DWREwJw0EU21PkiZeij0DEIlspqToo6BkKDPfXXCl35OQxSUXERlAhGQQpVSbEJLy0WZsbs6iAy4ohmKcCWeEdHLz/3p0VUyd3NHvXaLsyno/Qa2ZOBOOZgwUeHUA/p0zykUff7M4kIyGYatt1/vYKDH+UOC5fyB/nLtvrq7P1MrlfMGyEjtc7nFDEHz4VeAP1iUItKEzsyrqEH/KbAa3/ZeSoSfaFxoKvEtSKF5tnICyVp6uiUTNfi/cN74dmiDfG+vtcF0nt philip@localhost.localdomain
philip@Linuxplus:~$
```

太棒了！最后一步是在客户端系统(Fedora 28)上运行`ssh`命令，并验证我们能够在不使用密码的情况下登录到服务器(Ubuntu 18)，如下所示:

```sh
[philip@localhost ~]$ ssh 172.16.175.130
Enter passphrase for key '/home/philip/.ssh/id_rsa':
Welcome to Ubuntu 18.04 LTS (GNU/Linux 4.15.0-20-generic x86_64)
Last login: Thu Sep 13 16:47:50 2018 from 172.16.175.129
philip@Linuxplus:~$
```

在前面的代码中，我们被要求输入`passphrase`，而不是用户的密码。此外，可以将`passphrase`存储在代理中，这将允许我们在未来无缝登录，而无需在每次尝试登录时提供密码。这可以通过使用`ssh-agent`和`ssh-add`命令来实现。`ssh agent`命令存储`passphrase`之后，我们将使用`ssh-add`命令。这就产生了所谓的**单点登录** ( **单点登录**)。下面的代码片段显示了我们如何使用`ssh-add`命令:

```sh
[philip@localhost ~]$ ssh-agent
SSH_AUTH_SOCK=/tmp/ssh-qLovqqH69q1D/agent.79449; export SSH_AUTH_SOCK;
SSH_AGENT_PID=79450; export SSH_AGENT_PID;
echo Agent pid 79450;
 [philip@localhost ~]$
```

太棒了！我们启动了`ssh agent`，它创建了必要的变量并启动了进程。接下来，我们将使用`-l`选项运行`ssh-add`命令；这将列出`ssh agent`知道的所有身份，如下所示:

```sh
[philip@localhost ~]$ ssh-add -l
The agent has no identities.
[philip@localhost ~]$
```

正如您在前面的命令中看到的，代理不知道任何身份；我们现在将添加我们之前创建的身份，使用`ssh-add`命令，没有任何选项，如下所示:

```sh
[philip@localhost ~]$ ssh-add
Enter passphrase for /home/philip/.ssh/id_rsa:
Identity added: /home/philip/.ssh/id_rsa (/home/philip/.ssh/id_rsa)
[philip@localhost ~]$ ssh-add -l
2048 SHA256:BwdFiHu2iEyvnnXhnY+1tNpZmlaZZdL1Zugwda9PJ7g /home/philip/.ssh/id_rsa (RSA)
[philip@localhost ~]$
```

太棒了！您现在可以看到我们之前生成的私钥的标识。现在，我们将尝试启动 SSH 会话，如下所示:

```sh
[philip@localhost ~]$ ssh 172.16.175.130
Welcome to Ubuntu 18.04 LTS (GNU/Linux 4.15.0-20-generic x86_64)
Last login: Fri Sep 14 10:06:44 2018 from 172.16.175.129
philip@Linuxplus:~$ exit
[philip@localhost ~]$
```

太棒了！我们成功登录，无需输入用户密码或`passphrase`。SSH 配置存储在`/etc/ssh/ssh_config`中:

```sh
philip@localhost ~]$ cat /etc/ssh/ssh_config
# $OpenBSD: ssh_config,v 1.33 2017/05/07 23:12:57 djm Exp $
# IdentityFile ~/.ssh/id_dsa
# IdentityFile ~/.ssh/id_ecdsa
# IdentityFile ~/.ssh/id_ed25519
# Port 22
# Protocol 2
#   Ciphers aes128-ctr,aes192-ctr,aes256-ctr,aes128-cbc,3des-cbc
#   MACs hmac-md5,hmac-sha1,umac-64@openssh.com
#   EscapeChar ~
#   Tunnel no
#   TunnelDevice any:any
# To modify the system-wide ssh configuration, create a  *.conf  file under
#  /etc/ssh/ssh_config.d/  which will be automatically included below
Include /etc/ssh/ssh_config.d/*.conf
[philip@localhost ~]$
```

在前面的代码中，为了简洁起见，省略了一些输出。所有设置都使用默认值。

保存`known_hosts`的另一个位置是`/etc/ssh/known_hosts`；这允许管理员添加局域网内所有服务器的身份。此方法可防止每次新用户尝试启动与服务器的 SSH 会话时，都出现身份消息。我们可以将`~./ssh/known_hosts`的内容复制到`/etc/ssh/known_hosts`，如果我们尝试以另一个用户身份登录，我们将看不到身份信息:

```sh
[philip@localhost ~]$ cat ~/.ssh/known_hosts
172.16.175.130 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBPhEHNo6YSOE+ZZ9vHVmQqBPFQd8WtAUFoGYAJe3VPQJlhjhc9bxy+vwsetQiEIKTyMgnfrOC7LNbhxxmJ4IX8w=
[philip@localhost ~]$ cat /etc/ssh/ssh_known_hosts
172.16.175.130 ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBPhEHNo6YSOE+ZZ9vHVmQqBPFQd8WtAUFoGYAJe3VPQJlhjhc9bxy+vwsetQiEIKTyMgnfrOC7LNbhxxmJ4IX8w=
[philip@localhost ~]$
 [philip@localhost ~]$ ssh hacker@172.16.175.130
hacker@172.16.175.130's password:
Welcome to Ubuntu 18.04 LTS (GNU/Linux 4.15.0-20-generic x86_64)
$ exit
Connection to 172.16.175.130 closed.
[philip@localhost ~]$ ssh teddy@172.16.175.130
teddy@172.16.175.130's password:
[philip@localhost ~]$
```

太好了。两个用户都没有收到身份信息。请注意，系统会提示他们输入各自的密码，因为我们只为`philip`用户设置了基于密钥的身份验证；我们必须为每个用户生成密钥。

# 加密

在当今的环境中，保护我们的数据至关重要。我们可以使用各种加密方法；在我们的环境中，我们将使用 **GNU 隐私保护** ( **GnuPG** ，或 **GPG** )来加密和解密我们的文件和文件夹。我们将在处理加密和解密时使用`gpg`命令。

首先，我们将使用最基本的形式加密文件，**对称加密**；这使用密码。以下命令显示了如何使用`gpg`命令执行对称加密，使用`-c`或`--symmetric`选项:

```sh
[philip@localhost ~]$ cd Documents/
[philip@localhost Documents]$ ls
date_schedule  lsa_schedule  ls.txt  schedule  ssh  STDERR.txt  STDIN_STDOUT  STDIN_STDOUT.txt  TestFile1  The_Tee_command.txt
[philip@localhost Documents]$ gpg -c The_Tee_command.txt
Enter passphrase:
```

我们必须输入密码/密码短语，然后重新输入，如下所示:

```sh
[philip@localhost Documents]$ gpg -c The_Tee_command.txt
Repeat passphrase:
[philip@localhost Documents]$
[philip@localhost Documents]$ ls -l | grep The
-rw-r--r--. 1 root   root   370 Aug  7 14:53 The_Tee_command.txt
-rw-rw-r--. 1 philip philip 307 Sep 14 11:01 The_Tee_command.txt.gpg
[philip@localhost Documents]$
```

太棒了。创建了一个新文件，扩展名为`.gpg`；这是加密文件。我们可以尝试使用`cat`命令查看内容:

```sh
[philip@localhost Documents]$ cat The_Tee_command.txt.gpg
```

![](img/00168.jpeg)

内容是加密的，我们现在可以删除原始内容并保留加密内容，如下所示:

```sh
[philip@localhost Documents]$ rm The_Tee_command.txt
rm: remove write-protected regular file 'The_Tee_command.txt'? yes
[philip@localhost Documents]$ ls -l | grep The
-rw-rw-r--. 1 philip philip 307 Sep 14 11:01 The_Tee_command.txt.gpg
[philip@localhost Documents]$
```

现在，只剩下加密文件了。我们可以通过传递`-d`选项来解密该文件，如下所示:

```sh
[philip@localhost Documents]$ gpg -d The_Tee_command.txt.gpg
gpg: AES encrypted data
Enter passphrase:
```

我们必须提供密码才能解密文件，如下所示:

```sh
[philip@localhost Documents]$ gpg -d The_Tee_command.txt.gpg
gpg: AES encrypted data
Enter passphrase:
gpg: AES encrypted data
gpg: encrypted with 1 passphrase
#
# hosts.allow This file contains access rules which are used to
#             allow or deny connections to network services that
#             either use the tcp_wrappers library or that have been
#             started through a tcp_wrappers-enabled xinetd.
#
#              See 'man 5 hosts_options' and 'man 5 hosts_access'
#              for information on rule syntax.
#              See 'man tcpd' for information on tcp_wrappers
#
[philip@localhost Documents]$ ls -l | grep The
-rw-rw-r--. 1 philip philip 307 Sep 14 11:01 The_Tee_command.txt.gpg
[philip@localhost Documents]$
```

太棒了！显示文件的内容，但是，正如我们所看到的，当我们运行`ls`命令时，我们仍然只有加密的文件，没有生成新的文件。放心；我们可以通过`-o`选项将输出保存到一个文件中，如下所示:

```sh
[philip@localhost Documents]$ gpg -o The_Tee_command.txt -d The_Tee_command.txt.gpg
gpg: AES encrypted data
gpg: encrypted with 1 passphrase
[philip@localhost Documents]$ ls -l | grep The
-rw-rw-r--. 1 philip philip 370 Sep 14 11:10 The_Tee_command.txt
-rw-rw-r--. 1 philip philip 307 Sep 14 11:01 The_Tee_command.txt.gpg
[philip@localhost Documents]$
```

太棒了。现在，我们有加密和未加密的文件。

我们还可以通过使用私有/公共密钥对来加密和解密。首先，我们必须使用带有`--gen-key`选项的`gpg`生成密钥对，如下所示:

```sh
[philip@localhost Documents]$ gpg --gen-key
gpg (GnuPG) 1.4.22; Copyright (C) 2015 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Please select what kind of key you want:
 (1) RSA and RSA (default)
 (2) DSA and Elgamal
 (3) DSA (sign only)
 (4) RSA (sign only)
Your selection?
```

我们必须选择键的类型，`RSA and RSA`为默认值；我们将接受默认值，如下所示:

```sh
RSA keys may be between 1024 and 4096 bits long.
```

我们还要指定按键的大小，默认为`2048`；我们将选择`4096`，因为更长的密钥更安全:

```sh
What keysize do you want? (2048) 4096
Requested keysize is 4096 bits
Please specify how long the key should be valid.
 0 = key does not expire
 <n>  = key expires in n days
 <n>w = key expires in n weeks
 <n>m = key expires in n months
 <n>y = key expires in n years
Key is valid for? (0) 1y
```

我们还要指定密钥什么时候到期，默认为`0`，也就是说永远不会到期。我们将选择`1y`，这意味着它将在一年后到期:

```sh
Key expires at Sat 14 Sep 2019 11:15:50 AM EDT
Is this correct? (y/N) y
You need a user ID to identify your key; the software constructs the user ID
from the Real Name, Comment and Email Address in this form:
 "Heinrich Heine (Der Dichter) <heinrichh@duesseldorf.de>"
Real name: Philip Inshanally
```

然后，我们要确认到期日，指定`Real Name`；我们将按如下方式填写信息:

```sh
Email address: pinshanally@gmail.com
Comment: It's always good to help others
You selected this USER-ID:
 "Philip Inshanally (It's always good to help others) <pinshanally@gmail.com>"
Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit?
```

我们现在必须通过键入`O`来确认，如下所示:

```sh
Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O
You need a Passphrase to protect your secret key.
Repeat passphrase:
```

我们还必须保护我们的密钥，如下所示:

```sh
We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
.+++++
...+++++
We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
...............+++++
...+++++
gpg: key 73941CF4 marked as ultimately trusted
public and secret key created and signed.
gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
gpg: next trustdb check due at 2019-09-14
pub   4096R/73941CF4 2018-09-14 [expires: 2019-09-14]
 Key fingerprint = 3C24 9577 0081 C03B 4D88  2D34 60E4 B83C 7394 1CF4
uid                  Philip Inshanally (It's always good to help others) <pinshanally@gmail.com>
sub   4096R/B29CE2BA 2018-09-14 [expires: 2019-09-14]
[philip@localhost Documents]$
```

太棒了！我们已成功生成密钥对；我们可以通过使用`gpg`命令传递`--list-keys`选项来验证这一点，如下所示:

```sh
[philip@localhost Documents]$ gpg --list-keys
/home/philip/.gnupg/pubring.gpg
-------------------------------
pub   4096R/73941CF4 2018-09-14 [expires: 2019-09-14]
uid                  Philip Inshanally (It's always good to help others) <pinshanally@gmail.com>
sub   4096R/B29CE2BA 2018-09-14 [expires: 2019-09-14]
[philip@localhost Documents]$
```

太棒了！可以看到，我们的公钥信息在`/home/philip/.gnupg/pubring.gpg`中:

```sh
[philip@localhost Documents]$ ls -a ~/.gnupg/
.  ..  gpg.conf  pubring.gpg  pubring.gpg~  random_seed  secring.gpg  trustdb.gpg
[philip@localhost Documents]$
```

我们现在可以看到我们的公钥信息。接下来，我们将检查我们的私钥信息；我们将通过`gpg`命令传递`--list-secret-keys`选项，如下所示:

```sh
[philip@localhost Documents]$ gpg --list-secret-keys
/home/philip/.gnupg/secring.gpg
-------------------------------
sec   4096R/73941CF4 2018-09-14 [expires: 2019-09-14]
uid                  Philip Inshanally (It's always good to help others) <pinshanally@gmail.com>
ssb   4096R/B29CE2BA 2018-09-14
[philip@localhost Documents]$
```

太棒了！我们可以看到关于私钥的信息；即私钥在`/home/philip/.gnupg/secring.gpg`中，如下所示:

```sh
[philip@localhost Documents]$ ls -a ~/.gnupg/
.  ..  gpg.conf  pubring.gpg  pubring.gpg~  random_seed  secring.gpg  trustdb.gpg
[philip@localhost Documents]$
```

太棒了。现在，我们可以使用刚刚创建的公钥进行加密，通过`gpg`命令传递`-r`选项，如下所示:

```sh
[philip@localhost Documents]$ gpg -e The_Tee_command.txt
You did not specify a user ID. (you may use "-r")
Current recipients:
Enter the user ID.  End with an empty line: pinshanally@gmail.com
Current recipients:
4096R/B29CE2BA 2018-09-14 "Philip Inshanally (It's always good to help others) <pinshanally@gmail.com>"
Enter the user ID.  End with an empty line:
File `The_Tee_command.txt.gpg' exists. Overwrite? (y/N) y
[philip@localhost Documents]$ ls
date_schedule  ls.txt    ssh         STDIN_STDOUT      TestFile1            The_Tee_command.txt.gpg
lsa_schedule   schedule  STDERR.txt  STDIN_STDOUT.txt  The_Tee_command.txt
[philip@localhost Documents]$
```

我们没有用命令指定用户标识，所以系统会提示我们指定用户标识；然后我们按下*进入*移动到第二行`Enter the user ID`。以空行结束:`""`，我们简单按*回车*生成空行。接下来，我们必须确认是否要覆盖之前执行对称加密时加密的文件。我们也可以用`-r`选项指定`user ID`。让我们试一试:

```sh
[philip@localhost Documents]$ rm The_Tee_command.txt.gpg
[philip@localhost Documents]$ gpg -e -r pinshanally@gmail.com The_Tee_command.txt
[philip@localhost Documents]$ ls -l | grep The
-rw-rw-r--. 1 philip philip 370 Sep 14 11:10 The_Tee_command.txt
-rw-rw-r--. 1 philip philip 827 Sep 14 11:34 The_Tee_command.txt.gpg
[philip@localhost Documents]$
```

太棒了！我们没有被提示输入`user ID`，因为我们使用`-r`选项指定了它。为了解密文件，我们通过`-d`选项，如下所示:

```sh
[philip@localhost Documents]$ gpg -d The_Tee_command.txt.gpg
You need a passphrase to unlock the secret key for
user: "Philip Inshanally (It's always good to help others) <pinshanally@gmail.com>"
4096-bit RSA key, ID B29CE2BA, created 2018-09-14 (main key ID 73941CF4)
Enter passphrase:
user: "Philip Inshanally (It's always good to help others) <pinshanally@gmail.com>"
4096-bit RSA key, ID B29CE2BA, created 2018-09-14 (main key ID 73941CF4)
gpg: encrypted with 4096-bit RSA key, ID B29CE2BA, created 2018-09-14
 "Philip Inshanally (It's always good to help others)<pinshanally@gmail.com>"
# hosts.allow     This file contains access rules which are used to
#                 allow or deny connections to network services that
#                either use the tcp_wrappers library or that have been
#               started through a tcp_wrappers-enabled xinetd.
#
#            See 'man 5 hosts_options' and 'man 5 hosts_access'
#             for information on rule syntax.
#              See 'man tcpd' for information on tcp_wrappers
[philip@localhost Documents]$
```

在前面的代码中，我们遇到了与对称解密时相同的问题；未保存显示的内容。我们可以通过`-o`选项快速解决这个问题:

```sh
[philip@localhost Documents]$ ls -l | grep The
-rw-rw-r--. 1 philip philip 370 Sep 14 11:10 The_Tee_command.txt
-rw-rw-r--. 1 philip philip 827 Sep 14 11:34 The_Tee_command.txt.gpg
[philip@localhost Documents]$ rm The_Tee_command.txt
[philip@localhost Documents]$ gpg -o The_Tee_command.txt -d The_Tee_command.txt.gpg
You need a passphrase to unlock the secret key for
user: "Philip Inshanally (It's always good to help others) <pinshanally@gmail.com>"
4096-bit RSA key, ID B29CE2BA, created 2018-09-14 (main key ID 73941CF4)
Enter passphrase:
gpg: encrypted with 4096-bit RSA key, ID B29CE2BA, created 2018-09-14
 "Philip Inshanally (It's always good to help others) <pinshanally@gmail.com>"
[philip@localhost Documents]$ ls -l | grep The
-rw-rw-r--. 1 philip philip 370 Sep 14 11:39 The_Tee_command.txt
-rw-rw-r--. 1 philip philip 827 Sep 14 11:34 The_Tee_command.txt.gpg
[philip@localhost Documents]$
```

太棒了！文件已成功解密。

也可以编辑密钥；我们通过`gpg`命令传递`--edit-key`选项，如下所示:

```sh
[philip@localhost Documents]$ gpg --edit-key pinshanally@gmail.com
gpg (GnuPG) 1.4.22; Copyright (C) 2015 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Secret key is available.
pub  4096R/73941CF4  created: 2018-09-14  expires: 2019-09-14  usage: SC 
 trust: ultimate      validity: ultimate
sub  4096R/B29CE2BA  created: 2018-09-14  expires: 2019-09-14  usage: E 
[ultimate] (1). Philip Inshanally (It's always good to help others)<pinshanally@gmail.com>
gpg>
```

在前面的命令中，我们可以进行一些更改。例如，如果我们想禁用该键，我们可以键入`disable`，如下所示:

```sh
gpg> disable
gpg> list
pub  4096R/73941CF4  created: 2018-09-14  expires: 2019-09-14  usage: SC 
 trust: ultimate      validity: ultimate
*** This key has been disabled
sub  4096R/B29CE2BA  created: 2018-09-14  expires: 2019-09-14  usage: E 
[ultimate] (1). Philip Inshanally (It's always good to help others) <pinshanally@gmail.com>
Please note that the shown key validity is not necessarily correct
unless you restart the program.
gpg>
```

在前面的命令中，我们改变了键表示`*** This key has been disabled`；让我们通过保存和退出来看看这样做的效果，如下所示:

```sh
gpg> save
Key not changed so no update needed.
[philip@localhost Documents]$ rm The_Tee_command.txt.gpg
[philip@localhost Documents]$
[philip@localhost Documents]$ gpg -e -r pinshanally@gmail.com The_Tee_command.txt
gpg: pinshanally@gmail.com: skipped: public key not found
gpg: The_Tee_command.txt: encryption failed: public key not found
[philip@localhost Documents]$
```

当我们试图使用密钥加密文件时，我们会得到一个错误。我们可以通过将`gpg`控制台内的`disable`更改为`enable`来快速解决此问题，如下所示:

```sh
philip@localhost Documents]$ gpg --edit-key pinshanally@gmail.com
gpg (GnuPG) 1.4.22; Copyright (C) 2015 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Secret key is available.
pub  4096R/73941CF4  created: 2018-09-14  expires: 2019-09-14  usage: SC 
 trust: ultimate      validity: ultimate
*** This key has been disabled
sub  4096R/B29CE2BA  created: 2018-09-14  expires: 2019-09-14  usage: E 
[ultimate] (1). Philip Inshanally (It's always good to help others) <pinshanally@gmail.com>
gpg> enable
gpg> list
pub  4096R/73941CF4  created: 2018-09-14  expires: 2019-09-14  usage: SC 
 trust: ultimate      validity: ultimate
sub  4096R/B29CE2BA  created: 2018-09-14  expires: 2019-09-14  usage: E 
[ultimate] (1). Philip Inshanally (It's always good to help others) <pinshanally@gmail.com>
Please note that the shown key validity is not necessarily correct
unless you restart the program.
gpg> save
Key not changed so no update needed.
[philip@localhost Documents]$
[philip@localhost Documents]$ gpg -e -r pinshanally@gmail.com The_Tee_command.txt
gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
gpg: next trustdb check due at 2019-09-14
[philip@localhost Documents]$ ls -l | grep The
-rw-rw-r--. 1 philip philip 370 Sep 14 11:54 The_Tee_command.txt
-rw-rw-r--. 1 philip philip 827 Sep 14 11:55 The_Tee_command.txt.gpg
[philip@localhost Documents]$
```

太棒了！

# 摘要

在本章中，我们介绍了在 Linux 环境中可以使用的各种安全特性。首先，我们介绍了使用根权限访问命令；特别是，我们看了`su`和`sudo`命令。然后，我们继续讨论 TCP 包装器，重点是`/etc/hosts.allow`和`/etc/hosts.deny`文件。我们研究了这两个文件如何互补，允许通过`/etc/hosts.allow`文件访问，拒绝`/etc/hosts.deny`文件中的所有内容。

接下来，我们介绍了 SSH 我们研究了在客户端和服务器之间设置 SSH 访问，允许无缝登录而无需输入密码，我们介绍了如何使用密码短语。然后，我们缓存了密码，这样用户在登录服务器时就不必输入密码。最后，我们深入讨论了加密。我们关注对称加密，它涉及一个密码短语；然后，我们通过在加密中使用密钥对，使它更上一层楼。最后，我们来看看如何编辑键的属性。

在下一章(也是最后一章)，我们将通过关注 shell 脚本和 SQL 数据管理来完成这本书。在 Linux 环境中工作时，了解一些 shell 脚本和 SQL 管理技能是至关重要的。

# 问题

1.  在`/etc/hosts.allow`中，每次激活规则时，以下哪个命令可以启动另一个命令？

A.所有
B .否认
C .产生
D .日志

2.  `su`代表什么？

A.超级用户
B .替代用户
C .切换用户
D .以上都不是

3.  当我们在没有任何选项的情况下使用`su`命令时，要求以下哪个用户的密码？

A.根用户
B .当前用户
C. SSH 密码
D .以上都不是

4.  以下哪个选项允许在不登录的情况下使用`su`命令执行命令？

A.`-a`T4【b .】`-c`T5【c .】`-d`T6【d .`-l`

5.  在`/etc/sudoers`中声明时，下列哪个符号必须在一个组的前面？

A.`-`T4【b .】`^`T5【c .】`-$`T6【d .`%`

6.  以下哪个命令用于创建 SSH 密钥对？

A.`ssh-keygen`T4【b .】`ssh-key-gen`T5【c .】`ssh-create-key`T6【d .`ssh-key`

7.  以下哪个命令用于向 SSH 代理添加身份？

A.`ssh-add`T4【b .】`ssh-agent`T5【c .】`ssh.service`T6【d .`ssh-daemon`

8.  以下哪个命令可以安全地复制 SSH 公钥？

A.`ssh-copy`T4【b .】`ssh-copy-id`T5【c .】`ssh-cp`T6【d .`ssh-id-copy`

9.  以下哪个选项用于使用`gpg`命令加密文件？

A.`-d`T4【b .】`-e`T5【c .】`-r`T6【d .`-a`

10.  以下哪个选项用于为`gpg`命令提供标识？

A.`-f`T4【b .】`-e`T5【c .】`-r`T6【d .`-a`

# 进一步阅读

*   以下网站提供了关于`sudo`:[https://www.computerhope.com/unix/sudo.htm](https://www.computerhope.com/unix/sudo.htm)的有用信息
*   以下网站提供了关于 SSH 的有用信息:[https://www.ssh.com](https://www.ssh.com)
*   以下网站提供了关于加密的有用信息:[http://linuxaria.com](http://linuxaria.com)