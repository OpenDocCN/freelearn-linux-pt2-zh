# 十六、网络配置和故障排除

在最后一章中，我们对互联网协议版本 4 或 IPv4 和互联网协议版本 6 或(IPv6)进行了深入的研究。除此之外，我们还讨论了子网掩码。之后，我们讨论了子网划分。最后，我们使用了众所周知的协议。我们介绍了一些最广泛使用的协议及其端口号。

在本章中，我们的重点将转移到 IPv4 和 IPv6 的配置上。首先，我们将研究配置 IPv4 地址及其子网掩码的方法。接下来，我们将看看 Linux 系统中的路由表；特别是配置静态路由，并以默认路由配置结束。然后在 Linux 系统中配置 IPv6 地址；然后是 IPv6 的路由表。然后配置 IPv6 路由；最后是 IPv6 默认路由的配置。在这之后，我们的重点就转移到了 DNS 的配置上；特别是，在 Linux 环境中配置指向 DNS 服务器的 DNS IP 地址。最后，本章以网络故障排除结束；我们查看各种命令行工具，这些工具可以帮助我们排除潜在的连接相关问题。

在本章中，我们将涵盖以下主题:

*   IPv4 配置
*   IPv6 配置
*   客户端域名系统
*   网络故障排除

# IPv4 配置

在 Linux 系统中有多种配置 IPv4 地址的方法。首先，我们可以使用图形用户界面实用程序来执行 IPv4 配置。让我们看看我们的 Ubuntu 18 系统。

我们可以选择网络图标，然后选择下拉箭头并选择有线设置，如下图所示:

![](img/00156.jpeg)

太棒了。基于我们在前面例子中看到的，当我们选择有线设置时，它会打开设置对话框；在这之后，我们应该选择齿轮图标。这将打开网络设置。为了配置 IPv4 设置，我们将选择 IPv4 选项卡，如下图所示:

![](img/00157.jpeg)

根据前面的示例，我们可以看到 IPv4 寻址的默认方法是自动(DHCP)；这意味着系统将通过网络上配置为动态发布 IPv4 寻址信息的服务器获取其 IPv4 寻址信息。出于演示的目的，我们希望使用手动方法分配我们的 IPv4 地址。选择手动后，将出现地址字段，允许我们输入 IPv4 地址信息，如下图所示:

![](img/00158.jpeg)

太棒了！根据前面的截图，我们可以看到我们有机会输入 IPv4 信息。我们输入了一个 IPv4 地址；此外，我们将看到一个名为“网络掩码”的文本框，这是子网掩码的另一个名称。输入完 IPv4 地址信息后，我们将选择应用按钮。需要记住的一件重要事情是，我们可以在一个接口上配置多个 IPv4 地址。没错。我们只需点击第二行的文本框，输入我们选择的 IPv4 地址，如下图所示:

![](img/00159.jpeg)

根据我们在前面示例中看到的内容，当我们输入第二个 IPv4 地址时，第三行应该会出现另一个文本框；如果我们在第三行输入 IPv4 地址，这种情况会再次发生。一旦我们对配置满意，我们就应该选择应用按钮来保存我们的更改。管理 IPv4 寻址的另一种方法是通过 Shell；我们可以在命令提示符下使用各种命令添加和删除 IPv4 地址。

# ifconfig 命令

`ifconfig`命令可用于在命令行管理 IPv4 寻址信息。我们可以在没有任何选项的情况下运行`ifconfig`命令，它将只显示活动界面，如下命令所示:

```sh
root@philip-virtual-machine:/home/philip# ifconfig
Command 'ifconfig' not found, but can be installed with:
apt install net-tools
root@philip-virtual-machine:/home/philip#
```

基于我们在前面的命令中发现的内容，我们看到`ifconfig`实用程序在 Ubuntu 18 中默认没有安装；这可以通过运行`apt`或`apt-get`命令轻松解决，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# apt install net-tools
Reading package lists... Done
Building dependency tree 
Reading state information... Done
The following NEW packages will be installed:
 net-tools
Setting up net-tools (1.60+git20161116.90da8a0-1ubuntu1) ...
root@philip-virtual-machine:/home/philip#
```

为了简洁起见，省略了一些输出。现在我们可以再次运行`ifconfig`命令，如下图所示:

```sh
root@philip-virtual-machine:/home/philip# ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.16.175.132  netmask 255.255.255.0  broadcast 172.16.175.255
 inet6 fe80::d5a6:db57:33f4:7285  prefixlen 64  scopeid 0x20<link>
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
 RX packets 75738  bytes 57194615 (57.1 MB)
 RX errors 0  dropped 0  overruns 0  frame 0
 TX packets 35446  bytes 3084763 (3.0 MB)
 TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
 inet 127.0.0.1  netmask 255.0.0.0
 inet6 ::1  prefixlen 128  scopeid 0x10<host>
 loop  txqueuelen 1000  (Local Loopback)
 RX packets 17102  bytes 1274792 (1.2 MB)
 RX errors 0  dropped 0  overruns 0  frame 0
 TX packets 17102  bytes 1274792 (1.2 MB)
 TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
root@philip-virtual-machine:/home/philip#
```

太棒了。基于我们在前面代码中的发现，我们可以看到我们获得了丰富的信息；特别是，IPv4 寻址位于`inet`部分。我们可以过滤以仅显示 IPv4 寻址信息，如以下代码所示:

```sh
root@philip-virtual-machine:/home/philip# ifconfig | grep inet
 inet 172.16.175.132  netmask 255.255.255.0  broadcast 172.16.175.255
 inet6 fe80::d5a6:db57:33f4:7285  prefixlen 64  scopeid 0x20<link>
 inet 127.0.0.1  netmask 255.0.0.0
 inet6 ::1  prefixlen 128  scopeid 0x10<host>
root@philip-virtual-machine:/home/philip#
```

根据前面的代码，除了一些 IPv6 之外，我们还可以看到 IPv4 寻址信息。我们之前又配置了两个 IPv4 地址；但是，它们不会显示，因为默认情况下，只会显示主 IPv4 地址。我们将在下一个命令中看到如何轻松查看这些额外的 IPv4 地址。除了只查看活动界面，我们还可以查看非活动界面；我们将传递`-a`选项，如下面的代码所示:

```sh
root@philip-virtual-machine:/home/philip# ifconfig -a
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.16.175.132  netmask 255.255.255.0  broadcast 172.16.175.255
 inet6 fe80::d5a6:db57:33f4:7285  prefixlen 64  scopeid 0x20<link>
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
 RX packets 75817  bytes 57204880 (57.2 MB)
 RX errors 0  dropped 0  overruns 0  frame 0
 TX packets 35485  bytes 3087793 (3.0 MB)
 TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
 inet 127.0.0.1  netmask 255.0.0.0
 inet6 ::1  prefixlen 128  scopeid 0x10<host>
 loop  txqueuelen 1000  (Local Loopback)
 RX packets 17110  bytes 1275456 (1.2 MB)
 RX errors 0  dropped 0  overruns 0  frame 0
 TX packets 17110  bytes 1275456 (1.2 MB)
 TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
root@philip-virtual-machine:/home/philip#
```

根据我们在前面示例中看到的内容，该系统上只有一个物理接口，因此输出与运行`ifconfig`命令相同，没有任何选项。此外，我们可以使用`ifconfig`命令选择要显示的界面；我们将指定如下代码所示的接口:

```sh
root@philip-virtual-machine:/home/philip# ifconfig ens33
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.16.175.132  netmask 255.255.255.0  broadcast 172.16.175.255
 inet6 fe80::d5a6:db57:33f4:7285  prefixlen 64  scopeid 0x20<link>
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
 RX packets 75825  bytes 57205574 (57.2 MB)
 RX errors 0  dropped 0  overruns 0  frame 0
 TX packets 35493  bytes 3088408 (3.0 MB)
 TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0
root@philip-virtual-machine:/home/philip#
```

太棒了。这在系统可能有很多接口，而你只对一个特定的接口感兴趣的情况下很有用。我们可以使用`ifconfig`命令分配一个 IPv4 地址；我们只需传递接口和 IPv4 地址，如下面的代码所示:

```sh
root@philip-virtual-machine:/home/philip# ifconfig ens33 172.10.1.1
root@philip-virtual-machine:/home/philip# ifconfig ens33
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.10.1.1  netmask 255.255.0.0  broadcast 172.10.255.255
 inet6 fe80::d5a6:db57:33f4:7285  prefixlen 64  scopeid 0x20<link>
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
 RX packets 76407  bytes 57564515 (57.5 MB)
 RX errors 0  dropped 0  overruns 0  frame 0
 TX packets 35550  bytes 3099266 (3.0 MB)
 TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
root@philip-virtual-machine:/home/philip#
```

根据我们在前面代码中的发现，我们可以看到主 IPv4 地址已经更改为我们指定的 IPv4 地址。那么，如果我们不想删除以前的 IPv4 地址呢？我们可以通过创建别名接口来满足这个需求；这只是一个逻辑接口。然后，我们将第二个 IPv4 地址分配给别名接口。以下是我们实现这一目标的方法:

```sh
root@philip-virtual-machine:/home/philip# ifconfig ens33 172.16.175.132/24
root@philip-virtual-machine:/home/philip# ifconfig ens33:0 172.10.1.1
root@philip-virtual-machine:/home/philip# ifconfig ens33
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.16.175.132  netmask 255.255.255.0  broadcast 172.16.175.255
 inet6 fe80::d5a6:db57:33f4:7285  prefixlen 64  scopeid 0x20<link>
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
 RX packets 76902  bytes 57781395 (57.7 MB)
 RX errors 0  dropped 0  overruns 0  frame 0
 TX packets 35579  bytes 3104505 (3.1 MB)
 TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
root@philip-virtual-machine:/home/philip# ifconfig ens33:0
ens33:0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.10.1.1  netmask 255.255.0.0  broadcast 172.10.255.255
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
root@philip-virtual-machine:/home/philip#
```

太棒了！基于这一点，我们现在可以看到，除了创建了具有辅助 IPv4 地址的别名接口之外，我们还在物理接口上获得了原始 IPv4。需要注意的一点是，当我们为别名接口指定 IPv4 地址时，我们没有指定任何子网掩码。系统根据第一个八位字节自动检测子网掩码；子网掩码被设置为乙类子网掩码`255.255.0.0`或`/16`。我们可以通过删除 IPv4 地址，然后用 CIDR 符号添加带有子网掩码的 IPv4 地址来解决这个问题，如下面的代码所示:

```sh
root@philip-virtual-machine:/home/philip# ifconfig ens33:0 down
root@philip-virtual-machine:/home/philip# ifconfig ens33:0
ens33:0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
root@philip-virtual-machine:/home/philip# ifconfig ens33:0 172.10.1.1/23
root@philip-virtual-machine:/home/philip# ifconfig ens33:0
ens33:0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.10.1.1  netmask 255.255.254.0  broadcast 172.10.1.255
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
root@philip-virtual-machine:/home/philip#
```

干得好！根据我们在前面代码中的发现，为了删除 IPv4 地址，我们可以通过键入`down`来禁用接口。然后，我们应该用 CIDR 符号添加带有子网掩码的 IPv4 地址。此外，广播地址是为我们设置的，系统根据子网掩码计算广播地址。但是，我们可以使用`ifconfig`命令设置广播，因此我们将通过`broadcast`选项，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ifconfig ens33:0 broadcast 172.10.20.255
root@philip-virtual-machine:/home/philip# ifconfig ens33:0
ens33:0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.10.0.1  netmask 255.255.254.0  broadcast 172.10.20.255
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
root@philip-virtual-machine:/home/philip#
```

根据我们在前面代码中的发现，我们可以看到广播地址使用我们提供的地址进行了更改。让我们通过将其更改回正确的广播地址来解决这个问题，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ifconfig ens33:0 broadcast 172.10.1.255
root@philip-virtual-machine:/home/philip# ifconfig ens33:0
ens33:0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.10.0.1  netmask 255.255.254.0  broadcast 172.10.1.255
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
root@philip-virtual-machine:/home/philip#
```

删除 IPv4 地址的另一种方法是通过`ifconfig`命令传递`del`选项，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ifconfig ens33:0 del 172.10.0.1
root@philip-virtual-machine:/home/philip# ifconfig ens33:0
ens33:0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
root@philip-virtual-machine:/home/philip#
```

太棒了。在前面的示例中，我们看到 IPv4 地址被成功删除。当我们处理完别名后，我们可以通过传递`down`选项来删除它的配置，如下面的代码所示:

```sh
root@philip-virtual-machine:/home/philip# ifconfig ens33:0 down
root@philip-virtual-machine:/home/philip# ifconfig -a
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.16.175.132  netmask 255.255.255.0  broadcast 172.16.175.255
 inet6 fe80::d5a6:db57:33f4:7285  prefixlen 64  scopeid 0x20<link>
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
 RX packets 77475  bytes 57962754 (57.9 MB)
 RX errors 0  dropped 0  overruns 0  frame 0
 TX packets 35781  bytes 3140240 (3.1 MB)
 TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
 inet 127.0.0.1  netmask 255.0.0.0
 inet6 ::1  prefixlen 128  scopeid 0x10<host>
 loop  txqueuelen 1000  (Local Loopback)
 RX packets 17311  bytes 1289908 (1.2 MB)
 RX errors 0  dropped 0  overruns 0  frame 0
 TX packets 17311  bytes 1289908 (1.2 MB)
 TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
root@philip-virtual-machine:/home/philip#
```

太棒了！看前面的例子，可以看到界面不再用`ifconfig`命令识别。

# ifup 命令

`ifup`命令用于调出或启用界面。该接口然后能够发送和接收数据包。

但是，`ifup`命令只能识别`/etc/network/interfaces`中列出的接口。让我们关闭`ens33`界面，使用`ifup`命令调出`ens33`界面。下面是我们如何做到这一点:

```sh
root@philip-virtual-machine:/home/philip# ifconfig ens33 down
root@philip-virtual-machine:/home/philip# ifup ens33
Unknown interface ens33
root@philip-virtual-machine:/home/philip# cat /etc/network/interfaces
# interfaces(5) file used by ifup(8) and ifdown(8)
auto lo
iface lo inet loopback
root@philip-virtual-machine:/home/philip#
```

基于我们在前面例子中看到的情况，`ifup`没有识别出`ens33`界面。这是因为`ens33`界面没有列在`/etc/network/interfaces`中。我们可以添加这个条目，然后它将与`ifup`命令一起工作。这可以从以下示例中看出:

```sh
root@philip-virtual-machine:/home/philip# cat /etc/network/interfaces
# interfaces(5) file used by ifup(8) and ifdown(8)
auto lo
iface lo inet loopback
auto ens33
iface ens33 inet manual
root@philip-virtual-machine:/home/philip# ifup ens33
root@philip-virtual-machine:/home/philip# ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.16.170.1  netmask 255.255.255.0  broadcast 172.16.170.255
 inet6 fe80::d5a6:db57:33f4:7285  prefixlen 64  scopeid 0x20<link>
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
 RX packets 77776  bytes 58152478 (58.1 MB)
 RX errors 0  dropped 0  overruns 0  frame 0
 TX packets 35893  bytes 3155908 (3.1 MB)
 TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
 inet 127.0.0.1  netmask 255.0.0.0
 inet6 ::1  prefixlen 128  scopeid 0x10<host>
 loop  txqueuelen 1000  (Local Loopback)
 RX packets 17323  bytes 1290784 (1.2 MB)
 RX errors 0  dropped 0  overruns 0  frame 0
 TX packets 17323  bytes 1290784 (1.2 MB)
 TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
root@philip-virtual-machine:/home/philip# 
```

太棒了！基于我们在前面例子中看到的情况，`ifup`命令已经成功调出`ens33`界面。此外，分配的 IPv4 地址是我们通过图形用户界面网络设置配置的 IPv4 地址。在 Ubuntu 18 中，默认情况下，所有网络设置都由网络管理器服务处理；每当我们通过命令提示符进行更改时，如果系统重新启动或者网络管理器服务重新启动，那么通过命令提示符进行的所有更改都将丢失，并且只使用位于`network-manager.service`中的更改。为了解决这个问题，我们需要停止`network-manger.service`，然后禁用网络管理器服务。请注意，如果您不在 Ubuntu 18 系统的`/etc/network/interfaces`中保存对网络设置的更改(包括 IP、子网掩码默认网关、DNS 和 IPs)，这样做可能会使您的系统无法连接。

Do not stop the `network-manager.service` unless you're sure that you've saved the network configuration in the `/etc/network/interfaces` file.

# ifdown 命令

`ifdown`命令可用于关闭或禁用接口；同样，仅识别在`/etc/network/interfaces`中列出的接口。让我们使用`ifdown`命令关闭`ens33`界面，如以下代码所示:

```sh
root@philip-virtual-machine:/home/philip# ifdown ens33
root@philip-virtual-machine:/home/philip# ifconfig
lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
 inet 127.0.0.1  netmask 255.0.0.0
 inet6 ::1  prefixlen 128  scopeid 0x10<host>
 loop  txqueuelen 1000  (Local Loopback)
 RX packets 17323  bytes 1290784 (1.2 MB)
 RX errors 0  dropped 0  overruns 0  frame 0
 TX packets 17323  bytes 1290784 (1.2 MB)
 TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
root@philip-virtual-machine:/home/philip#  
```

太棒了。在前面的例子中，`ifdown`命令成功关闭了`ens33`界面，因为我们在`/etc/network/interfaces`文件中添加了`ens33`界面。

# ip 命令

`ip`命令远比`ifconfig`命令更具扩展性。例如，我们可以使用 ip 命令查看每个接口上配置的所有辅助 IPv4 地址。没有任何选项，`ip`命令将显示可以使用的选项；这可以在下面的例子中看到:

```sh
root@philip-virtual-machine:/home/philip# ip
Usage: ip [ OPTIONS ] OBJECT { COMMAND | help }
 ip [ -force ] -batch filename
where  OBJECT := { link | address | addrlabel | route | rule | neigh | ntable |
tunnel | tuntap | maddress | mroute | mrule | monitor | xfrm |
netns | l2tp | fou | macsec | tcp_metrics | token | netconf | ila |
vrf | sr }
OPTIONS := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |
-h[uman-readable] | -iec |
-f[amily] { inet | inet6 | ipx | dnet | mpls | bridge | link } |
-4 | -6 | -I | -D | -B | -0 |
-l[oops] { maximum-addr-flush-attempts } | -br[ief] |
-o[neline] | -t[imestamp] | -ts[hort] | -b[atch] [filename] |
-rc[vbuf] [size] | -n[etns] name | -a[ll] | -c[olor]}
root@philip-virtual-machine:/home/philip#
```

基于前面的例子，我们可以看到许多可以传递的选项；其中一个选项就是`a`选项。这将显示所有寻址信息，如以下代码所示:

```sh
root@philip-virtual-machine:/home/philip# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
 inet 127.0.0.1/8 scope host lo
 valid_lft forever preferred_lft forever
 inet6 ::1/128 scope host
 valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
 link/ether 00:0c:29:32:fc:d5 brd ff:ff:ff:ff:ff:ff
 inet 172.16.170.1/24 brd 172.16.170.255 scope global noprefixroute ens33
 valid_lft forever preferred_lft forever
 inet 172.16.30.1/24 brd 172.16.30.255 scope global noprefixroute ens33
 valid_lft forever preferred_lft forever
root@philip-virtual-machine:/home/philip#
```

太棒了。看前面的例子，我们马上可以看到`ens33`接口的多个 IPv4 地址。我们可以使用`ip`命令添加一个 IPv4 地址；我们将通过`add`选项，如以下代码所示:

```sh
root@philip-virtual-machine:/home/philip# ip a add 172.16.20.2/24 dev ens33
root@philip-virtual-machine:/home/philip# ip a | grep ens33
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
 inet 172.16.170.1/24 brd 172.16.170.255 scope global noprefixroute ens33
 inet 172.16.30.1/24 brd 172.16.30.255 scope global noprefixroute ens33
 inet 172.16.20.2/24 scope global ens33
root@philip-virtual-machine:/home/philip#
```

太棒了！所以现在我们可以看到添加了 IPv4 地址。同样，我们可以删除和 IPv4 地址；我们将通过`del`选项，如以下代码所示:

```sh
root@philip-virtual-machine:/home/philip# ip a del 172.16.20.2/24 dev ens33
root@philip-virtual-machine:/home/philip# ip a show ens33
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
 link/ether 00:0c:29:32:fc:d5 brd ff:ff:ff:ff:ff:ff
 inet 172.16.170.1/24 brd 172.16.170.255 scope global noprefixroute ens33
 valid_lft forever preferred_lft forever
 inet 172.16.30.1/24 brd 172.16.30.255 scope global noprefixroute ens33
 valid_lft forever preferred_lft forever
root@philip-virtual-machine:/home/philip#
```

基于此，我们可以看到我们用`del`选项指定的 IPv4 地址已经被删除。此外，我们使用了`show`选项，这使我们能够指定我们感兴趣的界面。也可以指定类似于`ifconfig`命令的广播地址。为此，我们将通过`brd`或`broadcast`选项，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ip a add 172.16.20.2/22 brd 255.255.252.0 dev ens33
root@philip-virtual-machine:/home/philip# ip a show ens33
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
 link/ether 00:0c:29:32:fc:d5 brd ff:ff:ff:ff:ff:ff
 inet 172.16.170.1/24 brd 172.16.170.255 scope global noprefixroute ens33
 valid_lft forever preferred_lft forever
 inet 172.16.30.1/24 brd 172.16.30.255 scope global noprefixroute ens33
```

```sh
 valid_lft forever preferred_lft forever
 inet 172.16.20.2/22 brd 255.255.252.0 scope global ens33
 valid_lft forever preferred_lft forever
root@philip-virtual-machine:/home/philip#
```

太棒了！基于前面的例子，我们可以看到广播地址已经被分配给 IPv4 地址。除此之外，还可以使用`ip`命令关闭或启用接口。为此，我们将使用`ip`命令的`link`选项，如以下代码所示:

```sh
root@philip-virtual-machine:/home/philip# ip link set dev ens33 down
root@philip-virtual-machine:/home/philip# ip a show ens33 | grep DOWN
2: ens33: <BROADCAST,MULTICAST> mtu 1500 qdisc fq_codel state DOWN group default qlen 1000
root@philip-virtual-machine:/home/philip#
```

通过查看前面的示例，我们可以看到链接已被关闭。同样，我们可以通过传递`up`选项调出一个界面，如下面的代码所示:

```sh
root@philip-virtual-machine:/home/philip# ip link set dev ens33 up
root@philip-virtual-machine:/home/philip# ip a show ens33 | grep UP
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
root@philip-virtual-machine:/home/philip#
```

太棒了。基于前面的例子，我们可以看到接口被恢复了。我们也可以使用 IP 命令使用别名；我们将通过`ip`命令传递`a`或`add`选项。这可以在下面的代码中看到:

```sh
root@philip-virtual-machine:/home/philip# ip a a 172.50.5.1/24 brd + dev ens33 label ens33:1
root@philip-virtual-machine:/home/philip# ip a show ens33
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
 link/ether 00:0c:29:32:fc:d5 brd ff:ff:ff:ff:ff:ff
 inet 172.16.170.1/24 brd 172.16.170.255 scope global noprefixroute ens33
 valid_lft forever preferred_lft forever
 inet 172.16.30.1/24 brd 172.16.30.255 scope global noprefixroute ens33
 valid_lft forever preferred_lft forever
 inet 172.50.5.1/24 brd 172.50.5.255 scope global ens33:1
 valid_lft forever preferred_lft forever
 inet6 fe80::d5a6:db57:33f4:7285/64 scope link noprefixroute
 valid_lft forever preferred_lft forever
root@philip-virtual-machine:/home/philip#
root@philip-virtual-machine:/home/philip# ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.16.170.1  netmask 255.255.255.0  broadcast 172.16.170.255
 inet6 fe80::d5a6:db57:33f4:7285  prefixlen 64  scopeid 0x20<link>
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
 RX packets 79421  bytes 58846078 (58.8 MB)
 RX errors 0  dropped 1  overruns 0  frame 0
 TX packets 36124  bytes 3191485 (3.1 MB)
 TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
ens33:1: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.50.5.1  netmask 255.255.255.0  broadcast 172.50.5.255
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
 TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
root@philip-virtual-machine:/home/philip#
```

太棒了。基于前面的例子，我们可以看到别名用`ip`命令列在`ens33`下。然而，当我们使用`ifconfig`命令时，我们看到`ens33:1`被列为一个单独的逻辑接口。使用完别名后，我们可以通过使用`ip`命令传递`del`选项来移除别名，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ip a del 172.50.5.1/24 brd + dev ens33 label ens33:1
root@philip-virtual-machine:/home/philip# ip a show ens33
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
 link/ether 00:0c:29:32:fc:d5 brd ff:ff:ff:ff:ff:ff
 inet 172.16.170.1/24 brd 172.16.170.255 scope global noprefixroute ens33
 valid_lft forever preferred_lft forever
 inet 172.16.30.1/24 brd 172.16.30.255 scope global noprefixroute ens33
 valid_lft forever preferred_lft forever
 inet6 fe80::d5a6:db57:33f4:7285/64 scope link noprefixroute
 valid_lft forever preferred_lft forever
root@philip-virtual-machine:/home/philip# ifconfig
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet 172.16.170.1  netmask 255.255.255.0  broadcast 172.16.170.255
 inet6 fe80::d5a6:db57:33f4:7285  prefixlen 64  scopeid 0x20<link>
 ether 00:0c:29:32:fc:d5  txqueuelen 1000  (Ethernet)
root@philip-virtual-machine:/home/philip#
```

为了简洁起见，省略了一些输出。基于前面的例子，我们可以看到别名接口已经被移除。在网络使用虚拟局域网或虚拟局域网的环境中，可以创建能够映射到 VLAN 的子接口，从而有效地使 Linux 系统能够处理被标记的 VLAN 流量。您需要配置网络交换机来标记流量，然后将 VLAN 内部的流量发送到 Linux 系统。然后，Linux 系统和交换机之间的链路被视为`trunk`端口，因为它可以通过其物理链路发送多个虚拟局域网，并且 Linux 系统可以处理流量，因为它知道我们创建的虚拟局域网。我们将使用带`add`选项的`ip link`。下面是我们如何创建子界面并将其映射到 VLAN:

```sh
root@philip-virtual-machine:/home/philip# ip link add link ens33 name ens33.100 type vlan id 100
root@philip-virtual-machine:/home/philip# ip a | grep ens
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
 inet 172.16.170.1/24 brd 172.16.170.255 scope global noprefixroute ens33
 inet 172.16.30.1/24 brd 172.16.30.255 scope global noprefixroute ens33
3: ens33.100@ens33: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000
root@philip-virtual-machine:/home/philip#
```

太棒了！基于我们在前面示例中看到的内容，该接口被创建并被视为一个单独的接口。为了检验这一点，我们可以像分配物理接口一样分配一个 IPv4 地址，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ip a a 172.16.5.5/24 dev ens33.100
root@philip-virtual-machine:/home/philip# ip a | grep ens
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
 inet 172.16.170.1/24 brd 172.16.170.255 scope global noprefixroute ens33
 inet 172.16.30.1/24 brd 172.16.30.255 scope global noprefixroute ens33
3: ens33.100@ens33: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default qlen 1000
 inet 172.16.5.5/24 scope global ens33.100
root@philip-virtual-machine:/home/philip#
```

太棒了。最后一步是打开界面。为此，我们将把`up`选项传递给`ip link`命令，如下面的代码所示:

```sh
root@philip-virtual-machine:/home/philip# ip link set dev ens33.100 up
root@philip-virtual-machine:/home/philip# ip a | grep ens
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
 inet 172.16.170.1/24 brd 172.16.170.255 scope global noprefixroute ens33
 inet 172.16.30.1/24 brd 172.16.30.255 scope global noprefixroute ens33
3: ens33.100@ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default qlen 1000
 inet 172.16.5.5/24 scope global ens33.100
root@philip-virtual-machine:/home/philip#
```

基于前面的例子，我们可以看到映射到 VLAN 100 的子界面现在已经打开。我们可以添加和删除类似于物理接口的 IP 地址信息。当我们处理完子界面后，我们可以通过将`del`选项传递给`ip link`命令来移除它，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ip link del ens33.100
root@philip-virtual-machine:/home/philip# ip a | grep ens
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP group default qlen 1000
 inet 172.16.170.1/24 brd 172.16.170.255 scope global noprefixroute ens33
 inet 172.16.30.1/24 brd 172.16.30.255 scope global noprefixroute ens33
root@philip-virtual-machine:/home/philip#
```

太棒了！查看该示例，我们可以看到子界面不再存在。`ip`命令的另一个有用的目的是能够查看界面的统计数据。我们将通过`ip link`命令传递`-s`和`ls`选项，如以下代码所示:

```sh
root@philip-virtual-machine:/home/philip# ip -s link ls ens33
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
 link/ether 00:0c:29:32:fc:d5 brd ff:ff:ff:ff:ff:ff
 RX: bytes  packets  errors  dropped overrun mcast 
 58851742   79482    0       1       0       0 
 TX: bytes  packets  errors  dropped carrier collsns
 3199078    36174    0       0       0       0 
root@philip-virtual-machine:/home/philip#
```

基于前面的例子，我们可以看到关于接收和发送的数据包的统计数据；我们甚至可以通过在当前命令中添加另一个`-s`选项来查看帧、丢失和 CRC 错误，如以下代码所示:

```sh
root@philip-virtual-machine:/home/philip# ip -s -s link ls ens33
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
 link/ether 00:0c:29:32:fc:d5 brd ff:ff:ff:ff:ff:ff
 RX: bytes  packets  errors  dropped overrun mcast 
 58852018   79485    0       1       0       0 
 RX errors: length   crc     frame   fifo    missed
 0        0       0       0       0 
 TX: bytes  packets  errors  dropped carrier collsns
 3199078    36174    0       0       0       0 
 TX errors: aborted  fifo   window heartbeat transns
 0        0       0       0       20 
root@philip-virtual-machine:/home/philip#
```

太棒了！基于前面的例子，我们可以看到与循环冗余校验、帧等相关的计数器。

# 配置 IPv4 路由

到目前为止，我们已经分配了 IPv4 寻址信息，但是我们没有指定任何类型的路由信息。我们可以使用一些命令来查看当前的路由表。例如，我们可以使用`route`命令显示路由表，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
link-local      0.0.0.0         255.255.0.0     U     1000   0        0 ens33
172.16.30.0     0.0.0.0         255.255.255.0   U     100    0        0 ens33
172.16.170.0    0.0.0.0         255.255.255.0   U     100    0        0 ens33
root@philip-virtual-machine:/home/philip#
```

根据我们在前面示例中看到的内容，仅显示映射到配置的 IPv4 地址的已连接路由。也可以使用`ip`命令显示路由表；我们将传递`route`选项，如下命令所示:

```sh
root@philip-virtual-machine:/home/philip# ip route
169.254.0.0/16 dev ens33 scope link metric 1000
172.16.30.0/24 dev ens33 proto kernel scope link src 172.16.30.1 metric 100
172.16.170.0/24 dev ens33 proto kernel scope link src 172.16.170.1 metric 100
root@philip-virtual-machine:/home/philip#
```

基于前面的示例，我们可以看到类似于 route 命令的信息。另一个可以用来打印路由表的命令是`netstat`命令；为此，我们将通过`-r`选项，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# netstat -r
Kernel IP routing table
Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
link-local      0.0.0.0         255.255.0.0     U         0 0          0 ens33
172.16.30.0     0.0.0.0         255.255.255.0   U         0 0          0 ens33
172.16.170.0    0.0.0.0         255.255.255.0   U         0 0          0 ens33
root@philip-virtual-machine:/home/philip#
```

干得好！在前面的示例中，路由表再次被打印。我们尚未配置默认路由；默认路由用于到达不在同一子网上的主机或位于局域网外的主机。我们将使用带有`add`和`default`选项的`ip route`命令来定义默认路线。以下示例显示了这种情况:

```sh
root@philip-virtual-machine:/home/philip# ip route add default via 172.16.175.1
root@philip-virtual-machine:/home/philip# ip route | grep def
default via 172.16.175.1 dev ens33
root@philip-virtual-machine:/home/philip#
root@philip-virtual-machine:/home/philip# route  | grep UG
default         _gateway        0.0.0.0         UG    0      0        0 ens33
root@philip-virtual-machine:/home/philip#
```

太棒了。根据前面的示例，我们可以看到添加了默认路由。当我们运行`route`命令时，我们看到的是单词`_gateway`而不是 IPv4 地址；我们可以通过`-n`选项查看默认网关的数值。以下示例演示了这一点:

```sh
root@philip-virtual-machine:/home/philip# route -n | grep UG
0.0.0.0         172.16.175.1    0.0.0.0         UG    0      0        0 ens33
root@philip-virtual-machine:/home/philip#
```

太棒了！我们还可以通过指定我们试图到达的子网来创建静态路由。以下是我们实现这一目标的方法:

```sh
root@philip-virtual-machine:/home/philip# ip route add 10.20.0.0/24 via 172.16.30.1
root@philip-virtual-machine:/home/philip# ip route | grep via
default via 172.16.175.1 dev ens33
10.20.0.0/24 via 172.16.30.1 dev ens33
root@philip-virtual-machine:/home/philip#
root@philip-virtual-machine:/home/philip# route -n | grep UG
0.0.0.0         172.16.175.1    0.0.0.0         UG    0      0        0 ens33
10.20.0.0       172.16.30.1     255.255.255.0   UG    0      0        0 ens33
root@philip-virtual-machine:/home/philip#
```

太棒了！基于前面的例子，我们现在可以看到通过`172.16.30.1`为`10.20.0.0/24`子网添加的静态路由。当我们不再需要某条路线时，我们可以使用带有`del`选项的`ip route`命令将其删除，如下命令所示:

```sh
root@philip-virtual-machine:/home/philip# ip route del 10.20.0.0/24 via 172.16.30.1
root@philip-virtual-machine:/home/philip# ip route | grep via
default via 172.16.175.1 dev ens33
root@philip-virtual-machine:/home/philip# route -n | grep UG
0.0.0.0         172.16.175.1    0.0.0.0         UG    0      0        0 ens33
root@philip-virtual-machine:/home/philip#
```

正如我们在前面的例子中看到的那样，`10.20.0.0/24`的静态路由不再出现在我们的路由表中。

# IPv6 配置

我们可以用类似于 IPv4 的方式配置 IPv6 寻址信息。要仅查看 IPv6 地址，我们可以使用`ip`命令并传递`-6`选项，如下命令所示:

```sh
root@philip-virtual-machine:/home/philip# ip -6 a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 state UNKNOWN qlen 1000
 inet6 ::1/128 scope host
 valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 state UP qlen 1000
```

```sh
 inet6 fe80::d5a6:db57:33f4:7285/64 scope link noprefixroute
 valid_lft forever preferred_lft forever
root@philip-virtual-machine:/home/philip#
```

基于前面的例子，我们只能看到 IPv6 信息，尤其是以`fe80`开头的链路本地地址。我们可以使用`ip`命令添加 IPv6 地址。我们将通过以下方式添加 IPv6 地址:

```sh
root@philip-virtual-machine:/home/philip# ip -6 a a 2001:0db8:0:f101::1/64 dev ens33
root@philip-virtual-machine:/home/philip# ip -6 a show ens33
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 state UP qlen 1000
 inet6 2001:db8:0:f101::1/64 scope global
 valid_lft forever preferred_lft forever
 inet6 fe80::d5a6:db57:33f4:7285/64 scope link noprefixroute
 valid_lft forever preferred_lft forever
root@philip-virtual-machine:/home/philip#
```

太棒了！在前面的例子中，我们可以看到 IPv6 地址被分配给了`ens33`接口。此外，我们可以使用`ifconfig`命令显示 IPv6 寻址信息，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ifconfig | egrep 'ens|inet6'
ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
 inet6 2001:db8:0:f101::1  prefixlen 64  scopeid 0x0<global>
 inet6 fe80::d5a6:db57:33f4:7285  prefixlen 64  scopeid 0x20<link>
 inet6 ::1  prefixlen 128  scopeid 0x10<host>
root@philip-virtual-machine:/home/philip#
```

看前面的例子，我们可以在`inet6`部分看到 IPv6 信息。也可以配置多个 IPv6 地址；我们只需将`ip`与`-6`命令一起使用，如下命令所示:

```sh
root@philip-virtual-machine:/home/philip# ip -6 a a 2001:0db8:0:f102::2/64 dev ens33
root@philip-virtual-machine:/home/philip# ip -6 a show ens33
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 state UP qlen 1000
 inet6 2001:db8:0:f102::2/64 scope global
 valid_lft forever preferred_lft forever
 inet6 2001:db8:0:f101::1/64 scope global
 valid_lft forever preferred_lft forever
 inet6 fe80::d5a6:db57:33f4:7285/64 scope link noprefixroute
 valid_lft forever preferred_lft forever
root@philip-virtual-machine:/home/philip#
```

基于该示例，我们可以看到添加了第二个 IPv6 地址。当我们不再需要 IPv6 地址时，我们可以通过`ip`命令传递`del`选项，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ip -6 a del 2001:0db8:0:f102::2/64 dev ens33
root@philip-virtual-machine:/home/philip# ip -6 a show ens33
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 state UP qlen 1000
 inet6 2001:db8:0:f101::1/64 scope global
 valid_lft forever preferred_lft forever
 inet6 fe80::d5a6:db57:33f4:7285/64 scope link noprefixroute
 valid_lft forever preferred_lft forever
root@philip-virtual-machine:/home/philip#
```

太棒了！在前面的例子中，IPv6 地址被删除了，这是我们用`del`选项指定的。

# 配置 IPv6 路由

我们已经查看了 IPv4 路由表，但是还有一个 IPv6 路由表。我们可以使用相同的`ip route`命令和`-6`选项，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ip -6 route
2001:db8:0:f101::/64 dev ens33 proto kernel metric 256 pref medium
fe80::/64 dev ens33 proto kernel metric 100 pref medium
fe80::/64 dev ens33 proto kernel metric 256 pref medium
root@philip-virtual-machine:/home/philip#
```

正如我们在前面的示例中看到的，只显示了 IPv6 路由信息。此系统中当前没有为 IPv6 配置默认网关。我们可以通过使用`ip route`命令并传递`-6`和`add`选项来解决这个问题，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ip -6 route add ::/0 via 2001:db8:0:f101::2
root@philip-virtual-machine:/home/philip# ip -6 route
2001:db8:0:f101::/64 dev ens33 proto kernel metric 256 pref medium
fe80::/64 dev ens33 proto kernel metric 100 pref medium
fe80::/64 dev ens33 proto kernel metric 256 pref medium
default via 2001:db8:0:f101::2 dev ens33 metric 1024 pref medium
root@philip-virtual-machine:/home/philip#
```

太棒了。在前面的示例中，我们可以看到为 IPv6 添加了默认路由。我们还可以使用 route 命令查看 IPv6 路由信息；我们将通过`-6`选项，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# route -6 | grep UG
[::]/0                         _gateway                   UG   1024 1     0 ens33
root@philip-virtual-machine:/home/philip#
root@philip-virtual-machine:/home/philip# route -6 -n | grep UG
::/0                           2001:db8:0:f101::2         UG   1024 1     0 ens33
root@philip-virtual-machine:/home/philip#
```

太棒了！根据前面的示例，我们可以看到默认网关的 IPv6 地址。也可以为 IPv6 子网配置静态路由，该子网位于不同的 IPv6 子网或局域网之外。下面是我们如何为 IPv6 子网添加静态路由:

```sh
root@philip-virtual-machine:/home/philip# ip -6 route add 2001:db8:2222:1::/64 via 2001:db8:0:f101::2
root@philip-virtual-machine:/home/philip# ip -6 route | grep via
2001:db8:2222:1::/64 via 2001:db8:0:f101::2 dev ens33 metric 1024 pref medium
default via 2001:db8:0:f101::2 dev ens33 metric 1024 pref medium
root@philip-virtual-machine:/home/philip# route -6 | grep UG
2001:db8:2222:1::/64           _gateway                   UG   1024 1     0 ens33
[::]/0                         _gateway                   UG   1024 1     0 ens33
root@philip-virtual-machine:/home/philip# route -6 -n | grep UG
2001:db8:2222:1::/64           2001:db8:0:f101::2         UG   1024 1     0 ens33
::/0                           2001:db8:0:f101::2         UG   1024 1     0 ens33
root@philip-virtual-machine:/home/philip#
```

干得好！在前面的示例中，您可以看到我们为 IPv6 子网添加了静态路由。同样，我们可以通过传递带有`ip route`命令的`del`选项来删除 IPv6 子网的静态路由，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ip -6 route del 2001:db8:2222:1::/64 via 2001:db8:0:f101::2
root@philip-virtual-machine:/home/philip# route -6 -n | grep UG
::/0                           2001:db8:0:f101::2         UG   1024 1     0 ens33
root@philip-virtual-machine:/home/philip#
```

太棒了！

# 客户端域名系统

到目前为止，我们已经在系统中为网络连接分配了寻址信息(IPv4 和 IPv6)。然而，为了我们能够浏览互联网，我们将不得不在系统中配置域名系统；具体来说，我们需要告诉 Linux 系统在尝试上网时使用哪个 DNS 服务器。正如我们在本章前面看到的，我们可以使用图形用户界面实用程序为 IPv4、IPv6、网关和 DNS 信息填写各种文本框。这里，我们将在命令提示符下查看配置 DNS 信息；尤其是`/etc/resolv.conf`文件。以下是`/etc/resolv.conf`文件的内容:

```sh
root@philip-virtual-machine:/home/philip# cat /etc/resolv.conf
# This file is managed by man:systemd-resolved(8). Do not edit.
nameserver 127.0.0.53
root@philip-virtual-machine:/home/philip#
```

为了简洁起见，省略了一些输出。从前面的例子可以看出，在 Ubuntu 18 中定义 DNS 服务器的格式如下:

```sh
nameserver <DNS IP>
```

基于该代码，我们可以在该文件中指定我们的 DNS 服务器 IP。看看能不能浏览互联网，如下图截图所示:

![](img/00160.jpeg)

根据我们在前面例子中看到的，我们无法接触到互联网。我们用 vi 或 nano 等编辑器在`/etc/resolv.conf`里面放一个 DNS 服务器的 IP 地址；下面的条目是我们想要放进去的:

```sh
root@philip-virtual-machine:/home/philip# cat /etc/resolv.conf | grep name
nameserver 8.8.8.8
root@philip-virtual-machine:/home/philip#
```

正如我们在前面的例子中看到的，我们添加了一个域名系统条目。现在，当我们刷新页面时，我们将看到内容开始填充页面，如下图所示:

![](img/00161.jpeg)

太棒了！我们还可以在`/etc/hosts`文件内创建本地域名解析的本地 DNS 条目。以下是`/etc/hosts file`的内容:

```sh
root@philip-virtual-machine:/home/philip# cat /etc/hosts
127.0.0.1              localhost
127.0.1.1              philip-virtual-machine
# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
root@philip-virtual-machine:/home/philip#
```

我们可以编辑这个文件，并使用文本编辑器(如 vi 或 nano)为 Fedora 28 系统添加一个条目。下面是我们添加到其中的一个示例条目:

```sh
root@philip-virtual-machine:/home/philip# cat /etc/hosts | grep Fed
172.16.175.129  Fedora28
root@philip-virtual-machine:/home/philip#
```

太棒了。现在，我们可以通过使用其 IP 地址或名称来满足 Fedora 28 系统，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ssh philip@Fedora28
The authenticity of host 'fedora28 (172.16.175.129)' can't be established.
ECDSA key fingerprint is SHA256:DqRh+J43GfuMKC0i+QHkMU+V2MpephHZqSYANA362hg.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added 'fedora28' (ECDSA) to the list of known hosts.
philip@fedora28's password:
root@philip-virtual-machine:/home/philip#
```

太棒了！

# 网络故障排除

我们可以使用许多工具来帮助我们排除网络连接问题，从图形用户界面实用程序到命令行工具。我们的重点将是使用我们可用的命令行工具进行故障排除。

# ping 命令

`ping`实用程序使用 ICMP 协议发送请求和接收回复。我们可以使用 ping 实用程序来测试本地或互联网上系统之间的基本可达性。ping 实用程序的基本语法是:

```sh
ping  <DNS name or IPv4>
```

基于我们在前面示例中看到的内容，我们现在可以试用`ping`实用程序，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# ping Fedora28
PING Fedora28 (172.16.175.129) 56(84) bytes of data.
64 bytes from Fedora28 (172.16.175.129): icmp_seq=1 ttl=64 time=0.299 ms
64 bytes from Fedora28 (172.16.175.129): icmp_seq=2 ttl=64 time=0.341 ms
64 bytes from Fedora28 (172.16.175.129): icmp_seq=3 ttl=64 time=0.733 ms
64 bytes from Fedora28 (172.16.175.129): icmp_seq=4 ttl=64 time=0.957 ms
64 bytes from Fedora28 (172.16.175.129): icmp_seq=5 ttl=64 time=0.224 ms
^C
--- Fedora28 ping statistics ---
6 packets transmitted, 6 received, 0% packet loss, time 5064ms
rtt min/avg/max/mdev = 0.224/0.564/0.957/0.287 ms
root@philip-virtual-machine:/home/philip#
```

正如我们在前面的例子中看到的那样，`ping`实用程序将一直运行，直到用户使用 *CTRL* + *C* 将其停止；这在 Windows 环境中是不同的，在 Windows 环境中，只能看到四个 ICMP 回应请求/回复。

# ping6 命令

还可以测试 IPv6 的潜在连接问题。我们将使用`ping6`命令；`ping6`命令的语法如下:

```sh
ping6  <DNS name or IPv6>
```

根据我们在前面示例中看到的内容，我们只需指定目标系统的域名或 IPv6 地址。下面是我们如何使用`ping6`命令:

```sh
root@philip-virtual-machine:/home/philip# ping6 2001:db8:0:f101::3
PING 2001:db8:0:f101::3(2001:db8:0:f101::3) 56 data bytes
64 bytes from 2001:db8:0:f101::3: icmp_seq=1 ttl=64 time=0.355 ms
64 bytes from 2001:db8:0:f101::3: icmp_seq=2 ttl=64 time=0.289 ms
64 bytes from 2001:db8:0:f101::3: icmp_seq=3 ttl=64 time=0.222 ms
64 bytes from 2001:db8:0:f101::3: icmp_seq=4 ttl=64 time=0.596 ms
^C
--- 2001:db8:0:f101::3 ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3052ms
rtt min/avg/max/mdev = 0.222/0.365/0.596/0.142 ms
root@philip-virtual-machine:/home/philip#
```

太棒了。

# traceroute 命令

我们可以使用`traceroute`命令来测试潜在的连接问题。`traceroute`命令显示目标系统路径上的每个设备；每个设备都被认为是一个`hop`。`traceroute`的基本语法如下:

```sh
traceroute <DNS name or IPv4>
```

您可以看到，我们只需要指定目标系统的域名或 IPv4 地址。这在以下示例中显示:

```sh
root@philip-virtual-machine:/home/philip# traceroute Fedora28
Command 'traceroute' not found, but can be installed with:
apt install inetutils-traceroute
apt install traceroute 
root@philip-virtual-machine:/home/philip# apt install inetutils-traceroute
update-alternatives: using /usr/bin/inetutils-traceroute to provide /usr/bin/traceroute (traceroute) in auto mode
Processing triggers for man-db (2.8.3-2) ...
root@philip-virtual-machine:/home/philip#
```

正如我们在前面的例子中看到的，`traceroute`实用程序在 Ubuntu 18 中默认不安装；我们通过安装`inetutils-traceroute`包很快补救了这一点。现在让我们再次尝试运行`traceroute`命令，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# traceroute Fedora28
traceroute to Fedora28 (172.16.175.129), 64 hops max
 1 172.16.175.129 0.199ms 0.199ms 0.251ms
root@philip-virtual-machine:/home/philip#
```

太棒了。基于前面的例子，我们可以看到该设备距离 Ubuntu 系统有一跳之遥。

# traceroute6 命令

也可以使用`traceroute6`命令测试 IPv6 系统之间的潜在瓶颈。`traceroute6`命令的基本语法如下:

```sh
traceroute6  <DNS name or IPv6>
```

根据我们在前面示例中看到的内容，我们只需指定目标系统的域名或 IPv6 地址。以下示例显示了我们将如何使用`traceroute6`命令:

```sh
root@philip-virtual-machine:/home/philip# traceroute6 2001:db8:0:f101::2
traceroute to 2001:db8:0:f101::2 (2001:db8:0:f101::2) from 2001:db8:0:f101::1, 30 hops max, 24 byte packets
sendto: Invalid argument
 1 traceroute: wrote 2001:db8:0:f101::2 24 chars, ret=-1
^C
root@philip-virtual-machine:/home/philip#
```

所以我们可以看到`traceroute6`命令的工作方式与`traceroute`命令相似。

# netstat 命令

我们可以使用`netstat`命令来解决许多不同的问题。我们在本章前面讨论路由时已经看到，我们需要通过`-r`选项来查看路由表。我们也可以使用`netstat`命令来查看活动连接。当我们使用不同的端口运行不同的程序时，这在服务器环境中特别有用；这些端口可以是 TCP 或 UDP 端口。我们可以通过`-n`选项，显示数字地址；`-t`选项，显示 TCP 连接；`-l`，显示哪些插座在监听；和显示节目标识和节目名称的`-p`选项。当试图缩小您的 TCP 端口时，这些选项可以很好地协同工作。下面是 TCP 的情况:

![](img/00162.jpeg)

太棒了！看前面的例子，我们可以看到很多程序在运行，包括`dns`、`sshd`、`ryslogd`等等。同样，我们可以查看 UDP 连接；我们将通过`nulp`选项。`-u`表示 UDP，如下例所示:

![](img/00163.jpeg)

太棒了！看前面的例子，我们可以看到相当多的服务在监听连接，`systemd-resolve`(端口`53`)就是其中之一。

# tracepath 命令

`tracepath`命令是测试系统之间潜在瓶颈的另一种方法。它的工作方式类似于`traceroute`命令。`tracepath`命令的基本语法如下:

```sh
tracepath <DNS name or IPv4>
```

根据我们在前面例子中看到的，我们只需要指定域名或 IPv4 地址就可以使用`tracepath`命令。这在以下命令中显示:

```sh
root@philip-virtual-machine:/home/philip# tracepath Fedora28
 1?: [LOCALHOST]          pmtu 1500
 1:  Fedora28             0.309ms reached
 1:  Fedora28             0.201ms reached
 Resume: pmtu 1500 hops 1 back 1
root@philip-virtual-machine:/home/philip#
```

在前面的示例中，除了到目的设备的跳数之外，还显示了`pmtu`或`Path MTU`。

# tracepath -6 命令

类似于`tracepath`命令，带有`-6`选项的`tracepath`是测试使用 IPv6 寻址的系统之间潜在瓶颈的另一种方法。带有`-6`选项的`tracepath`的基本语法如下:

```sh
tracepath -6 <DNS name or IPv6>
```

根据我们在前面示例中看到的内容，我们只需指定域名或 IPv6 地址，即可将`tracepath`与`-6`选项一起使用。这在以下示例中显示:

```sh
root@philip-virtual-machine:/home/philip# tracepath -6 2001:db8:0:f101::3
 1?: [LOCALHOST]                        0.012ms pmtu 1500
 1:  2001:db8:0:f101::3                                    0.384ms reached
 1:  2001:db8:0:f101::3                                    0.352ms reached
 Resume: pmtu 1500 hops 1 back 1
root@philip-virtual-machine:/home/philip#
```

太棒了！基于我们在前面示例中看到的内容，我们可以看到带有`-6`选项的`tracepath`的工作方式类似于用于 IPv4 的`tracepath`命令。

# nmap 命令

网络映射器(nmap)也可以通过使用`nmap`命令排除潜在的连接问题；该命令扫描给定的系统，并显示为使用`nmap`命令指定的系统打开的服务及其各自的端口号。

`nmap`命令的基本语法如下:

```sh
nmap <option>  <IP of destination>
```

根据我们在上一个示例中看到的内容，我们将指定我们正在排除故障的目标系统的选项和 IP，如下例所示:

```sh
root@Linuxplus:/home/philip# nmap -A -T4 172.16.175.129
Nmap scan report for Fedora28 (172.16.175.129)
Host is up (0.00066s latency).
Not shown: 845 closed ports, 154 filtered ports
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 7.7 (protocol 2.0)
| ssh-hostkey:
|   2048 b8:02:f8:79:f4:d8:77:b4:26:de:70:93:e8:66:94:69 (RSA)
|   256 9b:e0:d1:33:3b:08:02:bf:fd:c6:48:c1:47:7d:9c:9e (ECDSA)
|_  256 cd:f8:47:d1:75:95:e3:59:f3:b6:c0:12:a0:8b:d1:0e (EdDSA)
MAC Address: 00:0C:29:04:35:BD (VMware)
Device type: general purpose
Running: Linux 3.X|4.X
OS CPE: cpe:/o:linux:linux_kernel:3 cpe:/o:linux:linux_kernel:4
OS details: Linux 3.10 - 4.8
Network Distance: 1 hop
TRACEROUTE
HOP RTT     ADDRESS
1   0.66 ms Fedora28 (172.16.175.129)
OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 49.30 seconds
root@Linuxplus:/home/philip#
```

太棒了！基于前面的示例，我们可以看到目标系统上运行的是哪个服务及其各自的端口号。`-A`选项用于显示操作系统和版本检测；`-T4`选项用于更快的执行。在运行`nmap`命令之前，您应该征求目标系统或网络的所有者或管理员的许可；尤其是在有策略管理给定网络使用的公司环境中。

Always seek permission before performing any kind of port scans in a network.

# 挖掘命令

到目前为止，我们已经研究了排除连接问题的方法，但是 DNS 问题也可能带来风险。我们可以使用`dig`实用程序为给定的域执行域名系统查找。`dig`命令的基本语法如下:

```sh
dig <domain>
```

如您所见，我们只需指定要对其执行查找的域。

下面是我们执行简单查找的方法:

```sh
root@philip-virtual-machine:/home/philip# dig www.packtpub.com
; <<>> DiG 9.11.3-1ubuntu1-Ubuntu <<>> www.packtpub.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 39472
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1
;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;www.packtpub.com.                    IN           A
;; ANSWER SECTION:
www.packtpub.com.     14037    IN           CNAME                varnish.packtpub.com.
varnish.packtpub.com.  14049    IN           A             83.166.169.231
;; Query time: 77 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Wed Mar 06 16:21:23 -04 2019
;; MSG SIZE  rcvd: 83
root@philip-virtual-machine:/home/philip#
```

太棒了！基于前面的例子，我们可以看到给定域的 DNS 记录；特别是我们可以看到`A`的记录。回答我们查询的服务器是`8.8.8.8`，我们在`/etc/resolv.conf`配置的。但是，我们可以通过传递带有`dig`命令的`@`来使用不同的域名系统服务器，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# dig @8.8.4.4 packtpub.com
; <<>> DiG 9.11.3-1ubuntu1-Ubuntu <<>> @8.8.4.4 packtpub.com
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 16754
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;packtpub.com.                                                IN          A
;; ANSWER SECTION:
packtpub.com.                  21599    IN           A             83.166.169.231
;; Query time: 116 msec
;; SERVER: 8.8.4.4#53(8.8.4.4)
;; WHEN: Wed Mar 06 16:25:29 -04 2019
;; MSG SIZE  rcvd: 57
root@philip-virtual-machine:/home/philip#
```

从前面的例子中我们可以看到，我们已经指定了一个不同的 DNS 服务器来回答我们的查询。除此之外，我们还可以通过传递`NS`和`dig`命令来查找特定的域名系统信息，如名称服务器或域名系统，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# dig @8.8.4.4 packtpub.com NS
; <<>> DiG 9.11.3-1ubuntu1-Ubuntu <<>> @8.8.4.4 packtpub.com NS
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 40936
;; flags: qr rd ra; QUERY: 1, ANSWER: 4, AUTHORITY: 0, ADDITIONAL: 1
;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;packtpub.com.                                                IN           NS
;; ANSWER SECTION:
packtpub.com.                  21599    IN           NS          dns2.easydns.net.
packtpub.com.                  21599    IN           NS          dns3.easydns.org.
packtpub.com.                  21599    IN           NS          dns4.easydns.info.
packtpub.com.                  21599    IN           NS          dns1.easydns.com.
;; Query time: 105 msec
;; SERVER: 8.8.4.4#53(8.8.4.4)
;; WHEN: Wed Mar 06 16:26:06 -04 2019
;; MSG SIZE  rcvd: 159
root@philip-virtual-machine:/home/philip#
```

太棒了！在前面的例子中，我们可以看到给定域的名称服务器。

# whois 命令

也可以使用`whois`命令获取某个域的信息。`whois`命令的基本语法如下:

```sh
whois <domain>
```

因此，我们可以简单地用`whois`命令传递一个域名，并获得给定域的有价值的信息，如下例所示:

```sh
root@Linuxplus:/home/philip# whois packtpub.com
 Domain Name: PACKTPUB.COM
 Registry Domain ID: 97706392_DOMAIN_COM-VRSN
 Registrar WHOIS Server: whois.easydns.com
 Registrar URL: http://www.easydns.com
 Updated Date: 2015-08-10T20:01:35Z
 Creation Date: 2003-05-09T14:34:02Z
 Registry Expiry Date: 2024-05-09T14:34:02Z
 Registrar: easyDNS Technologies, Inc.
 Registrar IANA ID: 469
 Registrar Abuse Contact Email:
 Registrar Abuse Contact Phone:
 Domain Status: clientTransferProhibited https://icann.org/epp#clientTransferProhibited
 Domain Status: clientUpdateProhibited https://icann.org/epp#clientUpdateProhibited
 Name Server: DNS1.EASYDNS.COM
 Name Server: DNS2.EASYDNS.NET
 Name Server: DNS3.EASYDNS.ORG
 Name Server: DNS4.EASYDNS.INFO
You have 20 lookups left today
root@Linuxplus:/home/philip#
```

太棒了。为了简洁起见，省略了一些输出。前面的例子表明，我们得到了给定领域的大量信息。

# 主机名命令

此命令仅用于设置或返回系统的域名和系统的 IP 地址。基本语法如下:

```sh
hostname <options> <new hostname>
```

该示例显示，如果我们简单地输入`hostname`命令，它将产生以下代码:

```sh
root@philip-virtual-machine:/home/philip# hostname
philip-virtual-machine
root@philip-virtual-machine:/home/philip#
```

所以，我们可以看到系统的 DNS 名称。我们也可以通过`-i`选项查看与`hostname`关联的 IP，如下例所示:

```sh
root@philip-virtual-machine:/home/philip# hostname -i
127.0.1.1
root@philip-virtual-machine:/home/philip#
```

太棒了！基于前面的例子，我们可以从`127.0.0.0/8`的环回范围看到一个 IP。我们可以通过传递一个新的`hostname`值来改变`hostname`，如下面的代码所示:

```sh
root@philip-virtual-machine:/home/philip# hostname Linuxplus
root@philip-virtual-machine:/home/philip# hostname
Linuxplus
root@philip-virtual-machine:/home/philip#
```

使用前面的例子，我们可以看到`hostname`命令表示`hostname`已经更改，但是没有更新提示。我们可以退出 root 并重新登录，我们将看到以下更改:

```sh
root@philip-virtual-machine:/home/philip# exit
exit
philip@philip-virtual-machine:~$ sudo su
[sudo] password for philip:
root@Linuxplus:/home/philip#
```

太棒了！现在我们可以看到主机名被更改以反映我们指定的名称。但是，当我们重新启动系统时，主机名将被设置回`/etc/hostname`文件中指定的值，如下例所示:

```sh
root@Linuxplus:/home/philip# cat /etc/hostname
philip-virtual-machine
root@Linuxplus:/home/philip#reboot
root@philip-virtual-machine:/home/philip# cat /etc/hostname
philip-virtual-machine
root@philip-virtual-machine:/home/philip# hostname Linuxplus
```

我们可以通过使用文本编辑器(如 vi 或 nano)编辑`/etc/hostname`文件来解决这个问题，并按如下代码所示放置该值:

```sh
root@philip-virtual-machine:/home/philip#cat /etc/hostname
Linuxplus
root@philip-virtual-machine:/home/philip# reboot
root@Linuxplus:/home/philip#
```

太棒了！

# 摘要

在本章中，我们配置了 IPv4、IPv6 配置、客户端 DNS 和网络故障排除。首先，我们使用了 IPv4，并研究了管理 IPv4 寻址的各种方法。接下来，我们介绍了 IPv4 路由；我们看到了除了为未直接连接的子网添加静态路由之外，如何添加默认路由。随后是 IPv6 配置；我们看到了如何通过命令行使用各种工具来管理我们的 IPv6 基础架构。接下来，我们研究了如何为 IPv6 配置路由，特别是针对未直接连接的子网的默认路由和静态路由。接下来，我们介绍了客户端域名系统。我们研究了配置域名系统服务器的 IP 地址的方法。然后，我们通过浏览互联网来测试我们的域名系统配置。最后，我们讲述了网络故障排除；我们介绍了命令行中可用的许多工具，以帮助我们排除潜在的网络连接问题。

在下一章中，我们将重点讨论安全性；特别是主机安全、SSH 和加密。下一章至关重要，因为当今环境中存在许多安全风险。希望下一章能见到你。

# 问题

1.  使用`ifconfig`命令的哪个选项显示所有活动和非活动界面？

A.`-s`T4【b .】`-d`T5【c .】`-A`T6【d .`-a`

2.  创建最后的网关时，哪个关键字与`ip`路由命令一起使用？

A.`default`
B. `0.0.0.0`
C .关口
D .以上都不是

3.  `ping`使用哪种协议在源和目的地之间发送和接收消息？

A.FTP
b . TFTP
c . icmp
d . ssh . 1.1

4.  哪个文件保存了系统的`hostname`值？

A.`/etc/hosts`T4【b .】`/etc/hostname`T5【c .】`/etc/hostname/hosts`T6【d .`/var/log/hosts`

5.  哪个命令执行跟踪并输出跳跃以及`pmtu`值？

A.`traceroute`T4【b .】`trace`T5【c .】`tracepath`T6【d .`tracert`

6.  哪个命令执行给定域的 DNS 查询？

A.`ping`T4【b .】`traceroute`T5【c .】`dnsq`T6【d .`dig`

7.  哪个命令为 IPv6 添加了默认路由？

A.`ip -6 route add default via 2001:db8:0:f101::2`T4【b .】`iproute add default via 2001:db8:0:f101::2`T5【c .】`ip-6 route add default via 2001:db8:0:f101::2`T6【d .`ip -6 add default via 2001:db8:0:f101::2`

8.  netstat 命令的哪些选项显示了打开的 UDP 连接的 IP 地址和端口号，以及程序 ID 和程序名称？

A.`-t`T4【b .】`-u`T5【c .】`-udp`T6【d .`-ulp`

9.  哪个命令用于扫描系统，以便显示正在使用的服务及其各自的端口号？

A.`traceroute`T4【b .】`dig`T5【c .】`nmap`T6【d .`ip`

10.  哪个命令显示给定域的注册表信息？

A.`who`T4【b .】`whois`T5【c .】`whoami`T6【d .`w`

# 进一步阅读

*   本网站提供了有关配置 IPv4 和 IPv6 的有用信息:[https://superuser.com](https://superuser.com)
*   本网站提供了有关配置客户端域名系统的有用信息:[https://unix.stackexchange.com](https://unix.stackexchange.com)
*   本网站提供了有关故障排除的有用信息:[https://www.computernetworkingnotes.com](https://www.computernetworkingnotes.com)