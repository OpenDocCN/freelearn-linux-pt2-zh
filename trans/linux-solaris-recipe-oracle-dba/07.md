# 七、Shell 脚本

Shell 脚本是每个专业 DBA 都必须掌握的一项重要技能。大多数 DBA 使用这种编码技术来自动化许多关键的数据库管理任务，比如备份和监控。作为您工作的一部分，您将被要求维护以前的 DBA 编写的脚本，并且您还将被要求根据需要编写新的 shell 脚本。你越擅长编写脚本，你就能越好地完成你的工作。为了有效地编写 shell 脚本，DBA 至少需要熟悉四种工具:

*   结构化查询语言
*   文字编辑器
*   外壳接口
*   外壳脚本语言

映射到前面列表的最常见工具是 SQL*Plus、`vi (or vim)`编辑器和 Bash shell。Bash shell 既是一个 shell 接口，也是一种脚本语言。前面的项目符号列表是您应该熟悉的工具的最小列表。您将在 shell 脚本中调用各种 Oracle 数据库实用程序，如 SQL*Plus、RMAN、数据泵、外部表等。

如前几章所述，shell 是一个命令行界面，允许您与 Linux/Solaris 内核进行交互。DBA 和开发人员常用的一些 shell 是 Bash shell ( `bash`)、Korn shell ( `ksh`)和 C shell ( `csh`或改进的`tcsh`)。正如在[第 3 章](03.html)中所解释的，这本书主要关注 Bash shell，所以我们不会在这里重复这些细节。

shell 脚本是一个 OS 文件，它包含一个或多个 shell 可以执行的命令。shell 可以执行的任何命令都可以放在 shell 脚本文件中。例如，shell 脚本可以运行其他 shell 脚本、可执行二进制文件(如`sqlplus`或`rman`)或任何系统实用程序(如`df`、`ps`等)。

DBA 使用 shell 脚本执行关键任务，例如主动监控数据库和进行备份。这些关键任务需要可重复且可靠。DBA 通常使用 shell 脚本运行一系列命令来完成所需的任务。DBA 喜欢 shell 脚本，因为他们不需要成为编程专家来编写 shell 脚本。有了基础知识(和一个很好的例子)，创建一个执行所需任务的 shell 脚本是相当快速和容易的。

本章的目的是提供一组核心技术，使您能够成功地编写 shell 脚本。

本章并没有涵盖 shell 脚本的所有方面(这需要一整本书才能完成)。相反，我们为您提供了 DBA 执行工作所需的通用方法和 shell 脚本基础。我们还提供了有用的真实世界的例子。一旦您熟练掌握了 shell 脚本，您就能够利用这些技能来自动化关键的数据库作业。有人可能会说，数据库管理员可能专门使用图形用户界面(GUI)来自动化数据库任务。我们强烈建议您学习如何编写 shell 脚本来自动化数据库管理任务。如果 GUI 变得不可访问或者不能做您需要它做的事情，为了您的工作，您最好知道如何编写和调试 shell 脚本。

本章的第一个菜谱向您介绍了如何编写 shell 脚本的基础知识。

## 7-1.编写简单的 Shell 脚本

### 问题

您是 shell 编程的新手，希望编写一个简单的脚本来确定您的数据库是否可访问。

### 解决办法

使用编辑器创建一个新文件(关于使用`vi`文件编辑器的详细信息，参见[第 4 章](04.html))。将以下文本放入文件中:

`#!/bin/bash`

`# Check if database is up.`

`ORACLE_SID=O1212`

`ORACLE_HOME=/orahome/app/oracle/product/12.1.0.2/db_1`

`PATH=$ORACLE_HOME/bin:$PATH`

`echo "select ’DB up’ from dual;" | sqlplus -s system/foo`

`exit 0`

修改前面的代码以匹配您的`ORACLE_SID`和`ORACLE_HOME`变量以及您的`system`模式密码。创建文件后，您还需要修改文件的权限以使其可执行。在本例中，文件名为`dbcheck.bsh`:

`$ chmod +x dbcheck.bsh`

这段代码将文件的权限更改为可执行文件(`x`)。现在，您应该能够成功运行该程序了:

`$ dbcheck.bsh`

如果您的数据库正在运行，您应该会收到如下消息:

`’DBUP`

`-----`

`DB up`

脚本中的所有检查都是用一行代码执行的:

`echo "select ’DB up’ from dual;" | sqlplus -s system/foo`

`echo`命令将一个有效的 SQL 语句传输到`sqlplus`可执行文件。然后，`sqlplus`可执行文件将尝试使用`system`模式登录并运行该语句。

Note

将文件扩展名`.sh`、`.bsh`或`.bash`添加到 Bash shell 脚本的末尾是常见的行业惯例。请记住，文件扩展名在 Linux/Solaris 环境中毫无意义(除了帮助您记录脚本类型之外)。这与 DOS 不同，DOS 中的`.exe`、`.com`、`.bat`表示可执行的 OS 文件。

### 它是如何工作的

这个菜谱的“解决方案”部分中的 shell 脚本的第一行需要多一点解释。我们在此复制了该行以供讨论:

`#!/bin/bash`

字符通常用于注释掉 shell 脚本中的一行；例如:

`# This is a comment.`

该规则的一个例外是当`#!`作为 shell 脚本中的第一个文本出现时。当`#!`放在第一行时，它可以与路径和程序名结合。路径和程序名指定解释脚本中命令的程序的位置和名称。这很重要，因为这意味着您可以使用指定的 shell 运行脚本，而不管您使用的是什么交互式 shell。

Note

两个字符的序列`#!`有时被称为 shebang。

如果您不指定`#!/<path>/<program>`，您当前登录的 shell 将用于解释脚本中的命令。我们建议您在脚本的第一行指定路径和 shell 程序，以便明确使用哪个 shell 来解释脚本中的命令。

在大多数系统中，`bash`解释器位于`/bin`目录中。如果您不知道您的`bash`可执行文件的位置，您可以使用`which`或`whereis`命令来定位它:

`$ whereis bash`

`bash: /bin/bash`

当您第一次尝试运行 shell 脚本时，可能会收到类似以下内容的错误:

`-bash: dbcheck.bsh: command not found`

这意味着您的`PATH`变量不包括当前工作目录。要解决这个问题，您可以重置`PATH`变量来包含当前的工作目录。这个例子导出了`PATH`变量以包含当前的工作目录:

`$ export PATH=$PATH:.`

确保 Bash shell 能够定位脚本的另一种方法是包含脚本所在位置的完整目录路径。在本例中，脚本位于目录`/home/oracle`中，如下所示运行:

`$ /home/oracle/dbcheck.bsh`

您还可以指示 shell 在当前工作目录中查找，以确定脚本的位置。您可以通过在脚本名称前放置`./`来实现这一点:

`$ ./dbcheck.bsh`

第一次运行该脚本时，您也可能会收到如下消息:

`Error 6 initializing SQL*Plus`

`SP2-0667: Message file sp1<lang>.msb not found`

这个消息很可能意味着`ORACLE_HOME`变量没有正确设置。在这种情况下，确保将`ORACLE_HOME`变量设置到正确的位置。

BASH SHELL EXIT COMMAND

您可以在 shell 脚本中的任何位置放置一个`exit`命令，指示 Bash shell 立即终止程序。成功的退出通常用一个`exit`或一个`exit 0`来表示。当检测到故障条件时，退出 shell 脚本由一个非零值表示，比如一个`exit 1`。我们建议您在 shell 脚本中显式放置一个`exit 0`命令来表示成功完成。当检测到错误情况时，您还应该使用非零值，例如`exit 1`。

执行的每个 Bash shell 命令也将返回一个退出代码。如果命令成功执行，它将以状态`0`终止。如果出现了某种故障，退出代码将是非零的。您可以通过检查`$?`变量来检查退出代码的状态:

`$ echo $?`

`0`

`$?`变量保存先前执行的命令的退出值。退出代码的不成功值因每个命令而异。例如，`grep`实用程序将在成功找到匹配项时返回一个`0`，如果没有找到匹配项则返回一个`1`，如果出现了某种语法错误或缺少输入，则返回一个`2`。

## 7-2.检查简单条件

### 问题

您希望检查某个条件，例如某个关键的数据库后台进程是否正在运行，并在出现问题时发送电子邮件。

### 解决办法

使用`if/then/else` Bash 控制结构来检查条件并执行适当的动作。以下示例使用一个`if/then/else`结构来确定 Oracle 系统监视器(SMON)进程是否正在运行，如果没有检测到该进程，则发送一封电子邮件:

`#!/bin/bash`

`# Check for background process.`

`ORACLE_SID=O1212`

`critProc=ora_smon`

`ps -ef | grep -v ’grep’ | grep ${critProc}_$ORACLE_SID`

`if [ $? -eq 0 ]; then`

`echo "SMON $ORACLE_SID is available."`

`else`

`echo "SMON $ORACLE_SID issue." | mailx -s "issue with SMON $ORACLE_SID"` `dba@gmail.com`

`fi`

`exit 0`

将前面的代码放在名为`bgcheck.bsh`的文件中，并使其可执行:

`$ chmod +x bgcheck.bsh`

然后运行它:

`$ ./bgcheck.bsh`

如果 SMON 进程正在运行，您将看到类似如下的输出:

`oracle   27910     1  0 May11 ?        00:00:00 ora_smon_O1212`

`SMON O1212 is available.`

前面的例子使用了`$?`变量。该变量通常用在条件语句之后，以评估前一个命令是成功还是失败。`$?`变量包含前一个执行命令的状态。如果之前执行的命令成功，`$?`变量将包含一个`0`；否则，它将包含一个非零值。

### 它是如何工作的

`if/then/else`控制结构有三种基本形式。第一个声明如果条件是`true`，执行下面的命令。语法如下:

`if condition ; then`

`commands`

`fi`

在前一个例子的第一行代码中，关键字`then`是一个独立于关键字`if`的命令，因此您必须插入一个分号来表示关键字`if`的结束行终止点。执行前一位代码的另一种方式如下:

`if condition`

`then`

`commands`

`fi`

`if/then/else`结构的下一种形式表明，如果条件是`true`，则执行以下命令。如果第一个条件为假，则执行一组单独的命令。其语法如下:

`if condition ; then`

`commands`

`else`

`commands`

`fi`

`if/then/else`结构的第三种形式是，如果一个条件是`true`，执行第一组命令；否则，检查下一个条件。如果是`true`，执行命令。该功能通过`elif`关键字启用。在这种形式中你可以有许多`elif`条件。其语法如下:

`if condition ; then`

`commands`

`elif  condition`

`commands`

`elif  condition`

`commands`

`fi`

Tip

您还可以通过两个条件操作符`||`和`&&`来检查命令是否成功。关于条件运算符的更多细节，请参见配方 7-8。

## 7-3.测试条件

### 问题

您希望编写一个脚本来检查某些条件，比如传递给脚本的参数数量。根据条件，您希望执行一个操作，如显示信息性消息或退出脚本。

### 解决办法

如配方 7-2 所示，`if/then/else`结构是一种重要的编程技术。然而，正是将`if/then/else`与一个可以测试的条件结合在一起，为您提供了一个更加强大的自动化 DBA 任务的工具。`test`命令使您能够检查`if`命令中的条件。下面是`test`命令的基本语法:

`test operand1 operator operand2`

也可以用`[ ]`语法编写`test`命令。此语法使用左方括号开始命令，然后用右方括号结束命令。其语法如下:

`[ operand1 operator operand2 ]`

Note

本章中的 shell 脚本示例使用了`test`命令的`[ ]`形式。

对于某些测试条件，不需要`operand1`。该条件的语法如下:

`[ operator operand2 ]`

先前的`test`条件检查将以状态`0`(真)或`1`(假)退出，这取决于条件的评估。确保操作数、运算符和括号之间有一个空格。空格是 shell 知道操作符和操作数在哪里分开的方式。如果运算符、操作数和括号之间没有空格，shell 会将值解释为一个字符串，这将导致错误的结果。

为了将`if/then/else`和`test`放在一起，我们将编写一段小而有用的代码，检查是否向脚本传递了正确数量的参数。该脚本将使用`$#`变量。`$#`变量自动分配给在命令行输入的位置参数的数量，并传递给脚本。当您想要检查传递给脚本的参数数量是否正确时，这个变量非常方便。该脚本还将使用`$1`变量来显示传递给脚本的第一个参数。当参数传递给脚本时，第一个参数自动存储在`$1`变量中，第二个参数存储在`$2`中，依此类推。

以下代码使用`-ne`条件检查来确定传递给脚本的参数数量是否不等于`1`:

`#!/bin/bash`

`if [ $# -ne 1 ]`

`then`

`echo "Wrong number of parameters passed to script."`

`exit 1`

`else`

`echo "$1 passed to the script"`

`fi`

`exit 0`

接下来，我们将这段代码放在一个名为`ss.bsh`的脚本中，并使其可执行:

`$ chmod +x ss.bsh`

现在运行脚本，不传递任何参数:

`$ ./ss.bsh`

以下是相应的输出:

`Wrong number of parameters passed to script.`

现在运行该脚本，并向其传递一个参数:

`$ ./ss.bsh testparm`

以下是输出:

`testparm passed to the script`

`$0`参数通常与`$#`参数结合使用，以显示调用脚本时所需的语法。在一个 shell 脚本中，`$0`参数包含正在执行的 shell 脚本的名称。下面是前面代码的一个微小变化，它使用`$0`变量来显示脚本的名称:

`#!/bin/bash`

`if [ $# -ne 1 ]`

`then`

`echo "Wrong number of parameters passed to script."`

`echo "Usage: $0 ORACLE_SID"`

`exit 1`

`else`

`echo "$1 passed to the script"`

`fi`

`exit 0`

`-ne`运算符是一个算术运算符，用于测试操作数是否不相等。如果调用脚本(名为`ss.bsh`)时没有向其传递一个参数，则会显示以下输出:

`Wrong number of parameters passed to script.`

`Usage: ./ss.bsh ORACLE_SID`

注意前面输出中脚本名称前面的`./`。要从输出中消除`./`，使用`basename`命令。此实用程序用于从文件名中去除任何目录或后缀信息；例如:

`#!/bin/bash`

`Pgm=$(basename $0)`

`if [ $# -ne 1 ]`

`then`

`echo "Wrong number of parameters passed to script."`

`echo "Usage: $Pgm ORACLE_SID"`

`exit 1`

`else`

`echo "$1 passed to the script"`

`fi`

`exit 0`

该脚本将再次执行:

`$ ./ss.bsh`

请注意，在输出中，显示的脚本名称没有目录信息:

`Wrong number of parameters passed to script.`

`Usage: ss.bsh ORACLE_SID`

最后一点注意:前面脚本中的下面一行代码需要多一点解释:

`Pgm=$(basename $0)`

前一行使用了一种称为命令替换的技术。命令替换允许您获取命令的输出并填充变量。执行此操作的基本语法如下:

`variable=$(shell commands)`

这是一个强大的特性，允许您用其他命令的输出填充变量。在我们的例子中，我们获取了`basename $0`的输出并填充了`Pgm`变量。请注意，在旧版本的 shell 中，您可能会看到用反勾语法实现的命令替换:

`variable=`shell commands``

这是一种较旧的样式，不会在我们的任何示例中使用。

### 它是如何工作的

条件测试是 shell 脚本逻辑不可或缺的一部分。“解决方案”一节提供了一个使用带有`[ ]`语法的`test`命令的实际例子。还有几个额外的用例需要测试条件(例如，算术条件、字符串、文件是否存在等等)。下面几节将探讨几个真实的场景。

#### 测试算术条件

我们偶尔会遇到异常多的 SQL 会话连接到数据库的情况。这可能是由于一个错误的程序启动了与数据库的连接，并且从未退出。在这种情况下，让一个 shell 脚本定期检查服务器上运行的 SQL 进程的数量是否小于某个阈值是非常有用的。

下面是一个简单的脚本，它检查 SQL 进程的数量是否少于 300。如果有 300 个或更多的进程正在执行，脚本将发送一封电子邮件:

`#!/bin/bash`

`crit_var=$(ps -ef | grep sqlplus | wc -l)`

`if [ $crit_var -lt 300 ]; then`

`echo $crit_var`

`echo "processes running normal"`

`else`

`echo "too many processes"`

`echo $crit_var | mailx -s "too many sqlplus procs" dba@gmail.com`

`fi`

`exit 0`

在前面的脚本中，命令替换用于用`ps`命令的输出填充`crit_var`变量。然后用`-lt`(小于)算术运算符测试`crit_var`的值。

Bash shell 提供了几个算术运算符。表 [7-1](#Tab1) 给出了每个操作员的简要描述。

表 7-1。

Arithmetic Operators

<colgroup><col> <col></colgroup> 
| 操作员 | 描述 |
| --- | --- |
| `-eq` | 如果两个整数相等，则为 True |
| `-ne` | 如果两个整数不相等，则为 True |
| `-lt` | 如果`operand1`小于`operand2`则为真 |
| `-le` | 如果`operand1`小于或等于`operand2`则为真 |
| `-gt` | 如果`operand1`大于`operand2`则为真 |
| `-ge` | 如果`operand1`大于或等于`operand2`则为真 |

#### 测试字符串

您可以在测试条件中使用字符串，并且有很多种使用字符串比较的方法。例如，在脚本中运行命令之前，您可能想要检查以确保您作为某个操作系统用户登录。该示例检查运行脚本的用户是否是`oracle`:

`#!/bin/bash`

`checkUser=oracle`

`curWho=$(whoami)`

`if [ "$curWho" != "$checkUser" ]; then`

`echo "You are currently logged on as: $curWho"`

`echo "Must be logged in as $checkUser to run this script.."`

`exit 1`

`fi`

`exit 0`

在前面的代码中，我们使用命令替换来用`whoami`命令的输出填充`curWho`变量。然后通过`!=`(不等于)运算符检查`curWho`变量，看它是否与字符串`oracle`匹配。如果用户不匹配，脚本会显示信息性消息并退出脚本。表 [7-2](#Tab2) 列出了字符串的测试操作及其描述。

表 7-2。

String Operators

<colgroup><col> <col></colgroup> 
| 字符串运算符 | 描述 |
| --- | --- |
| `-z string` | 如果字符串为空，则为 True |
| `-n string` | 如果字符串不为空，则为 True |
| `string1 = string2` | 如果`string1`等于`string2`则为真 |
| `string1 != string2` | 如果字符串不相等，则为 True |
| `string1 < string2` | 如果`string1`在`string2`之前排序，则为真 |
| `string1 > string2` | 如果`string1`在`string2`之后排序，则为真 |

#### 接受来自命令行的输入

字符串比较的另一个有用的例子是从键盘读取用户输入并验证操作。假设您想在脚本中继续运行更多命令之前检查当前的 Oracle `SID`变量。如果您使用一台物理服务器上包含的多个数据库，这将非常有用。该脚本显示`ORACLE_SID`的值，并询问您是否要继续运行该脚本:

`#!/bin/bash`

`keepGoing=n`

`echo "Current value of ORACLE_SID: $ORACLE_SID"`

`echo -n "Do you want to continue? y/n "`

`read keepGoing`

`if [ "$keepGoing" = "y" ]; then`

`echo "Continue to run script."`

`else`

`echo "Exiting script"`

`exit 1`

`fi`

`exit 0`

#### 测试文件是否存在

除了算术和字符串比较，您还可以对 OS 文件执行各种测试。`test`命令允许您执行诸如文件可用性、文件类型等检查。例如，您可能想要确定日志文件是否存在；如果是，您希望它向适当的支持人员发送一封电子邮件。这个脚本使用`test`命令的`-e (exists)`参数来确定这一点:

`#!/bin/bash`

`checkFile=/home/trace/error.log`

`if [ -e $checkFile ]; then`

`mail -s "error.log exists"``dba@gmail.com`T2】

`else`

`echo "$checkFile does not exist"`

`fi`

`exit 0`

如果您希望 shell 脚本在检查条件后什么都不做，请使用冒号(`:`)命令(有时称为无操作或 null)。例如，如果检测到给定的文件存在，下面这段代码不执行任何操作:

`#!/bin/bash`

`checkFile=/home/oracle/error.log`

`if [ -e $checkFile ]; then`

`:`

`else`

`echo "$checkFile does not exist"`

`fi`

`exit 0`

表 [7-3](#Tab3) 包含对文件操作的 Bash shell 测试的描述。

表 7-3。

File Operators

<colgroup><col> <col></colgroup> 
| 文件操作员 | 描述 |
| --- | --- |
| `-a` | 如果文件存在，则为真 |
| `-b` | 如果文件是块设备文件，则为 True |
| `-c` | 如果文件是字符设备文件，则为 True |
| `-d` | 如果文件是目录，则为 True |
| `-e` | 如果文件存在，则为真 |
| `-f` | 如果文件存在并且是常规文件，则为 True |
| `-g` | 如果文件设置了`set-group-id`权限，则为真 |
| `-h` | 如果文件是符号链接，则为 True |
| `-L` | 如果文件是符号链接，则为 True |
| `-k` | 如果设置了文件的粘滞位，则为真 |
| `-p` | 如果文件是命名管道，则为 True |
| `-r` | 如果文件可读(当前用户),则为 True |
| `-s` | 如果文件存在且不为空，则为 True |
| `-S` | 如果文件是套接字，则为真 |
| `-u` | 如果文件为`set-user-id`则为真 |
| `-w` | 如果文件可写(当前用户可写),则为 True |
| `-x` | 如果文件是可执行的，则为真 |
| `-O` | 如果文件实际上由当前用户所有，则为 True |
| `-G` | 如果文件实际上由当前用户组所有，则为 True |
| `-N` | 如果自上次读取后文件已被修改，则为 True |
| `file1 -nt file2` | 如果`file1`比`file2`新，则为真 |
| `file1 -ot file2` | 如果`file1`比`file2`老，则为真 |
| `file1 -ef file2` | 如果`file1`是到`file2`的硬链接，则为真 |

Tip

`test`命令选项因操作系统版本而异。要获得您的环境中可用测试操作的完整列表，请使用`help test`命令或`man test`命令。

## 7-4.检查复杂条件

### 问题

您需要执行一组复杂的条件检查，比如检查服务器上的可用磁盘空间。当一个特定的装载点达到某个阈值时，您希望向 DBA 团队发送一封电子邮件。您怀疑您需要比`if/then/else`检查更复杂的东西，比如一个`case`语句。

### 解决办法

在许多情况下，检查一个条件只需要一个简单的`if/then/else`构造。然而，一旦你面对许多不同的操作时，`if/then/else`语法就会变得笨拙和不直观。在这些情况下，使用`case`语句来代替。`case`语句的基本语法如下:

`case expression in`

`pattern1)`

`commands ;;`

`pattern2)`

`commands ;;`

`esac`

本节中的下一个例子使用了一个`case`语句来检查空闲磁盘空间。脚本根据`df`命令的输出进行回复。所以要理解这个脚本是如何工作的，首先运行`df -h`并查看它的输出:

`$ df -h`

下面是该服务器的相应输出:

`Filesystem            Size  Used Avail Use% Mounted on`

`/dev/xvda2            191G  165G   17G  91% /`

`/dev/xvda1            996M  136M  809M  15% /boot`

该服务器上的两个挂载点是`/`和`/boot`。展望脚本，脚本中的`mntlist`变量被定义为与服务器上需要监控已用空间的挂载点相匹配:

`mntlist="/ /boot"`

基于这种理解，考虑下面的代码，它使用一个`case`语句来执行几项检查:

`#!/bin/bash`

`BOX=$(uname -a | awk ’{print $2}’)`

`mntlist="/ /boot"`

`for ml in $mntlist`

`do`

`echo "Mount point: $ml"`

`usedSpc=$(echo $(df -h $ml|awk ’{print $5}’|grep -v Use|cut -d "%" -f1 -))`

`BOX=$(uname -a | awk ’{print $2}’)`

`case $usedSpc in`

`[0-9])`

`diskStat="relax, lots of disk space: $usedSpc"`

`;;`

`[1-7][0-9])`

`diskStat="disk space okay: $usedSpc"`

`;;`

`[8][0-9])`

`diskStat="space getting low: $usedSpc"`

`;;`

`[9][0-9])`

`diskStat="warning, running out of space: $usedSpc"`

`echo $diskStat $ml | mailx -s "space on: $BOX" dba@gmail.com`

`;;`

`[1][0][0])`

`diskStat="update resume, no space left: $usedSpc"`

`echo $diskStat $ml | mailx -s "space on: $BOX" dba@gmail.com`

`;;`

`*)`

`diskStat="huh?: $usedSpc"`

`esac`

`# end case`

`echo $diskStat`

`done`

`# end for`

`exit 0`

假设前面的代码放在一个名为`filesp.bsh`的脚本中，并可执行:

`$ chmod +x filesp.bsh`

接下来执行脚本:

`$ filesp.bsh`

输出显示如下:

`Mount point: /`

`warning, running out of space: 91`

`Mount point: /boot`

`disk space okay: 15`

在该脚本中，`usedSpc`变量被赋予一个值，该值显示在一个挂载点上使用了多少百分比的磁盘空间。然后，`case`语句检查`usedSpc`以确定变量落在哪个范围内。最后，如果给定的装载点超过了 90%满阈值，脚本会向 DBA 发送一封电子邮件，指出可能存在问题。

### 它是如何工作的

这个菜谱的“解决方案”部分中的代码在几行代码中使用了 shell 命令、一个`case`语句和各种编码技术。结果是一个监视磁盘空间的小但非常有用的脚本。脚本的`usedSpc`行需要额外的解释。为方便起见，我们在此重复一遍:

`usedSpc=$(echo $(df -h $ml|awk ’{print $5}’|grep -v Use|cut -d "%" -f1 -))`

`usedSpc`变量包含在`$mntlist`中`ml`的循环结构中。循环针对`mntlist`变量中定义的每个挂载点执行。`ml`变量被分配给当前被检查的挂载点。`df`命令的输出被传送到`awk`命令，后者提取第五列。这又被传递给`grep`命令，该命令消除任何包含字符串`"Use"`的输出。该输出通过管道传输到`cut`命令，该命令提取由`%`字符分隔的第一个字段。

请注意，代码行中嵌入了一个`echo`命令；之所以使用它，是因为在某些系统上，`df`命令的输出中包含了额外的空间，而`echo`会删除这些额外的空间。得到的字符串应该是有问题的装载点上使用的磁盘空间的百分比。

您可能需要调整代码的`usedSpc`行，这取决于系统的`df`输出。例如，在某些平台上，`df`命令的输出可能不会显示字符串`"Use"`。典型的例子:在一些 Solaris 系统上，`df`命令的输出显示字符串`"Capacity"`来指示使用的磁盘空间量；例如:

`$ df -h`

以下是 Solaris 系统上的一些示例输出:

`Filesystem             Size   Used  Available Capacity  Mounted on`

`orapool1/ora01         350G   203G       147G      59%  /ora01`

`orapool2/ora02         350G   265G        85G      76%  /ora02`

`orapool1/ora03         350G   254G        96G      73%  /ora03`

在这种情况下，您可以修改脚本来使用`grep`过滤掉字符串`"Capacity"`；例如:

`usedSpc=$(echo $(df -h $ml|awk ’{print $5}’|grep -v Capacity|cut -d "%" -f1 -))`

下面是在 Solaris 系统上运行`filesp.bsh`时的相应输出:

`Mount point: /ora01`

`disk space okay: 59`

`Mount point: /ora02`

`disk space okay: 76`

`Mount point: /ora03`

`disk space okay: 73`

还要注意，对于这个 Solaris 系统，脚本中的`mntlist`变量需要定义如下:

`mntlist="/ora01 /ora02 /ora03"`

现在让我们回到这个配方的“解决方案”部分的例子:`case`语句对存储在`usedSpc`变量中的值执行一组复杂的字符串比较。`case`语句将检查每个条件，直到找到匹配的为止。当满足一个条件时，`case`语句运行匹配部分中的任何语句，然后退出。

一个例子将有助于澄清这个概念。让我们看看这个配方的“解决方案”部分的`case`语句中的第一个条件:

`[0-9])`

`diskStat="relax, lots of disk space: $usedSpc"`

`;;`

在前面的代码片段中，`case`语句检查变量的值，看它是否是一个包含 0 到 9 范围内的值的一位数字符串。如果匹配，它将变量`diskStat`设置为适当的消息，并退出`case`语句。

看看`case`语句中的第二个条件:

`[1-7][0-9])`

`diskStat="disk space okay: $usedSpc"`

`;;`

在这段代码中，`case`语句检查一个两位数。它查找的第一个字符必须在 1 到 7 的范围内。第二个字符可以是 0 到 9 之间的任何数字。如果模式匹配，`diskStat`变量被设置为适当的值，然后`case`语句退出。

现在检查一下`case`语句末尾附近的条件:

`[9][0-9])`

`diskStat="warning, running out of space: $usedSpc"`

`echo $diskStat $ml | mailx -s "space on: $BOX" dba@gmail.com`

`;;`

`[1][0][0])`

`diskStat="update resume, no space left: $usedSpc"`

`echo $diskStat $ml | mailx -s "space on: $BOX" dba@gmail.com`

`;;`

这里的想法是，如果一个挂载点的使用率达到 90%或更高，就向 DBA 发送一封电子邮件，警告磁盘空间越来越少。最后，如果没有匹配，将执行 catchall 子句`*)`，并退出`case`语句。

`case`语句的结构允许您执行复杂的比较，如果您试图使用`if/then/else`语句对它们进行编码，这可能会让您发疯。表 [7-4](#Tab4) 列出了一些在`case`语句中使用的常见模式匹配字符。

表 7-4。

Common Character-Matching Patterns

<colgroup><col> <col></colgroup> 
| 模式 | 描述 |
| --- | --- |
| `a&#124;b` | 匹配`a`或`b` |
| `*` | 匹配任何字符串，通常用于总括字符 |
| `[abc]` | 匹配任意字符`a`、`b`或`c` |
| `[a-c]` | 匹配任意字符`a`、`b`或`c` |
| `[0-9]` | 匹配从`0`到`9`的任何字符 |
| `"<string>"` | 匹配引号中的字符串 |

最后一点:通常我们会使用`cron`实用程序(详见第 10 章)定期自动运行磁盘监控脚本(例如，每 30 分钟一次或每小时一次)。这样，当服务器空间不足时，我们会得到警告。您可能在想，“监控磁盘空间不是系统管理员的工作吗？”是的，但是我们遇到过许多这样的情况(多得数不清),装载点被填满，数据库停止工作，生产支持 DBA 被调用。通过运行您自己的磁盘空间监控脚本，您将会得到一些关于磁盘满度问题的警告，并省去许多麻烦。

## 7-5.重复任务

### 问题

您希望对服务器上运行的几个数据库执行检查。您不想为每个数据库创建一个脚本；换句话说，您宁愿以灵活的方式编写一个脚本，用于所有数据库。

### 解决办法

一个`for`循环允许你重新运行一段代码固定的次数。这种控制结构特别有用，因为 DBA 通常有一组需要操作的已知数据库或文件。`for`循环语法如下:

`for name [in list]`

`do`

`commands that can use $name`

`done`

下面的代码说明了一个`for`循环的威力。在此环境中，有三个数据库正在被监控，以执行一个关键的后台进程。`for`循环允许您提供一个输入列表，并为输入列表中的每个数据库名称重新执行相同的代码:

`#!/bin/bash`

`SID_LIST="dev1 dev2 dev3"`

`critProc=ora_smon`

`for curSid in $SID_LIST`

`do`

`ps -ef | grep -v ’grep’ | grep ${critProc}_$curSid`

`if [ $? -eq 0 ]; then`

`echo "$curSid is available."`

`else`

`echo "$curSid has issues." | mail -s "issue with  $curSid"` `dba@gmail.com`

`fi`

`done`

`exit 0`

通过这种方式，您可以有效地使用代码来重复任务。

### 它是如何工作的

`for`循环遍历传递给参数列表的每个参数。这种控制结构对于固定输入列表来说是理想的。(根据您使用的 shell，语法可能与“解决方案”一节中描述的略有不同。)

关于循环还有一些其他方面需要进一步分析。例如，您可以使用内置的 Bash shell `$@`变量将一个参数列表传递给一个`for`循环。`$@`变量包含传递给脚本的带引号的参数列表。默认情况下，如果没有提供输入列表，`for`循环将使用`$@`。可以稍微修改前面的代码片段来利用这种技术，如下所示:

`#!/bin/bash`

`critProc=ora_smon`

`for curSid in $@`

`do`

`ps -ef | grep -v ’grep’ | grep -i ${critProc}_$curSid`

`if [ $? -eq 0 ]; then`

`echo "$curSid is available."`

`else`

`echo "$curSid has issues." | mail -s "issue with  $curSid"` `dba@gmail.com`

`fi`

`done`

`exit 0`

假设前面的代码放在一个名为`dbup.bsh`的文件中。现在可以从命令行运行它，传入要检查的数据库列表:

`$ dbup.bsh dev1 dev2 dev3`

最后一点:有许多不同的方法来实现一个`for`循环。例如，可以根据一个命令的输出来遍历一个`for`循环:

`for a in $(ls /home/oracle)`

`do`

`echo "$a"`

`done`

您还可以基于一系列数字进行迭代:

`for a in {1..10}`

`do`

`echo "$a "`

`done`

下面是另一种循环遍历数字序列的常用方法:

`for ((a=1; a <= 10; a++))`

`do`

`echo "$a "`

`done`

您选择的方法取决于您的个人偏好和手头的任务。

## 7-6.迭代直到满足一个条件

### 问题

您希望执行一个操作未知的次数，直到达到某个条件。

### 解决办法

`while`和`until`流控制结构允许一段代码迭代，直到满足一个条件。与`for`循环结构相比，`while`和`until`循环在预先不知道继续循环的次数时非常有用。`while`循环运行，直到测试条件处于零退出状态。`while`循环的语法如下:

`while condition ; do`

`commands`

`done`

一个小例子将展示`while`循环的效用。假设您想每隔 15 秒检查一次盒子上的`sqlplus`进程计数。如果它超过了某个值，您想发送一封电子邮件并退出。下面是实现这一点的一些代码:

`#/bin/bash`

`crit_var=0`

`while [ $crit_var -lt 300 ]; do`

`crit_var=$(ps -ef | grep sqlplus | wc -l)`

`echo "Number of sqlplus processes: $crit_var"`

`sleep 15`

`done`

`echo $crit_var | mailx -s "too many sqlplus procs" dba@gmail.com`

`exit 0`

`until`控制结构类似于`while`循环。`until`循环运行，直到测试条件具有非零退出状态:

`until condition ; do`

`commands`

`done`

接下来是一个脚本，它以与`while`循环示例相同的方式使用了一个`until`循环:

`#/bin/bash`

`crit_var=0`

`until [ $crit_var -ge 300 ]; do`

`crit_var=$(ps -ef | grep sqlplus | wc -l)`

`echo "Number of sqlplus processes: $crit_var"`

`sleep 15`

`done`

`echo $crit_var | mailx -s "too many sqlplus procs" dba@gmail.com`

`exit 0`

这样，您可以持续执行任务，直到满足某个条件。

### 它是如何工作的

当您需要迭代但不知道迭代次数时,`while`或`until`构造非常有用。换句话说，要求是循环，直到满足一个条件，然后退出。

这里是另一个使用`while`循环的有用例子。有时，在调试脚本时，迭代传递给 shell 脚本的所有参数并查看参数值是很有用的。这段代码使用一个`while`循环来显示传递给脚本的所有参数:

`while [ $# -ne 0 ]; do`

`echo $1`

`shift 1`

`done`

代码放在一个名为`test.bsh`的 shell 脚本中，可执行，运行如下:

`$ chmod +x test.bsh`

`$ test.bsh dev1 dev2 dev3`

以下是相应的输出:

`dev1`

`dev2`

`dev3`

在前面的代码示例中，`shift`命令用于将位置参数向左移动一个位置。您可以将位置参数视为一个值数组，并且(当被调用时)`shift`命令(破坏性地)将数组中的这些值向左移动指定数量的值。

一个例子有助于澄清这种不可靠的概念。假设有三个参数传入一个程序:`A`、`B`和`C`。位置变量`$1`将包含`A`，`$2`将包含`B`，`$3`将包含`C`。当您发出`shift 1`命令时，`$1`现在包含`B` , `$2`包含`C`,`$3`现在不包含任何内容。另一次换档会将`C`移入`$1`，而`$2`和`$3`现在将为空，以此类推。

最后一点:有许多不同的方法来实现一个`while`循环。这里有一个 C 程序员会认识的常见的`while`循环结构:

`((a = 1))`

`while (( a <= 10 ))`

`do`

`echo "$a "`

`((a += 1))`

`done`

下面是一个函数使用`while`循环的例子(本章后面会有更多关于函数的内容):

`a=0`

`condition ()`

`{`

`((a++))`

`if [ $a -lt 11 ]`

`then`

`return 0  # true`

`else`

`return 1  # false`

`fi`

`}`

`while condition`

`do`

`echo "$a"`

`done`

这里还有另一种实现`until`循环的方法:

`a=1`

`until (( a > 10 ))`

`do`

`echo "$a"`

`(( a++ ))`

`done`

您选择的方法取决于您的个人偏好和手头的任务。

## 7-7.显示选项菜单

### 问题

您希望为 shell 脚本用户提供一个选项菜单以供选择。

### 解决办法

`select`命令允许你从输入列表创建一个菜单。如果省略输入列表，位置参数(包含在`$@`变量中)用于构建菜单。`select`命令的语法与`for`命令的语法几乎相同:

`select name in [input list ]`

`do`

`commands that use $name`

`done`

接下来列出的是一个 shell 脚本，它使用`select`命令来查询`/etc/oratab`文件的内容(在 Solaris 环境中是`/var/opt/oracle/oratab`),并根据您选择的`ORACLE_SID`值来设置您的 Oracle OS 变量:

`#!/bin/bash`

`# Sets Oracle environment variables.`

`# Setup: 1\. Put oraset file in /etc (Linux), in /var/opt/oracle (Solaris)`

`#        2\. Ensure /etc or /var/opt/oracle is in $PATH`

`# Usage: batch mode: . oraset <SID>`

`#        menu mode:  . oraset`

`#====================================================`

`if [ -f /etc/oratab ]; then`

`OTAB=/etc/oratab`

`elif [ -f /var/opt/oracle/oratab ]; then`

`OTAB=/var/opt/oracle/oratab`

`else`

`echo ’oratab file not found.’`

`exit`

`fi`

`#`

`if [ -z $1 ]; then`

`SIDLIST=$(egrep -v ’#|\*’ ${OTAB} | cut -f1 -d:)`

`# PS3 indicates the prompt to be used for the Bash select command.`

`PS3=’SID? ’`

`select sid in ${SIDLIST}; do`

`if [ -n $sid ]; then`

`HOLD_SID=$sid`

`break`

`fi`

`done`

`else`

`if egrep -v ’#|\*’ ${OTAB} | grep -w "${1}:">/dev/null; then`

`HOLD_SID=$1`

`else`

`echo "SID: $1 not found in $OTAB"`

`fi`

`shift`

`fi`

`#`

`export ORACLE_SID=$HOLD_SID`

`export ORACLE_HOME=$(egrep -v ’#|\*’ $OTAB|grep -w $ORACLE_SID:|cut -f2 -d:)`

`export ORACLE_BASE=${ORACLE_HOME%%/product*}`

`export TNS_ADMIN=$ORACLE_HOME/network/admin`

`export ADR_BASE=$ORACLE_BASE/diag`

`export PATH=$ORACLE_HOME/bin:/usr/ccs/bin:/opt/SENSsshc/bin/\`

`:/bin:/usr/bin:.:/var/opt/oracle:/usr/sbin:/etc`

`export LD_LIBRARY_PATH=/usr/lib:$ORACLE_HOME/lib`

在这个例子中，代码被放在 Linux 上的`/etc`目录中一个名为`oraset`的文件中(或者在 Solaris 上是`/var/opt/oracle`)。`oraset`脚本可执行如下:

`$ chmod +x oraset`

在运行`oraset`之前，查看本例中`oratab`文件的内容:

`ORA12CR1:/orahome/app/oracle/product/12.1.0.1/db_1:N`

`O1212:/orahome/app/oracle/product/12.1.0.2/db_1:N`

`TRG:/orahome/app/oracle/product/12.1.0.2/db_1:N`

`O112:/orahome/app/oracle/product/11.2.0.4/db_1:N`

`ORA117:/orahome/app/oracle/product/11.1.0/db_1:N`

前面文本中的数据库名称是`ORA12Cr1`、`O1212`等等。下一行是每个数据库主目录的路径(用一个`:`与数据库名分开)。最后一列应该包含一个`Y`或一个`N`，它表示您是否希望数据库在系统重启时自动重启(除了`Y` / `N`之外，这需要额外的设置)。

现在从命令行运行`oraset`,如下所示:

`$ . /etc/oraset`

当从命令行运行`oraset`时，您应该看到这样的菜单(来自于您的`oratab`文件中的数据库名称):

`1) ORA12CR1`

`2) O1212`

`3) TRG`

`4) O112`

`5) ORA117`

`SID ?`

在本例中，您现在可以输入`1`、`2`、`3`、`4`或`5`来设置您想要使用的数据库所需的操作系统变量。这允许您以交互方式设置所需的 Oracle OS 变量，而不管服务器上安装了多少数据库。

### 它是如何工作的

Bash shell 内置的`select`命令提供了一种向 shell 脚本用户呈现选项菜单的简单方法。本菜谱的“解决方案”一节中介绍的`oraset`脚本是一个很好的例子，说明当一台服务器上运行多个数据库时，DBA 使用`select`命令来帮助准确、一致地设置所需的 OS 变量。

运行`oraset`时，一定要使用`.`(点)符号，它指示 shell 获取脚本。Sourcing 告诉您当前的 shell 进程继承已执行脚本中设置的任何变量。如果不使用`.`符号，脚本中设置的变量只在脚本执行时产生的子 shell 的上下文中可见。

Note

在 Bash 和 C-shell shell 中，`source`命令和内置的`.`是同义词。

您可以从命令行或启动文件(如`.profile`、`.bash_profile`或`.bashrc`)运行`oraset`脚本。例如，将这一行放在启动文件中:

`. /etc/oraset`

现在，每次登录到服务器时，您都会看到一个选项菜单，您可以使用它来指示要为其设置 OS 变量的数据库。如果您希望将 OS 变量自动设置为特定的数据库，请在启动文件中输入一个条目，如下所示:

`. /etc/oraset TRG`

前一行将为数据库`TRG`运行`oraset`文件，并适当地设置 OS 变量。

## 7-8.基于前一个命令的成功/失败运行命令

### 问题

您已经设置了一些定制的数据库监控代码。作业应该在数据库服务器上持续运行，但有时作业会意外终止。您希望设置另一个作业来确定该作业是否没有运行；如果没有，它应该重新启动监视作业。换句话说，在一行代码中，你需要运行一个命令来查看进程是否在运行；如果没有，请运行另一个命令来重新启动作业。

### 解决办法

在一行代码中，使用`|| <space>`和`&&`控制操作符根据之前运行命令的状态有条件地执行命令。下面是`||`如何工作的基本语法:

`<run command 1> || <run command 2 if command 1 did not succeed>`

下面是`&&`操作符的语法:

`<run command 1> && <run command 2 if command 1 succeeded>`

这里有一个简单的例子来说明它是如何工作的:

`$ ls myfile.txt || echo "file does not exist"`

下面是指示执行了`echo`命令的输出(意味着`ls`命令没有成功列出`myfile.txt`文件):

`myfile.txt: No such file or directory`

`file does not exist`

现在假设您创建了以下文件:

`$ touch myfile.txt`

重新运行该命令:

`$ ls myfile.txt || echo "file does not exist"`

因为`ls`命令成功，所以`echo`命令没有执行。唯一返回的输出是`ls`命令的输出:

`myfile.txt`

现在您已经有了背景信息，请检查以下代码行:

`$ ps -ef | grep dbwatch | grep -v grep || nohup /home/oracle/bin/dbwatch.bsh &`

如果`ps -ef | grep dbwatch | grep -v grep`的输出没有返回值(意味着`dbwatch`没有在服务器上运行)，则执行下面的代码来重新启动进程:

`nohup /orahome/oracle/bin/dbwatch.bsh &`

如果`ps`命令确实返回值，这意味着进程正在运行，所以不要执行脚本来重新启动作业。如果您想自动执行，您可以在`cron`中放置一行如下:

`33 * * * * ps -ef | grep dbwatch | grep -v grep || nohup /home/oracle/bin/dbwatch.bsh &`

前面的代码每小时自动运行一次(每小时后 33 分钟),并检查`dbwatch`是否正在运行。如果没有，则重新启动。

### 它是如何工作的

有时，根据上一个立即运行的命令的成功或失败，有条件地执行一个命令是有用的(在一行代码中)。`&&`和`||`操作符就是用来做这件事的。“解决方案”部分展示了一个使用`||`的例子；接下来是一个使用`&&`的例子，这意味着如果前面的命令成功，您希望执行一个命令。

在下一行代码中，只有当`grep`命令在`alert.log`文件中成功找到字符串`"ORA-00600"`时，才会发送一封电子邮件:

`$ grep ORA-00600 alert*.log && echo "DB prob" | mailx -s "ORA 600 error" dba@gmail.com`

在一行代码中，您可以根据前面命令的成功或失败有条件地执行命令。本菜谱中的示例提供了另一个 shell 脚本工具，您可以用它来以创造性的方式监视各种活动，并在出现问题时向您发出警报。

## 7-9.模块化脚本

### 问题

你想让你的脚本更加模块化和功能化。您认为 shell 函数将有助于完成这项任务。

### 解决办法

大多数编程语言中常用的函数是执行动作的命令块。您可以将一个函数想象成另一个脚本中的一个小脚本，它分隔了一段代码。这个想法是定义一段代码一次，然后从程序的其他部分多次调用这段代码。使用函数允许您将代码模块化，使其更具可重用性、可读性和可维护性。

像变量一样，函数必须在使用前声明。毫不奇怪，`function`命令用于声明函数。为了说明函数的用法，假设您需要创建一段可重用的代码来显示一些调试信息。这个例子创建了一个名为`showMsg`的函数:

`function showMsg {`

`echo "----------------------------------------"`

`echo "You’re at location: $1 in the $0 script."`

`echo "----------------------------------------"`

`} # showMsg`

现在可以在脚本中声明该函数的位置之后的任何地方引用该函数。例如，假设您想在脚本中使用 previous 函数。您可以在调用它之前添加它，然后在代码中多次引用该函数:

`#!/bin/bash`

`debug=1`

`function showMsg {`

`echo "----------------------------------------"`

`echo "You’re at location: $1 in the $0 script."`

`echo "----------------------------------------"`

`} # showMsg`

`#`

`SID_LIST="dev1 dev2 dev3"`

`critProc=ora_smon`

`#`

`if [[ debug -eq 1 ]]; then`

`showMsg 1`

`fi`

`#`

`for curSid in $SID_LIST`

`do`

`ps -ef | grep -v ’grep’ | grep ${critProc}_$curSid`

`if [ $? -eq 0 ]; then`

`echo "$curSid is available."`

`else`

`echo "$curSid has issues." | mail -s "issue with  $curSid"` `dba@gmail.com`

`fi`

`done`

`#`

`if [[ debug -eq 1 ]]; then`

`showMsg 2`

`fi`

`#`

`exit 0`

假设前面的代码放在一个名为`d.bsh`的脚本中。执行后，输出如下:

`----------------------------------------`

`You’re at location: 1 in the ./d.bsh script.`

`----------------------------------------`

`----------------------------------------`

`You’re at location: 2 in the ./d.bsh script.`

`----------------------------------------`

这样，您可以使用一个函数来定义一次代码，并在脚本中多次执行它。

### 它是如何工作的

函数允许您将大型 shell 脚本组织成模块化的代码片段，从而简化调试、维护和可重用性。也可以直接从 OS 命令行声明和调用函数。从 DBA 的角度来看，这为您提供了一个非常强大的工具，允许您创建和使用任意数量的有用函数，这些函数可以像操作系统命令一样运行。例如，创建一个名为`dba_fcns`的文件，并将其放在以下命令中:

`#!/bin/bash`

`#------------------------------------------------------------------------------#`

`# sshl : ssh with your login to remote host`

`function sshl {`

`echo "ssh -l $LOGNAME $*"`

`ssh -l $LOGNAME $*`

`} # sshl`

`#------------------------------------------------------------------------------#`

`# ssho : ssh with the oracle userid to remote host`

`function ssho {`

`echo "ssh -l oracle $*"`

`ssh -l oracle $*`

`} # ssho`

`#------------------------------------------------------------------------------#`

`# chkps: check for a process on the box`

`function chkps {`

`ps -ef | grep -i $1 | grep -v grep`

`} # chkps`

`#------------------------------------------------------------------------------#`

现在，如下所示对文件进行源文件处理:

`$ . dba_fcns`

您现在可以从操作系统命令行访问`sshl`、`ssho`和`chkps`功能。为了说明这一点，在传入要操作的`smon`字符串时，调用了`chkps`函数:

`$ chkps smon`

您很可能会在 DBA 工具包中收集许多函数，以减轻键入冗长、容易出错的 shell 命令的负担。是的，对于前面的简单函数，您可以创建别名来完成基本相同的任务。但是，函数为您提供了额外的能力来组合几个不同的命令、使用参数以及显示有用的信息性消息。

## 7-10.向脚本传递参数

### 问题

你不喜欢在脚本中硬编码变量。您希望更改脚本，根据传递给脚本的参数来设置变量，这样您的代码就更具可重用性、灵活性和可维护性。

### 解决办法

首先，看一下这个脚本，其中包含数据库`SID`的硬编码值:

`#!/bin/bash`

`ORACLE_SID=brdstn`

`rman target / <<EOF`

`backup database;`

`EOF`

`<<`字符指示运行的命令(在本例中是`rman`实用程序)从第一个`EOF`和最后一个`EOF`之间出现的任何东西接收输入。你不必使用`EOF`作为开始和结束标记；您可以使用任何文本字符串。它只是标记 shell 指导命令运行的输入的开始和结束位置。

如果您想使用这个脚本来备份不同的数据库，您必须手动编辑它并更改数据库的名称，这不是很有效。更好的方法是修改脚本，以便可以动态地向它传递要备份的数据库的名称。对于这个例子，假设脚本名是`back.bsh`。如下所示修改脚本，以接受数据库名称作为输入:

`#!/bin/bash`

`ORACLE_SID=$1`

`rman target / <<EOF`

`backup database;`

`EOF`

在前面的代码中，`$1`是 Bash shell 中的内置变量。`$1`变量保存调用时传递给脚本的第一个参数。现在可以通过传入数据库名称来运行脚本。在这个例子中，传入`devdb`的名字:

`$ back.bsh devdb`

### 它是如何工作的

向脚本传递参数可以提高脚本的灵活性和可重用性。您可以向 shell 脚本传递任意数量的参数。第一个参数在脚本中被引用为`$1`，第二个参数被引用为`$2`，依此类推。这些 shell 变量称为位置参数，是由 shell 内部设置的特殊变量，可供您在脚本中使用。

如果向脚本传递超过九个位置参数，当引用位置变量时，必须使用大括号`{}`将参数的数字部分用多位参数括起来。如果没有大括号，变量`$10`将被解释为`$1`的内容，后面还有一个`0`，而`${10}`将被解释为第十个变量的内容。

一个例子有助于说明这一点。假设您向脚本传递了 10 个参数，如下所示:

`$ myscript.bsh a b c d e f g h i j`

为了便于说明，假设这一行代码包含在脚本中:

`echo $10`

在这种情况下，产生了结果`a0`，因为它回显了与`0`连接的参数`1`的内容。

当大括号与`echo`命令一起使用时，该行代码产生一个`j`，这是传递给脚本的第十个参数:

`echo ${10}`

记得在 shell 脚本中引用多位参数时使用大括号，否则将得不到想要的结果。

请注意，除了位置参数之外，shell 还为您提供了其他特殊变量。表 [7-5](#Tab5) 中描述了一些更有用的特殊外壳变量。在本章中可以找到使用这些变量的例子。

表 7-5。

Special Shell Variables

<colgroup><col> <col></colgroup> 
| 名字 | 描述 |
| --- | --- |
| `$1 - $n` | 保存传递给脚本的参数值的位置参数。 |
| `$?` | 最后一个命令的退出状态。包含成功执行命令的`0`值。包含失败命令的非零值。这个非零值取决于命令实际返回的内容。 |
| `$0` | 在 shell 脚本中，包含正在执行的 shell 脚本的名称。 |
| `$#` | 传递给脚本的位置参数的数量。 |
| `$$` | 外壳的进程号。可用于生成唯一的文件名。 |
| `$!` | 最近执行的后台进程的进程号。 |
| `$*` | 包含传递给脚本的所有位置参数。 |

## 7-11.加工参数

### 问题

当向 shell 脚本传递参数时，您需要一个有效的内置方法来处理参数。例如，您想要一个简单的方法来测试意外的参数或缺少的参数。

### 解决办法

`getopts`工具是一个内置的 shell 命令，它提供了一种有效的机制来验证传递给 shell 脚本的开关和参数。理解其工作原理的最佳方式是检查一个使用`getopts`来处理参数的脚本。假设您需要向 RMAN 备份脚本传递要备份的数据库名称以及是否应该启用备份压缩。您希望能够看到是否传入了正确的参数，如果参数不正确，则显示一条信息性消息。下面是一个脚本，它使用`getopts`来检查并处理传递给 RMAN 备份脚本的参数:

`#!/bin/bash`

`PRG=$(basename $0)`

`USAGE="Usage: $PRG -s SID [-c compress] [-h]"`

`if [ $# -eq 0 ]; then`

`echo $USAGE`

`exit 1`

`fi`

`#`

`# In the OPTSTRING variable, if the first character is a :, then surpress system`

`# generated messages. If a char is followed by :, then an argument is expected to be`

`# passed in for a given option. The OPTARG environment variable contains the`

`# argument passed in for a given option.`

`#`

`OPTSTRING=":s:c:h"`

`while getopts "$OPTSTRING" ARGS; do`

`case $ARGS in`

`s) ORACLE_SID=${OPTARG}`

`;;`

`c) COMP_SWITCH=$(echo ${OPTARG} | tr ’[A-Z]’ ’[a-z’)`

`if [ $COMP_SWITCH = "compress" ]; then`

`COMP_MODE=" as compressed backupset "`

`else`

`echo $USAGE`

`exit 1`

`fi`

`;;`

`h) echo $USAGE`

`exit 0`

`;;`

`*) echo "Error: Not a valid switch or missing argument."`

`echo ${USAGE}`

`exit 1`

`;;`

`esac`

`done`

`#`

`echo rman backup`

`rman target / <<EOF`

`backup $COMP_MODE database;`

`EOF`

`#`

`exit 0`

假设之前的代码放在名为`rman.bsh`的脚本中，确保该脚本是可执行的:

`$ chmod +x rman.bsh`

这个脚本的有效参数是`s`(伴随着`ORACLE_SID`)、`c`(压缩)和`h`(帮助)。首先，下面是使用无效参数运行脚本时发生的情况:

`$ rman.bsh -v mydb`

`Error: Not a valid switch or missing argument.`

`Usage: rman.bsh -s SID [-c compress] [-h]`

用法说明指定了运行脚本的正确方式；例如:

`$ rman.bsh -s O1212 -c compress`

`connected to target database: O1212 (DBID=353735090)`

`RMAN>`

`Starting backup...`

如果要显示 shell 脚本的帮助，请执行以下操作:

`$ rman.bsh -h`

`Usage: rman.bsh -s SID [-c compress] [-h]`

这个简单的例子展示了使用`getopts`评估参数的灵活性和简易性。

### 它是如何工作的

`getopts` (get options)实用程序使您能够有效地检查和处理命令行开关和参数。`getopts`程序确保外壳程序参数处理使用标准接口。`getopts`的基本语法如下:

`getopts optstring name`

`OPTSTRING`变量包含执行脚本时从命令行传入的选项列表。`NAME`是用于逐个读取命令行选项的变量。`getopts`命令也依赖于`OPTARG`环境变量。该变量包含为每个选项传递的参数值。

基于这种理解,“解决方案”部分中的脚本包含以下两行代码:

`OPTSTRING=":s:c:h"`

`while getopts "$OPTSTRING" ARGS; do`

当`OPSTRING`中的第一个字符为:时，它将禁止任何系统生成的错误信息。换句话说，当`OPTSTRING`中的第一个字符是`:`时，它指示`getopts`命令处理所有生成的错误消息(不显示系统生成的消息)。

如果选项字符后跟:，则命令行上应该有一个参数。`s`和`c`选项后面都跟有冒号，所以它们需要将参数传递给脚本。`h`选项后面没有冒号，所以它不需要参数。

Note

还有一个`getopt`命令(末尾没有 s)。该命令的使用方式与`getopts`类似。查看`man getopt`文档了解更多信息。

## 7-12.在脚本中运行数据库命令

### 问题

您希望在 shell 脚本中运行数据库实用程序命令。例如，您希望从 shell 脚本中运行 RMAN 备份。

### 解决办法

有几种技术可以从 shell 脚本中运行数据库命令。这两种技术是常用的:

*   直接运行命令
*   在变量中捕获输出

这些技术将在以下章节中介绍。

#### 直接运行命令

以下是调用 Oracle RMAN 实用程序并备份数据库的脚本:

`#!/bin/bash`

`ORACLE_SID=DEV_DB`

`rman target / <<EOF`

`backup database;`

`EOF`

`exit 0`

`<<`字符指示正在运行的命令(在本例中是`rman`实用程序)从第一个`EOF`和最后一个`EOF`之间出现的任何东西接收输入。您不必使用`EOF`作为开始和结束标记，您可以使用任何文本字符串。它只是标记 shell 指导命令运行的输入的开始和结束位置。

这种技术适用于任何 Oracle 实用程序。以下代码在 shell 脚本中运行 SQL*Plus 命令:

`#!/bin/bash`

`ORACLE_SID=DEV_DB`

`sqlplus -s <<EOF`

`/ as sysdba`

`select sysdate from dual;`

`EOF`

`exit 0`

#### 在变量中捕获输出

命令替换是一种运行命令并将其输出存储在变量中的技术。您可以使用命令替换来运行数据库实用程序(如 SQL*Plus)。例如，您希望确定关键实体化视图是否每天都在刷新。一种方法是从数据字典视图`USER_MVIEWS`中选择一个计数，其中最后刷新日期大于一天。这段代码使用命令替换来运行一个数据库命令，并在`critVar`变量中捕获命令的输出:

`#/bin/bash`

`critVar=$(sqlplus -s <<EOF`

`pdb_m/abc@papd`

`SET HEAD OFF FEED OFF`

`SELECT count(*) FROM user_mviews WHERE sysdate-last_refresh_date > 1;`

`EXIT;`

`EOF)`

该脚本将一个值返回到变量`critVar`中，您可以测试该值是否为`0`:

`if [ $critVar -ne 0 ]; then`

`mail -s "Problem with MV refresh"``dba@gmail.com`T2】

`MVs not okay.`

`EOF`

`else`

`echo "MVs okay."`

`fi`

`exit 0`

如果`critVar`变量中的值不是`0`，脚本将发送一封电子邮件。

### 它是如何工作的

在脚本中运行数据库实用程序的基本技术是直接运行实用程序(就像从命令行运行一样)或使用命令替换。这里的关键是您必须使用以下语法:

`database_utility << EOF`

`<run database_utility commands>`

`EOF`

该代码指示外壳执行数据库实用程序；那么在`<< EOF`和下一个`EOF`之间的任何内容都是由数据库实用程序运行的命令。字符串`"EOF"`可以是任何字符串。我们用`EOF`作为我们的标准。

以下示例使用`EOF`作为开始和结束标记。开始和结束标记之间的任何文本都是由 SQL*Plus 执行的命令。这个特定的脚本显示了上周创建的所有数据库对象:

`#!/bin/bash`

`newobjs=$(sqlplus -s << EOF`

`fbar/invqi@INVQI`

`select object_name`

`from dba_objects`

`where created > sysdate - 7`

`and owner not in (’SYS’,’SYSTEM’);`

`EOF)`

`echo $newobjs | mailx -s "new objects"` `dba@gmail.com`

`exit 0`

请注意，有两种技术可以在 shell 脚本中实现命令替换:

*   `$(command)`
*   ``command``

例如，如果您想将服务器的名称返回到一个变量中，可以使用两种技术。第一个是以下内容:

`$ BOX=$(uname -a | awk ’{print$2}’)`

第二个是如下:

`$ BOX=`uname -a | awk ’{print$2}’``

`$(command)`更现代，因此是首选技术。请注意，您可能会看到用``command``语法实现的命令替换。

最后一点:如果您使用的数据字典视图(在 shell 脚本中)包含一个作为视图名称一部分的`$`,那么您必须在 shell 脚本中用反斜杠对美元符号进行转义。例如，下面从视图`V$DATAFILE`中选择具有`OFFLINE`状态的数据文件的数量:

`#!/bin/bash`

`nf=$(sqlplus -s << EOF`

`/ as sysdba`

`set head off`

`select count(*)`

`from v\$datafile`

`where status=’OFFLINE’;`

`EOF)`

`echo "offline count: $nf"  | mailx -s "# files offline"` `prod@supp.com`

必须对脚本中显示的`$`进行转义(例如`v\$datafile`)。如果不转义`$`，shell 脚本会将视图名解释为一个 shell 变量。在`$`前面的反斜杠(`\`)指示 shell 脚本忽略特殊字符的含义。

## 7-13.打造健壮的 DBA Shell 脚本

### 问题

您希望编写一个灵活的、可重用的 shell 脚本，它包含了经验丰富的 shell 作者所使用的技术。

### 解决办法

DBA 使用的大多数 shell 脚本都需要以下功能:

Sets the shell   Validates parameters passed to the script   Sets any special variables to be used in the script   Sets the Oracle environment variables   Calls the Oracle utility   Captures the output in a unique log file name   Sends an e-mail indicating the success or failure of the job   Exits the script  

接下来列出的是一个基本的 shell 脚本，它使用这些技术来确定 SQL*Plus 连接是否可以连接到数据库。出于讨论目的，包含了行号；在您尝试运行脚本之前，应该删除它们:

`1  #!/bin/bash`

`2  PRG=$(basename $0)`

`3  #`

`4  # Validate parameters`

`5  USAGE="Usage: ${PRG} <database name> "`

`6  if [ $# -ne 1 ]; then`

`7     echo "${USAGE}"`

`8     exit 1`

`9  fi`

`10  #`

`11  # Set variables used in the script`

`12  SID=${1}`

`13  CONSTR=system/foo@${SID}`

`14  MAILX=’/bin/mailx’`

`15  MAIL_LIST=’dba@gmail.com’`

`16  LOG_DIR=/home/oracle/scripts`

`17  DAY=$(date +%F)`

`18  LOG_FILE=${LOG_DIR}/${PRG}.${DAY}.$$.log`

`19  LOC_SID=O1212`

`20  BOX=$(uname -a | awk ’{print$2}’)`

`21  #`

`22  # Source oracle variables`

`23  . /etc/oraset $LOC_SID`

`24  #`

`25  # Attempt to connect to database via SQL*Plus`

`26  crit_var=$(sqlplus -s <<EOF`

`27  $CONSTR`

`28  SET HEAD OFF FEED OFF`

`29  select ’success’ from dual;`

`30  EOF)`

`31  #`

`32  # Write output to log file`

`33  echo ${crit_var} > $LOG_FILE`

`34  #`

`35  # Send status`

`36  echo $crit_var | grep success 2>&1 >/dev/null`

`37  if [[ $? -ne 0 ]]; then`

`38    $MAILX -s "Problem with ${SID} on ${BOX}" $MAIL_LIST <$LOG_FILE`

`39  else`

`40    echo "Success: ${SID} on ${BOX}" | \`

`41    $MAILX -s "Success: ${SID} okay on ${BOX}" $MAIL_LIST`

`42  fi`

`43  #`

`44  exit 0`

Tip

如果你使用`vi`作为编辑器，使用`set number`和`set nonumber`命令切换行号的查看(更多细节见配方 4-11)。

### 它是如何工作的

本菜谱“解决方案”部分中的 shell 脚本使用了各种各样的 shell 编程技术。您可以使用这些方法来自动化各种 DBA 任务。shell 程序中包含了行号来描述每一行的用途。表 [7-6](#Tab6) 包含每行代码的简要描述。

表 7-6。

Explanation of Shell Script to Check on Database Status

<colgroup><col> <col></colgroup> 
| 行数 | 说明 |
| --- | --- |
| one | 为此脚本指定 Bash shell 命令解释器。 |
| Two | 在 PRG shell 变量中捕获 shell 脚本的名称。`$0`变量包含程序的名称。`basename`命令去掉程序名前的任何目录文本。 |
| 3–4 | 评论。 |
| five | 构造一个信息字符串并将其放入`USAGE`变量。 |
| 6–9 | 如果参数个数不等于 1，则显示脚本用法字符串并退出程序。工艺变量的高级讨论见配方 7-11。 |
| 10–11 | 评论。 |
| Twelve | 将`SID`变量设置为传入脚本的参数。 |
| Thirteen | 将`CONSTR`变量设置为包含 SQL*Plus 数据库连接字符串。 |
| Fourteen | 将`MAILX`变量设置为服务器上邮件实用程序的路径和名称。 |
| Fifteen | 指定接收作业状态的 DBA 的电子邮件地址。 |
| Sixteen | 将`LOG_DIR`变量设置为日志文件的目录。 |
| Seventeen | 将`DAY`变量设置为当前日期字符串。 |
| Eighteen | 将`LOG_FILE`指定为节目名称和日期的组合。`$$`变量是一个惟一的进程标识符，它允许您每天生成多个日志文件。 |
| Nineteen | 将`LOC_SID`设置为运行 shell 脚本的机器上的本地实例名。 |
| Twenty | 将`BOX`变量设置为包含本地数据库服务器的名称。 |
| 21–22 | 评论。 |
| Twenty-three | 使用程序设置所需的操作系统变量，如`ORACLE_HOME`。关于设置 Oracle 变量的文件示例，参见配方 7-7。 |
| 24–25 | 评论。 |
| Twenty-six | 在`crit_var`变量中捕获 SQL*Plus 命令的输出。启动与 SQL*Plus 的连接。`EOF`指定 SQL*Plus 命令的起点。 |
| Twenty-seven | 使用`CONSTR`中的值连接到 SQL*Plus。 |
| 28–29 | 运行 SQL*Plus 格式和 SQL 命令。 |
| Thirty | `EOF`指定要解释为 SQL 的文本的结尾。 |
| 31–32 | 评论。 |
| Thirty-three | 将`crit_var`变量的内容写入日志文件。 |
| 34–35 | 评论。 |
| Thirty-six | 检查从 SQL*Plus 命令返回的字符串`success`的`crit_var`变量的内容。 |
| Thirty-seven | `$?`包含先前运行命令的状态。检查之前的`grep`命令是否找到了字符串`success`。如果`grep`命令成功，`$?`将包含一个`0`。如果`grep`命令在`crit_var`变量中找不到字符串`success`，则`$?`变量将包含一个非零值。 |
| Thirty-eight | 发送电子邮件，指出存在问题。 |
| 39–41 | `$?`等于`0`；因此，`grep`命令在`crit_var`变量中找到了字符串`success`。发送指示数据库已启动的电子邮件。 |
| forty-two | `if`语句的结束。 |
| Forty-three | 空白注释行。 |
| forty-four | 以成功状态退出 shell 脚本(用`0`表示)。 |

CREATING A LOCK FILE

确保一次只运行一个 shell 脚本实例的一种常用方法是为脚本创建一个锁文件。执行脚本时，如果锁定文件已经存在，则作业当前正在运行或之前异常终止(并且锁定文件未被删除)。将以下代码放在脚本的开头。修改`LOCKFILE`参数以匹配您的环境:

`LOCKFILE=/ora01/oradata/BRDSTN/lock/rman.lock`

`if [ -f $LOCKFILE ]; then`

`echo "lock file exists, exiting..."`

`exit 1`

`else`

`echo "DO NOT REMOVE,  RMAN LOCKFILE" > $LOCKFILE`

`fi`

在脚本结束时，删除锁文件:

`if [ -f $LOCKFILE ]; then`

`rm $LOCKFILE`

`fi`

锁文件的使用确保了如果脚本已经在运行并被再次调用，它不会启动新的作业。

## 7-14.在后台运行脚本

### 问题

您在分布式环境中工作，并且在远程位置拥有数据库服务器。您希望在后台运行作业，即使出现网络问题或您注销机器后，该作业仍会继续运行。

### 解决办法

使用`&`(与号)字符在后台放置作业。该示例在后台运行`rman.bsh`脚本:

`$ rman.bsh &`

`[1] 6507`

根据前面的输出，`[1]`表示作业号，`6507`是进程标识符。您可以通过`jobs`命令验证程序是否在后台运行:

`$ jobs`

`[1]+  Running                rman.bsh &`

在一些较旧的系统上，您可能需要使用`nohup` (no hangup)命令，以确保即使您注销服务器，作业仍会执行。如果使用较旧的 shell，请使用以下语法在后台放置作业:

`$ nohup rman.bsh &`

要停止后台作业，使用`kill`命令。下一行代码停止作业 1:

`$ kill %1`

### 它是如何工作的

有时你需要在后台运行作业。在后台运行作业的优势在于，即使在发生以下情况后，也可以继续执行:

*   你注销了邮箱
*   网络问题导致您的终端会话断开
*   由于服务器会话超时设置，您的会话被断开

对于长时间运行的作业，您可以在后台运行它们，而不必担心因为与服务器断开连接而重新启动作业。

#### 解释&和 nohup

默认情况下，当您从命令行运行 shell 脚本时，它将在前台运行。要在后台执行作业，请在命令字符串的末尾放置一个&字符。以下是一般语法:

`$ <command>  &`

使用`&`确保一个命令将继续运行，即使你注销了机器。在一些较旧的系统上，您可能需要使用`nohup`命令来实现这个功能。在本例中，`nohup`命令用于在后台运行一个 shell 脚本:

`$ nohup export_db.bsh &`

默认情况下，`nohup`命令的输出被写入一个名为`nohup.out`的文件。您可以通过连续查看输出文件来监视作业:

`$ tail -f nohup.out`

您可以将输出重定向到您选择的文件，如下所示:

`$ nohup export_db.bash >exp.out &`

通过使用`tail -f`命令查看，您可以交互式地监控前一个任务的输出:

`$ tail -f exp.out`

Note

如果您希望一个作业在指定的时间在后台持续运行，请使用一个调度实用程序，如`cron`。有关自动化作业的详细信息，请参见第 10 章。

#### 使用屏幕分离并重新连接到会话

使用`&`和`nohup`命令是保持作业在后台运行的传统方式。您还可以使用 Linux 的`screen`命令来获得同样的结果，但功能要多得多。`screen`命令在您的服务器上启动一个终端会话，即使出现意外的网络中断，该会话也将持续存在。

要启动一个`screen`会话，发出以下命令:

`$ screen`

如果您收到诸如“无法打开 terminal /dev/pts/1”的错误消息，请将该文件的权限更改为`root`:

`# chmod a+rw /dev/pts/1`

当您调用`screen`时，您会看到一个终端，从中您可以键入命令并运行脚本。一个`screen`会话和一个普通的终端会话的区别在于，即使你被分离，`screen`会话也将继续运行。

例如，假设您在工作地点，登录到一个数据库服务器并启动一个`screen`会话。然后，在您的`screen`会话中启动一个长期运行的备份作业。作业启动后，通过按 Ctrl+A 然后按 D 键(同时按 Ctrl 和 A 键，松开它们，然后按 D 键)从屏幕会话中分离。然后，您可以开车回家，远程登录到数据库服务器，并重新连接到您在工作时启动的`screen`会话。您可以监视备份作业，就好像您正在查看您在工作时启动的同一终端一样。

这里有一个简单的例子来说明这是如何工作的。键入`screen`，如下所示:

`$ screen`

打印当前工作目录，这样当您从另一个终端连接到此`screen`会话时，您可以在屏幕上看到一些输出:

`$ pwd`

`/home/oracle`

现在按 Ctrl+A，然后按 D 键，这将使您脱离`screen`会话。您应该会看到以下消息:

`[detatched]`

现在启动一个不同的终端会话并登录到数据库服务器。发出以下命令显示任何分离的`screen`会话:

`$ screen -ls`

`There is a screen on:`

`31334.pts-1.rmougprd2   (Detached)`

`1 Socket in /tmp/uscreens/S-oracle.`

您可以使用`-r`(重新挂接)选项后跟`[[pid.]tty[.host]]`来重新挂接任何`screen`会话。对于这个特定的示例，您可以通过键入以下命令来重新建立`screen`连接:

`$ screen -r 31334.pts-1.rmougprd2`

您现在应该会看到之前输入的`pwd`命令的输出。就好像您从未离开过`screen`终端会话。这是一个非常强大的实用程序，可以用来启动作业，然后从另一个远程终端会话监视它们。您甚至可以与其他用户共享一个`screen`会话。

要显示`screen`在线帮助，请按 Ctrl+A，然后按？钥匙。要离开`screen`会话，使用`exit`命令，这将停止您的`screen`会话。

## 7-15.监控脚本的进度

### 问题

您正在执行一个 shell 脚本，并希望监控它的进度。

### 解决办法

有时，您必须监控长时间运行的 shell 脚本的进度。您可以使用带有`f` (follow)开关的 Linux `tail`命令来显示作业写入日志文件时的输出。在本例中，备份作业的输出被重定向到名为`rmanback.out`的输出文件:

`$ rmanback.bash >rmanback.out 2>&1`

在另一个会话中，使用`tail -f`命令交互查看写入日志文件的输出:

`$ tail -f rmanback.out`

以下是可能显示在屏幕上的典型输出片段:

`channel ORA_DISK_2: starting archive log backupset`

`channel ORA_DISK_2: specifying archive log(s) in backup set`

`input archive log thread=1 sequence=868 recid=859 stamp=628426116`

`...`

### 它是如何工作的

DBA 经常使用`tail`命令来监控诸如警报日志之类的东西，并在数据库出现问题时查看潜在的问题。在本例中，您将持续跟踪正在写入 Oracle 数据库`alert.log`文件的内容显示:

`$ tail -f alert_BRDSTN.log`

下面是写入`alert.log`文件的典型输出片段:

`Completed: ALTER DATABASE BACKUP CONTROLFILE TO TRACE`

`DBID: 2917656785`

`Thread 1 advanced to log sequence 71`

`Current  log# 2 seq# 71 mem# 0: /ora01/oradata/BRDSTN/oradata/redo02a.log`

当您想停止查看日志文件的内容时，按 Ctrl+C 退出`tail`命令。

## 7-16.调试脚本

### 问题

你的剧本没有达到你的预期。您想要调试脚本。

### 解决办法

Bash shell 有几个特性对于调试和解决脚本中的问题很有用。`-n`(不执行)开关允许您在运行脚本之前检查它的语法。要检查 Bash shell 脚本的语法错误，使用如下所示的`-n`:

`$ bash -n db.bash`

如果脚本包含任何错误，它将显示如下消息:

`db.bsh: line 10: syntax error: unexpected end of file`

另一个有用的调试特性是`-o xtrace`选项，它指示 Bash shell 在执行每个命令之前显示它。该选项还显示任何变量替换和扩展，因此您可以查看 shell 脚本执行时使用的实际变量值。您可以从命令行调用`-o xtrace`特性，如下所示:

`$ bash -o xtrace <script name>`

请注意，输出中包含的行似乎与您的代码没有任何关系:

`+ alias ’rm=rm -i’`

`+ alias ’cp=cp -i’`

`+ alias ’mv=mv -i’`

`+ ’[’ -f /etc/bashrc ’]’`

`+ . /etc/bashrc`

`+++ id -gn`

`+++ id -un`

`+++ id -u`

`++ ’[’ root = root -a 0 -gt 99 ’]’`

`++ umask 022`

`++ ’[’ ’’ ’]’`

`+ export JAVA_HOME=/opt/java`

这是因为输出中的前几行来自代码执行的启动脚本。还要注意:输出中的加号表示脚本中命令的嵌套级别。

### 它是如何工作的

随着 shell 脚本变得越来越长、越来越复杂，在脚本中消除 bug 的来源有时会有问题。当您维护别人编写的代码时，这个问题会变得特别尖锐。

如果您只想查看脚本中特定命令的跟踪，请将`set-o xtrace`直接嵌入到代码中的所需位置。在这个例子中，跟踪在`if`语句之前打开，然后在最后关闭:

`set -o xtrace`

`if [ $? -eq 0 ]; then`

`echo "$critProc is available."`

`else`

`echo "$critProc has issues." | mail -s "problem with  $critProc"` `bbill@gmail.com`

`fi`

`set +o xtrace`

以下是在启用跟踪的情况下运行前面的脚本时的输出:

`++ ’[’ 0 -eq 0 ’]’`

`++ echo ’ is available.’`

`is available.`

`++ set +o xtrace`

要启用一个`set`命令特性，您必须使用减号(`-`)，这可能看起来违反直觉。同样违反直觉的是，使用加号(`+`)来禁用`set`命令特性。

Note

您也可以使用`set -x`命令在执行前打印每个命令的参数赋值；要关闭跟踪，使用`set +x`，它与`set -o xtrace`和`set +o xtrace`命令相同。