- en: '*Chapter 3*: Diving Deep into C in Linux'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：深入学习Linux中的C'
- en: It's time to take an in-depth look at C programming in Linux. Here, we will
    learn more about the **compiler**, the four stages from source code to **binary
    program**, how to use the **Make** tool, and differences between system calls
    and standard library functions. We will also take a look at some essential header
    files when it comes to Linux, and look at some **C** and **Portable Operating
    System Interface** (**POSIX**) **standards**. C is tightly integrated with Linux,
    and mastering C will help you understand Linux.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候深入了解Linux中的C编程了。在这里，我们将更多地了解编译器，从源代码到二进制程序的四个阶段，如何使用Make工具，以及系统调用和标准库函数之间的区别。我们还将看一些关于Linux的基本头文件，并查看一些C和便携操作系统接口（POSIX）标准。C与Linux紧密集成，掌握C将帮助您了解Linux。
- en: In this chapter, we will develop both programs and libraries for Linux. We will
    also write both a generic **Makefile** and more advanced ones for more significant
    projects. While doing this, we will also learn about the different **C standards**,
    why they matter, and how they affect your programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为Linux开发程序和库。我们还将编写一个通用的Makefile和更复杂的Makefile，用于更大的项目。在这样做的同时，我们还将了解不同的C标准，它们为什么重要，以及它们如何影响您的程序。
- en: 'This chapter will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下示例：
- en: Linking against libraries using the **GNU Compiler Collection** (**GCC**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GNU编译器集合（GCC）链接库
- en: Changing C standards
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改C标准
- en: Using system calls
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用系统调用
- en: sand when not to use them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用它们，何时不使用它们
- en: Getting information about Linux- and Unix-specific header files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取有关Linux和Unix特定头文件的信息
- en: Defining feature test macros
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义特性测试宏
- en: Looking at the four stages of compilation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看编译的四个阶段
- en: Compiling with Make
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Make进行编译
- en: Writing a generic Makefile with GCC options
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用GCC选项编写通用Makefile
- en: Writing a simple Makefile
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的Makefile
- en: Writing a more advanced Makefile
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个更高级的Makefile
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you will need the Make tool and the GCC compiler, preferably
    installed via the meta-package or group install mentioned in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将需要Make工具和GCC编译器，最好是通过[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中提到的元包或组安装来安装。
- en: All source code for this chapter is available at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有源代码都可以在[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3)上找到。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3sElIvu](https://bit.ly/3sElIvu)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以查看“代码实战”视频：[https://bit.ly/3sElIvu](https://bit.ly/3sElIvu)
- en: Linking against libraries using GCC
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GCC链接库
- en: In this recipe, we will learn how to link a program to an external **library**,
    both one that's installed system-wide and one that resides in our home directory.
    Before we can link to a library, however, we need to create it. This is also something
    that we are going to cover in this recipe. Knowing how to link against libraries
    will enable you to make use of a wide variety of ready-to-use functions. Instead
    of writing everything by yourself, you can use libraries that are already available.
    Often, there is no need to reinvent the wheel, thus saving you a lot of time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何将程序链接到外部库，包括系统范围内安装的库和位于我们家目录中的库。然而，在我们可以链接到库之前，我们需要创建它。这也是我们将在这个示例中涵盖的内容。了解如何链接到库将使您能够使用各种各样的现成函数。您可以使用已经可用的库，而不是自己编写所有内容。通常情况下，没有必要重新发明轮子，从而节省大量时间。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll only need what's listed under the *Technical requirements*
    section of this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本示例，您只需要本章的*技术要求*部分中列出的内容。
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Here, we will learn how to link against both a **shared library** installed
    on your system and a library from your home directory. We will begin with a library
    already on your system: the **math library**.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将学习如何链接到系统上安装的共享库和家目录中的库。我们将从系统上已有的库开始：数学库。
- en: Linking against the math library
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接到数学库
- en: Here, we will make a small program that calculates the compound interest on
    a bank account. For this, we need the `pow()` function, which is included in the
    math library.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将制作一个小程序，用于计算银行账户上的复利。为此，我们需要数学库中包含的`pow()`函数。
- en: 'Write the following code and save it in a file called `interest.c`. Note that
    we include `math.h` at the top. The `pow()` function''s first argument is the
    base; the second argument is the exponent:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码，并将其保存在名为`interest.c`的文件中。请注意，我们在顶部包含了`math.h`。`pow()`函数的第一个参数是底数；第二个参数是指数：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, compile and `-l`, and the name of the library is `m` (see the `man 3 pow`
    manual page for more information):'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译和`-l`，库的名称是`m`（有关更多信息，请参阅`man 3 pow`手册页）：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And finally, let''s try the program:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们尝试一下程序：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Creating our own library
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们自己的库
- en: Here, we'll create our very own shared library. In the next section of this
    recipe, we'll link a program to this library. The library we are creating here
    is used to find out if a number is a prime number or not.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建我们自己的共享库。在本示例的下一部分中，我们将将程序链接到此库。我们在这里创建的库用于查找一个数字是否是质数。
- en: 'Let''s start with creating a simple header file. This file will only contain
    a single line—the function prototype. Write the following content in a file and
    name it `prime.h`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的头文件开始。这个文件只包含一行内容——函数原型。在文件中写入以下内容，并将其命名为`prime.h`：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, it''s time to write the actual function that will be included in the library.
    Write the following code in a file and save it as `primc.c`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候编写实际的函数，该函数将被包含在库中。在文件中写入以下代码，并将其保存为`primc.c`：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to convert this to a library somehow. The first step is to compile
    it into something that''s called an object file. We also need to parse some extra
    arguments to the compiler to make it work in a library. More specifically, we
    need to make it `prime.o`, which we''ll see with the `ls -l` command. We''ll learn
    more about object files later in this chapter:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以某种方式将其转换为库。第一步是将其编译为一个称为对象文件的东西。我们还需要解析一些额外的参数给编译器，使其在库中工作。更具体地说，我们需要使它成为`prime.o`，我们将在`ls
    -l`命令中看到。我们将在本章后面学习更多关于对象文件的知识：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we must package the object file as a library. In the following command,
    the `-shared` option is just what it sounds like: it creates a `-Wl,-soname,libprime.so`
    options are for the linker. This tells the linker that the shared library name
    (`soname`) will be `libprime.so`. The `-o` option specifies the output filename,
    which is `libprime.so`. This is a standard naming convention for `so` ending stands
    for *shared object*. When the library is to be used system-wide, a number is often
    added to indicate the version. At the very end of the command, we have the `prime.o`
    object file that is included in this library:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须将对象文件打包成一个库。在下面的命令中，`-shared`选项就是它听起来的样子：它创建了一个`-Wl,-soname,libprime.so`选项是为了链接器。这告诉链接器共享库的名称（`soname`）将是`libprime.so`。`-o`选项指定输出文件名，即`libprime.so`。这是`so`结尾的标准命名约定代表*shared
    object*。当库要在系统范围内使用时，通常会添加一个数字来表示版本。在命令的最后，我们有`prime.o`对象文件，它包含在这个库中：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Linking against a library in your home directory
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接到主目录中的库
- en: Sometimes, you have a shared library you want to link against in your home directory
    (or some other directory). Maybe it's a library you downloaded from the internet
    or a library you have built yourself, as in this case. We will learn more about
    making our own libraries in a later chapter of this book. Here, we use the small
    sample library we've just made, called `libprime.so`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能有一个共享库，您希望链接到您的主目录（或其他目录）。也许它是您从互联网上下载的库，或者是您自己构建的库，就像在这种情况下一样。我们将在本书的后面章节中了解更多关于制作自己的库的知识。在这里，我们使用我们刚刚制作的小样本库，名为`libprime.so`。
- en: 'Write the following source code in a file and name it `is-it-a-prime.c`. This
    program will use the library we just downloaded. We must also include the header
    file we created, `prime.h`. Note the different syntax for including a local header
    file (not a system-wide header file):'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下源代码写入文件并命名为`is-it-a-prime.c`。这个程序将使用我们刚刚下载的库。我们还必须包含我们创建的头文件`prime.h`。注意包含本地头文件（而不是系统范围的头文件）的不同语法：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, compile it and link it to `libprime.so`. Since the library resides in
    our home directory, we need to specify the path to it:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并将其链接到`libprime.so`。由于库位于我们的主目录中，我们需要指定路径：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need to set the `$LD_LIBRARY_PATH` **environment variable** to our current
    directory (where the library resides) before we can run the program. The reason
    for this is that the library is dynamically linked and is not on the usual system
    path for libraries:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行程序之前，我们需要将`$LD_LIBRARY_PATH` **环境变量**设置为我们当前的目录（库所在的位置）。这样做的原因是，该库是动态链接的，不在通常的系统库路径上：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And now, we can finally run the program. Test it with some different numbers
    to find out if they are prime numbers or not:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们终于可以运行程序了。用一些不同的数字测试它，看看它们是不是质数：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: $> ldd is-it-a-prime
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: $> ldd is-it-a-prime
- en: linux-vdso.so.1 (0x00007ffc3c9f2000)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: linux-vdso.so.1 (0x00007ffc3c9f2000)
- en: libprime.so => /home/jake/libprime.so (0x00007fd8b1e48000)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: libprime.so => /home/jake/libprime.so (0x00007fd8b1e48000)
- en: libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd8b1c4c000)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd8b1c4c000)
- en: /lib64/ld-linux-x86-64.so.2 (0x00007fd8b1e54000)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: /lib64/ld-linux-x86-64.so.2 (0x00007fd8b1e54000)
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `pow()` function we used in the *Linking against the math library* section
    requires us to link against the math library, `libm.so`. You can find this file
    in one of the system's library locations, often in `/usr/lib` or `/usr/lib64`.
    On Debian and Ubuntu, it's often `/usr/lib/x86_64-linux-gnu` (for 64-bit systems).
    Since the file is in the system's default library location, we can include it
    using only the `-l` option. The full name of the library file is `libm.so`, but
    when we specify the library to link against, we only specify the `m` part (that
    is, we remove the `lib` part and the `.so` extension). There shouldn't be any
    space between `-l` and the `m` part, so to link against it, we type `-lm`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*链接到数学库*部分中使用的`pow()`函数需要我们链接到数学库`libm.so`。您可以在系统的库位置之一找到此文件，通常在`/usr/lib`或`/usr/lib64`中。在Debian和Ubuntu上，它通常是`/usr/lib/x86_64-linux-gnu`（对于64位系统）。由于文件位于系统的默认库位置，我们只需使用`-l`选项即可包含它。库文件的完整名称是`libm.so`，但是当我们指定要链接的库时，我们只指定`m`部分（也就是说，我们去掉`lib`部分和`.so`扩展名）。`-l`和`m`部分之间不应该有空格，因此要链接到它，我们输入`-lm`。
- en: The reason we need to link against the library to use the `pow()` function is
    that the math library is separate from the standard C library, `libc.so`. All
    the functions we have used previously have been part of the *standard library*,
    which is the `libc.so` file. This library is linked by default, so there's no
    need to specify it. If we really wanted to specify the linkage to `libc.so` when
    compiling, we could do so with `gcc -lc some-program.c -o some-program`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要链接到库以使用`pow()`函数的原因是，数学库与标准C库`libc.so`是分开的。我们之前使用的所有函数都是*标准库*的一部分，这是`libc.so`文件。这个库默认被链接，所以不需要指定它。如果我们真的想在编译时指定链接到`libc.so`，我们可以使用`gcc
    -lc some-program.c -o some-program`。
- en: The `pow()` function takes two arguments, *x*, and *y*, such as `pow(x,y)`.
    The function then returns the value of *x* raised to the power of *y*. For example,
    `pow(2,8)` will return 256\. The returned value is a **double float**, and both
    *x* and *y* are double floats.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`pow()`函数接受两个参数，*x*和*y*，如`pow(x,y)`。然后函数返回*x*的*y*次方的值。例如，`pow(2,8)`将返回256。返回的值是**双精度浮点数**，*x*和*y*都是双精度浮点数。'
- en: 'The formula for calculating compound interest is shown here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 计算复利的公式如下所示：
- en: '![](img/B13043_03_001.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B13043_03_001.jpg)'
- en: Here, *P* is the starting capital you put in the account, *r* is the interest
    rate in percent, and *y* is the number of years that the money should stay untouched
    in the account.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*P*是您放入账户的起始资本，*r*是百分比利率，*y*是资金应该在账户中保持不变的年数。
- en: Linking against a library in your home directory
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接到主目录中的库
- en: 'In the `is-it-a-prime.c` C program, we needed to include the `prime.h` header
    file. The header file only contains one line: the function prototype for the `isprime()`
    function. The actual `isprime()` function is included in the `libprime.so` library
    we created from `prime.o`, which we created from `prime.c`. A `.so` file is a
    **shared library** or **shared object file**. A shared library contains compiled
    object files for functions. We will cover what object files are later in this
    chapter.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`is-it-a-prime.c`的C程序中，我们需要包含`prime.h`头文件。头文件只包含一行：`isprime()`函数的函数原型。实际的`isprime()`函数包含在我们从`prime.c`创建的`prime.o`中，我们从`prime.o`创建的`libprime.so`库中。`.so`文件是一个**共享库**或**共享对象文件**。共享库包含函数的已编译对象文件。我们将在本章后面介绍对象文件是什么。
- en: When we want to link against a library that we have downloaded or created ourselves,
    and that is not installed in the system's default location for libraries, things
    get a bit more complicated.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要链接到一个我们下载或自己创建的库，而该库未安装在系统默认的库位置时，事情就会变得有点复杂。
- en: First, we need to specify the library's name and the path where the library
    is located. The path is specified with the `-L` option. Here, we set the path
    to the current directory where we created the library. `${PWD}` is a shell environment
    variable that contains the full path to the current directory. You can try it
    with `echo ${PWD}`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要指定库的名称和库所在的路径。路径是用`-L`选项指定的。在这里，我们将路径设置为我们创建库的当前目录。`${PWD}`是一个shell环境变量，它包含当前目录的完整路径。您可以使用`echo
    ${PWD}`来尝试它。
- en: 'But then, to be able to run the program, we need to set an environment variable
    called `$LD_LIBRARY_PATH` to our current directory (and whatever it already contains).
    The reason for this is that the program is `$LD_LIBRARY_PATH`. We also don''t
    want to overwrite what''s already in the `$LD_LIBRARY_PATH` variable; that''s
    why we also include the variable''s content. If we hadn''t set that environment
    variable, we would get an error message when executing the program, saying "*error
    while loading shared libraries: libprime.so*". When we listed the dependencies
    with `ldd`, we saw that `libprime.so` is located in a home directory, not in the
    system''s library locations.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '但是，为了能够运行程序，我们需要设置一个名为`$LD_LIBRARY_PATH`的环境变量到我们的当前目录（以及它已经包含的内容）。这样做的原因是程序是`$LD_LIBRARY_PATH`。我们也不想覆盖`$LD_LIBRARY_PATH`变量中已经存在的内容；这就是为什么我们还包括了该变量的内容。如果我们没有设置这个环境变量，当执行程序时会收到一个错误消息，说“*error
    while loading shared libraries: libprime.so*”。当我们用`ldd`列出依赖项时，我们看到`libprime.so`位于主目录中，而不是系统的库位置。'
- en: There's more…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If you are interested in reading more about the standard C library, you can
    read `man libc`. To read more about the `pow()` function, you can read `man 3
    pow`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对标准C库感兴趣，可以阅读`man libc`。要了解有关`pow()`函数的更多信息，可以阅读`man 3 pow`。
- en: I also encourage you to read the manual page for `ldd` with `man ldd`. Also,
    check out some program's dependencies with `ldd`—for example, the `interest` program
    we wrote in this recipe. While doing so, you'll see `libm.so` and its location
    in the system. You can also try `ldd` on system binaries, such as `/bin/ls`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我还鼓励您阅读`man ldd`的手册页。还可以使用`ldd`检查一些程序的依赖项，例如我们在本示例中编写的`interest`程序。在这样做时，您将看到`libm.so`及其在系统中的位置。您还可以尝试在系统二进制文件上使用`ldd`，例如`/bin/ls`。
- en: Changing C standards
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改C标准
- en: In this recipe, we will be learning and exploring different **C standards**,
    what they are, why they matter, and how they affect our programs. We will also
    learn how to set the C standard at **compile** time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习和探索不同的**C标准**，它们是什么，为什么它们很重要，以及它们如何影响我们的程序。我们还将学习如何在**编译**时设置C标准。
- en: The most commonly used C standards today are **C89**, **C99**, and **C11** (C89
    for 1989, C11 for 2011, and so on). Many compilers still default to using C89
    because it's the most compatible, widespread, and complete implementation. However,
    C99 is a more flexible and modern implementation. Often, under newer versions
    of Linux, the default is **C18**, together with some POSIX standards.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 今天最常用的C标准是**C89**、**C99**和**C11**（C89代表1989年，C11代表2011年，依此类推）。许多编译器仍然默认使用C89，因为它是最兼容、最广泛和最完整的实现。然而，C99是一种更灵活和现代的实现。通常，在较新版本的Linux下，默认是**C18**，还有一些POSIX标准。
- en: We will write two programs and compile them with both C89 and C99, and see their
    differences.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写两个程序，并用C89和C99编译它们，看看它们的区别。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All you need for this recipe is a Linux computer with GCC installed, preferably
    via the meta-package or package group described in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing our First Linux Programs*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要的只是一台安装了GCC的Linux计算机，最好是通过[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中描述的元包或软件包组来安装。
- en: How to do it…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Follow along to explore the differences between the C standards.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 跟着来探索C标准之间的差异。
- en: 'Write the small C program shown here and save it as `no-return.c`. Note the
    missing `return` statement:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写这里显示的小型C程序，并将其保存为`no-return.c`。注意缺少`return`语句：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, compile it using the C89 standard:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用C89标准编译它：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the program and check the exit code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并检查退出代码：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, recompile the program with the same C standard, but enable *all warnings*,
    *extra warnings*, and *pedantic* checking (`-W` is the option for warnings, and
    `all` is which warnings, hence `-Wall`). Note the error message we get from GCC:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用相同的C标准重新编译程序，但启用*所有警告*、*额外警告*和*严格检查*（`-W`是警告的选项，`all`是哪些警告，因此是`-Wall`）。注意我们从GCC得到的错误消息：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, recompile the program using the C99 standard instead and enable all warnings
    and pedantic checking. No errors should be displayed this time:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重新使用C99标准编译程序，并启用所有警告和严格检查。这次不应该显示错误：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Rerun the program and check the exit code. Note the difference:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行程序并检查退出代码。注意区别：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Write the following program and name it `for-test.c`. This program creates
    an `i` integer variable inside the `for` loop. This is only allowed in C99:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下程序并将其命名为`for-test.c`。该程序在`for`循环内部创建了一个`i`整数变量。这只在C99中允许：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Compile it using the C99 standard:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用C99标准编译它：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, run it. Everything should work just fine:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后运行它。一切应该正常工作：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, instead, try to compile it with the C89 standard. Note that the error
    message clearly explains that this only works in C99 or higher. The error messages
    from GCC are useful, so always make sure to read them. They can save you a lot
    of time:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试使用C89标准编译它。请注意，错误消息清楚地解释了这只适用于C99或更高版本。GCC的错误消息很有用，所以一定要确保阅读它们。它们可以节省您很多时间：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, write the following small program and name it `comments.c`. In this program,
    we use C99 comments (also called C++ comments):'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写以下小程序并将其命名为`comments.c`。在这个程序中，我们使用C99注释（也称为C++注释）：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Compile it using C99:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用C99编译它：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And now, try to compile it using C89\. Note that this error message is also
    helpful:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试使用C89编译它。请注意，这个错误消息也很有帮助：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: These are some of the more common differences between C89 and C99\. There are
    other differences that aren't apparent in Linux using GCC. We will discuss some
    of those invisible differences in the *There's more…* section of this recipe.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是C89和C99之间一些更常见的差异。在Linux使用GCC时，还有其他一些差异是不明显的。我们将在本示例的*还有更多…*部分讨论一些看不见的差异。
- en: We change the C standard with the `-std` option to GCC. In this recipe, we try
    the two standards, C89 and C99.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用GCC的`-std`选项来改变C标准。在这个示例中，我们尝试了两种标准，C89和C99。
- en: In *Steps 1-6*, we saw the difference in what happens when we forget the return
    value. In C99, a return value of 0 is assumed since no other value was specified.
    In C89, on the other hand, it's not okay to forget the return value. The program
    will still compile, but the program will return the value 13 (an error code),
    which is wrong since no error occurred in our program. The actual code returned
    could differ, though, but it will always be greater than 0\. When we enabled *all
    warnings*, *extra warnings*, and *pedantic* checking of the code (`-Wall -Wextra
    -pedantic`), we also saw that the compiler issued a warning message, meaning it
    isn't legal to forget the return value. So, always return a value with `return`
    in C89.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1-6*中，我们看到了当我们忘记返回值时会发生什么的区别。在C99中，假定返回值为0，因为没有指定其他值。另一方面，在C89中，忘记返回值是不可以的。程序仍然会编译，但程序将返回值13（错误代码），这是错误的，因为我们的程序没有发生错误。实际返回的代码可能会有所不同，但它总是大于0。当我们启用*所有警告*、*额外警告*和*严格*检查代码（`-Wall
    -Wextra -pedantic`）时，我们还看到编译器发出了警告消息，这意味着忘记返回值是不合法的。因此，在C89中，始终使用`return`返回一个值。
- en: Then, in *Steps 7-10*, we saw that in C99 it's okay to declare a new variable
    inside a `for` loop, something that is not okay in C89.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*步骤7-10*中，我们看到在C99中，在`for`循环内部声明一个新变量是可以的，而在C89中是不可以的。
- en: In *Steps 11-13*, we saw a new way of using comments, two slashes `//`. This
    isn't legal in C89.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤11-13*中，我们看到了一种使用注释的新方法，即两条斜杠`//`。这在C89中是不合法的。
- en: There's more…
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There are more C standards and dialects than just C89 and C99\. Just to mention
    a few more, there are *C11*, *GNU99* (GNU's dialect of C99), *GNU11* (GNU's dialect
    of C11), and some others, but the most commonly used today are C89, C99, and C11\.
    C18 is starting to appear as default for some compilers and distributions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: C89和C99之外还有更多的C标准和方言。还有*C11*、*GNU99*（GNU的C99方言）、*GNU11*（GNU的C11方言）等等，但今天最常用的是C89、C99和C11。C18正在成为一些编译器和发行版的默认标准。
- en: There are actually more differences between C89 and C99 than what we've seen
    here. Some of these differences can't be demonstrated in Linux with GCC, since
    GCC has implemented workarounds for the differences. The same goes for some other
    compilers out there. But in C89, for example, the `long long int` type isn't specified;
    it was specified in C99\. But despite that, some compilers (including GCC) support
    `long long int` in C89, but we should be careful with using it in C89 since not
    all compilers support it. If you want to use `long long int`, it's safer to use
    C99, C11, or C18.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，C89和C99之间的差异比我们在这里看到的要多。在Linux中使用GCC，一些差异无法演示，因为GCC已经为这些差异实施了解决方法。其他一些编译器也是如此。但是在C89中，例如，`long
    long int`类型没有被指定；它是在C99中指定的。但尽管如此，一些编译器（包括GCC）在C89中支持`long long int`，但在C89中使用它时应该小心，因为并非所有编译器都支持它。如果要使用`long
    long int`，最好使用C99、C11或C18。
- en: I recommend that you always compile your programs with the `-Wall`, `-Wextra`,
    and `-pedantic` options. These will warn you about all sorts of things that would
    otherwise go unnoticed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您始终使用`-Wall`、`-Wextra`和`-pedantic`选项编译您的程序。这些选项将警告您各种可能被忽略的问题。
- en: Using system calls – and when not to use them
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用系统调用-以及何时不使用它们
- en: '`printf()`, `fgets()`, `putc()`, and so on. Below them, at the lowest levels,
    we have the system calls, such as `creat()`, `write()`, and so on:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf()`、`fgets()`、`putc()`等。在它们下面，最低级别是系统调用，比如`creat()`、`write()`等：'
- en: '![](img/Figure_3.1_B13043.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.1_B13043.jpg)'
- en: Figure 3.1 – High-level functions and low-level functions
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1-高级函数和低级函数
- en: When I talk about system calls here in this book, I mean system calls as C functions
    provided by the kernel, not the actual system call table. The system call functions
    we use here reside in **user space**, but the functions themselves execute in
    **kernel space**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在这本书中谈论系统调用时，我指的是内核提供的C函数，而不是实际的系统调用表。我们在这里使用的系统调用函数驻留在**用户空间**，但函数本身在**内核空间**中执行。
- en: Many of the standard C library functions, such as `putc()`, use one or more
    system call functions behind the curtains. The `putc()` function is an excellent
    example; this uses `write()` to print a character on the screen (which is a system
    call). There are also standard C library functions that don't use any system calls
    at all, such as `atoi()`, which resides entirely in user space. There is no need
    to involve the kernel to convert a string into a number.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 许多标准的C库函数，比如`putc()`，在幕后使用一个或多个系统调用函数。`putc()`函数是一个很好的例子；它使用`write()`在屏幕上打印一个字符（这是一个系统调用）。还有一些标准的C库函数根本不使用任何系统调用，比如`atoi()`，它完全驻留在用户空间。没有必要涉及内核来将字符串转换为数字。
- en: Generally speaking, if there is a standard C library function available, we
    should use that instead of a system call. System calls are often harder to work
    with and more primitive. Think of system calls as *low-level* operations, and
    standard C functions as *high-level* operations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果有标准的C库函数可用，我们应该使用它，而不是系统调用。系统调用通常更难处理，更原始。将系统调用视为*低级*操作，将标准C函数视为*高级*操作。
- en: There are cases, though, when we need to use system calls, or when they are
    easier to use or more beneficial. Learning when and why to use system calls will
    make you a better system programmer altogether. For example, there are many filesystem
    operations we can perform on Linux via system calls that aren't available elsewhere.
    Another example when we need to use a system call is when we want to `fork()`
    a process, something we will discuss in more detail later on. In other words,
    we need to use system calls when we need to perform some form of *system operation*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下，我们需要使用系统调用，或者它们更容易使用或更有益。学会何时以及为什么使用系统调用将使你成为一个更好的系统程序员。例如，在Linux上，我们可以通过系统调用执行许多文件系统操作，而这些操作在其他地方是不可用的。另一个需要使用系统调用的例子是当我们想要`fork()`一个进程时，这是我们稍后将更详细讨论的事情。换句话说，当我们需要执行某种形式的*系统操作*时，我们需要使用系统调用。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will be using a Linux-specific system call, so you'll need
    a Linux computer (which you most probably already have since you're reading this
    book). But do notice that the `sysinfo()` system call won't work under FreeBSD
    or macOS.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用一个特定于Linux的系统调用，所以你需要一台Linux计算机（你很可能已经有了，因为你正在阅读这本书）。但请注意，`sysinfo()`系统调用在FreeBSD或macOS下不起作用。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤：
- en: There isn't actually much difference between using a function from the standard
    C library versus using a system call function. System calls in Linux are declared
    in `unistd.h`, so we need to include this file when using system calls.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在使用标准C库函数和使用系统调用函数之间并没有太大的区别。Linux中的系统调用在`unistd.h`中声明，因此在使用系统调用时需要包含这个文件。
- en: 'Write the following small program and name it `sys-write.c`. It uses the `write()`
    system call. Notice that we don''t include `stdio.h` here. Since we aren''t using
    any `printf()` function or any of the stdin, stdout, or stderr file streams, we
    don''t need `stdio.h` here. We print directly to file descriptor 1, which is standard
    output. The three standard file descriptors are always opened:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下小程序，并将其命名为`sys-write.c`。它使用`write()`系统调用。请注意，我们这里没有包含`stdio.h`。因为我们没有使用任何`printf()`函数或任何stdin、stdout或stderr文件流，所以我们这里不需要`stdio.h`。我们直接打印到文件描述符1，这是标准输出。三个标准文件描述符总是打开的：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Compile it. From now on, we will always include `-Wall`, `-Wextra`, and `-pedantic`
    to write cleaner and better code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译它。从现在开始，我们将始终包括`-Wall`，`-Wextra`和`-pedantic`来编写更清洁、更好的代码：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the program:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, write the same program but with the `fputs()` function instead—a higher-level
    function. Notice that we include `stdio.h` here, instead of `unistd.h`. Name the
    program `write-chars.c`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写相同的程序，但使用`fputs()`函数——一个更高级的函数。请注意，我们在这里包含了`stdio.h`，而不是`unistd.h`。将程序命名为`write-chars.c`：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Compile it:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译它：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, run it:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后运行它：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, it''s time to write a program that reads some user and system information.
    Save the program as `my-sys.c`. All the system calls in the program are highlighted.
    This program fetches your user''s ID, current working directory, the machine''s
    total and free **random-access memory** (**RAM**), and current **process ID**
    (**PID**):'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候编写一个程序，读取一些用户和系统信息。将程序保存为`my-sys.c`。程序中的所有系统调用都已经突出显示。这个程序获取你的用户ID、当前工作目录、机器的总和空闲的**随机存取内存**（**RAM**），以及当前的**进程ID**（**PID**）：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Compile the program:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, run the program. You should now see some information about your user
    and the machine you are using:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后运行程序。现在你应该能看到有关你的用户和你正在使用的机器的一些信息：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *Steps 1-6*, we explored the difference between `write()` and `fputs()`.
    The difference might not be that obvious but `write()`, the system call, uses
    `printf()`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1-6*中，我们探讨了`write()`和`fputs()`之间的区别。区别可能并不那么明显，但`write()`这个系统调用使用了`printf()`。
- en: 'In *Steps 7-9*, we wrote a program that fetches some system and user information.
    Here, we included three system call-specific header files: `unistd.h`, `sys/types.h`,
    and `sys/sysinfo.h`.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7-9*中，我们编写了一个获取一些系统和用户信息的程序。在这里，我们包含了三个特定于系统调用的头文件：`unistd.h`，`sys/types.h`和`sys/sysinfo.h`。
- en: We have already seen `unistd.h`, a common header file for system calls in Unix
    and Linux systems. The `sys/types.h` header file is another common header file
    for system calls, especially when it comes to getting values from the system.
    This header file contains special variable types; for example, `uid_t` and `gid_t`
    for `int`. Others are `ino_t` for `pid_t` for PIDs, and so on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`unistd.h`，这是Unix和Linux系统中系统调用的一个常见头文件。`sys/types.h`头文件是另一个常见的系统调用头文件，特别是在从系统获取值时。这个头文件包含特殊的变量类型；例如，`uid_t`和`gid_t`用于`int`。其他的是`ino_t`用于`pid_t`用于PIDs，等等。
- en: The `sys/sysinfo.h` header file is specifically for the `sysinfo()` function,
    which is a system call specifically for Linux, and hence this won't work under
    other Unix systems such as macOS, Solaris, or FreeBSD/OpenBSD/NetBSD. This header
    file declares the `sysinfo` struct, which we populate with information by calling
    the `sysinfo()` function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys/sysinfo.h` 头文件专门用于 `sysinfo()` 函数，这是一个专门为 Linux 设计的系统调用，因此在其他类Unix系统（如
    macOS、Solaris 或 FreeBSD/OpenBSD/NetBSD）下不起作用。这个头文件声明了 `sysinfo` 结构，我们通过调用 `sysinfo()`
    函数来填充它的信息。'
- en: 'The first system call we use in the program is `getcwd()`, to get the current
    working directory. The function takes two arguments: a buffer where it should
    save the path, and the length of that buffer.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序中使用的第一个系统调用是 `getcwd()`，用于获取当前工作目录。该函数有两个参数：一个缓冲区，用于保存路径，以及该缓冲区的长度。
- en: The next system call is the Linux-specific `sysinfo()` function. This one gives
    us a lot of information. When the function executes, all data is saved to the
    struct `sysinfo`. This information includes the `man 2 sysinfo`, you can find
    information on the variables in the struct `sysinfo` and their data types. Further
    down in the code, we print some of these values using `printf()`—for example,
    `si.totalram`, which contains the size of the system's memory.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个系统调用是特定于 Linux 的 `sysinfo()` 函数。这个函数给了我们很多信息。当函数执行时，所有数据都保存在结构 `sysinfo`
    中。这些信息包括 `man 2 sysinfo` 中，您可以找到关于结构 `sysinfo` 中变量和它们的数据类型的信息。在代码的后面，我们使用 `printf()`
    打印了其中一些值，例如 `si.totalram`，它包含了系统内存的大小。
- en: The rest of the system calls are called directly from `printf()` and returns
    integer values.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的系统调用直接从 `printf()` 中调用，并返回整数值。
- en: There's more…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There is a lot of detailed information about Linux system calls in the manual.
    A good starting point is `man 2 intro` and `man 2 syscalls`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 手册中有关 Linux 系统调用的详细信息。一个很好的起点是 `man 2 intro` 和 `man 2 syscalls`。
- en: Tip
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Most system calls will return -1 if an error occurs. It's generally a good idea
    to check for this value to detect errors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统调用在发生错误时会返回 -1。通常最好检查这个值以检测错误。
- en: Getting information about Linux- and Unix-specific header files
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取关于 Linux 和 Unix 特定头文件的信息
- en: 'There are a lot of specific functions and `sysinfo()`. We have already seen
    two of the POSIX files in the previous recipe: `unistd.h` and `sys/types.h`. Since
    they''re POSIX files, they''re available in all Unix-like systems such as Linux,
    FreeBSD, OpenBSD, macOS, and Solaris.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多特定的函数和 `sysinfo()`。在前面的示例中，我们已经看到了两个 POSIX 文件：`unistd.h` 和 `sys/types.h`。由于它们是
    POSIX 文件，它们在所有类Unix系统（如 Linux、FreeBSD、OpenBSD、macOS 和 Solaris）中都可用。
- en: In this recipe, we will learn more about these POSIX header files, what they
    do, and when and how you can use them. We will also learn how to look up information
    about these files in the manual page.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习更多关于这些 POSIX 头文件的知识，它们的作用，以及何时以及如何使用它们。我们还将学习如何在手册页中查找有关这些文件的信息。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will look up header files in the manual. If you are using
    a Fedora-based system, such as `dnf install man-pages` as root, or with `sudo`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将在手册中查找头文件。如果您使用的是基于 Fedora 的系统，如 `dnf install man-pages` 作为 root 用户，或者使用
    `sudo`。
- en: If, on the other hand, you are using a Debian-based system such as **Ubuntu**
    or **Debian**, you will need to install those manual pages first. Follow the instructions
    here to install the manual pages required for this recipe.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果您使用的是基于 Debian 的系统，如 **Ubuntu** 或 **Debian**，您需要先安装这些手册页。按照这里的说明安装此示例所需的手册页。
- en: Debian
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Debian
- en: Debian is more strict about not including non-free software, so there are a
    few extra steps we need to take.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Debian 对不包括非自由软件更严格，因此我们需要采取一些额外的步骤。
- en: Open up `/etc/apt/sources.list` in an editor as root.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 root 身份在编辑器中打开 `/etc/apt/sources.list`。
- en: Add the word `non-free` after the lines that say `main` at the end of them (with
    a space between `main` and `non-free`).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些行的末尾（`main` 之后，用一个空格隔开），在它们后面加上单词 `non-free`。
- en: Save the file.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。
- en: Run `apt update` as root.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 root 身份运行 `apt update`。
- en: Install the manual pages by running `apt install manpages-posix-dev` as root.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以 root 用户身份运行 `apt install manpages-posix-dev` 安装手册页。
- en: Ubuntu
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ubuntu
- en: Ubuntu and other distributions based on Ubuntu aren't as strict about non-free
    software, so here we can install the correct package right away.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Ubuntu 和其他基于 Ubuntu 的发行版对非自由软件不那么严格，因此我们可以立即安装正确的软件包。
- en: Simply run `sudo apt install manpages-posix-dev`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 只需运行 `sudo apt install manpages-posix-dev`。
- en: How to do it…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: There are many header files to cover, so what's more important is learning how
    to know which header files we should use and how to find information about them,
    reading their manual pages, and knowing how to list them all. We will cover all
    of this here.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多头文件需要涵盖，因此更重要的是学习如何知道我们应该使用哪些头文件，以及如何找到有关它们的信息，阅读它们的手册页，并知道如何列出它们。我们将在这里涵盖所有这些内容。
- en: In the previous recipe, we used the `sysinfo()` and `getpid()` functions. Here,
    we will learn how to find every possible piece of information related to those
    system calls and the required header files.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了 `sysinfo()` 和 `getpid()` 函数。在这里，我们将学习如何找到与这些系统调用和所需的头文件相关的每一个可能的信息。
- en: 'First of all, we start by reading the manual page for `sysinfo()`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从阅读 `sysinfo()` 的手册页开始：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Under the **SYNOPSIS** heading, we find the following two lines:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **SYNOPSIS** 标题下，我们找到了以下两行：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This information means that we need to include `sys/sysinfo.h` to use `sysinfo()`.
    It also shows that the function takes a struct called `sysinfo` as an argument.
    Under `sysinfo` struct looks like.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些信息意味着我们需要包含 `sys/sysinfo.h` 来使用 `sysinfo()`。它还显示该函数以一个名为 `sysinfo` 的结构作为参数。`sysinfo`
    结构是什么样子呢？
- en: 'Now, let''s look up `getpid()`. It''s a POSIX function, and hence there is
    more information available:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们查找 `getpid()`。这是一个 POSIX 函数，因此有更多的信息可用：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s continue investigating. Open up the manual page for `sys/types.h`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续调查。打开 `sys/types.h` 的手册页：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'But let''s investigate further. Let''s read the manual page for `unistd.h`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但让我们进一步调查。让我们阅读 `unistd.h` 的手册页：
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, search this manual page for the word `pid_t`, and we'll find even more
    information about it.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在这个手册页中搜索`pid_t`这个词，我们会找到更多关于它的信息。
- en: Type a `/` character and then type `pid_t`, and press *Enter* to search. Press
    the letter *n* on your keyboard to search for the next occurrence of the word.
    You'll find that other functions also return a `pid_t` type—for example, `fork()`,
    `getpgrp()`, and `getsid()`, to mention a few.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`/`字符，然后输入`pid_t`，按*Enter*进行搜索。在键盘上按下字母*n*以搜索单词的下一个出现位置。您会发现其他函数也返回`pid_t`类型，例如`fork()`、`getpgrp()`和`getsid()`等。
- en: While you are reading the manual page for `unistd.h`, you can also see all functions
    that are declared in this header file. If you can't find it, search for `Declarations`.
    Press */*, type `Declarations`, and press *Enter*.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您阅读`unistd.h`的手册页时，您还可以看到在此头文件中声明的所有函数。如果找不到，请搜索`Declarations`。按下*/*，输入`Declarations`，然后按*Enter*。
- en: How it works…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The manual pages in the *7posix* or *0p* special section, depending on your
    Linux distribution, are from something called *POSIX Programmer's Manual*. If
    you open, for example, `man unistd.h`, you can see the text *POSIX Programmer's
    Manual*, as opposed to `man 2 write`, which says *Linux Programmer's Manual*.
    *POSIX Programmer's Manual* is from the **Institute of Electrical and Electronics
    Engineers** (**IEEE**) and **The Open Group**, not from the **GNU Project** or
    the Linux community.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 手册页在*7posix*或*0p*特殊部分中，取决于您的Linux发行版，来自一个称为*POSIX程序员手册*的东西。例如，如果您打开`man unistd.h`，您会看到*POSIX程序员手册*，而不是`man
    2 write`，它说*Linux程序员手册*。*POSIX程序员手册*来自**电气和电子工程师学会**（**IEEE**）和**开放组织**，而不是**GNU项目**或Linux社区。
- en: Since *POSIX Programmer's Manual* isn't free (as in open source), Debian has
    chosen not to include it in their main repository. That's why we need to add the
    non-free repository to Debian.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*POSIX程序员手册*不是免费的（开源的），Debian选择不将其包含在其主要存储库中。这就是为什么我们需要将非自由存储库添加到Debian中。
- en: POSIX is a set of standards specified by IEEE. The purpose of the standard is
    to have a common programming interface among all POSIX operating systems (most
    Unix and Unix-like systems). If you only use POSIX functions and POSIX header
    files in your program, it will be compatible with all other Unix and Unix-like
    systems out there. The actual implementation can differ from system to system,
    but the overall functions should be the same.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX是由IEEE指定的一组标准。标准的目的是在所有POSIX操作系统（大多数Unix和类Unix系统）之间具有一个共同的编程接口。如果您的程序只使用POSIX函数和POSIX头文件，它将与所有其他Unix和类Unix系统兼容。实际的实现可能因系统而异，但总体功能应该是相同的。
- en: Sometimes, when we need some specific information (such as which type `pid_t`
    is), we need to read more than one manual page, as we did in this recipe.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当我们需要一些特定的信息（比如`pid_t`是哪种类型），我们需要阅读多个手册页，就像在这个示例中所做的那样。
- en: The main takeaway here is to use the manual page for the function to find the
    corresponding header file, and then to use the manual page for the header file
    to find more specific information.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要要点是使用函数的手册页来查找相应的头文件，然后使用头文件的手册页来查找更具体的信息。
- en: There's more…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The manual pages for POSIX header files are in a special section of the manual
    page, not listed in `man man`. Under Fedora and CentOS, the section is called
    *0p*, and under Debian and Ubuntu, it's called *7posix*.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX头文件的手册页位于手册页的特殊部分中，不在`man man`中列出。在Fedora和CentOS下，该部分称为*0p*，在Debian和Ubuntu下，称为*7posix*。
- en: Tip
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can list all of the manual pages available in a given section using the
    `apropos` command with a dot (a dot means to match all).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`apropos`命令加上一个点（点表示匹配所有）来列出特定部分中所有可用的手册页。
- en: For example, to list all of the manual pages in *Section 2*, type `apropos -s
    2.` (include the dot—it's part of the command). To list all of the manual pages
    in the *7posix* special section under Ubuntu, type `apropos -s 7posix.`
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要列出*Section 2*中的所有手册页，输入`apropos -s 2.`（包括点号—它是命令的一部分）。要列出Ubuntu下*7posix*特殊部分中的所有手册页，输入`apropos
    -s 7posix.`。
- en: Defining feature test macros
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义特性测试宏
- en: In this recipe, we'll learn what some common POSIX standards are, how and why
    to use them, and how we specify them using **feature test macros**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习一些常见的POSIX标准，以及如何以及为什么使用它们，以及如何使用**特性测试宏**来指定它们。
- en: We have already seen several examples of when we have included either a POSIX
    standard or some specific C standard. For example, when we used `getopt()`, we
    defined `_XOPEN_SOURCE 500` at the very top of the source code file (`mph-to-kph_v2.c`
    from [*Chapter 2*](B13043_02_Final_SK_ePub.xhtml#_idTextAnchor050), *Making Your
    Programs Easy to Script*).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几个例子，当我们包含了POSIX标准或一些特定的C标准时。例如，当我们使用`getopt()`时，我们在源代码文件的顶部定义了`_XOPEN_SOURCE
    500`（来自[*第2章*](B13043_02_Final_SK_ePub.xhtml#_idTextAnchor050)，*使您的程序易于脚本化*）。
- en: A feature test macro controls the definitions that are exposed by system header
    files. We can leverage this in two ways. Either we can use it to create portable
    applications by using a feature test macro that prevents us from using non-standard
    definitions or we can use it the other way around, allowing us to use non-standard
    definitions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 特性测试宏控制了系统头文件中暴露的定义。我们可以以两种方式利用它。一种是通过使用特性测试宏来创建可移植的应用程序，从而防止我们使用非标准定义，另一种是相反，允许我们使用非标准定义。
- en: Getting ready
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will write two small programs in this recipe, `str-posix.c` and `which-c.c`.
    You can either download them from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3)
    or follow along and write them. You'll also need the GCC compiler we installed
    in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the
    Necessary Tools and Writing Our First Linux Programs*. It's also a good idea to
    have access to all the manual pages, including the ones from *POSIX Programmer's
    Manual* covered in the previous recipe.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将编写两个小程序，`str-posix.c`和`which-c.c`。您可以从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3)下载它们，或者跟着编写它们。您还需要我们在[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中安装的GCC编译器。还有一个好主意是要有访问所有手册页的权限，包括上一个配方中涵盖的*POSIX程序员手册*中的手册页。
- en: How to do it…
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Here, we will explore the dark corners of the inner workings of feature test
    macros, POSIX and C standards, and other related things.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将探索特性测试宏、POSIX和C标准以及其他相关事物的内部工作的黑暗角落。
- en: 'Write the following code and save it in a file called `str-posix.c`. This program
    will simply copy a string using `strdup()` and then print it. Note that we include
    `string.h` here:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码并将其保存在名为`str-posix.c`的文件中。该程序将简单地使用`strdup()`复制一个字符串，然后打印它。请注意，我们在这里包括`string.h`：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we begin with compiling it using the C99 standard and see what happens.
    More than one error message will be printed:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们开始使用C99标准编译它，看看会发生什么。将打印出多个错误消息：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That generated a pretty severe warning. The compilation succeeded, though.
    If we try to run the program, it will fail on some distributions but not others.
    This is what''s called **undefined behavior**:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这产生了一个相当严重的警告。尽管编译成功了。如果我们尝试在一些发行版上运行程序，它会失败，但在其他发行版上不会。这就是所谓的**未定义行为**：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'On another Linux distribution, we might see the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个Linux发行版上，我们可能会看到以下内容：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now comes the fascinating—and somewhat confusing—part. There is one reason
    why this program crashes sometimes, but there are several possible solutions to
    it. We will cover them all here. But first, the reason it failed is that `strdup()`
    isn''t part of C99 (we will cover why it *sometimes* works in the *How it works…*
    section). The most straightforward solution is to look at the manual page, which
    clearly states that we need the `_XOPEN_SOURCE` feature test macro set to `500`
    or higher. For the sake of this experiment, let''s set it to `700` (I''ll explain
    why later). Add the following line at the very top of `str-posix.c`. It needs
    to be on the very first line before any `include` statement; otherwise, it won''t
    work:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是迷人的——有些令人困惑的——部分。这个程序有时会崩溃的原因有一个，但是有几种可能的解决方案。我们将在这里涵盖它们。但首先，它失败的原因是`strdup()`不是C99的一部分（我们将在*它是如何工作的…*部分解释为什么它有时会工作）。最直接的解决方案是查看手册页，手册页清楚地说明我们需要将`_XOPEN_SOURCE`特性测试宏设置为`500`或更高。为了这个实验，让我们将其设置为`700`（稍后我会解释为什么）。在`str-posix.c`的最顶部添加以下行。它需要在任何`include`语句之前的第一行；否则，它将不起作用：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now that you have added the preceding line, let''s try to recompile the program:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经添加了前面的行，让我们尝试重新编译程序：
- en: '[PRE44]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'No warnings this time, so let''s run the program:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次没有警告，所以让我们运行程序：
- en: '[PRE45]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: So, that was one of the possible solutions and the most obvious one. Now, delete
    that first line again (the entire `#define` line).
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，这是可能的解决方案之一，也是最明显的解决方案。现在，再次删除第一行（整个`#define`行）。
- en: 'Once you have deleted the `#define` line we''ll recompile the program, but
    this time, we set the feature test macro at the command line instead. We use the
    `-D` flag in GCC to accomplish this:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您删除了`#define`行，我们将重新编译程序，但这次我们在命令行上设置特性测试宏。我们使用GCC中的`-D`标志来实现这一点：
- en: '[PRE46]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s try to run it:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试运行它：
- en: '[PRE47]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'That was the second solution. But if we read the manual page for feature test
    macros with `man feature_test_macros`, we see that `_XOPEN_SOURCE` with a value
    of 700 or greater has the same effect as defining `_POSIX_C_SOURCE` with a value
    of 200809L or greater. So, let''s try to recompile the program using `_POSIX_C_SOURCE`
    instead:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是第二种解决方案。但是，如果我们阅读特性测试宏的手册页`man feature_test_macros`，我们会发现`_XOPEN_SOURCE`的值为700或更高时具有与将`_POSIX_C_SOURCE`的值定义为200809L或更高相同的效果。因此，让我们尝试使用`_POSIX_C_SOURCE`重新编译程序：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'That worked just fine. Now, for the final—and possibly dangerous—solution.
    This time, we''ll recompile the program without setting any C-standard or any
    feature test macros at all:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做得很好。现在，进行最终的——可能危险的——解决方案。这一次，我们将重新编译程序，而不设置任何C标准或任何特性测试宏：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'No warning, so let''s try to run it:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有警告，所以让我们尝试运行它：
- en: '[PRE50]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'How on earth could that work when we just had to define all of these macros
    and standards? Well, it turns out that when we don''t set any C-standard or any
    feature test macros, the compiler sets a couple of standards of its own. To prove
    this, and to know how your compiler works, let''s write the following program.
    Name it `which-c.c`. This program will print the C-standard that is being used
    and any commonly defined feature test macros:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们刚刚定义了所有这些宏和标准时，它怎么可能会工作呢？嗯，事实证明，当我们不设置任何C标准或特性测试宏时，编译器会设置一些自己的标准。为了证明这一点，并了解您的编译器是如何工作的，让我们编写以下程序。将其命名为`which-c.c`。该程序将打印正在使用的C标准和任何常见定义的特性测试宏：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s compile and run this program without setting any C standard or feature
    test macros:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译并运行这个程序，而不设置任何C标准或特性测试宏：
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s try to specify that we want to use C-standard C99, and recompile `which.c`.
    What will happen here is that the compiler will enforce a strict C standard mode
    and disable the default feature test macros it might otherwise have set:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试指定我们要使用C标准C99，并重新编译`which.c`。这里会发生的是编译器将强制执行严格的C标准模式，并禁用它可能设置的默认特性测试宏：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s see what happens when we set `_XOPEN_SOURCE` to `600`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看当我们将`_XOPEN_SOURCE`设置为`600`时会发生什么：
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works…
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *Steps 1-10*, we saw what happened to our program when we used different
    standards and feature test macros. We also noticed that it surprisingly worked
    without specifying any C standard or feature test macro. That's because GCC—and
    other compilers as well—set a lot of these features and standards by default.
    But we can't count on it. It's always safer to specify it ourselves; that way,
    we know it will work.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤1-10*中，我们看到了当我们使用不同的标准和特性测试宏时，我们的程序发生了什么。我们还注意到，即使没有指定任何C标准或特性测试宏，它也奇迹般地工作了。这是因为GCC和其他编译器会默认设置许多这些特性和标准。但我们不能依赖它。最安全的方式是自己指定；这样，我们就知道它会工作。
- en: 'In *Step 13*, we wrote a program to print out the feature test macros used
    at compile time. To prevent the compiler from generating errors if a feature test
    macro was not set, we wrapped all the `printf()` lines inside `#ifdef` and `#endif`
    statements. These statements are `if` statements for the compiler, not the resulting
    program. For example, let''s take the following line:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤13*中，我们编写了一个程序来打印编译时使用的特性测试宏。为了防止编译器在没有设置特性测试宏时生成错误，我们将所有的`printf()`行包裹在`#ifdef`和`#endif`语句中。这些语句是编译器的`if`语句，而不是最终的程序。例如，让我们看下面这行：
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If `_XOPEN_SOURCE` is not defined, then this `printf()` line isn't included
    after the `_XOPEN_SOURCE`, on the other hand, is defined, it will be included.
    We will cover what preprocessing is in the next recipe.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`_XOPEN_SOURCE`没有定义，那么`printf()`行就不会被包含；另一方面，如果定义了`_XOPEN_SOURCE`，它就会被包含。我们将在下一个步骤中介绍预处理是什么。
- en: In *Step 14*, we saw that on my system, the compiler sets `_POSIX_C_SOURCE`
    to `200809`. But the manual said that we should set `_XOPEN_SOURCE` to `500` or
    greater. But it still worked—how come?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤14*中，我们看到在我的系统上，编译器将`_POSIX_C_SOURCE`设置为`200809`。但手册中说我们应该将`_XOPEN_SOURCE`设置为`500`或更高。但它仍然有效——为什么呢？
- en: If we read the manual page for the feature test macros (`man feature_test_macros`),
    we see that `_XOPEN_SOURCE` of a value greater than `700` has the same effect
    as setting `_POSIX_C_STANARD` to `200809` or greater. And since GCC has set `_POSIX_C_STANDARD`
    to `200809` for us, this has the same impact as `_XOPEN_SOURCE` `700`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们阅读特性测试宏的手册页（`man feature_test_macros`），我们会发现大于`700`的`_XOPEN_SOURCE`的值具有与将`_POSIX_C_STANARD`设置为`200809`或更高相同的效果。而且由于GCC已经为我们设置了`_POSIX_C_STANDARD`为`200809`，这与`_XOPEN_SOURCE`
    `700`具有相同的影响。
- en: In *Step 15*, we learned that the compiler enforces a strict C standard when
    we specify a standard—for example, `-std=c99`. This is the reason why `str-posix.c`
    failed to run (and got warning messages during compilation). The `strdup()` function
    isn't a standard C function; it's a POSIX function. That's why we needed to include
    some POSIX standard to use it. When the compiler uses a strict C standard, no
    other features are enabled. This enables us to write code that is portable to
    all systems with a C compiler that supports C99.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤15*中，我们了解到当我们指定一个标准时，比如`-std=c99`，编译器会强制执行严格的C标准。这就是为什么`str-posix.c`无法运行（并在编译过程中收到警告消息）。`strdup()`函数不是标准的C函数；它是一个POSIX函数。这就是为什么我们需要包含一些POSIX标准来使用它。当编译器使用严格的C标准时，不会启用其他特性。这使我们能够编写可在所有支持C99的C编译器的系统上运行的代码。
- en: 'In *Step 16*, we specified `_XOPEN_SOURCE` `600` when we compiled the program—doing
    so also sets `_POSIX_C_STANDARD` to `200112`. We can read about this in the manual
    page (`man feature_test_macros`). From the manual: *"[When] _XOPEN_SOURCE is defined
    with a value greater than or equal to 500 […] the following macros are implicitly
    defined, _POSIX_C_SOURCE […]*".'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤16*中，我们在编译程序时指定了`_XOPEN_SOURCE` `600`，这也将`_POSIX_C_STANDARD`设置为`200112`。我们可以在手册页（`man
    feature_test_macros`）中了解这一点。从手册中得知：“[当] _XOPEN_SOURCE被定义为大于或等于500的值时，以下宏会被隐式定义，_POSIX_C_SOURCE[...]”。
- en: But what do feature macros do, then? How do they modify the code?
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 那么特性宏到底是做什么的？它们如何修改代码？
- en: The header files on the system are full of `#ifdef` statements, enabling and
    disabling various functions and features, depending on which feature test macros
    are set. For example, in our case with `strdup()`, the `string.h` header file
    has the `strdup()` function wrapped in `#ifdef` statements. Those statements check
    if either `_XOPEN_SOURCE` or some other POSIX standard is defined. If no such
    standards are specified, then `strdup()` is not visible. That is how feature test
    macros work.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的头文件中充满了`#ifdef`语句，根据设置的特性测试宏启用或禁用各种函数和特性。例如，在我们的情况下，对于`strdup()`，`string.h`头文件中将`strdup()`函数包裹在`#ifdef`语句中。这些语句检查是否定义了`_XOPEN_SOURCE`或其他一些POSIX标准。如果没有指定这些标准，那么`strdup()`就不可见。这就是特性测试宏的工作原理。
- en: But why did the program end with a segmentation fault in *Step 3* on some Linux
    distribution and not others? As already mentioned, the `strdup()` function is
    there, but without the feature test macro there's no declaration for it. What
    happens then is *undefined*. It could work because of some specific implementation
    detail, but it could also not work. When we program, we should always avoid *undefined
    behavior*. Just because something works on this specific computer, on this Linux
    distribution, with this compiler version, on this particular night when it's a
    full moon, this doesn't guarantee that it will work on someone else's computer
    on some other night. Therefore, we should always strive to write correct code
    following a specific standard. That way, we avoid undefined behavior.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么在*步骤3*中，程序在某些Linux发行版上以分段错误结束，而在其他发行版上却没有？如前所述，`strdup()`函数是存在的，但是没有特性测试宏，它就没有声明。那么会发生*未定义*的情况。它可能会因为某些特定的实现细节而工作，但也可能不工作。当我们编程时，应该始终避免*未定义的行为*。仅仅因为某些东西在这台特定的计算机上工作，在这个Linux发行版上，在这个编译器版本上，在这个特定的月夜上工作，这并不保证它会在别人的计算机上在其他的夜晚上工作。因此，我们应该始终努力编写正确的代码，遵循特定的标准。这样，我们就可以避免未定义的行为。
- en: There's more…
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: All of these feature test macros we have defined correspond to a POSIX or other
    standard of some sort. The idea behind these standards is to create a uniform
    programming interface among the different Unix versions and Unix-like systems
    out there.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的所有这些特性测试宏都对应于某种POSIX或其他标准。这些标准背后的想法是在不同的Unix版本和类Unix系统之间创建统一的编程接口。
- en: 'For anyone who wants to dig deep into standards and feature test macros, there
    are some excellent manual pages available. Just to mention a few:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想深入了解标准和特性测试宏的人，有一些优秀的手册页面可供阅读。只是举几个例子：
- en: '`man 7 feature_test_macros` (Here, you can read all about which feature test
    macros correspond to which standard, such as POSIX, Single Unix Specification,
    XPG (X/Open Portability Guide), and so on.)'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 7 feature_test_macros`（在这里，您可以阅读有关哪些特性测试宏对应于哪些标准的所有信息，例如POSIX、Single Unix规范、XPG（X/Open可移植性指南）等等。）'
- en: '`man 7 standards` (Even more information about the standards)'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 7 standards`（有关标准的更多信息）'
- en: '`man unistd.h`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man unistd.h`'
- en: '`man 7 libc`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 7 libc`'
- en: '`man 7 posixoptions`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 7 posixoptions`'
- en: Looking at the four stages of compilation
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看编译的四个阶段
- en: When we generally speak of compilation, we mean the entire process of turning
    code into a running binary program. But there are actually four steps involved
    in compiling a source code file into a running binary program, and it's just one
    of these steps that's called compilation.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通常谈论编译时，我们指的是将代码转换为运行的二进制程序的整个过程。但实际上，在将源代码文件编译为运行的二进制程序时涉及四个步骤，而只有一个步骤被称为编译。
- en: Knowing about these four steps, and how to extract the intermediate files, enables
    us to do everything from writing efficient Makefiles to writing shared libraries.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这四个步骤，以及如何提取中间文件，使我们能够从编写高效的Makefile到编写共享库等所有事情。
- en: Getting ready
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备完成
- en: For this recipe, we will write three small C source code files. You can also
    download them from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3).
    You'll also need the GCC compiler that we installed in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将编写三个小的C源代码文件。您也可以从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3)下载它们。您还需要我们在[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中安装的GCC编译器，*获取必要的工具并编写我们的第一个Linux程序*。
- en: How to do it…
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: In this recipe, we will create a small program and then manually compile it
    by executing each step individually, using the compiler's flags. We will also
    look at the files generated from each step. The program we will write is intentionally
    small so that we can look at the resulting code without too much clutter. The
    program we will write will simply return a cubed number—in our case, 4 cubed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个小程序，然后通过逐个执行每个步骤来手动编译它，使用编译器的标志。我们还将查看从每个步骤生成的文件。我们将编写的程序故意很小，以便我们可以在没有太多混乱的情况下查看生成的代码。我们将编写的程序将简单地返回一个立方数——在我们的例子中是4的立方。
- en: 'The first source code file for this recipe is a file called `cube-prog.c`.
    This will be the source code file with the `main()` function in it:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个示例的第一个源代码文件是一个名为`cube-prog.c`的文件。这将是带有`main()`函数的源代码文件：
- en: '[PRE58]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we write the function for `cube()` in a file called `cubed-func.c`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在一个名为`cubed-func.c`的文件中编写`cube()`的函数：
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And finally, we write the header file, `cube.h`. This is just the function
    prototype:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们编写头文件`cube.h`。这只是函数原型：
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Before we build the program step by step, we first compile it as usual since
    we haven't covered how to compile a program that consists of several files yet.
    To compile a program that's made up of more than one source file, we simply list
    them at the GCC command line. Note, however, that we don't list the header file
    here. Since the header file is included with a `#include` line, the compiler already
    knows about it.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们逐步构建程序之前，我们首先像往常一样编译它，因为我们还没有涵盖如何编译由多个文件组成的程序。要编译由多个源文件组成的程序，我们只需在GCC命令行中列出它们。但是请注意，我们在这里不列出头文件。由于头文件包含了`#include`行，编译器已经知道它。
- en: 'This is how we compile a program with several files:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们如何编译一个由几个文件组成的程序：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And then, let''s run it, and also check the return value:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们运行它，并检查返回值：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we begin to build the program step by step instead. First, we delete the
    binary file already produced:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们开始逐步构建程序。首先，我们删除已经生成的二进制文件：
- en: '[PRE63]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, let''s begin compiling the program step by step. The first step is what
    is called the `#include` files in the program itself:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们逐步开始编译程序。第一步是在程序本身中所谓的`#include`文件：
- en: '[PRE64]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now, we have two *preprocessed* files (`cube-prog.i` and `cube-func.i`). Let's
    take a look at them with `cat` or an editor. I have highlighted the changes in
    the following code snippet. Note how the `#include` statement has been replaced
    by the code from the header file, and how the `NUMBER` macro has been replaced
    by a `4`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有两个*预处理*文件（`cube-prog.i`和`cube-func.i`）。让我们用`cat`或编辑器来看看它们。我已经在下面的代码片段中突出显示了更改。请注意`#include`语句已被替换为头文件中的代码，以及`NUMBER`宏已被替换为`4`。
- en: 'First, we take a look at `cube-prog.i`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看看`cube-prog.i`：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: int cube(int n)
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: int cube(int n)
- en: '{'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return n*n*n;
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: return n*n*n;
- en: '}'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE66]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The second step is the **compilation**. It is here that our preprocessed files
    are translated into *assembly language*. The resulting assembly files will look
    different on different machines and architectures:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是**编译**。在这里，我们的预处理文件被翻译成*汇编语言*。生成的汇编文件在不同的机器和架构上看起来会有所不同：
- en: '[PRE67]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Let's take a look at these files as well, but do note that these files can be
    different on your machine.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也看看这些文件，但请注意，这些文件在您的机器上可能会有所不同。
- en: 'First, we take a look at `cube-prog.s`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看看`cube-prog.s`：
- en: '[PRE68]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we take a look at `cube-func.s`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看看`cube-func.s`：
- en: '[PRE69]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The third step is called **assembly**. This step is where the assembly source
    code files are built to what are called **object files**:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步称为**汇编**。这一步是将汇编源代码文件构建为所谓的**目标文件**的过程：
- en: '[PRE70]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we have two object files. We can''t look at them since they are binary
    files, but we can use the `file` command to see what they are. The description
    here can also differ on different architectures—for example, 32-bit x86 machines,
    ARM64, and so on:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有两个目标文件。我们无法查看它们，因为它们是二进制文件，但我们可以使用`file`命令来查看它们是什么。这里的描述也可能因不同的架构而有所不同——例如，32位x86机器，ARM64等等：
- en: '[PRE71]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, we are at the fourth and final step. This is where we combine all the
    object files into a single binary file. This step is called the **linker**:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们来到了第四个也是最后一个步骤。这是将所有目标文件合并成单个二进制文件的过程。这一步被称为**链接器**：
- en: '[PRE72]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, we have a binary file ready, called `cube`. Let''s see what `file` has
    to say about it:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为`cube`的准备好的二进制文件。让我们看看`file`对它的评价：
- en: '[PRE73]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'And finally, let''s run it to verify that it works:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们运行它来验证它是否工作：
- en: '[PRE74]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: How it works…
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In *Step 7* (the first step in the process), we used the `-E` and `-P` options
    to produce *preprocessed files*. The `-E` option makes GCC stop after preprocessing
    the files— that is, creating preprocessed files. The `-P` option is an option
    for the preprocessor not to include line markers in the preprocessed files. We
    want clean output files.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤7*（过程中的第一步），我们使用了`-E`和`-P`选项来生成*预处理文件*。`-E`选项使GCC在预处理文件后停止——也就是说，创建预处理文件。`-P`选项是预处理器不在预处理文件中包含行标记的选项。我们需要干净的输出文件。
- en: All `#include` statements include the content of those files in the preprocessed
    files. Likewise, any macros—such as `NUMBERS`—are replaced by the actual number.
    Preprocessed files usually have a `.i` extension.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`#include`语句都会在预处理文件中包含这些文件的内容。同样，任何宏—比如`NUMBERS`—都会被实际数字替换。预处理文件通常具有`.i`扩展名。
- en: In *Step 9* (the second step in the process), we compiled the preprocessed files.
    The compilation step creates assembly language files. For this step, we used the
    `-S` option, which tells GCC to stop after the compilation process is complete.
    Assembly files usually have a `.s` extension.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤9*（过程中的第二步），我们编译了预处理文件。编译步骤创建了汇编语言文件。对于这一步，我们使用了`-S`选项，告诉GCC在编译过程完成后停止。汇编文件通常具有`.s`扩展名。
- en: In *Step 11* (the third step in the process), we *assembled* the files. This
    step is also called the *assembly* stage. This step takes the assembly language
    files and makes *object files*. We will use object files later in this book when
    we create libraries. The `-c` option tells GCC to stop after the assembly stage
    (or after compiling). Object files usually have a `.o` extension.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤11*（过程中的第三步），我们*汇编*了文件。这一步也称为*汇编*阶段。这一步将汇编语言文件转换为*目标文件*。在本书的后面，当我们创建库时，我们将使用目标文件。`-c`选项告诉GCC在汇编阶段（或编译完成后）停止。目标文件通常具有`.o`扩展名。
- en: 'Then, in *Step 13* (the fourth and final step), we *linked* the files, creating
    a single binary file that we can execute. No options were needed for this since
    the default action GCC takes is to run through all the steps and, finally, link
    the files to a single binary file. After we linked the files, we got a running
    binary file called `cube`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*步骤13*（过程中的第四个也是最后一个步骤），我们*链接*了文件，创建了一个可以执行的单个二进制文件。这一步不需要任何选项，因为GCC的默认操作是运行所有步骤，最后将文件链接到一个单个的二进制文件中。在我们链接文件之后，我们得到了一个名为`cube`的运行中的二进制文件：
- en: '![Figure 3.2 – The four stages of compilation'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.2 - 编译的四个阶段'
- en: '](img/Figure_3.2_B13043.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_3.2_B13043.jpg)'
- en: Figure 3.2 – The four stages of compilation
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 - 编译的四个阶段
- en: Compiling with Make
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Make进行编译
- en: We have already seen some example usage with **Make**. Here, we will recap on
    what Make is and how we can use it to compile programs so that we don't have to
    type GCC commands.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些使用**Make**的示例。在这里，我们将回顾一下Make是什么，以及我们如何使用它来编译程序，这样我们就不必输入GCC命令了。
- en: Getting ready
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All you need for this recipe is the GCC compiler and Make. You have already
    installed these tools if you followed [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020),
    *Getting the Necessary Tools and Writing Our First Linux Programs*.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个步骤，你所需要的只是GCC编译器和Make。如果你遵循[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)，*获取必要的工具并编写我们的第一个Linux程序*，那么你已经安装了这些工具。
- en: How to do it…
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: We will write a small program that calculates the circumference of a circle,
    given the radius. We will then use the Make tool to compile it. The Make tool
    is smart enough to figure out the name of the source code file.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个小程序，用于计算给定半径的圆的周长。然后我们将使用Make工具来编译它。Make工具足够智能，可以找出源代码文件的名称。
- en: 'Write the following code and save it as `circumference.c`. This program is
    built on the same code as `mph-to-kph.c` from the previous chapter:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码，并将其保存为`circumference.c`。这个程序是建立在上一章的`mph-to-kph.c`代码的基础上的：
- en: '[PRE75]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, let''s compile it with Make:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用Make来编译它：
- en: '[PRE76]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If we try to recompile it, it will only tell us that the program is up to date:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试重新编译它，它只会告诉我们程序是最新的：
- en: '[PRE77]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Add some more decimal places to the `PI` macro, making it 3.14159265 instead.
    The fourth line in the code should now look like this:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PI`宏的小数位数增加到8位，变为3.14159265。代码中的第四行现在应该是这样的：
- en: '[PRE78]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Save the file once you have made the changes.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行更改后保存文件。
- en: 'If we try to recompile the program now it will do so, since it notices that
    the code has changed:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在尝试重新编译程序，它会这样做，因为它注意到代码已经改变了：
- en: '[PRE79]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Let''s try out the program:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们试试这个程序：
- en: '[PRE80]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: How it works…
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The Make tool is a tool to ease the compilation of larger projects, but it is
    useful even for small programs like this.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Make工具是一个用于简化大型项目编译的工具，但即使对于像这样的小程序也很有用。
- en: When we execute `make circumference`, it assumes that we want to build a program
    called `circumference` and that its source code file is `circumference.c`. It
    also assumes that our compiler command is `cc` (`cc` is a *link* to `gcc` on most
    Linux systems), and compiles the program using the `cc circumference.c -o circumference`
    command. This command is the same that we run for ourselves when we compile a
    program, except that we have used the real name—`gcc`—instead. In the next recipe,
    we will learn how to change this default command.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行`make circumference`时，它假设我们想要构建一个名为`circumference`的程序，其源代码文件是`circumference.c`。它还假设我们的编译器命令是`cc`（在大多数Linux系统上，`cc`是`gcc`的链接），并使用`cc
    circumference.c -o circumference`命令编译程序。这个命令与我们自己编译程序时运行的命令相同，只是我们使用了真实的名字—`gcc`—而不是`cc`。在下一个示例中，我们将学习如何更改这个默认命令。
- en: The Make tool is also smart enough not to recompile a program unless it's necessary.
    This feature comes in handy on massive projects, where it can take several hours
    to recompile. Only recompiling the changed files saves a lot of time.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Make工具还足够智能，不会重新编译程序，除非有必要。这个功能在大型项目中非常有用，因为重新编译可能需要几个小时。只重新编译已更改的文件可以节省大量时间。
- en: Writing a generic Makefile with GCC options
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GCC选项编写通用的Makefile
- en: In the previous recipe, we learned that Make compiles a program using the `cc
    prog.c -o prog` command. In this recipe, we will learn how to change that default
    command. To control the default command, we write a **Makefile** and place that
    file in the same directory as the source file.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们学习了Make使用`cc prog.c -o prog`命令编译程序。在这个示例中，我们将学习如何更改默认命令。为了控制默认命令，我们编写一个**Makefile**并将该文件放在与源文件相同的目录中。
- en: Writing a generic Makefile for all your projects is an excellent idea since
    you can then enable `-Wall`, `-Wextra`, and `-pedantic` for all files you compile.
    With these three options enabled, GCC will warn you about many more errors and
    irregularities in your code, making your programs better. That is what we will
    do in this recipe.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有项目编写通用的Makefile是一个很好的主意，因为你可以为所有编译的文件启用`-Wall`、`-Wextra`和`-pedantic`。启用这三个选项后，GCC会警告你的代码中更多的错误和不规范之处，使你的程序更加完善。这就是我们将在这个示例中做的事情。
- en: Getting ready
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will use the `circumference.c` source code file that we wrote
    in the previous recipe. If you don't already have the file on your computer, you
    can download it from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch3/circumference.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch3/circumference.c).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用我们在上一个示例中编写的`circumference.c`源代码文件。如果你的计算机上还没有这个文件，你可以从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch3/circumference.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch3/circumference.c)下载它。
- en: How to do it…
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: Here, we will write a generic Makefile that you can use for all your projects
    to ensure your programs follow the C99 standard and don't contain any apparent
    errors.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写一个通用的Makefile，你可以用它来确保你的所有项目都遵循C99标准，并且不包含任何明显的错误。
- en: 'Write the following code and save it as a file called `Makefile` in the same
    directory as `circumference.c`. This Makefile sets your default compiler and some
    common compiler options:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写下以下代码，并将其保存为一个名为`Makefile`的文件，放在与`circumference.c`相同的目录中。这个Makefile设置了你的默认编译器和一些常见的编译器选项：
- en: '[PRE81]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now, remove the `circumference` binary file if you still have it from the previous
    recipe. If you don't have it, skip ahead.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你还有上一个示例中的`circumference`二进制文件，就把它删除掉。如果你没有，就跳过这一步。
- en: 'Now, compile the `circumference` program with Make, and notice how the compilation
    command has changed from the previous recipe. The options we just specified in
    the Makefile should now be applied:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用Make编译`circumference`程序，并注意编译命令如何与上一个示例中的不同。我们刚刚在Makefile中指定的选项现在应该已经生效了：
- en: '[PRE82]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Run the program to make sure it works:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序以确保它能正常工作：
- en: '[PRE83]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works…
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The Makefile we created controls the Make behavior. Since this Makefile isn't
    written for any particular project, it works for all programs in the same directory.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的Makefile控制了Make的行为。由于这个Makefile并不是为任何特定的项目编写的，它适用于同一目录中的所有程序。
- en: On the first line of the Makefile, we set the compiler to `gcc` using the special
    `CC` variable. On the second line, we set the flags to the compiler using the
    special `CFLAGS` variable. We set this variable to `-Wall -Wextra -pedantic -std=c99`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在Makefile的第一行，我们使用特殊的`CC`变量将编译器设置为`gcc`。在第二行，我们使用特殊的`CFLAGS`变量将标志设置给编译器。我们将这个变量设置为`-Wall
    -Wextra -pedantic -std=c99`。
- en: When we execute `make`, it puts together the `CC` variable and the `CFLAGS`
    variable, which results in a `gcc -Wall -Wextra -pedantic -std=c99` command. And,
    as we learned in the previous recipe, Make assumes the binary name we wish to
    use is the name we gave it. It also assumes the source code file has the same
    name, but with a `.c` ending.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行`make`时，它会组合`CC`变量和`CFLAGS`变量，得到一个`gcc -Wall -Wextra -pedantic -std=c99`的命令。正如我们在上一个示例中学到的，Make假设我们希望使用的二进制文件名与我们给定的名字相同。它还假设源代码文件具有相同的名字，只是以`.c`结尾。
- en: 'Even on a small project like this with only one file, Make saves us from typing
    a long GCC command every time we want to recompile it. And that is what Make is
    all about: saving us time and energy.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在一个只有一个文件的小项目中，Make也可以帮我们节省每次重新编译时输入长长的GCC命令的时间。这就是Make的全部意义：节省我们的时间和精力。
- en: There's more…
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: If you want to learn more about Make, you can read `man 1 make`. There is even
    more detailed information in `info make`. If you don't have the `info` command,
    you'll need to install it first using your package manager as root. The package
    is called `info` on most Linux distributions.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于Make的信息，你可以阅读`man 1 make`。在`info make`中还有更详细的信息。如果你没有`info`命令，你需要首先以root身份使用你的包管理器安装它。在大多数Linux发行版中，这个包叫做`info`。
- en: Writing a simple Makefile
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个简单的Makefile
- en: In this recipe, we will learn how to write a Makefile for a specific project.
    The Makefile we wrote in the previous recipe was generic, but this will be for
    a single project only. Knowing how to write Makefiles for your projects will save
    you a lot of time and energy as you start making more complex programs.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何为一个特定项目编写Makefile。我们在上一个示例中编写的Makefile是通用的，但这将只针对一个项目。了解如何为你的项目编写Makefile将为你节省大量时间和精力，因为你开始制作更复杂的程序。
- en: Also, including a Makefile in a project is considered good manners. The person
    downloading your project usually has no idea how to build it. That person only
    wants to use your program, not be forced to understand how things fit together
    and how to compile it. After downloading, for example, an open source project,
    they would expect to be able just to type `make` and `make install` (or possibly
    also some form of configuration script, but we won't cover that here). The program
    should then be ready to run.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在项目中包含一个Makefile被认为是一种良好的习惯。下载你的项目的人通常不知道如何构建它。那个人只想使用你的程序，而不是被迫理解如何将事物组合在一起以及如何编译它。例如，在下载了一个开源项目之后，他们希望只需输入`make`和`make
    install`（或者可能还有一些形式的配置脚本），程序就应该准备好运行了。
- en: Getting ready
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use the `cube` program we made in the *Looking at the
    four stages of compilation* recipe in this chapter. The source code files we will
    use are `cube-prog.c`, `cube-func.c`, and `cube.h`. They can all be downloaded
    from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将使用本章中“查看编译的四个阶段”示例中制作的`cube`程序。我们将使用的源代码文件是`cube-prog.c`、`cube-func.c`和`cube.h`。它们都可以从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3)下载。
- en: Save these three files in a new and separate directory, preferably called `cube`.
    Make sure you are inside that directory when you create the Makefile.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 将这三个文件保存在一个新的独立目录中，最好叫做`cube`。确保你在创建Makefile时在该目录中。
- en: How to do it…
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Before we start writing the code, make sure you are in the directory where you
    saved the source code files for the `cube` program.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，请确保你在保存了`cube`程序源代码文件的目录中。
- en: 'Let''s create the Makefile for the `cube` program. Save the file as `Makefile`.
    In this Makefile we have only one *target*, `cube`. Below the target, we have
    the command that compiles the program:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`cube`程序创建Makefile。将文件保存为`Makefile`。在这个Makefile中，我们只有一个*目标*，`cube`。在目标下面，我们有编译程序的命令：
- en: '[PRE84]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, it''s time to try to build the program using Make:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候尝试使用Make构建程序了：
- en: '[PRE85]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And finally, we execute the program. Don''t forget to also check the return
    value:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们执行程序。不要忘记也检查返回值：
- en: '[PRE86]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'If we try to rebuild the program now, it will say that everything is up to
    date, which it is. Let''s try it:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在尝试重新构建程序，它会说一切都是最新的，这是正确的。让我们试试：
- en: '[PRE87]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'But if we change something in one of the source code files, it will rebuild
    the program. Let''s change the `NUMBER` macro to `2`. The second line in the `cube-prog.c`
    file should now look like this:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是，如果我们更改了一个源代码文件中的内容，它将重新构建程序。让我们将`NUMBER`宏更改为`2`。`cube-prog.c`文件中的第二行现在应该是这样的：
- en: '[PRE88]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Now, we can recompile the program with Make:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用Make重新编译程序了：
- en: '[PRE89]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'And then, let''s view the changes that are made to our program:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们查看对我们的程序所做的更改：
- en: '[PRE90]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Now, delete the `cube` program so that we can try to recompile it in the next
    step:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，删除`cube`程序，以便我们可以尝试在下一步中重新编译它：
- en: '[PRE91]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Rename one of the source code files—for example, `cube.h` to `cube.p`:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源代码文件中的一个文件重命名，例如将`cube.h`重命名为`cube.p`：
- en: '[PRE92]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If we try to recompile it now, Make will protest that it''s missing `cube.h`
    and refuse to go any further:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在尝试重新编译它，Make会抱怨缺少`cube.h`并拒绝继续进行：
- en: '[PRE93]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: How it works…
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We have already seen the first two lines in the Makefile. The first one, `CC`,
    sets the default C compiler to `gcc`. The second one, `CFLAGS`, sets the flags
    we want to pass to the compiler.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在Makefile中看到了前两行。第一行`CC`将默认的C编译器设置为`gcc`。第二行`CFLAGS`设置了我们想要传递给编译器的标志。
- en: The next line—the one that starts with `cube:`—is called a **target**. Right
    after the target, on the same line, we list all the files that this target is
    dependent upon, which are all the source code files and header files.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行——以`cube:`开头的那一行——被称为**目标**。紧接着目标，在同一行上，我们列出了这个目标所依赖的所有文件，这些文件都是源代码文件和头文件。
- en: 'Below the target, we have an indented line with the following content:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标下面，我们有一行缩进的内容：
- en: '[PRE94]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This line is the command that will compile the program. `$(CC)` and `$(CFLAGS)`
    will be replaced with the content of those variables, which is `gcc` and `-Wall
    -Wextra -pedantic -std=c99`. Basically, we have just written what we would usually
    write at the command line, but in a Makefile instead.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行是编译程序的命令。`$(CC)`和`$(CFLAGS)`将被替换为这些变量的内容，即`gcc`和`-Wall -Wextra -pedantic
    -std=c99`。基本上，我们只是在Makefile中写了我们通常在命令行中写的内容。
- en: In the next recipe, we will learn how to leverage some of the smarter stuff
    in Make.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将学习如何利用Make中的一些更智能的功能。
- en: Writing a more advanced Makefile
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写更高级的Makefile
- en: In the previous recipe, we wrote a basic Makefile without using any of its more
    advanced features. In this recipe, however, we will write a more advanced Makefile,
    using object files, more variables, dependencies, and other fancy things.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们编写了一个基本的Makefile，没有使用任何更高级的功能。然而，在这个示例中，我们将编写一个更高级的Makefile，使用对象文件、更多的变量、依赖关系和其他花哨的东西。
- en: 'Here, we will create a new program. The program will calculate the area of
    three different objects: circles, triangles, and rectangles. Each calculation
    will be performed in its own function, and every function will reside in its own
    file. On top of that, we will have a function in a separate file for the help
    text. There will also be a header file that holds all of the function prototypes.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个新的程序。该程序将计算三种不同对象的面积：圆、三角形和矩形。每个计算将在其自己的函数中执行，每个函数都将驻留在自己的文件中。此外，我们将在一个单独的文件中拥有一个帮助文本的函数。还将有一个包含所有函数原型的头文件。
- en: Getting ready
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This project will consist of a total of seven files. If you want, you can choose
    to download all the files from the directory at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3/area](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3/area).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将包括总共七个文件。如果你愿意，你可以选择从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3/area](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch3/area)目录下载所有文件。
- en: Since we will create a Makefile for this project, I really recommend that you
    place all of the project files in a new and separate directory.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将为这个项目创建一个Makefile，我真的建议您将所有项目文件放在一个新的独立目录中。
- en: You will also need the Make tool and the GCC compiler installed in [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the Necessary Tools
    and Writing Our First Linux Programs*.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中安装Make工具和GCC编译器，*获取必要的工具并编写我们的第一个Linux程序*。
- en: How to do it…
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: First of all, we write all of the code files required for this program. Then,
    we try to compile the program using Make, and finally, we try to run it. Follow
    along.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们编写了这个程序所需的所有代码文件。然后，我们尝试使用Make编译程序，最后，我们尝试运行它。跟着做。
- en: 'Let''s start by writing a main program file called `area.c`. This is the main
    part of the program, and it contains the `main()` function:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从编写一个名为`area.c`的主程序文件开始。这是程序的主要部分，包含`main()`函数：
- en: '[PRE95]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Next, we write the header file, called `area.h`. This file contains all of
    the function prototypes:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们编写名为`area.h`的头文件。该文件包含所有函数原型：
- en: '[PRE96]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'And now, add the `help` function in its own file, called `help.c`: (Shankar)'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在其自己的文件中添加`help`函数，名为`help.c`：（Shankar）
- en: '[PRE97]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, let''s write a function for calculating the area of a circle. We write
    this in a file called `circle.c`:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个用于计算圆面积的函数。我们将其写在一个名为`circle.c`的文件中：
- en: '[PRE98]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Next up is a function for calculating the area of a rectangle. We name this
    file `rectangle.c`:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是一个用于计算矩形面积的函数。我们将这个文件命名为`rectangle.c`：
- en: '[PRE99]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'And the last function is for calculating the area of a triangle. We name this
    file `triangle.c`:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个函数是用于计算三角形面积的函数。我们将这个文件命名为`triangle.c`：
- en: '[PRE100]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now comes the exciting part: the `Makefile`. Note that the indentations in
    a Makefile must be precisely one tab character. Note that the `area` target lists
    all the object files using the `OBJS` variable. The command for this target, `$(CC)
    -o area $(OBJS) $(LIBS)`, links together all the object files into a single binary,
    using what''s called a linker. But since the linker depends on all the object
    files, Make builds them first before linking:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是令人兴奋的部分：`Makefile`。请注意，Makefile中的缩进必须精确为一个制表符。请注意，`area`目标使用`OBJS`变量列出所有对象文件。此目标的命令`$(CC)
    -o area $(OBJS) $(LIBS)`将所有对象文件链接成一个单一的二进制文件，使用所谓的链接器。但由于链接器依赖于所有对象文件，因此在链接之前，Make会先构建它们：
- en: '[PRE101]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Finally, we can try to compile this entire program by typing `make`. Note that
    you must be in the same directory as the source code files and the Makefile. Notice
    here that all the object files get compiled first, then they are linked in the
    final step:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以尝试通过输入`make`来编译整个程序。请注意，您必须在与源代码文件和Makefile相同的目录中。请注意，所有的对象文件都会先被编译，然后它们会在最后一步被链接：
- en: '[PRE102]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'And now, let''s try out the program. Test all the different functions:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试运行程序。测试所有不同的函数：
- en: '[PRE103]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now, let''s pretend we have changed some part of the `circle.c` file by updating
    its timestamp. We can update the timestamp of a file by running `touch` on it:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们已经通过更新时间戳来更改了`circle.c`文件的某些部分。我们可以通过在文件上运行`touch`来更新文件的时间戳：
- en: '[PRE104]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Now, we rebuild the program. Compare the output from *Step 8*, where all the
    object files were compiled. This time, the only file that gets recompiled is `circle.o`.
    After the recompilation of `circle.o`, the binary is relinked into a single binary:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们重新构建程序。比较*步骤8*的输出，那里所有的对象文件都被编译。这一次，唯一重新编译的文件是`circle.o`。在`circle.o`重新编译之后，二进制文件被重新链接成一个单一的二进制文件：
- en: '[PRE105]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now, let''s try to install the program on the system by using the `install`
    target. For this to succeed, you need to run it as root using either `su` or `sudo`:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用`install`目标将程序安装到系统上。为了成功，您需要以root身份运行它，可以使用`su`或`sudo`：
- en: '[PRE106]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Let''s uninstall the program from the system. It''s good practice to include
    an `uninstall` target, especially if the `install` target installs lots and lots
    of files on the system:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从系统中卸载程序。包括一个`uninstall`目标是个好习惯，特别是如果`install`目标在系统上安装了大量文件：
- en: '[PRE107]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Let''s also try the target called `clean`. This will delete all the object
    files and the binary file. It''s good practice to include a target for cleaning
    up object files and other temporary files:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也尝试一下名为`clean`的目标。这将删除所有对象文件和二进制文件。包括一个用于清理对象文件和其他临时文件的目标是个好习惯：
- en: '[PRE108]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: How it works…
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Even though the program example for this recipe was rather big, it's a pretty
    straightforward program. There are some parts of it, though, that are worth commenting
    on.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个配方的程序示例相当大，但它是一个非常直接的程序。然而，其中一些部分值得评论。
- en: All of the C files get compiled to object files independently of each other.
    That's the reason why we need to include `stdio.h` in every single file that uses
    `printf()` or `scanf()`.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的C文件都会独立地编译成对象文件。这就是为什么我们需要在每个使用`printf()`或`scanf()`的文件中包含`stdio.h`的原因。
- en: In the `circle.c` file, we have included the `math.h` header file. This header
    file is for the `pow()` function. We also defined `_XOPEN_SOURCE` with a value
    of `700`. The reason is that the `M_PI` macro that holds the value of Pi isn't
    included in the C standard but it is, on the other hand, included in the **X/Open**
    standard.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在`circle.c`文件中，我们包含了`math.h`头文件。这个头文件是为了`pow()`函数。我们还定义了`_XOPEN_SOURCE`，值为`700`。原因是`M_PI`宏，它保存了Pi的值，没有包含在C标准中，但是，另一方面，它包含在**X/Open**标准中。
- en: The Makefile
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Makefile
- en: Now, it's time to discuss the Makefile in greater detail. We have already seen
    the first two variables, `CC` and `CFLAGS`, in previous recipes, but notice that
    we haven't used the `CFLAGS` variable anywhere in the code. We don't need to.
    `CFLAGS` is automatically applied when compiling the object files. If we had applied
    the `CFLAGS` variable manually after the `CC` variable in the command for the
    `area` target, those flags would also have been used for the linking process.
    In other words, the command we have specified for the target called `area` is
    just for the linking stage. The compilation of the object files happens automatically.
    Since the object files are a dependency, Make tries to figure out how to build
    them all on its own.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候更详细地讨论Makefile了。我们已经在之前的示例中看到了前两个变量`CC`和`CFLAGS`，但请注意，我们在代码中没有使用`CFLAGS`变量。我们不需要。在编译目标文件时，`CFLAGS`会自动应用。如果我们在`area`目标的命令中手动应用了`CC`变量后的`CFLAGS`变量，那些标志也会被用于链接过程。换句话说，我们为名为`area`的目标指定的命令只是用于链接阶段。目标文件的编译会自动发生。由于目标文件是一个依赖项，Make会尝试自行找出如何构建它们。
- en: When we run Make without specifying a target, Make will run the first target
    in the Makefile. That's the reason why we put the `area` target first in the file,
    so that when we simply type `make`, the program is built.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行Make而没有指定目标时，Make会运行Makefile中的第一个目标。这就是为什么我们将`area`目标放在文件中的第一位的原因，这样当我们简单地输入`make`时，程序就会被构建。
- en: Then, we have `LIBS=-lm`. This variable is added to the end of the `area` target
    to link against the math library, but do note that it is only the linker that
    makes use of this. Look at the output in *Step 8*. All the object files are compiled
    as usual, but at the last stage, when the linker assembles all the object files
    in to a single binary, `-lm` is added at the end.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`LIBS=-lm`。这个变量被添加到`area`目标的末尾，以链接到数学库，但请注意，只有链接器才会使用它。看一下*步骤8*中的输出。所有目标文件都像往常一样被编译，但在最后阶段，当链接器将所有目标文件组装成一个单一的二进制文件时，`-lm`被添加到末尾。
- en: 'Then, we have the following line:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有以下一行：
- en: '[PRE109]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This variable lists all the object files. This is where Make gets really smart.
    The first place where we use `OBJS` is the dependency for the `area` target. To
    put together the `area` binary program, we need all of the object files.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量列出了所有的目标文件。这就是Make变得非常智能的地方。我们第一次使用`OBJS`的地方是`area`目标的依赖项。为了组合`area`二进制程序，我们需要所有的目标文件。
- en: The next place where we use `OBJS` is in the build command for the `area` binary.
    Note that we don't specify the C files here, only the object files (via `OBJS`).
    Make is smart enough to figure out that to build the binary, we first need the
    object files, and to compile the object files, we need the C files with the same
    names as the object files. Therefore, we don't need to spell out the entire command
    with all the source code files. Make figures this out all on its own.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个使用`OBJS`的地方是`area`二进制构建命令。请注意，我们这里没有指定C文件，只有目标文件（通过`OBJS`）。Make足够智能，可以找出构建二进制文件所需的首先是目标文件，而要编译目标文件，我们需要与目标文件同名的C文件。因此，我们不需要详细列出包含所有源代码文件的整个命令。Make会自行找出这一切。
- en: 'The next new variable is `DEPS`. In this variable, we list the header file
    required to build the `area.o` object file. We specify this dependency on the
    `area.o: $(DEPS)` line. This target doesn''t contain any command; we just use
    it to verify the dependency.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '下一个新变量是`DEPS`。在这个变量中，我们列出了构建`area.o`目标文件所需的头文件。我们在`area.o: $(DEPS)`行上指定了这个依赖项。这个目标不包含任何命令；我们只是用它来验证依赖项。'
- en: The final variable is `bindir`, which contains the full path to where the binary
    file should be installed. This variable is used in the `install` and `uninstall`
    targets, which we will discuss next.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个变量是`bindir`，它包含了二进制文件应该安装的完整路径。这个变量在`install`和`uninstall`目标中使用，接下来我们将讨论这些目标。
- en: We have already covered the `area` and `area.o` targets in the discussion about
    variables. So, let's move on to the `clean`, `install`, and `uninstall` targets.
    These targets are common in most projects. It's considered good manners to include
    them. They have nothing to do with compiling and building the program, but they
    help the end user to install and uninstall the software on the system. The `clean`
    target helps the end user in keeping the source code directory clean from temporary
    files such as object files. The commands under each of these targets are typical
    Linux commands, combined with the variables we have already covered.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在关于变量的讨论中涵盖了`area`和`area.o`目标。所以，让我们继续讨论`clean`、`install`和`uninstall`目标。这些目标在大多数项目中都很常见。包含它们被认为是礼貌的。它们与编译和构建程序无关，但它们帮助最终用户在系统上安装和卸载软件。`clean`目标帮助最终用户保持源代码目录干净，不包含目标文件等临时文件。每个目标下的命令都是典型的Linux命令，结合了我们已经涵盖的变量。
- en: The `install` command used in the `install` target copies the `area` file to
    where `bindir` points (`/usr/local/bin` in our case). It also sets the user and
    group for the installed file.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`install`目标中使用的`install`命令将`area`文件复制到`bindir`指向的位置（在我们的例子中是`/usr/local/bin`）。它还为安装的文件设置用户和组。'
- en: Note that we have specified dependencies for the `install` and `uninstall` targets
    (the dependency is the file that is to be installed or removed). This makes sense;
    there is no need to run these commands if the file doesn't exist. But for the
    `clean` target, we didn't specify any dependency. It could happen that the user
    has already deleted *some* of the object files themself. When they run `make clean`,
    they don't want the entire target to fail but to continue removing any leftover
    files.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经为`install`和`uninstall`目标指定了依赖项（依赖项是要安装或移除的文件）。这是有道理的；如果文件不存在，就没有必要运行这些命令。但对于`clean`目标，我们没有指定任何依赖关系。用户可能已经自己删除了*一些*目标文件。当他们运行`make
    clean`时，他们不希望整个目标失败，而是希望继续删除任何剩余的文件。
