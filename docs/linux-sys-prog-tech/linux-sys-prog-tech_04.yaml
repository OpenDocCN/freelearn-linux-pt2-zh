- en: '*Chapter 4*: Handling Errors in Your Programs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：处理程序中的错误'
- en: In this chapter, we will learn about **error handling** in C programs in Linux—specifically,
    how to catch errors and print relevant information about them. We will also learn
    how to incorporate this knowledge with what we have previously learned about **stdin**,
    **stdout**, and **stderr**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习在Linux中的C程序中的**错误处理**，具体来说是如何捕获错误并打印相关信息。我们还将学习如何将这些知识与我们之前学到的关于**stdin**、**stdout**和**stderr**的知识结合起来。
- en: We will continue on the path of system calls and learn about a particular variable
    called **errno**. Most system calls use this variable to save specific error values
    when an error occurs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续学习系统调用的路径，并了解一个特定的变量称为**errno**。大多数系统调用在发生错误时使用这个变量保存特定的错误值。
- en: Handling errors in your programs will make them more stable. Errors do occur;
    it's just a matter of handling them correctly. A well-handled error does not seem
    like an error to the end user. For example, instead of letting your program crash
    in some mysterious way when the hard drive is filled, it's better to catch the
    error and print a human-readable and friendly message about it. That way, it merely
    appears as information to the end user and not an error. That, in turn, will make
    your programs seem friendlier and, most of all, more stable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中处理错误将使它们更加稳定。错误确实会发生；只是要正确处理它们。一个良好处理的错误对最终用户来说不会看起来像是错误。例如，不要让你的程序在硬盘已满时以某种神秘的方式崩溃，最好是捕获错误并打印一个人类可读且友好的消息。这样，对最终用户来说，它只是信息而不是错误。这反过来会使你的程序看起来更友好，最重要的是更加稳定。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Why error handling is important in system programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么错误处理在系统编程中很重要
- en: Handling some common errors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理一些常见错误
- en: Error handling and `errno`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理和`errno`
- en: Handling more `errno` macros
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理更多的`errno`宏
- en: Using `errno` with `strerror()`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`strerror()`和`errno`
- en: Using errno with `perror()`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`perror()`和`errno`
- en: Returning an error value
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个错误值
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need the GCC compiler, the Make tool, and all the manual
    pages (dev and POSIX) installed. We covered how to install GCC and Make in [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*, Getting the Necessary Tools
    and Writing Our First Linux Programs*, and the manual pages in [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*,
    Diving Deep into C in Linux*. You will also need the generic Makefile that we
    created in [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*, Diving
    Deep into C in Linux*. Place that file in the same directory as the code you are
    writing for this chapter. You'll find a copy of that file—along with all other
    source code files we will write here—in the GitHub folder for this chapter, at
    [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch4](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch4).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你将需要GCC编译器、Make工具以及所有手册页（dev和POSIX）已安装。我们在[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*中介绍了如何安装GCC和Make，以及在[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*中介绍了手册页*，深入Linux中的C*。你还需要我们在[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*中创建的通用Makefile。将该文件放在你为本章编写代码的同一目录中。你将在GitHub文件夹中找到该文件的副本，以及我们在这里编写的所有其他源代码文件，网址为[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch4](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch4)。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/39rJIdQ](https://bit.ly/39rJIdQ)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 点击以下链接查看代码演示视频：[https://bit.ly/39rJIdQ](https://bit.ly/39rJIdQ)
- en: Why error handling is important in system programming
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么错误处理在系统编程中很重要
- en: 'This recipe is a short introduction to what error handling is. We will also
    see an example of a common error: *insufficient access rights*. Knowing these
    basic skills will make you a better programmer in the long run.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱是对错误处理是什么的一个简短介绍。我们还将看到一个常见错误的例子：*权限不足*。掌握这些基本技能将使你在长远的道路上成为一个更好的程序员。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll only need the GCC compiler, preferably installed via
    the meta-package or group install, as we covered in [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*,
    Getting the Necessary Tools and Writing Our First Linux Programs*. Make sure that
    the Makefile mentioned in the *Technical requirements* section is placed in the
    same directory as the source code for this recipe.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你只需要GCC编译器，最好是通过元包或组安装，就像我们在[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*中介绍的那样，获取必要的工具并编写我们的第一个Linux程序。确保在本食谱的源代码所在的同一目录中放置*技术要求*部分提到的Makefile。
- en: How to do it…
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to explore a common error and how to handle it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤来探索一个常见错误以及如何处理它：
- en: 'First, we will write the program without any `simple-touch-v1.c`. The program
    will create an empty file that the user specifies as an argument. The `PATH_MAX`
    macro is new to us. It contains the maximum number of characters we can use in
    a path on our Linux system. It''s defined in the `linux/limits.h` header file:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将编写没有任何`simple-touch-v1.c`的程序。该程序将创建一个用户指定的空文件作为参数。`PATH_MAX`宏对我们来说是新的。它包含我们在Linux系统上可以在路径中使用的最大字符数。它在`linux/limits.h`头文件中定义：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Compile the program:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s try to run the program and see what happens. If we don''t give
    it any arguments, it will print an error message and return `1`. When we give
    it a file that doesn''t exist, it will create it with the permissions 644 (we''ll
    cover permissions in the next chapter):'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试运行程序并看看会发生什么。如果我们不给它任何参数，它将打印一个错误消息并返回`1`。当我们给它一个不存在的文件时，它将以权限644创建它（我们将在下一章中介绍权限）：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s see what happens if we try to create a file outside of our home directory;
    that is, a directory where we don''t have write permissions:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如果我们尝试在我们的家目录之外创建一个文件会发生什么；也就是说，在一个我们没有写权限的目录：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This seems to have worked since it didn''t complain—but it hasn''t. Let''s
    try to check out the file:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这似乎已经起作用，因为它没有抱怨，但实际上并没有。让我们尝试检查文件：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s rewrite the file so that it prints an error message—*Couldn''t create
    file*—to stderr in case `creat()` fails to create a file. To accomplish this,
    we wrap the entire call to `creat()` in an `if` statement. Name the new version
    `simple-touch-v2.c`. The changes from the previous version are highlighted here:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重写文件，以便在`creat()`无法创建文件时向stderr打印错误消息——*无法创建文件*。为了实现这一点，我们将整个对`creat()`的调用包装在一个`if`语句中。将新版本命名为`simple-touch-v2.c`。与上一个版本的更改在这里突出显示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Compile the new version:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译新版本：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, let''s rerun it, both with a file that we can create and one that
    we can''t. When we try to create a file that we don''t have permission to, we
    will get an error message stating *Couldn''t create file*:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们重新运行它，既使用我们可以创建的文件，又使用我们无法创建的文件。当我们尝试创建一个我们没有权限创建的文件时，我们将收到一个错误消息，指出*无法创建文件*：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we used a system call, `creat()`, that creates a file on the
    filesystem. The function takes two arguments: the first is the file to be created,
    while the second is which file access mode the newly created file shall have.
    In this case, we set the file''s `644`, which is read and write for the user who
    owns the file, and read for the owner''s group and all others. We will cover file
    access modes in more depth in [*Chapter 5*](B13043_05_Final_SK_ePub.xhtml#_idTextAnchor182)*,
    Working with File I/O and Filesystem Operations*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了一个系统调用`creat()`，它在文件系统上创建一个文件。该函数有两个参数：第一个是要创建的文件，第二个是新创建的文件应该具有的文件访问模式。在这种情况下，我们设置了文件的`644`，这是用户拥有文件的读写权限，对所有者的组和其他所有人的读权限。我们将在[*第5章*](B13043_05_Final_SK_ePub.xhtml#_idTextAnchor182)*，使用文件I/O和文件系统操作*中更深入地介绍文件访问模式。
- en: Nothing "bad" will happen if it can't create the file we ask it to create. It
    just returns -1 to the calling function (`main()` in this case). This means that
    in the first version of our program, it seems like everything has worked just
    fine and that the file has been created when, in fact, it hasn't. It's up to us,
    as programmers, to catch that return code and act on it. We can find the return
    values of the function in its manual page, `man 2 creat`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它无法创建我们要求创建的文件，不会发生任何“坏事”。它只是将-1返回给调用函数（在这种情况下是`main()`）。这意味着在我们的程序的第一个版本中，似乎一切都很顺利，文件已经创建了，而实际上并没有。作为程序员，我们需要捕获返回代码并对其进行操作。我们可以在函数的手册页`man
    2 creat`中找到函数的返回值。
- en: In the second version of the program, we added an `if` statement to check for
    -1\. If the function returns -1, an error message is printed to stderr, and 1
    is returned to the shell. We have now informed both the user and any programs
    that might depend on this program to create a file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的第二个版本中，我们添加了一个`if`语句来检查-1。如果函数返回-1，则会向stderr打印错误消息，并返回1给shell。我们现在已经通知了用户和可能依赖于该程序来创建文件的任何程序。
- en: Fetching the return values of functions is the most common—and most straightforward—way
    to check for errors. We should all make this a habit. As soon as we use some function,
    we should check its return value (as long as it's reasonable, of course).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 获取函数的返回值是检查错误的最常见和最直接的方法。我们都应该养成这个习惯。一旦我们使用了某个函数，我们就应该检查它的返回值（当然，只要合理）。
- en: Handling some common errors
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理一些常见的错误
- en: In this recipe, we will look at some common errors we can handle. Knowing what
    errors to look for is step one of mastering error handling. A police officer can't
    catch the bad guys if they don't know which crimes to look for.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看一些常见的错误，我们可以处理。知道要寻找哪些错误是掌握错误处理的第一步。如果警察不知道要寻找哪些犯罪，他们就无法抓到坏人。
- en: We will look at both errors that can occur due to resource limitations on a
    computer, permission errors, and mathematical errors. It's important to remember,
    though, that most functions return a special value (often -1 or some predefined
    value) when errors occur. The actual data is returned when no errors occur.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看由于计算机资源限制、权限错误和数学错误可能发生的错误。但重要的是要记住，大多数函数在发生错误时会返回一个特殊值（通常是-1或一些预定义的值）。当没有错误发生时，实际数据被返回。
- en: We will also briefly touch on the subject of handling buffer overflows. Buffer
    overflows are a vast subject that deserves a book of its own, but some short examples
    can help.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将简要涉及处理缓冲区溢出的主题。缓冲区溢出是一个值得一本书的广泛主题，但一些简短的例子可以帮助。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll write shorter code samples and compile them with GCC and
    Make. We'll also read some man pages from the *POSIX Programmer's Manual*. If
    you are using Debian or Ubuntu, you have to install these manual pages first,
    which we did in the *Getting information about Linux- and Unix-specific header
    files* section of [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*,
    Diving Deep into C in Linux*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写更短的代码示例，并使用GCC和Make进行编译。我们还将阅读*POSIX程序员手册*中的一些man页面。如果您使用的是Debian或Ubuntu，您必须首先安装这些手册页面，我们在[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*，深入Linux中的C*中的*获取有关Linux和Unix特定头文件的信息*部分中已经安装了这些手册页面。
- en: How to do it…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The easiest way to find errors that are most likely to occur when using a specific
    function is to read the **RETURN VALUE** section of the function''s manual page.
    Here, we will look at some examples:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 查找使用特定函数时最有可能发生的错误的最简单方法是阅读函数手册页的**返回值**部分。在这里，我们将看一些例子：
- en: Most `creat()`, `open()`, and `write()`. Look under the `errno` with more specific
    information. We will cover `errno` later in this chapter.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数`creat()`、`open()`和`write()`。查看`errno`以获取更具体的信息。我们将在本章后面介绍`errno`。
- en: 'Now, take a look at the manual page for the power function, `pow()`. Scroll
    down to the `pow()` function returns the answer to a calculation, it can''t return
    0 or -1 if an error occurs; this could be the answer to some calculation. Instead,
    some special numbers are defined that are referred to as `HUGE_VAL`, `HUGE_VALF`,
    and `HUGE_VALL`. On most systems, though, these are defined as infinity. However,
    we can still use these macros to test for them, as shown in the following example.
    Name the file `huge-test.c`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，查看幂函数`pow()`的手册页面。滚动到`pow()`函数返回计算的答案，如果出现错误，它不能返回0或-1；这可能是某些计算的答案。相反，定义了一些特殊的数字，称为`HUGE_VAL`、`HUGE_VALF`和`HUGE_VALL`。但是，在大多数系统中，这些被定义为无穷大。然而，我们仍然可以使用这些宏来进行测试，如下例所示。将文件命名为`huge-test.c`：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Compile the program and test it. Remember to link to the `math` library with
    `-lm`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序并测试它。记得链接到`math`库使用`-lm`：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Other errors that can occur that don''t give us return values are mostly overflow
    errors. This is especially true when handling `strcat()` has `strncat()`, `strdup()`
    has `strndup()`, and so on. Use these whenever possible. Write the following program
    and name it `str-unsafe.c`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他可能发生的错误，不会给我们返回值的大多是溢出错误。这在处理`strcat()`、`strncat()`、`strdup()`等函数时尤其如此。尽可能使用这些函数。编写以下程序并将其命名为`str-unsafe.c`：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, compile it using Make (and the Makefile that we have placed in this directory).
    Notice that we will get a warning from the compiler here since we aren''t using
    the `argc` variable. This warning comes from the `-Wextra` option to GCC. However,
    this is just a warning stating that we never used `argc` in our code, so we can
    ignore this message. Always read the warning messages; sometimes, things may be
    more severe:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用Make（以及我们放在此目录中的Makefile）编译它。请注意，我们将从编译器这里得到一个警告，因为我们没有使用`argc`变量。这个警告来自于GCC的`-Wextra`选项。然而，这只是一个警告，说明我们在代码中从未使用过`argc`，所以我们可以忽略这条消息。始终阅读警告消息；有时，事情可能更严重：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, test this with different input lengths. If we don''t provide any input
    at all or if we give it too much input (more than 9 characters), a segmentation
    fault will occur:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用不同的输入长度来测试。如果我们根本不提供任何输入，或者提供太多的输入（超过9个字符），就会发生分段错误：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s rewrite the program. First, we must make sure the user typed in an argument;
    second, we must replace `strcat()` with `strncat()`. Name the new version `str-safe.c`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重写程序。首先，我们必须确保用户输入了一个参数；其次，我们必须用`strncat()`替换`strcat()`。将新版本命名为`str-safe.c`：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compile it. This time, we won''t get a warning about `argc` since we''re using
    it in the code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译它。这次，我们不会收到关于`argc`的警告，因为我们在代码中使用了它：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s run it with various input lengths. Notice how the long text gets cut
    off at the ninth character, preventing a segmentation fault. Also, note that we
    have handled the segmentation fault on an empty input by requiring precisely one
    argument:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用不同的输入长度运行它。注意长文本在第九个字符处被截断，从而防止分段错误。还要注意，我们通过要求精确一个参数来处理空输入的分段错误：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *Step 2*, we looked at some manual pages to get a feel for what kind of errors
    we can expect to handle when dealing with them. Here, we learned that most system
    calls return -1 on errors and that most errors have something to do with either
    permissions or system resources.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，我们查看了一些手册页面，以了解在处理它们时可以期望处理什么样的错误。在这里，我们了解到大多数系统调用在出现错误时返回-1，并且大多数错误都与权限或系统资源有关。
- en: In *Steps 2* and *3*, we saw how math functions can return special numbers on
    errors (since the usual numbers—0, 1, and -1—can be valid answers to a calculation).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*和*3*中，我们看到数学函数在出现错误时可以返回特殊的数字（因为通常的数字——0、1和-1——可能是计算的有效答案）。
- en: In *Steps 4* to *9*, we briefly touched on the subject of handling user input
    and `strcat()`, `strcpy()`, and `strdup()` are unsafe since they copy whatever
    they get, even though the destination buffer doesn't have enough space for it.
    When we gave the program a string longer than 10 characters (nine actually, since
    the `NULL` character takes up one place), the program crashed with a *segmentation
    fault*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤4*至*9*中，我们简要涉及了处理用户输入和`strcat()`、`strcpy()`和`strdup()`是不安全的，因为它们复制它们得到的任何东西，即使目标缓冲区没有足够的空间。当我们给程序一个长于10个字符的字符串（实际上是九个，因为`NULL`字符占用一个位置）时，程序会崩溃并显示*分段错误*。
- en: These *str* functions have equivalent functions with *n* characters in their
    name; for example, `strncat()`. These functions only copy the size given to them
    as the third argument. In our example, we specified the size as `sizeof(buf)-1`,
    which in our program is 9\. The reason we used one less than the actual size of
    `buf` is to make room for the null-terminating character (`\0`) at the end. It's
    better to use `sizeof(buf)` than to use a literal number. If we would have used
    the literal number 9 here and then changed the size of the buffer to 5, we would
    most likely forget to update the number for `strncat()`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些*str*函数有相应的带有*n*字符的函数名称；例如，`strncat()`。这些函数只会复制作为第三个参数给定的大小。在我们的示例中，我们将大小指定为`sizeof(buf)-1`，在我们的程序中为9。我们使用比`buf`实际大小少一个的原因是为了为末尾的空终止字符(`\0`)腾出空间。最好使用`sizeof(buf)`而不是使用一个字面数。如果我们在这里使用了字面数9，然后将缓冲区的大小更改为5，我们很可能会忘记更新`strncat()`的数字。
- en: Error handling and errno
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理和errno
- en: Most of the system call functions in Linux and other UNIX-like systems set a
    special variable called `errno` variable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Linux和其他类UNIX系统中的大多数系统调用函数设置了一个名为`errno`的特殊变量。
- en: In this recipe, we'll learn what `errno` is, how to read values from it, and
    when it is set. We'll also see an example use case of `errno`. Learning about
    `errno` is imperative to system programming, primarily since it's used in conjunction
    with system calls.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习`errno`是什么，如何从中读取值，以及何时设置它。我们还将看到`errno`的一个示例用例。了解`errno`对于系统编程至关重要，主要是因为它与系统调用一起使用。
- en: The next few recipes in this chapter are closely tied to this recipe. In this
    recipe, we'll learn about `errno`; in the following three recipes, we'll learn
    how to interpret the error codes we get from `errno` and print human-readable
    error messages.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中接下来的几个食谱与本食谱密切相关。 在本食谱中，我们将学习关于`errno`；在接下来的三个食谱中，我们将学习如何解释我们从`errno`得到的错误代码并打印人类可读的错误消息。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll need the same components for this recipe that we used in the previous
    one; that is, the GCC compiler, the Make tool, and the *POSIX Programmer's Manual*,
    all of which we have already installed. If not, see [*Chapter 1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*,
    Getting the Necessary Tools and Writing Our First Linux Programs*, and the *Getting
    information about Linux- and UNIX-specific header files* section of [*Chapter
    3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*, Diving Deep into C in Linux*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要本食谱中与上一个食谱相同的组件；也就是说，我们已经安装的GCC编译器、Make工具和*POSIX程序员手册*。 如果没有，请参阅[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)*，获取必要的工具并编写我们的第一个Linux程序*，以及[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*，深入了解Linux中的C*中的*获取有关Linux和UNIX特定头文件的信息*部分。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll continue building on `simple-touch-v2.c` from the first
    recipe in this chapter. Here, we''ll extend it so that it prints some more useful
    information if it can''t create a file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将继续构建本章第一个食谱中的`simple-touch-v2.c`。 在这里，我们将扩展它，以便在无法创建文件时打印一些更有用的信息：
- en: 'Write the following code into a file and save it as `simple-touch-v3.c`. In
    this version, we''ll use the `errno` variable to check if the error is caused
    by a permission error (`EACCES`) or some other, unknown error. The changed code
    has been highlighted here:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入文件并保存为`simple-touch-v3.c`。 在这个版本中，我们将使用`errno`变量来检查错误是否是由权限错误（`EACCES`）或其他未知错误引起的。
    更改的代码已在这里突出显示：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s compile this version:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译这个版本：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, let''s run the new version. This time, the program gives us more information
    about what went wrong. If it''s a permission error, it will tell us that. Otherwise,
    it will print `Unknown error`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们运行新版本。 这一次，程序会给我们更多关于出错原因的信息。 如果是权限错误，它会告诉我们。 否则，它会打印“未知错误”：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The first difference we'll notice in this version is that we now include a header
    file called `errno.h`. This file is required if we wish to use the `errno` variable
    and the many error `EACCES`, which we used in our new version.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注意到这个版本的第一个区别是我们现在包括一个名为`errno.h`的头文件。 如果我们希望使用`errno`变量和我们在新版本中使用的许多错误`EACCES`，则需要此文件。
- en: The next difference is that we now use `sizeof(filename)-1` instead of `PATH_MAX-1`
    for the size argument to `strncpy()`. This was something we learned in the previous
    recipe.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个区别是，我们现在使用`sizeof(filename)-1`而不是`PATH_MAX-1`作为`strncpy()`的大小参数。 这是我们在上一个食谱中学到的东西。
- en: Then, we have the `if (errno == EACCES)` line, which checks the `errno` variable
    for `EACCES`. We can read about these macros, such as `EACCES`, in both `man errno.h`
    and `man 2 creat`. This particular macro means *permission denied*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`if (errno == EACCES)`行，它检查`errno`变量是否为`EACCES`。 我们可以在`man errno.h`和`man
    2 creat`中阅读关于这些宏的信息，比如`EACCES`。 这个特定的宏意味着*权限被拒绝*。
- en: When we use `errno`, we should first check the return value from the function
    or system call, as we did here with the `if` statement around `creat()`. The `errno`
    variable is just like any other variable, meaning that it isn't cleared after
    the system call. If we were to check `errno` directly, before checking the function's
    return value, `errno` could contain an error code from a previous error.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`errno`时，我们应该首先检查函数或系统调用的返回值，就像我们在这里使用`creat()`周围的`if`语句一样。 `errno`变量就像任何其他变量一样，这意味着在系统调用之后它不会被清除。
    如果我们在检查函数的返回值之前直接检查`errno`，`errno`可能包含来自先前错误的错误代码。
- en: In our version of `touch`, we only handle this specific error. Next, we have
    an `else` statement, which catches all other errors and prints an `Unknown error`
    message.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`touch`版本中，我们只处理了这个特定的错误。 接下来，我们有一个`else`语句，它捕获所有其他错误并打印一个“未知错误”消息。
- en: In *Step 3*, we generated an `Unknown error` message by trying to create a file
    in a directory that doesn't exist on our system. In the next recipe, we'll extend
    our program so that it can take more macros into account.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们通过尝试在我们系统上不存在的目录中创建文件来生成了一个“未知错误”消息。 在下一个食谱中，我们将扩展我们的程序，以便它可以考虑更多的宏。
- en: Handling more errno macros
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理更多的errno宏
- en: We'll continue to handle more `errno` macros in our version of `touch` in this
    recipe. In the previous recipe, we managed to provoke an `Unknown error` message
    since we only handled permission denied errors. Here, we'll find out what exactly
    caused that error and what it is called. We'll then implement another `if` statement
    to handle it. Knowing how to find the correct `errno` macros will help you gain
    a deeper understanding of computing, Linux, system calls, and error handling.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将继续处理我们的`touch`版本中的更多`errno`宏。 在上一个食谱中，我们设法引发了一个“未知错误”消息，因为我们只处理了权限被拒绝的错误。
    在这里，我们将找出到底是什么导致了那个错误以及它叫什么。 然后，我们将实现另一个`if`语句来处理它。 知道如何找到正确的`errno`宏将帮助您更深入地了解计算、Linux、系统调用和错误处理。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Once again, we'll examine the manual pages to find the information we are looking
    for. The only things that are needed for this recipe are the manual pages, the
    GCC compiler, and the Make tool.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将查看手册页面，找到我们正在寻找的信息。 这个食谱所需的唯一东西是手册页面，GCC编译器和Make工具。
- en: How to do it…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to complete this recipe:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成本食谱：
- en: Start by reading the manual page for `creat()` by using `man 2 creat`. Scroll
    down to the `ENOENT` (short for *Error No Entry*).
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先阅读`creat()`的手册页面，使用`man 2 creat`。 向下滚动到`ENOENT`（缩写为*错误无条目*）。
- en: 'Let''s implement a new `if` statement that handles `ENOENT`. Name the new version
    `simple-touch-v4.c`. The complete program is as follows. The changes from the
    previous version are highlighted here. Also, note that we have removed the brackets
    for some of the `if` statements in the highlighted code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现一个新的`if`语句来处理`ENOENT`。将新版本命名为`simple-touch-v4.c`。完整的程序如下。以下是与上一个版本的更改。还要注意，我们已经删除了突出显示的代码中一些`if`语句的括号：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Compile the new version:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译新版本：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s run it and generate some errors. This time, it will print an error message
    when the directory does not exist:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行它并生成一些错误。这次，当目录不存在时，它将打印出一个错误消息：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this version, I removed the brackets from the inner `if`, `else if`, and
    `else` statements to save space. This is valid code if there is only one statement
    under each of the `if`, `else if`, and `else`. However, this is potentially dangerous
    since it's easy to make a mistake. If we were to write more statements in one
    of the `if` statements, those would not be a part of the `if` statement, even
    though it looks correct and compiles with no errors. The name for this is *misleading
    indentation*. The indentation fools the brain, thinking it's right.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我从内部的`if`、`else if`和`else`语句中删除了括号，以节省空间。如果每个`if`、`else if`和`else`下只有一个语句，这是有效的代码。然而，这样做可能是危险的，因为很容易出错。如果我们在其中一个`if`语句中写更多的语句，那些语句将不属于`if`语句，尽管看起来正确且没有错误编译。这种情况称为*误导性缩进*。缩进会让大脑误以为是正确的。
- en: The next new thing in the code is the `else if (errno == ENOENT)` line and the
    lines below it. This is where we handle the `ENOENT` error macro.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的新内容是`else if (errno == ENOENT)`行及其下面的行。这是我们处理`ENOENT`错误宏的地方。
- en: There's more…
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Almost all of the functions listed in `man 2 syscalls` set the `errno` variable.
    Take a look at some of the manual pages for these functions and scroll down to
    `errno` macros the different functions sets.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`man 2 syscalls`中列出的几乎所有函数都设置了`errno`变量。查看一些这些函数的手册页，并滚动到不同函数设置的`errno`宏。'
- en: Also, read `man errno.h`, which contains useful information about these macros.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 还要阅读`man errno.h`，其中包含有关这些宏的有用信息。
- en: Using errno with strerror()
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用errno和strerror()
- en: Instead of looking up every possible errno macro and figuring out which ones
    apply and what they mean, it's easier to use a function called `strerror()`. This
    function converts the `errno` code into a readable message. Using `strerror()`
    is much faster than implementing everything ourselves. It's a lot safer, too,
    since there's less of a risk that we mess something up. Whenever there's a function
    available to ease the manual work for us, we should use it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与查找每个可能的errno宏并弄清楚哪些适用以及它们的含义相比，使用一个名为`strerror()`的函数更容易。这个函数将`errno`代码转换为可读的消息。使用`strerror()`比自己实现所有内容要快得多。这样做也更安全，因为我们犯错的风险更小。每当有一个函数可以帮助我们减轻手动工作时，我们都应该使用它。
- en: Do note that this function is meant to convert the `errno` macro into a readable
    error message. If we want to handle a particular error in some specific way, we
    still need to use the actual `errno` value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个函数的目的是将`errno`宏转换为可读的错误消息。如果我们想以某种特定的方式处理特定的错误，我们仍然需要使用实际的`errno`值。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The requirements from the previous recipe apply to this recipe. This means we
    need the GCC compiler, the Make tool (along with the Makefile), and the manual
    pages.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个配方的要求也适用于这个配方。这意味着我们需要GCC编译器、Make工具（以及Makefile）和手册页。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll continue developing our own version of `touch`. We''ll
    continue from the previous version. This time, we will rewrite the `if` statements
    we made for the different macros and use `strerror()` instead. Let''s get started:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将继续开发我们自己的`touch`版本。我们将从上一个版本继续。这次，我们将重写我们为不同的宏制作的`if`语句，并使用`strerror()`代替。让我们开始吧：
- en: 'Write the following code and save it as `simple-touch-v5.c`. Notice how the
    code has been smaller now that we have replaced the `if` statements with `strerror()`.
    This version is much cleaner. The changes from the previous version are highlighted
    here:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码，并将其保存为`simple-touch-v5.c`。注意，现在代码已经变得更小，因为我们用`strerror()`替换了`if`语句。这个版本更加清晰。以下是与上一个版本的更改：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Compile this new version:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译这个新版本：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s try it out. Notice how the program now prints error messages describing
    what has gone wrong. We didn''t even have to check the `errno` variable against
    possible errors:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们试一下。注意程序现在打印出描述出了什么问题的错误消息。我们甚至不需要检查`errno`变量是否存在可能的错误：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'All the `if`, `else if`, and `else` statements have now been replaced with
    a single line of code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`if`、`else if`和`else`语句现在都被一行代码替换了：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have also saved the value from `errno` in a new variable called `errornum`.
    We did this because on the next error that occurs, the value in `errno` will be
    overwritten by the new error code. To safeguard against showing the wrong error
    message in case `errno` gets overwritten, it's safer to save it to a new variable.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`errno`的值保存在一个名为`errornum`的新变量中。我们这样做是因为在下一个发生错误时，`errno`中的值将被新的错误代码覆盖。为了防止在`errno`被覆盖时显示错误的消息，将其保存到一个新变量中更安全。
- en: We then used the error code stored in `errornum` as an argument to a new function
    called `strerror()`. This function translates the error code into a human-readable
    error message and returns that message as a string. That way, we don't have to
    create `if` statements ourselves for every possible error that can occur.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用存储在`errornum`中的错误代码作为`strerror()`的参数。这个函数将错误代码转换为可读的错误消息，并将该消息作为字符串返回。这样，我们就不必为可能发生的每个错误创建`if`语句。
- en: In *Step 3*, we saw how `strerror()` had translated the `EACCES` macros into
    *Permission denied*, and `ENOENT` into *No such file or directory*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中，我们看到`strerror()`如何将`EACCES`宏翻译成*Permission denied*，将`ENOENT`翻译成*No such
    file or directory*。
- en: There's more…
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the `man 3 strerror` manual page, you'll find a similar function that can
    print error messages in the user's preferred locale.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在`man 3 strerror`手册页面中，您会找到一个类似的函数，可以以用户首选的语言打印错误消息。
- en: Using errno with perror()
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用perror()和errno
- en: In the previous recipe, we used `strerror()` to get a string containing a human-readable
    error message from `errno`. There's another function similar to `strerr()` called
    `perror()`. Its name stands for **print error**, and that's what it does; it prints
    the error message directly to *stderr*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个步骤中，我们使用`strerror()`从`errno`获取包含人类可读错误消息的字符串。还有一个类似于`strerr()`的函数叫做`perror()`。它的名字代表**打印错误**，这就是它的作用；它直接将错误消息打印到*stderr*。
- en: In this recipe, we'll write the sixth version of our simple touch program. This
    time, we'll replace both of the `fprinf()` lines with `perror()`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将编写我们的simple touch程序的第六个版本。这次，我们将用`perror()`替换两个`fprintf()`行。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The only programs necessary for this recipe are the GCC compiler and the Make
    tool (along with the generic Makefile).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤所需的程序只有GCC编译器和Make工具（以及通用的Makefile）。
- en: How to do it…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to create an even shorter and better version of `simple-touch`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个更短更好的`simple-touch`版本：
- en: 'Write the following code into a file and save it as `simple-touch-v6.c`. This
    time, the program is even smaller. We have removed the two `fprintf()` statements
    and replaced them with `perror()` instead. The changes from the previous version
    are highlighted here:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入文件并保存为`simple-touch-v6.c`。这次，程序更小了。我们删除了两个`fprintf()`语句，并用`perror()`替换了它们。与上一个版本相比的变化在这里突出显示：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Compile it using Make:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Make编译它：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run it and witness the change in the error message''s output:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行并观察错误消息输出的变化：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This time, we have replaced both the `fprintf()` lines with a single line:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们用一行替换了两个`fprintf()`行：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `perror()` function takes one argument, a string with a description or function
    name. In this case, I chose to give it the generic error message `Can't create
    file`. When `perror()`prints the error message, it grabs the last error code in
    `errno` (notice we didn't specify any error code variable) and applies that error
    message after the text `Can't create file`. Hence, we don't need the `fprintf()`
    lines anymore.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`perror()`函数接受一个参数，一个包含描述或函数名称的字符串。在这种情况下，我选择给它一个通用的错误消息`无法创建文件`。当`perror()`打印错误消息时，它会抓取`errno`中的最后一个错误代码（注意我们没有指定任何错误代码变量），并在文本`无法创建文件`之后应用该错误消息。因此，我们不再需要`fprintf()`行。'
- en: Even though `errno` isn't explicitly stated in the call to `perror()`, it still
    uses it. If another error occurs, then the next call to `perror()` will print
    that error message instead. The `perror()` function always prints the *last* error.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在调用`perror()`时没有明确说明`errno`，但它仍然使用它。如果发生另一个错误，那么下一次调用`perror()`将打印该错误消息。`perror()`函数总是打印*最后*的错误。
- en: There's more…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: There are some great tips in the manual page, `man 3 perror`. For example, it's
    a good idea to include the name of the function that caused the error. This makes
    it easier to debug the program when users are reporting bugs.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 手册页面`man 3 perror`中有一些很好的提示。例如，包含导致错误的函数名称是个好主意。这样在用户报告错误时更容易调试程序。
- en: Returning an error value
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回错误值
- en: Even though human-readable error messages are important, we must not forget
    to return a value to the shell that indicates an error. We have already seen that
    returning 0 means that everything is okay, while returning something else (most
    of the time, 1) means that some kind of error did occur. However, we can return
    more specific values if we want so that other programs relying on our program
    can read those numbers. For example, we can actually return the `errno` variable
    since it is just an integer. All the macros we have seen, such as `EACCES` and
    `ENOENT`, are integers (13 and 2 for `EACCES` and `ENOENT`, respectively).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可读的错误消息很重要，但我们不能忘记返回一个指示错误的值给shell。我们已经知道返回0表示一切正常，而返回其他值（大多数情况下是1）表示发生了某种错误。然而，如果需要，我们可以返回更具体的值，以便依赖我们程序的其他程序可以读取这些数字。例如，我们实际上可以返回`errno`变量，因为它只是一个整数。我们已经看到的所有宏，如`EACCES`和`ENOENT`，都是整数（分别为`EACCES`和`ENOENT`的13和2）。
- en: In this recipe, we will learn how to return the `errno` numbers to the shell
    to provide more specific information.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将学习如何将`errno`数字返回给shell，以提供更具体的信息。
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The same set of programs mentioned in the previous recipe apply to this recipe.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个步骤提到的相同的程序集适用于这个步骤。
- en: How to do it…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will make the seventh version of our `simple-touch` program.
    Let''s get started:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将制作我们的`simple-touch`程序的第七个版本。让我们开始吧：
- en: 'We are only going to change a single line in this version from the previous
    one. Open up `simple-touch-v6.c` and change the `return` statement just below
    the `perror()` line to `return errno;`. Save the new file as `simple-touch-v7.c`.
    The latest version is as follows, with the changed line highlighted:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个版本中，我们只会改变一个单独的行。打开`simple-touch-v6.c`，将`perror()`行下面的`return`语句改为`return
    errno;`。将新文件保存为`simple-touch-v7.c`。最新版本如下，突出显示了更改的行：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Compile the new version:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译新版本：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run it and check the exit codes:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行并检查退出代码：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The error macros defined in `errno.h` are regular integers. So, if we, for example,
    return `EACCES`, we return the number 13\. So, what is happening here (when an
    error occurs) is that, first, `errno` is set behind the scenes. Then, `perror()`
    uses the value stored in `errno` to print a human-readable error message. Finally,
    the program returns to the shell with the integer stored in `errno`, indicating
    to other programs what went wrong. We should be a bit careful with this, though,
    since there are some reserved return values. For example, in the shell, the return
    value `2` often means *Missuse of shell builtins*. However, in `errno`, the return
    value `2` means *No such file or directory* (`ENOENT`). This shouldn't cause you
    too much trouble, but keep it in mind just in case.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`errno.h`中定义的错误宏是常规整数。因此，例如，如果我们返回`EACCES`，我们返回数字13。因此，在发生错误时，首先在幕后设置了`errno`。然后，`perror()`使用存储在`errno`中的值打印人类可读的错误消息。最后，程序返回到shell，并使用存储在`errno`中的整数指示其他程序出了什么问题。不过，我们应该对此略加小心，因为有一些保留的返回值。例如，在shell中，返回值`2`通常表示*Missuse
    of shell builtins*。但是，在`errno`中，返回值`2`表示*No such file or directory* (`ENOENT`)。这不应该给您带来太多麻烦，但以防万一请记住这一点。
- en: There's more…
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is a small program called `errno` that can print all macros and their
    integers. This tool isn't installed by default, though. The name of the package
    is `moreutils`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`errno`的小程序，可以打印所有宏及其整数。不过，默认情况下并未安装此工具。软件包的名称是`moreutils`。
- en: Once installed, you can print a list of all the macros by running the `errno
    -l` command, where the `l` option stands for *list*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以通过运行`errno -l`命令打印所有宏的列表，其中`l`选项代表*list*。
- en: To install the package in *Debian* and *Ubuntu*, type `apt install moreutils`
    as root.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Debian*和*Ubuntu*中安装软件包，作为root用户输入`apt install moreutils`。
- en: To install the package in *Fedora*, use `dnf install moreutils` as root.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Fedora*中安装软件包，请以root身份使用`dnf install moreutils`。
- en: On *CentOS* and *Red Hat*, you must first add the `epel-release` repository
    with `dnf install epel-release`, then install the package with `dnf install moreutils`
    as root. At the time of writing, there are some dependency issues with CentOS
    8 regarding `moreutils`, so it might not work.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在*CentOS*和*Red Hat*中，您必须首先使用`dnf install epel-release`添加`epel-release`存储库，然后以root身份使用`dnf
    install moreutils`安装软件包。在撰写本文时，关于CentOS 8存在一些关于`moreutils`的依赖性问题，因此可能无法正常工作。
