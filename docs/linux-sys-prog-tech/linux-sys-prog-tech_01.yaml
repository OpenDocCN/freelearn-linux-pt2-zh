- en: '*Chapter 1*: Getting the Necessary Tools and Writing Our First Linux Programs'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：获取必要的工具并编写我们的第一个Linux程序'
- en: In this chapter, we'll install the necessary tools on our Linux system, such
    as **GCC**, **GNU Make**, **GDB**, and **Valgrind**. We'll also try them out and
    see how they work. Knowing how to use these tools is the key to being a fast and
    efficient developer. We'll then write our first programs—Linux style. By understanding
    the different parts of a **C program**, you can easily interact with the rest
    of the system in a best practice manner. After that, we'll learn how to use the
    built-in manual pages (**man pages** for short) to look up **commands**, **libraries**,
    and **system calls**—a skill that we'll need a lot throughout this book. Knowing
    how to look up things in the relevant built-in manual page is often much faster—and
    more precise—than searching the internet for answers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在我们的Linux系统上安装必要的工具，如GCC，GNU Make，GDB和Valgrind。我们还将尝试它们，并看看它们是如何工作的。知道如何使用这些工具是成为快速高效的开发人员的关键。然后，我们将编写我们的第一个程序——Linux风格。通过了解C程序的不同部分，您可以以最佳实践方式轻松地与系统的其余部分进行交互。之后，我们将学习如何使用内置手册页（简称man页）查找命令、库和系统调用——这是我们在整本书中需要大量使用的技能。知道如何在相关的内置手册页中查找信息通常比在互联网上搜索答案更快、更精确。
- en: 'In this chapter, we are going to cover the following recipes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Installing GCC and GNU Make
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装GCC和GNU Make
- en: Installing GDB and Valgrind
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装GDB和Valgrind
- en: Writing a simple C program for Linux
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Linux编写一个简单的C程序
- en: Writing a program that parses command-line options
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个解析命令行选项的程序
- en: Looking up information in the built-in manual pages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内置手册页中查找信息
- en: Searching the manual for information
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索手册以获取信息
- en: Let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need a computer with Linux already set up. It doesn't
    matter if it's a local machine or a remote machine. The particular distribution
    you use doesn't matter much either. We'll look at how to install the necessary
    programs in **Debian**-based distributions, as well as **Fedora**-based distributions.
    Most of the major Linux distributions are either Debian-based or Fedora-based.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章，您需要一台已经设置好Linux的计算机。无论是本地机器还是远程机器都没关系。您使用的特定发行版也不太重要。我们将看看如何在基于Debian的发行版以及基于Fedora的发行版中安装必要的程序。大多数主要的Linux发行版要么是基于Debian的，要么是基于Fedora的。
- en: You'll also be using a `vi` and `nano`, and they are available pretty much everywhere.
    We won't cover how to use a text editor in this book, though.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将使用`vi`和`nano`，它们几乎在任何地方都可以使用。不过在本书中我们不会介绍如何使用文本编辑器。
- en: The C files for this chapter can be downloaded from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques](https://github.com/PacktPublishing/Linux-System-Programming-Techniques),
    under the `ch1` directory. The filenames on GitHub correspond to the filenames
    in this book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的C文件可以从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques](https://github.com/PacktPublishing/Linux-System-Programming-Techniques)的`ch1`目录中下载。GitHub上的文件名对应本书中的文件名。
- en: 'You can also clone the entire repository to your computer. The files for this
    chapter are in the `ch1` Directory. You clone the repository with the following
    command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将整个存储库克隆到您的计算机上。本章的文件位于`ch1`目录中。您可以使用以下命令克隆存储库：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you don't have Git installed on your computer, you will need to follow some
    installation instructions, depending on your distribution.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机上没有安装Git，您将需要根据您的发行版遵循一些安装说明。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3wdEoV6](https://bit.ly/3wdEoV6)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以查看“代码实战”视频：[https://bit.ly/3wdEoV6](https://bit.ly/3wdEoV6)
- en: Installing Git to download the code repository
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Git以下载代码存储库
- en: Installing Git is only necessary if you want to clone (download) the entire
    code repository for this book to your computer. The steps listed here assume that
    your user has `sudo` privileges. If this isn't the case, you can run `su` first
    to switch to the root user and skip `sudo` (assuming you know the root password).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在您想要克隆（下载）整个代码存储库到您的计算机上时，才需要安装Git。这里列出的步骤假定您的用户具有`sudo`权限。如果不是这种情况，您可以首先运行`su`切换到root用户，然后跳过`sudo`（假设您知道root密码）。
- en: Debian-based distributions
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Debian的发行版
- en: 'These instructions work for most Debian-based distributions, such as Ubuntu:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些说明适用于大多数基于Debian的发行版，如Ubuntu：
- en: 'First, update the repository cache:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，更新存储库缓存：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, install Git using `apt`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用`apt`安装Git：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Fedora-based distributions
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Fedora的发行版
- en: 'This instruction work for all newer Fedora-based distributions, such as CentOS
    and Red Hat (if you are using an old version, you might need to replace `dnf`
    with `yum`):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些说明适用于所有较新的基于Fedora的发行版，如CentOS和Red Hat（如果您使用的是旧版本，您可能需要用`yum`替换`dnf`）：
- en: 'Install the Git package using `dnf`:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dnf`安装Git包：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Installing GCC and GNU Make
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装GCC和GNU Make
- en: In this section, we will install the essential tools that we'll need throughout
    this book; namely, GCC, the compiler. It's the **compiler** that turns the **C
    source code** into a **binary program** that we can run on the system. All the
    C code that we write will need to be compiled.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装本书中将需要的基本工具；即，编译器GCC。它是将C源代码转换为可以在系统上运行的二进制程序的**编译器**。我们编写的所有C代码都需要编译。
- en: We'll also install GNU Make, a tool that we'll be using later on to automate
    how projects containing more than one source file are compiled.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将安装GNU Make，这是一个我们以后将用来自动化包含多个源文件的项目编译的工具。
- en: Getting ready
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: Since we are installing software on the system, we'll need to be using either
    the `sudo` privileges. I will be using `sudo` in this recipe, but if you are on
    a system without `sudo`, you can switch to the root user with `su` before entering
    the commands (and then leave out `sudo`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们要在系统上安装软件，我们需要使用`sudo`权限。在本教程中，我将使用`sudo`，但如果您在没有`sudo`的系统上，您可以在输入命令之前切换到root用户使用`su`（然后省略`sudo`）。
- en: How to do it…
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We will be installing what is called a meta-package or a group, a package that
    contains a collection of other packages. This meta-package includes both GCC,
    GNU Make, several manual pages, and other programs and libraries, which are nice
    to have when we're developing.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装一个称为元包或组的软件包，该软件包包含其他软件包的集合。这个元包包括GCC、GNU Make、几个手册页面和其他在开发时很有用的程序和库。
- en: Debian-based systems
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Debian的系统
- en: 'These steps work for all Debian-based systems, such as Debian, **Ubuntu**,
    and **Linux Mint**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤适用于所有基于Debian的系统，如Debian、**Ubuntu**和**Linux Mint**：
- en: 'Update the repository cache to get the latest version in the next step:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新存储库缓存，以在下一步中获取最新版本：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Install the `build-essential` package, and answer `y` when prompted:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`build-essential`软件包，并在提示时回答`y`：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Fedora-based systems
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Fedora的系统
- en: 'This works for all Fedora-based systems, such as Fedora, **CentOS**, and **Red
    Hat**:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这对所有基于Fedora的系统都适用，如Fedora、**CentOS**和**Red Hat**：
- en: 'Install a software group called *Development Tools*:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装一个名为*Development Tools*的软件组：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Verify the installation (both Debian and Fedora)
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证安装（Debian和Fedora）
- en: 'These steps are the same for both Debian and Fedora:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤对Debian和Fedora都适用：
- en: 'Verify the installation by listing the versions installed. Note that the exact
    versions will differ from system to system; this is normal:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过列出安装的版本来验证安装。请注意，确切的版本会因系统而异；这是正常的：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, it''s time to try out the GCC compiler by compiling a minimal C program.
    Please type the source code into an editor and save it as `first-example.c`. The
    program will print the text "Hello, world!" on the Terminal:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候尝试使用GCC编译器编译一个最小的C程序了。请将源代码输入编辑器并保存为`first-example.c`。该程序将在终端上打印文本“Hello,
    world!”：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, compile it using GCC. This command produces a file called `a.out`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用GCC编译它。这个命令会产生一个名为`a.out`的文件：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, let''s try to run the program. To run a program in Linux that isn''t in
    the usual directories for binaries (`/bin`, `/sbin`, `/usr/bin,` and so on), you
    need to type the special`./` sequence before the filename. This executes the program
    from the current path:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试运行程序。在Linux中运行不在通常的二进制目录（`/bin`、`/sbin`、`/usr/bin`等）中的程序时，您需要在文件名前输入特殊的`./`序列。这会从当前路径执行程序：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, recompile the program. This time, we will specify a name for the program
    with the `-o` option (`-o` for *output*). This time, the program file will have
    the name `first-example`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重新编译程序。这次，我们将使用`-o`选项（`-o`代表*output*）指定程序的名称。这次，程序文件将被命名为`first-example`：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s rerun the program, this time with the new name, `first-example`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重新运行程序，这次使用新名称`first-example`：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let''s try to compile it using Make instead:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用Make来编译它：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, rerun the program:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，重新运行程序：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Installing software on the system always requires root privileges, either via
    a regular root user or via `sudo`. Ubuntu, for example, uses `sudo` and has the
    regular root user disabled. Debian, on the other hand, doesn't use `sudo` at all
    in the default installation. To use it, you have to set it up yourself.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统上安装软件始终需要root权限，可以通过常规root用户或`sudo`来获取。例如，Ubuntu使用`sudo`，并禁用了常规root用户。另一方面，Debian在默认安装中根本不使用`sudo`。要使用它，您必须自己设置。
- en: Debian and Ubuntu use the `apt-get update` command before installing the packages.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Debian和Ubuntu在安装软件包之前使用`apt-get update`命令。
- en: Fedora-based systems use the `dnf` on newer versions. If you are using an older
    version, you might need to replace `dnf` with `yum`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Fedora的系统在较新版本上使用`dnf`。如果您使用的是旧版本，可能需要用`yum`替换`dnf`。
- en: In both cases, we installed a group of packages that contain the utilities,
    manual pages, and compilers that we'll need throughout this book.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们安装了一组包，其中包含我们在本书中将需要的实用程序、手册页面和编译器。
- en: After the installation was complete, before trying to compile anything, we listed
    the GCC version and Make version.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，在尝试编译任何内容之前，我们列出了GCC版本和Make版本。
- en: Finally, we compiled a straightforward C program, first using GCC directly and
    then using Make. The first example with GCC produced a program with the name `a.out`,
    which stands for *assembler output*. That name has a long history and goes back
    to the first edition of Unix in 1971\. Even though the file format, `a.out`, isn't
    used anymore, the name still lives on today.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们编译了一个简单的C程序，首先直接使用GCC，然后使用Make。使用GCC的第一个示例生成了一个名为`a.out`的程序，它代表*assembler
    output*。这个名字有着悠久的历史，可以追溯到1971年Unix的第一版。尽管文件格式`a.out`不再使用，但这个名字今天仍然存在。
- en: Then, we specified a program name with the `-o` option, where `-o` stands for
    *output*. This produces a program with a name of our choosing. We gave the program
    the name `first-example`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`-o`选项指定了程序名称，其中`-o`代表*output*。这将生成一个我们选择的程序名称。我们给程序取名为`first-example`。
- en: When we used Make, we didn't need to type in the filename of the source code.
    We only wrote the name we wanted for the binary program produced by the compiler.
    The Make program is smart enough to figure out that the source code has the same
    filename but that it ends with `.c`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Make时，我们不需要输入源代码的文件名。我们只需写出编译器生成的二进制程序的名称。Make程序足够聪明，可以推断出源代码具有相同的文件名，但以`.c`结尾。
- en: When we executed the program, we ran it as `./first-example`. The `./` sequence
    tells the shell that we want to run the program from the current directory. If
    we leave out `./`, it won't `$PATH` variable—usually `/bin`, `/usr/bin`, `/sbin`,
    and `/usr/sbin`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行程序时，我们将其作为`./first-example`运行。`./`序列告诉shell我们要从当前目录运行程序。如果我们省略`./`，它将不会使用`$PATH`变量——通常是`/bin`、`/usr/bin`、`/sbin`和`/usr/sbin`。
- en: Installing GDB and Valgrind
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装GDB和Valgrind
- en: GDB and Valgrind are two useful **debugging** tools that we'll use later on
    in this book.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: GDB和Valgrind是两个有用的**调试**工具，我们将在本书中稍后使用。
- en: GDB is the GNU debugger, a tool that we can use to step through a program and
    see what's happening inside it. We can watch over variables, see how they change
    during runtime, set breakpoints where we want the program to pause, and even change
    variables. **Bugs** are inevitable, but with GDB, we can find these bugs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: GDB是GNU调试器，这是一个我们可以用来逐步执行程序并查看其内部发生情况的工具。我们可以监视变量，查看它们在运行时如何变化，设置我们希望程序暂停的断点，甚至更改变量。错误是不可避免的，但是有了GDB，我们可以找到这些错误。
- en: Valgrind is also a tool we can use to find bugs, though it was made explicitly
    for finding **memory leaks**. Memory leaks can be challenging to find without
    a program such as Valgrind. Your program might work as expected for weeks, but
    then suddenly, things may start to go wrong. That's probably a memory leak.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Valgrind也是一个我们可以用来查找错误的工具，尽管它是专门用于查找内存泄漏的。没有像Valgrind这样的程序，内存泄漏可能很难找到。您的程序可能在几周内按预期工作，但突然之间，事情可能开始出错。这可能是内存泄漏。
- en: Knowing how to use these tools will make you a better developer and your programs
    more secure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何使用这些工具将使您成为更好的开发人员，使您的程序更加安全。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since we will be installing software here as well, we'll need to execute these
    commands with root privileges. If our system has a traditional root user, we can
    use that by switching to root with `su`. If we are on a system with `sudo`, and
    our regular user has administrative rights, you can use `sudo` to execute the
    commands instead. Here, I'll be using `sudo`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在这里安装软件，所以我们需要以root权限执行这些命令。如果我们的系统有传统的root用户，我们可以通过切换到root用户来使用`su`。如果我们在一个具有`sudo`的系统上，并且我们的常规用户具有管理权限，您可以使用`sudo`来执行这些命令。在这里，我将使用`sudo`。
- en: How to do it…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: If you are using Debian or Ubuntu, you'll need to use the `apt-get` tool. If
    you, on the other hand, are using a Fedora-based distribution, you'll need to
    use the `dnf` tool.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Debian或Ubuntu，您将需要使用`apt-get`工具。另一方面，如果您使用的是基于Fedora的发行版，您将需要使用`dnf`工具。
- en: Debian-based systems
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Debian的系统
- en: 'These steps are for Debian, Ubuntu, and Linux Mint:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤适用于Debian、Ubuntu和Linux Mint：
- en: 'Update the repository cache before installing the packages:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装软件之前更新存储库缓存：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Install both GDB and Valgrind using `apt-get`. Answer `y` when prompted:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`apt-get`安装GDB和Valgrind。在提示时回答`y`：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Fedora-based systems
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Fedora的系统
- en: 'This step is for all Fedora-based systems, such as CentOS and Red Hat. If you
    are using an older system, you might need to replace `dnf` with `yum`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步适用于所有基于Fedora的系统，如CentOS和Red Hat。如果您使用的是较旧的系统，您可能需要用`yum`替换`dnf`：
- en: 'Install both GDB and Valgrind using `dnf`. Answer `y` when prompted:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`dnf`安装GDB和Valgrind。在提示时回答`y`：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Verifying the installation
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证安装
- en: 'This step is the same for both Debian-based and Fedora-based systems:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步对于基于Debian和基于Fedora的系统是相同的：
- en: 'Verify the installation of GDB and Valgrind:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证GDB和Valgrind的安装：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: GDB and Valgrind are two debugging tools that are not included in the group
    packages we installed in the previous recipe. That's why we need to install them
    as separate steps. The tool for installing software on Debian-based distributions
    is `apt-get`, while for Fedora, it's `dnf`. Since we are installing software on
    the system, we need to execute these commands with root privileges. That's why
    we needed to use `sudo`. Remember that if your user—or system—doesn't use `sudo`,
    you can use `su` to become root.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: GDB和Valgrind是两个调试工具，它们不包括在我们在上一个教程中安装的组包中。这就是为什么我们需要将它们作为单独的步骤安装。在基于Debian的发行版上安装软件的工具是`apt-get`，而在Fedora上是`dnf`。由于我们正在系统上安装软件，所以我们需要以root权限执行这些命令。这就是为什么我们需要使用`sudo`。请记住，如果您的用户或系统不使用`sudo`，您可以使用`su`来成为root。
- en: Finally, we verified the installations by listing the versions that were installed.
    The exact version can differ from system to system, though.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过列出安装的版本来验证了安装。确切的版本可能因系统而异。
- en: The reason why the versions differ is that every Linux distribution has its
    own software repository, and every Linux distribution maintains its own software
    versions as "latest". This means that the latest version of a program in a particular
    Linux distribution isn't necessarily the newest version of the program.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 版本不同的原因是每个Linux发行版都有自己的软件仓库，并且每个Linux发行版都维护自己的软件版本作为“最新版本”。这意味着特定Linux发行版中程序的最新版本不一定是该程序的最新版本。
- en: Writing a simple C program for Linux
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Linux编写一个简单的C程序
- en: In this recipe, we will be building a small **C program** that sums up the values
    that are passed to the program as **arguments**. The C program will contain some
    essential elements we need to know about when programming for Linux. These elements
    are **return values**, arguments, and **help texts**. As we progress through this
    book, these elements will show up, time and time again, along with some new ones
    that we'll learn about along the way.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将构建一个小的C程序，该程序将对作为参数传递给程序的值进行求和。C程序将包含一些我们在Linux编程时需要了解的基本元素。这些元素包括返回值、参数和帮助文本。随着我们在这本书中的进展，这些元素将一次又一次地出现，还会有一些我们在学习过程中会了解到的新元素。
- en: Mastering these elements is the first step to writing great software for Linux.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握这些元素是为Linux编写优秀软件的第一步。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The only thing you'll need for this recipe is the C source code, `sum.c`, and
    the GCC compiler. You can choose to type the code in yourself or download it from
    GitHub. Typing it in yourself gives you the benefit of learning how to write it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程唯一需要的是C源代码`sum.c`和GCC编译器。您可以选择自己输入代码，也可以从GitHub上下载。自己输入代码可以让您学会如何编写代码。
- en: How to do it…
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to write your first program in Linux:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在Linux中编写您的第一个程序：
- en: 'Open a text editor and type in the following code, naming the file `sum.c`.
    The program will sum up all the numbers that are entered as arguments into the
    program. The arguments to the program are contained in the `argv` array. To convert
    the arguments into integers, we can use the `atoi()` function:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个文本编辑器，输入以下代码，将文件命名为`sum.c`。该程序将对输入到程序中的所有数字进行求和。程序的参数包含在`argv`数组中。要将参数转换为整数，我们可以使用`atoi()`函数：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, it''s time to compile the source code using GCC:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候使用GCC编译源代码了：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the program. Don''t forget`./` before the filename:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。不要忘记在文件名前加上`./`：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let''s check the **exit code** from the program before we do anything
    else:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在做其他事情之前检查程序的**退出码**：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s rerun the program, this time with some **integers** that the program
    can sum up for us:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重新运行程序，这次使用一些整数，让程序为我们求和：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once again, we check the exit code from the program:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次检查程序的退出码：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's begin by exploring the basics of the code so that we understand what the
    different parts do and why they matter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索代码的基础知识开始，以便我们理解不同部分的作用以及它们为什么重要。
- en: The source code
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源代码
- en: First of all, we've included a `stdio.h`. This file is needed for `printf()`.
    The name *stdio* stands for `printf()` prints characters on the screen, it's classed
    as a *stdio* function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们包含了一个`stdio.h`。这个文件是`printf()`所需要的。*stdio*代表`printf()`在屏幕上打印字符，它被归类为*stdio*函数。
- en: The other header file we included is `stdlib.h`, which stands for `atoi()` function,
    which we can use to convert **strings** or **characters** into integers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含的另一个头文件是`stdlib.h`，它代表`atoi()`函数，我们可以用它将**字符串**或**字符**转换为整数。
- en: After that, we have a `printhelp()`. There is nothing particular to say about
    this; it's good C practice to keep the `main()`, and the function prototypes at
    the very beginning. The function prototype tells the rest of the program which
    argument the function takes, as well as what type of value it returns.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们有一个`printhelp()`。关于这个函数没有什么特别要说的；在C语言中，将`main()`和函数原型放在最开始是一个很好的实践。函数原型告诉程序的其余部分函数需要什么参数，以及它返回什么类型的值。
- en: Then, we declared the `main()` `int main(int argc, char *argv[])`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明了`main()` `int main(int argc, char *argv[])`。
- en: The two variables, `argc` and `argv`, have special meanings. The first, `argc`,
    is an integer and contains the number of arguments that were passed to the program.
    It will always be at least 1, even if no arguments are passed to the program;
    the very first argument is the name of the program itself.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 两个变量`argc`和`argv`有特殊的含义。第一个`argc`是一个整数，包含了传递给程序的参数数量。它至少为1，即使没有参数传递给程序；第一个参数是程序本身的名称。
- en: The next variable—or `argv`, which contains all the arguments that were passed
    to the program at the `argv[0]`, holds the name of the program—that is, the command
    line by which the program was executed. If the program was executed as `./sum`,
    then `argv[0]` contains the string `./sum`. If the program was executed as `/home/jack/sum`,
    then `argv[0]` contains the string `/home/jack/sum`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个变量是`argv`，它包含了传递给程序的所有参数，`argv[0]`包含了程序的名称，也就是执行程序时的命令行。如果程序被执行为`./sum`，那么`argv[0]`包含字符串`./sum`。如果程序被执行为`/home/jack/sum`，那么`argv[0]`包含字符串`/home/jack/sum`。
- en: It is this argument—or rather the program name—that we pass to the `printhelp()`
    function so that it prints the name of the program, along with the help text.
    It's good practice to do this is Linux and Unix environments.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这个参数，或者说是程序名称，我们将其传递给`printhelp()`函数，以便它打印程序的名称和帮助文本。在Linux和Unix环境中这样做是一个很好的实践。
- en: After that, we performed a simple `printhelp()` function that we built. Directly
    after that, we `return` from `main()` with the code 1, indicating to the `main()`
    using `return`, that code is sent to the shell and the program exits. These codes
    have special meanings, which we'll explore in more depth later in this book. Simply
    put, 0 indicates that everything is alright, while anything other than 0 is an
    error code. Using return values in Linux is a must; that's how other programs—and
    the shell—get notified of how the execution went.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，我们执行了一个我们构建的简单的`printhelp()`函数。紧接着，我们用代码1从`main()`中`return`，告诉`main()`使用`return`，将代码发送到shell并退出程序。这些代码有特殊的含义，我们将在本书的后面更深入地探讨。简单来说，0表示一切正常，而非0表示错误代码。在Linux中使用返回值是必须的；这是其他程序和shell得知执行情况的方式。
- en: A bit further down, we have the `for()` `argc` to walk through the list of arguments.
    We started at 1 with `i=1`. We can't begin with 0 here, since index 0 in the `argv[]`
    array is the program name. Index 1 is the first argument; that is, the integer
    that we can pass to the program.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微往下一点，我们有`for()` `argc`来遍历参数列表。我们从`i=1`开始。我们不能从0开始，因为`argv[]`数组中的索引0是程序名称。索引1是第一个参数；也就是我们可以传递给程序的整数。
- en: Inside the `for()` loop, we have `sum = sum + atoi(argv[i]);`. The important
    part we'll focus on here is `atoi(argv[i])`. All the arguments that we give to
    the program via the command line are passed on as strings. To be able to do calculations
    on them, we need to convert them into integers, which the `atoi()` function does
    for us. The name `atoi()` stands for *to integer*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for()`循环中，我们有`sum = sum + atoi(argv[i]);`。这里我们要重点关注的是`atoi(argv[i])`。我们通过命令行传递给程序的所有参数都被作为字符串传递。为了能够对它们进行计算，我们需要将它们转换为整数，而`atoi()`函数就是为我们做这个工作的。`atoi()`的名称代表*to
    integer*。
- en: Once the result has been printed on the screen with `printf()`, we `return`
    from main with 0, indicating everything is okay. When we return from `main()`,
    we return from the entire process to the shell; in other words, the **parent process**.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦结果被用`printf()`打印到屏幕上，我们用0从`main()`中`return`，表示一切正常。当我们从`main()`返回时，我们从整个进程返回到shell；换句话说，是**父进程**。
- en: Execution and return values
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行和返回值
- en: When we are executing programs outside the directories mentioned in the `$PATH`
    environment variable, we need to prepend the name of the file with `./`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`$PATH`环境变量中未提及的目录中执行程序时，需要在文件名前加上`./`。
- en: When the program finishes, it gives the return value to the shell, which, in
    turn, saves it to a variable called `?`. When another program ends, the variable
    is overwritten by the latest return value from that program. We print the value
    of the `echo`, a small utility that prints text and variables on the screen directly
    from the shell. To print environment variables, we need to put a `$` sign in front
    of the variable name, such as `$?`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序结束时，它将返回值传递给shell，shell将其保存到一个名为`?`的变量中。当另一个程序结束时，该变量将被该程序的最新返回值覆盖。我们打印`echo`的值，这是一个从shell直接在屏幕上打印文本和变量的小型实用程序。要打印环境变量，我们需要在变量名前加上`$`符号，例如`$?`。
- en: There's more…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'There are three other similar functions to `atoi()`, called `atol()`, `atoll()`,
    and `atof()`. The following are short descriptions for them:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另外三个类似于`atoi()`的函数，分别是`atol()`、`atoll()`和`atof()`。以下是它们的简短描述：
- en: '`atoi()` converts a string into an integer.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atoi()`将一个字符串转换为整型。'
- en: '`atol()` converts a string into a long integer.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atol()`将一个字符串转换为长整型。'
- en: '`atoll()` converts a string into a long long integer.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atoll()`将一个字符串转换为长长整型。'
- en: '`atof()` converts a string into a floating-point number (of type double).'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atof()`将一个字符串转换为浮点数（双精度类型）。'
- en: If you want to explore the return values of other programs, you can execute
    programs such as `ls` with a directory that exists and print the variable with
    `echo $?`. Then, you can try to list a directory with `ls` that doesn't exist
    and print the value of `$?` again.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索其他程序的返回值，你可以执行诸如`ls`之类的程序，指定一个存在的目录，并用`echo $?`打印变量。然后，你可以尝试列出一个不存在的目录，并再次打印`$?`的值。
- en: Tip
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: We've touched on the subject of the `$PATH` environment variable a couple of
    times in this chapter. If you want to know what that variable contains, you can
    print it with `echo $PATH`. If you want to add a new directory to the `$PATH`
    variable temporarily, let's say `/home/jack/bin`, you can execute the `PATH=${PATH}:/home/jack/bin`
    command.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经多次提到了`$PATH`环境变量。如果你想知道该变量包含什么，你可以用`echo $PATH`打印它。如果你想临时向`$PATH`变量添加一个新目录，比如`/home/jack/bin`，你可以执行`PATH=${PATH}:/home/jack/bin`命令。
- en: Writing a program that parses command-line options
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写解析命令行选项的程序
- en: In this recipe, we will create a more advanced program—one that parses command-line
    `argc` and `argv`. We will use those variables here as well, but for options.
    Options are the hyphenated letters, such as `-a` or `-v`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个更高级的程序——一个解析命令行`argc`和`argv`的程序。我们也会在这里使用这些变量，但是用于选项。选项是带有连字符的字母，比如`-a`或`-v`。
- en: This program is similar to the previous one, with the difference that this program
    can both this; `-s` for "sum" and `-m` for "multiply."
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序与上一个程序类似，不同之处在于这个程序可以同时进行加法和乘法运算；`-s`代表“求和”，`-m`代表“乘法”。
- en: Almost all programs in Linux take different options. Knowing how to parse options
    to the programs you create is a must; that is how the user changes the behavior
    of your program.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，几乎所有的程序都有不同的选项。了解如何解析程序的选项是必须的；这是用户改变程序行为的方式。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All you need is a text editor, the GCC compiler, and Make.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的只是一个文本编辑器、GCC编译器和Make。
- en: How to do it…
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'Since this source code will be a bit longer, it will be broken up into three
    pieces. The entire code goes into the same file, though. The complete program
    can be downloaded from GitHub at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch1/new-sum.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch1/new-sum.c).
    Let''s get started:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个源代码会比较长，它将被分成三部分。但整个代码都放在同一个文件中。完整的程序可以从GitHub上下载：[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch1/new-sum.c](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/blob/master/ch1/new-sum.c)。让我们开始吧：
- en: 'Open a text editor, type in the following code, and name it `new-sum.c`. This
    first bit is pretty similar to the previous recipe, except for some extra variables
    and a **macro** at the top:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个文本编辑器，输入以下代码，并将其命名为`new-sum.c`。这一部分与上一个示例非常相似，只是有一些额外的变量和顶部的**宏**：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, continue typing in the same file. This part is for actually parsing the
    command-line options, the calculations, and printing the result. We parse the
    options using `getopt()` and a `switch` statement. Notice that this time, we can
    also multiply the numbers:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，继续在同一个文件中输入。这部分是用于解析命令行选项、进行计算和打印结果。我们使用`getopt()`和`switch`语句来解析选项。注意，这次我们还可以进行乘法运算：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, continuing in the same file, add the `printhelp()` function at the
    bottom. This function prints a help message, sometimes called a *usage* message.
    This message is displayed either when the user uses the `-h` option or some form
    of error occurs, for example, when no arguments are given:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在同一个文件中，将`printhelp()`函数添加到底部。这个函数打印一个帮助消息，有时被称为*用法*消息。当用户使用`-h`选项或发生某种形式的错误时，例如没有给出参数时，将显示此消息：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Save and close the file.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并关闭文件。
- en: 'Now, it''s time to compile the program. This time, we''ll try using Make instead:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候编译程序了。这次，我们将尝试使用Make：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Test the program:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试程序：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The first bit is pretty similar to the previous recipe, except we have some
    more variables we `unistd.h`, which is required for the `getopt()` function, which
    we use to parse options to the program.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分与上一个示例非常相似，只是我们有一些更多的变量`unistd.h`，这是`getopt()`函数所需的，我们用它来解析程序的选项。
- en: 'There is also another new weird-looking part; that is, the first line:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个新的看起来有点奇怪的部分；那就是第一行：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will cover this in great detail later on in this book. But for now, just
    know that it's a feature macro we use to adhere to the `getopt()`, something we
    will cover in detail in the next recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面详细介绍这个。但现在，只需知道它是一个特性宏，我们用它来遵循`getopt()`，我们将在下一个食谱中详细介绍。
- en: The getopt() function
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: getopt()函数
- en: The next step in this recipe—step two—is the exciting part. It is here that
    we parse the options using the `getopt()` function—which stands for *get options*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的下一步——第二步——是令人兴奋的部分。在这里，我们使用`getopt()`函数解析选项，该函数代表*获取选项*。
- en: 'The way to use `getopt()` is to loop through the arguments in a `while` loop
    and using a `switch` statement to catch the options. Let''s take a closer look
    at the `while` loop and break it down into smaller pieces:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getopt()`的方法是在`while`循环中循环遍历参数，并使用`switch`语句捕获选项。让我们更仔细地看看`while`循环，并将其分解成较小的部分：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `getopt()` function returns the actual letter of the option it parses. This
    means that the first bit, `opt = getopt`, saves the option to the `opt` variable,
    but only the actual letter. So, for example, `-h` is saved as `h`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`getopt()`函数返回它解析的选项的实际字母。这意味着第一部分`opt = getopt`将选项保存到`opt`变量中，但只保存实际的字母。因此，例如，`-h`保存为`h`。'
- en: Then, we have the arguments that we must pass to the `getopt()` function, which
    is `argc` (the argument count), `argv` (the actual arguments), and, finally, the
    options that should be accepted (here `smh`, which is translated into `-s`, `-m`,
    and `-h`).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有必须传递给`getopt()`函数的参数，即`argc`（参数计数）、`argv`（实际参数）和最后应该接受的选项（这里是`smh`，它被翻译为`-s`、`-m`和`-h`）。
- en: The last bit, `!= -1`, is for the `while` loop. When `getopt()` has no more
    options to return, it returns -1, indicating that it's done parsing options. That's
    when the `while` loop should end.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分`!= -1`是为了`while`循环。当`getopt()`没有更多选项返回时，它返回-1，表示它已经完成了选项解析。这时`while`循环应该结束。
- en: Inside the while loop
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在while循环内
- en: Inside the loop, we use a `switch` statement to perform specific actions for
    each option. Under each `case`, we perform the calculation and `break` out of
    that `case` when we're done. Just as in the previous recipe, we use `atoi()` to
    convert the argument strings into integers.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内，我们使用`switch`语句对每个选项执行特定的操作。在每个`case`下，我们执行计算并在完成后`break`出该`case`。就像在上一个食谱中一样，我们使用`atoi()`将参数字符串转换为整数。
- en: Under the `h` case (the `-h` option, for help), we print the help message and
    return with code 0\. We asked for help, and hence it isn't an error. But below
    that, we have the default case, a case that is caught if no other option matches;
    that is, the user typed in an option that isn't accepted. This is indeed an error,
    so here, we return with code 1 instead, indicating an error.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`h`情况下（帮助的`-h`选项），我们打印帮助消息并返回代码0。我们请求帮助，因此这不是一个错误。但在此之下，我们有默认情况，即如果没有其他选项匹配，则捕获的情况；也就是说，用户输入了一个不被接受的选项。这确实是一个错误，所以在这里，我们返回代码1，表示错误。
- en: The help message function
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帮助消息函数
- en: A help message should show the various options a program takes, its arguments,
    and a simple usage example.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助消息应该显示程序接受的各种选项、其参数和一个简单的使用示例。
- en: With `printf()`, we can split long lines into multiple smaller lines in our
    code, just like we did here. The unique character sequence, `\n`, is a newline
    character. The line will break wherever this character is placed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`printf()`，我们可以在代码中将长行分成多个较小的行，就像我们在这里做的一样。独特的字符序列`\n`是一个换行字符。行将在放置这个字符的地方断开。
- en: Compiling and running the program
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译和运行程序
- en: In this recipe, we compiled the program using Make instead. The Make utility,
    in turn, uses `cc`, which is just a symbolic link to `gcc`. Later in this book,
    we'll learn how to change the behavior of Make by writing rules in Makefiles.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用Make编译了程序。Make实用程序又使用`cc`，它只是`gcc`的符号链接。本书后面，我们将学习如何通过在Makefile中编写规则来改变Make的行为。
- en: We then tried the program. First, we ran it without any options or arguments,
    causing the program to exit with the help text (and a return value of 1).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们尝试了这个程序。首先，我们没有使用任何选项或参数来运行它，导致程序退出并显示帮助文本（返回值为1）。
- en: 'We then tried two options: `-s` to summarize all the integers and `-m` to multiply
    all the integers.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们尝试了两个选项：`-s`用于总结所有整数和`-m`用于将所有整数相乘。
- en: Looking up information in the built-in manual page
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在内置手册页中查找信息
- en: In this recipe, we will learn how to look up information in the built-in manual
    pages. We will learn how we can look up everything from commands, system calls,
    and **standard library functions**. The manual pages are mighty once you get used
    to using them. Instead of searching the internet for answers, it's often quicker—and
    more accurate—to take a look in the manual.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何在内置手册页中查找信息。我们将学习如何查找从命令、系统调用到**标准库函数**的所有内容。一旦习惯使用它们，手册页就非常强大。与在互联网上搜索答案相比，查看手册通常更快、更准确。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Some of the manual pages (library calls and system calls) are installed as part
    of the *build-essential* package for Debian and Ubuntu. In Fedora-based distributions
    such as CentOS, these are often already installed in the base system as part of
    a package called *man pages*. If you are missing some manual pages, make sure
    you have installed these packages. Take a look at the very first recipe in this
    chapter, on how to install packages, to learn more.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一些手册页（库调用和系统调用）作为Debian和Ubuntu的*build-essential*软件包的一部分安装。在基于Fedora的发行版（如CentOS）中，这些通常已经作为*man
    pages*软件包的一部分安装在基本系统中。如果您缺少一些手册页，请确保已安装这些软件包。查看本章中的第一个食谱，了解更多关于安装软件包的信息。
- en: If you are on a minimal or slim installation, the `man` command might not be
    installed. If that is the case, you need to install two packages with the distribution
    package manager. The package names are *man-db* for the `man` command (same on
    nearly all distributions) and *manpages* (in Debian-based systems), or *man-pages*
    (in Fedora-based systems) for the actual manual pages. On Debian-based systems,
    you also need to install the *build-essential* package.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是最小化或精简安装，可能没有安装`man`命令。如果是这种情况，你需要使用发行版包管理器安装两个软件包。软件包名称为*man-db*（几乎所有发行版都是一样的）和*manpages*（在基于Debian的系统中），或者*man-pages*（在基于Fedora的系统中）用于实际的手册页。在基于Debian的系统中，你还需要安装*build-essential*软件包。
- en: How to do it…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法...
- en: 'Let''s explore the manual pages, step by step, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步探索手册页，如下所示：
- en: Type `man ls` into a console. You'll see the manual page for the `ls` command.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中键入`man ls`。你会看到`ls`命令的手册页。
- en: Scroll up and down the manual page, one line at a time, using either the *arrow*
    keys or the *Enter* key.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*箭头*键或*Enter*键逐行滚动手册页。
- en: Scroll down a full page (window) at a time by pressing the *spacebar*.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*空格键*以一次滚动一个完整页面（窗口）。
- en: Scroll up a full page by pressing the letter *b*. Keep pressing *b* until you
    reach the top.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下字母*b*来向上滚动整个页面。一直按*b*直到达到顶部。
- en: Now, press */* to open a search prompt.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按*/*打开搜索提示。
- en: Type `human-readable` into the search prompt and press *Enter*. The manual page
    is now automatically scrolled forward to the first occurrence of that word.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索提示中键入`human-readable`，然后按*Enter*。手册页现在会自动向前滚动到该单词的第一次出现。
- en: You can now press *n* to jump to the next occurrence of the word – if there
    is one.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以按*n*键跳转到下一个单词的出现位置 - 如果有的话。
- en: Quit the manual by pressing *q*.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*q*退出手册。
- en: Investigating the different sections
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调查不同的部分
- en: 'Sometimes, there are multiple manual pages with the same name but in different
    sections. Here, we will investigate those sections and learn how to specify which
    section we are interested in:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，同名但在不同部分的手册页可能有多个。在这里，我们将调查这些部分，并学习如何指定我们感兴趣的部分：
- en: Type `man printf` into the command prompt. What you will see is the manual page
    for the `printf` command, not the C function of the same name.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中键入`man printf`。你将看到`printf`命令的手册页，而不是同名的C函数。
- en: Quit the manual by pressing *q*.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*q*退出手册。
- en: Now, type `man 3 printf` into the console. This is the manual page of the `printf()`
    C function. `3` indicates section 3 of the manual. Look at the header of the manual
    page, and you'll see which section you are in right now. It should say **PRINTF(3)**
    at this very moment.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在控制台中键入`man 3 printf`。这是`printf()`C函数的手册页。`3`表示手册的第3部分。查看手册页的标题，你会看到你现在所在的部分。此刻应该会显示**PRINTF(3)**。
- en: Let's list all the sections. Quit the manual page you are looking at and type
    `man man` into the console. Scroll down a bit until you find the table that lists
    all the sections. There, you will also find a short description of each section.
    As you can see, section 3 is for library calls, which is what `printf()` is.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们列出所有的部分。退出你正在查看的手册页，然后在控制台中键入`man man`。向下滚动一点，直到找到列出所有部分的表格。在那里，你还会找到每个部分的简短描述。正如你所看到的，第3部分是用于库调用的，这就是`printf()`所在的部分。
- en: Look up the manual for the `unlink()` system call by typing `man 2 unlink` into
    the console.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在控制台中键入`man 2 unlink`来查找`unlink()`系统调用的手册。
- en: Quit the manual page and type `man unlink` into the console. This time, you
    will see the manual for the `unlink` command.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出手册页，然后在控制台中键入`man unlink`。这次，你会看到`unlink`命令的手册。
- en: How it works…
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The manual always starts at section 1 and opens the first manual it finds. That's
    why you are getting the `printf` and `unlink` commands, instead of the C function
    and system call when we leave out the section number. It's always a good idea
    to take a look at the header of the manual page that opens up to verify that you
    are reading the correct one.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 手册总是从第1部分开始，并打开它找到的第一个手册。这就是为什么当我们不指定部分号码时，你会得到`printf`和`unlink`命令，而不是C函数和系统调用。查看打开的手册页的标题总是一个好主意，以确保你正在阅读正确的手册页。
- en: There's more…
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Remember from the previous recipe that I "just knew" that `getopt()` returns
    `-1` when there are no more options to parse? I didn''t; it''s all in the manual.
    Open up the manual for `getopt()` by typing in `man 3 getopt`. Scroll down to
    the *Return value* header. There, you can read all about what `getopt()` returns.
    Almost all manual pages that cover library functions and system calls have the
    following headings: Name, Synopsis, Description, Return value, Environment, Attributes,
    Conforming to, Notes, Example, and See also.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一个步骤中记住，我“只是知道”当没有更多选项需要解析时，`getopt()`返回`-1`？其实不是，这都在手册中有。通过在控制台中键入`man 3
    getopt`来打开`getopt()`的手册。向下滚动到*Return value*标题。在那里，你可以阅读有关`getopt()`返回值的所有信息。几乎所有涵盖库函数和系统调用的手册页都有以下标题：名称、概要、描述、返回值、环境、属性、符合、注释、示例和参见。
- en: The Synopsis heading lists the header files we need to include for the particular
    function. This is really useful since we can't remember every function and its
    corresponding header file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 概要标题列出了我们需要包含的特定函数的头文件。这真的很有用，因为我们无法记住每个函数及其对应的头文件。
- en: Tip
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: There is a lot of useful information in the manual about the manual itself –
    `man man` – so at least skim through it. We will be using the manual pages a lot
    to look up information about library functions and system calls in this book.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 手册中有很多关于手册本身的有用信息 - `man man` - 所以至少浏览一下。在本书中，我们将经常使用手册页来查找有关库函数和系统调用的信息。
- en: Searching the manual for information
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索手册以获取信息
- en: If we don't know the exact name of a particular command, function, or system
    call, we can search all the manuals in the system for the correct one. In this
    recipe, we will learn how to use the `apropos` command to search the manual pages.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不知道特定命令、函数或系统调用的确切名称，我们可以搜索系统中所有手册以找到正确的。在这个示例中，我们将学习如何使用 `apropos` 命令搜索手册页。
- en: Getting ready
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The same requirements apply here that applied for the previous recipe.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这里适用于前一个示例的相同要求。
- en: How to do it…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: 'Let''s search the manual for different words, narrowing our result for each
    step:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们搜索不同的单词，每一步都缩小我们的结果：
- en: Type in `apropos directory`. A long list of manual pages will present itself.
    After each manual, there is a number inside parentheses. This number is the section
    that the manual page is located in.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 `apropos directory`。会出现一个手册页的长列表。在每个手册页后面，都有括号里的一个数字。这个数字是手册页所在的章节。
- en: To narrow the search down to only section 3 (library calls), type in `apropos
    -s 3 directory`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将搜索范围缩小到只有第 3 章节（库调用），输入 `apropos -s 3 directory`。
- en: Let's narrow down the search ever further. Type in `apropos -s 3 -a remove directory`.
    The `-a` option stands for *and*.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步缩小搜索范围。输入 `apropos -s 3 -a remove directory`。`-a` 选项代表 *and*。
- en: How it works…
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `apropos` command searches the manual pages descriptions and keywords. When
    we narrowed down the search with `apropos -s 3 -a remove directory`, the `-a`
    option stands for *and*, indicating that both *remove* and *directory* must be
    present. If we leave out the -`a` option, it searches for both keywords instead,
    regardless of whether one or both of them is present.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`apropos` 命令搜索手册页描述和关键字。当我们用 `apropos -s 3 -a remove directory` 缩小搜索范围时，`-a`
    选项代表 *and*，表示 *remove* 和 *directory* 必须同时存在。如果我们省略 `-a` 选项，它会搜索这两个关键字，而不管它们是否都存在。'
- en: There is more information about how `apropos` works in the manual page for it
    (`man apropos`).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `apropos` 如何工作的更多信息，请参阅其手册页（`man apropos`）。
- en: There's more…
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'If we just want to know what a particular command or function does, we can
    look up a short description of it using the `whatis` command, like so:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想知道特定命令或函数的作用，可以使用 `whatis` 命令查找它的简短描述，如下所示：
- en: '[PRE32]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
