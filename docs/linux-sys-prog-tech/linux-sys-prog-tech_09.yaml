- en: '*Chapter 9*: Terminal I/O and Changing Terminal Behavior'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：终端I/O和更改终端行为'
- en: In this chapter, we learn what a **TTY** (short for **TeleTYpewriter**) and
    a **PTY** (short for **Pseudo-TeletYpewriter**) are and how to get information
    about them. We also learn how to set their attributes. Then, we write a small
    program that takes input without echoing the text—perfect for a password prompt.
    We also write a program that checks the size of the current terminal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习**TTY**（**TeleTYpewriter**的缩写）和**PTY**（**Pseudo-TeletYpewriter**的缩写）是什么，以及如何获取有关它们的信息。我们还将学习如何设置它们的属性。然后，我们编写一个接收输入但不回显文本的小程序——非常适合密码提示。我们还编写一个检查当前终端大小的程序。
- en: A terminal can take many forms—for example, a terminal window in X (the graphical
    frontend); the seven terminals accessed with *Ctrl* + *Alt* + *F1* through *F7*;
    an old serial terminal; a dial-up terminal; or a remote terminal such as **Secure
    Shell** (**SSH**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 终端可以采用多种形式——例如，在X中的终端窗口（图形前端）；通过*Ctrl* + *Alt* + *F1*到*F7*访问的七个终端；旧的串行终端；拨号终端；或者远程终端，比如**Secure
    Shell**（**SSH**）。
- en: A **TTY** is a hardware terminal, such as the consoles accessed with *Ctrl*
    + *Alt* + *F1* through *F7*, or a serial console.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**TTY**是硬件终端，比如通过*Ctrl* + *Alt* + *F1*到*F7*访问的控制台，或者串行控制台。'
- en: A `xterm`, `rxvt`, `tmux`. It could also be a remote terminal, such as SSH.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`xterm`，`rxvt`，`tmux`。也可以是远程终端，比如SSH。
- en: Since we all use terminals in our daily lives with Linux, knowing how to get
    information about them and control them can help us write better software. One
    such example is to hide the password in a password prompt.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在日常生活中都使用Linux终端，了解如何获取有关它们的信息并控制它们可以帮助我们编写更好的软件。一个例子是在密码提示中隐藏密码。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Viewing terminal information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看终端信息
- en: Changing terminal settings with `stty`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stty`更改终端设置
- en: Investigating TTYs and PTYs and writing to them
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查TTY和PTY并向它们写入
- en: Checking if it's a TTY
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查它是否是TTY
- en: Creating a PTY
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个PTY
- en: Disabling echo for password prompts
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用密码提示的回显
- en: Reading the terminal size
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取终端大小
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we'll need all the usual tools, such as the `screen`. If you
    don't already have it, you can install it with your distribution's package manager—for
    example, `sudo apt-get install screen` for Debian/Ubuntu, or `sudo dnf install
    screen` for CentOS/Fedora.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将需要所有常用的工具，比如`screen`。如果您还没有安装，可以使用您发行版的软件包管理器进行安装——例如，对于Debian/Ubuntu，可以使用`sudo
    apt-get install screen`，对于CentOS/Fedora，可以使用`sudo dnf install screen`。
- en: All code samples for this chapter can be downloaded from [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch9](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch9).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以从[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch9](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch9)下载。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/2O8j7Lu](https://bit.ly/2O8j7Lu)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以查看实际操作视频：[https://bit.ly/2O8j7Lu](https://bit.ly/2O8j7Lu)
- en: Viewing terminal information
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看终端信息
- en: In this recipe, we'll learn more about what TTYs and PTYs are and how to read
    their attributes and information. This will help us in our understanding of TTYs
    as we move forward in the chapter. Here, we learn how to find out which TTY or
    PTY we are using, where it lives on the filesystem, and how to read its attributes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习更多关于TTY和PTY是什么，以及如何读取它们的属性和信息。这将有助于我们在本章中继续了解TTY。在这里，我们将学习如何找出我们正在使用的TTY或PTY，它在文件系统中的位置，以及如何读取它的属性。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: There are no special requirements for this recipe. We'll only use standard programs
    that are already installed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方没有特殊要求。我们只会使用已经安装的标准程序。
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll explore how to find your own TTY, what attributes it
    has, where its corresponding file lives, and what kind of TTY it is:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨如何找到自己的TTY，它具有什么属性，它的对应文件在哪里，以及它是什么类型的TTY：
- en: 'Start by typing `tty` in your terminal. This will tell you which TTY you are
    using on the system. There can be many TTYs and PTYs on a single system. Each
    of them is represented by a file on the system:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在终端中输入`tty`。这将告诉您在系统上使用的TTY。在单个系统上可以有许多TTY和PTY。它们每个都由系统上的一个文件表示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s examine that file. As we see here, it''s a special file type, called
    *character special*:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下那个文件。正如我们在这里看到的，这是一种特殊的文件类型，称为*字符特殊*：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s examine the terminal''s attributes with a program called `stty`.
    The `-a` option tells `stty` to display all attributes. The information we get
    is, for example, the size of the terminal (number of rows and columns); its speed
    (only important on serial terminals, dial-up, and so on); which *Ctrl* key combination
    is used for `-parenb`. All values without a minus sign, such as `cs8`, are enabled:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用一个名为`stty`的程序来检查终端的属性。`-a`选项告诉`stty`显示所有属性。我们得到的信息，例如终端的大小（行数和列数）；它的速度（只在串行终端、拨号等上重要）；用于`-parenb`的*Ctrl*键组合。所有没有减号的值，比如`cs8`，都是启用的：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It''s also possible to view another terminal''s attributes, assuming you own
    it, meaning the logged-in user must be you. If we try to view another user''s
    terminal, we get a *Permission denied* error:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以查看另一个终端的属性，假设您拥有它，这意味着已登录用户必须是您。如果我们尝试查看另一个用户的终端，将会收到*权限被拒绝*的错误：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works…
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: A single Linux system can have hundreds or thousands of logged-in users. Each
    of them is connected over a TTY or PTY. Back in the old days, this was often hardware
    terminals (TTYs) connected to the machine over serial lines. Nowadays, hardware
    terminals are pretty rare; instead, we log in over **SSH** or use terminal programs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 单个Linux系统可以有数百或数千个已登录用户。每个用户都通过TTY或PTY连接。在过去，这通常是硬件终端(TTY)通过串行线连接到计算机。如今，硬件终端相当罕见；相反，我们通过**SSH**登录或使用终端程序。
- en: In our example, the current user is logged in on a `/dev/pts/24`; that is *pts*,
    not *pty*. A PTY has two parts, a master and a slave. **PTS** stands for *pseudo-terminal
    slave*, and it's that part we connect to. The master part opens/creates the pseudo-terminal,
    but it's the slave that we use. We'll dig a bit deeper into this concept later
    in the chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，当前用户登录在`/dev/pts/24`上；那是*pts*，而不是*pty*。PTY有两个部分，一个主部分和一个从属部分。**PTS**代表*伪终端从属*，我们连接的就是这部分。主部分打开/创建伪终端，但我们使用的是从属部分。我们将在本章稍后深入探讨这个概念。
- en: The settings we used as an example in *Step 3* (`-parenb` and `cs8`) mean that
    `parenb` is disabled since it has a minus sign, and `cs8` is enabled. The `parenb`
    option will generate a parity bit and expect one back in the input. Parity bits
    were widely used in dial-up connections and serial communication. The `cs8` option
    sets the character size to 8 bits.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤3*中我们使用的设置（`-parenb`和`cs8`）意味着`parenb`被禁用，因为它有一个减号，而`cs8`被启用。`parenb`选项将生成一个奇偶校验位，并期望在输入中返回一个。奇偶校验位在拨号连接和串行通信中被广泛使用。`cs8`选项将字符大小设置为8位。
- en: The `stty` program can be used to both view and set attributes for a terminal.
    In the next recipe, we'll return to `stty` to change some values.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`stty`程序可以用来查看和设置终端的属性。在下一个食谱中，我们将返回到`stty`来更改一些值。'
- en: As long as we are the terminal device owner, we can read and write to it, as
    we saw in the last step of the recipe.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们是终端设备的所有者，我们就可以读写它，就像我们在食谱的最后一步中看到的那样。
- en: See also
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There's a lot of useful information in `man 1 tty` and `man 1 stty`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在`man 1 tty`和`man 1 stty`中有很多有用的信息。
- en: Changing terminal settings with stty
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用stty更改终端设置
- en: In this recipe, we'll learn how to change the settings (or attributes) of our
    terminal. In the previous recipe, we listed our current settings with `stty -a`.
    In this recipe, we'll change some of those settings, using the same `stty` program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何更改终端的设置（或属性）。在上一个食谱中，我们用`stty -a`列出了我们当前的设置。在这个食谱中，我们将改变其中一些设置，使用相同的`stty`程序。
- en: Knowing how to change your terminal settings will enable you to adapt it according
    to your preference.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何更改终端设置将使您能够根据自己的喜好进行调整。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好
- en: No special requirements exist for this recipe.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱没有特殊要求。
- en: How to do it…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Here, we will change some of the settings for our current terminal:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将更改当前终端的一些设置：
- en: 'Let''s start by turning off `whoami`, and get an answer. Notice that you won''t
    see the `whoami` command as you type it:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先关闭`whoami`，并得到一个答案。请注意，当您输入时，您看不到`whoami`命令：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To turn on echoing again, we type the same command again but without the minus
    sign. Notice that you won''t see the `stty` command when you type it:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要再次打开回显，我们再次输入相同的命令，但不带减号。请注意，当您输入时，您看不到`stty`命令：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also change special key sequences—for example, usually, the EOF character
    is *Ctrl* + *D*. We can rebind that with a single dot (`.`) if we''d like:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以更改特殊的键序列——例如，通常情况下，EOF字符是*Ctrl* + *D*。如果需要，我们可以将其重新绑定为一个单点（`.`）：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Type a single dot (`.`) now, and your current terminal will quit or log out.
    When you start a new terminal or log back in, the settings are back to normal.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在输入一个单点（`.`），您当前的终端将退出或注销。当您启动一个新终端或重新登录时，设置将恢复正常。
- en: 'To save the settings for reuse later, we first make the necessary changes—for
    example, setting EOF to a dot. Then, we use `stty --save`. That option will print
    a long line of hexadecimal numbers—these numbers are the settings. So, to save
    them, we can redirect the output from `stty --save` to a file:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了保存设置以便以后重用，我们首先进行必要的更改——例如，将EOF设置为一个点。然后，我们使用`stty --save`。该选项将打印一长串十六进制数字——这些数字就是设置。因此，为了保存它们，我们可以将`stty
    --save`的输出重定向到一个文件中：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, log out by pressing a dot.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，按下一个点来注销。
- en: 'Log back in (or re-open the terminal window). Try typing a dot, and nothing
    will happen. To reload our settings, we use the `my-tty-settings` file from the
    previous step. The `$()` sequence *expands* the command inside the parenthesis
    and is then used as an argument for `stty`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新登录（或重新打开终端窗口）。尝试输入一个点，什么也不会发生。为了重新加载我们的设置，我们使用上一步的`my-tty-settings`文件。`$()`序列*展开*括号内的命令，然后用作`stty`的参数：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we can once again try to log out by pressing a dot.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以再次尝试按下一个点来注销。
- en: How it works…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A terminal is often a "dumb" device, and hence it requires lots of settings
    to make it work right. This is also one of those leftovers from the old days of
    hardware teletypewriters. The `stty` program is used to set attributes on a terminal
    device.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 终端通常是一个“愚蠢”的设备，因此需要大量的设置才能使其正常工作。这也是旧硬件电传打字机的遗留物之一。`stty`程序用于在终端设备上设置属性。
- en: Options with a minus sign are negated—that is, disabled. Options without a minus
    sign are enabled. In our example, we first turned off echoing, a common practice
    for password prompts, and so on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 带有减号的选项被否定，即被禁用。没有减号的选项是启用的。在我们的例子中，我们首先关闭了回显，这是密码提示的常见做法，等等。
- en: There is no real way of saving the settings for a TTY, except for the way we
    saw here by saving it to a file and re-reading it later.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 没有真正的方法可以保存TTY的设置，除了我们在这里看到的通过将其保存到文件并稍后重新读取它。
- en: Investigating TTYs and PTYs and writing to them
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调查TTY和PTY并向它们写入
- en: In this recipe, we'll learn how to list currently logged-in users, which TTYs
    they use, and which programs they are running. We'll also learn how to write to
    those users and terminals. As we'll see in this recipe, we can write to a **terminal
    device** just as if it were a file, assuming we have the correct permissions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习如何列出当前登录的用户，他们使用的TTY以及他们正在运行的程序。我们还将学习如何向这些用户和终端写入。正如我们将在这个食谱中看到的，我们可以像写入文件一样向**终端设备**写入，假设我们有正确的权限。
- en: Knowing how to write to other terminals deepens understanding of how terminals
    work and what they are. It also enables you to write some interesting software
    and, above all, it will make you a better system administrator. It also teaches
    you about terminal security.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何写入其他终端会加深对终端工作原理和终端的理解。它还使您能够编写一些有趣的软件，并且最重要的是，它将使您成为一个更好的系统管理员。它还教会您有关终端安全的知识。
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We''ll start by investigating the logged-in users; then, we''ll learn how to
    send messages to them:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先调查已登录用户；然后，我们将学习如何向他们发送消息：
- en: To make things a bit more interesting, open up three to four terminal windows.
    If you're not using the **X-Window System**, log in on multiple TTYs. Or, if you
    are using a remote server, log in several times.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使事情变得更有趣，打开三到四个终端窗口。如果您没有使用**X-Window System**，请在多个TTY上登录。或者，如果您正在使用远程服务器，请多次登录。
- en: 'Now, type the `who` command in one of the terminals. You''ll get a list of
    all the logged-in users, which TTY/PTY they are using, and the date and time they
    logged in. In my example, I''ve logged in several times over SSH. If you are using
    a local machine with multiple `xterm` applications, you''ll see `(:0)` instead
    of the **Internet Protocol** (**IP**) address:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在其中一个终端中键入`who`命令。您将获得所有已登录用户的列表，他们正在使用的TTY/PTY，以及他们登录的日期和时间。在我的例子中，我通过SSH登录了多次。如果您正在使用具有多个`xterm`应用程序的本地计算机，则将看到`(:0)`而不是**Internet
    Protocol**（**IP**）地址：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There''s a similar command, `w`, that even shows which program the user on
    each terminal is currently using:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个类似的命令`w`，甚至显示每个终端上的用户当前正在使用的程序：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s find out which terminal we are using:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们找出我们正在使用哪个终端：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we know which terminal we are using, let''s send a message to another
    user and terminal. At the beginning of this book, I mentioned that everything
    is just a file or a process. This is true even for terminals. That means we can
    send data to a terminal using regular redirections:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们知道我们正在使用哪个终端，让我们向另一个用户和终端发送消息。在本书的开头，我提到一切都只是一个文件或一个进程。即使对于终端也是如此。这意味着我们可以使用常规重定向向终端发送数据：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The text *Hello* will now appear in the PTS2 terminal.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 文本*Hello*现在将出现在PTS2终端上。
- en: 'Sending messages to a terminal using `echo` only works if it''s the same user
    that''s logged in on the other terminal. For example, if I try to send a message
    to TTY1 where root is logged in, it doesn''t work—for a good reason:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅当发送消息的用户与另一个终端上已登录的用户相同时，使用`echo`向终端发送消息才有效。例如，如果我尝试向root已登录的TTY1发送消息，它不起作用——有一个很好的原因：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, there exists a program that allows users to write to each other''s
    terminal, assuming they have allowed it. That program is called `write`. To allow
    or disallow messages, we use the `mesg` program. If you can log in as root (or
    some other user) on a terminal, do so, and then allow messages (the letter `y`
    stands for *yes*):'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，存在一个允许用户向彼此终端写入的程序，假设他们已经允许。该程序称为`write`。要允许或禁止消息，我们使用`mesg`程序。如果您可以在终端上以root（或其他用户）登录，请这样做，然后允许消息（字母`y`代表*yes*）：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, from another user, we can write to that user and terminal:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从另一个用户，我们可以向该用户和终端写入：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That message will now appear on TTY1, where root is logged in.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 该消息现在将出现在TTY1上，其中root已登录。
- en: 'There''s another command that allows a user to write on *all* terminals. However,
    root is the only user that can write to users who have turned off messages. When
    logged in as root, issue the following command to write a message about a pending
    reboot to all logged-in users:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有另一个命令允许用户在*所有*终端上写入。但是，root是唯一可以向关闭消息的用户发送消息的用户。当以root身份登录时，请发出以下命令，向所有已登录用户写入有关即将重新启动的消息：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will display a message, shown here, on all users'' terminals:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在所有用户的终端上显示一个消息，如下所示：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Since all the terminals are represented by files on the filesystem, it's easy
    to send messages to them. The regular permissions apply, however, to prevent users
    from writing to other users or snooping on their terminal.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有终端都由文件表示在文件系统上，因此向它们发送消息很容易。然而，常规权限也适用，以防止用户向其他用户写入或窥视其终端。
- en: With the `write` program, though, users can write messages to each other quickly,
    without needing any third-party software.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`write`程序，用户可以快速地向彼此写入消息，而无需任何第三方软件。
- en: There's more…
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The `wall` program is used to warn users of a pending reboot or shutdown. For
    example, if root issues the `shutdown -h +5` command to schedule a shutdown in
    5 minutes, all users will receive a warning. That warning is sent automatically,
    using the `wall` program.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`wall`程序用于警告用户即将重新启动或关闭计算机。例如，如果root发出`shutdown -h +5`命令以安排在5分钟内关闭计算机，所有用户都将收到警告。使用`wall`程序会自动发送该警告。'
- en: See also
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'For more information about the commands covered in this recipe, see the following
    manual pages:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本配方中涵盖的命令的更多信息，请参阅以下手册页面：
- en: '`man 1 write`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 1 write`'
- en: '`man 1 wall`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 1 wall`'
- en: '`man 1 mesg`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 1 mesg`'
- en: Checking if it's a TTY
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查它是否是TTY
- en: In this recipe, we'll start looking at some of the C functions to examine TTYs.
    Here, we mean TTY in the broadest sense, meaning both TTY and PTY.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将开始查看一些C函数来检查TTY。在这里，我们指的是TTY的广义，即TTY和PTY。
- en: The program we will write here will check if stdout is a terminal. If it's not,
    it will print an error message.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里编写的程序将检查stdout是否是终端。如果不是，它将打印错误消息。
- en: Knowing how to check if stdin, stdout, or stderr are terminal devices will enable
    you to write error checks for programs that require a terminal to work.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何检查stdin、stdout或stderr是否是终端设备将使您能够为需要终端才能工作的程序编写错误检查。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll need the GCC compiler, the Make tool, and the generic
    Makefile. The generic Makefile can be downloaded from this chapter's GitHub folder,
    at https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch9.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们需要GCC编译器，Make工具和通用Makefile。通用Makefile可以从本章的GitHub文件夹下载，网址为https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch9。
- en: How to do it…
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Here, we''ll write a small program that prints an error message if stdout is
    not a terminal:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写一个小程序，如果stdout不是终端，则打印错误消息：
- en: 'Write the following small program in a file and save it as `ttyinfo.c`. We
    use two new functions here. The first one is `isatty()`, which checks if a `ttyname()`,
    which prints the terminal''s name connected to stdout (or actually the path):'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中编写以下小程序并将其保存为`ttyinfo.c`。我们在这里使用了两个新函数。第一个是`isatty()`，它检查一个`ttyname()`，它打印连接到stdout（或实际上是路径）的终端的名称：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Compile the program:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s try out the program. First, we run it without any redirections. The
    program will print the name of the terminal and the text *Hello world*:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试一下这个程序。首先，我们不使用任何重定向来运行它。程序将打印终端的名称和文本*Hello world*：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But if we were to redirect file descriptor 1 to a file, it''s no longer a terminal
    (because that file descriptor is then pointing to a file and not a terminal).
    This will print an error message, but the *Hello world* message is still redirected
    to the file:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但是，如果我们将文件描述符1重定向到文件，它就不再是终端（因为那个文件描述符指向文件而不是终端）。这将打印一个错误消息，但*Hello world*消息仍然被重定向到文件：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To prove the point, we can "redirect" file descriptor 1 to `/dev/stdout`. Everything
    will then work as usual since file descriptor 1 is then once again stdout:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了证明这一点，我们可以将文件描述符1“重定向”到`/dev/stdout`。然后一切将像往常一样工作，因为文件描述符1再次成为stdout：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Another step to prove the point is to redirect to our own terminal device.
    This will be similar to what we saw in the previous recipe when we used `echo`
    to print a text to a terminal:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个证明这一点的步骤是重定向到我们自己的终端设备。这将类似于我们在上一个配方中看到的，当我们使用`echo`将文本打印到终端时：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For the sake of experimentation, let''s open up a second terminal. Find the
    TTY name of the new terminal with the `tty` command (in my case, it''s `/dev/pts/26`).
    Then, from the first terminal, run the `ttyinfo` program again, but redirect file
    descriptor 1 (stdout) to the second terminal:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进行实验，让我们打开第二个终端。使用`tty`命令找到新终端的TTY名称（在我的情况下是`/dev/pts/26`）。然后，从第一个终端再次运行`ttyinfo`程序，但将文件描述符1（stdout）重定向到第二个终端：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'No output will show up in the *current* terminal. However, on the *second*
    terminal, we see the program''s output, with the name of the second terminal:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在*当前*终端上不会显示任何输出。但是，在*第二*终端上，我们可以看到程序的输出，以及第二个终端的名称：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `STDOUT_FILENO` macro, which we used with both `isatty()` and `ttyname()`,
    is just the integer 1—that is, file descriptor 1.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`STDOUT_FILENO`宏，它与`isatty()`和`ttyname()`一起使用，只是整数1-也就是文件描述符1。
- en: Remember that when we redirect stdout with a `>` sign, we redirect file descriptor
    1.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当我们用`>`符号重定向stdout时，我们重定向文件描述符1。
- en: Normally, file descriptor 1 is stdout, which is connected to your terminal.
    If we redirect file descriptor 1 with the `>` character to a file, it instead
    points to that file. Since the regular file isn't a terminal, we get an error
    message from the program (from the `isatty()` function's `errno` variable).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，文件描述符1是stdout，它连接到您的终端。如果我们使用`>`字符将文件描述符1重定向到文件，它将指向该文件。由于常规文件不是终端，我们会从程序（从`isatty()`函数的`errno`变量）得到一个错误消息。
- en: When we redirected file descriptor 1 back to `/dev/stdout`, it was once again
    stdout and no error message was printed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将文件描述符1重新重定向回`/dev/stdout`时，它再次成为stdout，不会打印错误消息。
- en: In the last step, when we redirected the program's output to another terminal,
    all text got redirected to that terminal. Not only that—the name of the TTY printed
    by the program was indeed that second terminal's. The reason is that the terminal
    device connected to file descriptor 1 was indeed that terminal (`/dev/pts/26`,
    in my case).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，当我们将程序的输出重定向到另一个终端时，所有文本都被重定向到该终端。不仅如此-程序打印的TTY名称确实是第二个终端的。原因是连接到文件描述符1的终端设备确实是那个终端（在我的情况下是`/dev/pts/26`）。
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information about the functions we used in the recipe, I recommend
    that you read `man 3 isatty` and `man 3 ttyname`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有关我们在配方中使用的函数的更多信息，我建议您阅读`man 3 isatty`和`man 3 ttyname`。
- en: Creating a PTY
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个PTY
- en: In this recipe, we'll create a `screen` and type away, and the characters will
    be printed to both the master and the slave. The slave is where the `screen` program
    is connected to, which is our terminal in this case. The master is usually quiet
    and runs in the background, but for demonstration purposes, we'll print the characters
    on the master as well.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个`screen`并开始输入，字符将被打印到主设备和从设备上。从设备是`screen`程序连接的地方，在这种情况下是我们的终端。主设备通常是静默的并在后台运行，但为了演示目的，我们也会在主设备上打印字符。
- en: Knowing how to create a PTY enables you to write your own terminal applications,
    such as `xterm`, Gnome Terminal, `tmux`, and so on.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何创建PTY使您能够编写自己的终端应用程序，如`xterm`，Gnome终端，`tmux`等。
- en: Getting ready
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need the GCC compiler, the Make tool, and the `screen`
    program. Installation instructions for `screen` are found in the *Technical requirements*
    section of this chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，您将需要GCC编译器，Make工具和`screen`程序。有关`screen`的安装说明，请参阅本章的*技术要求*部分。
- en: How to do it…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here, we''ll write a small program that creates a PTY. We''ll then connect
    to the slave end of this PTY—the PTS—using `screen`. We can then type characters,
    and they are printed back to us on the PTS:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写一个创建PTY的小程序。然后我们将使用`screen`连接到这个PTY的从端口-PTS。然后我们可以输入字符，它们会被打印回PTS上：
- en: 'We''ll start by writing the program for this recipe. There are a lot of new
    concepts here, so the code is broken up into several steps. Write all of the code
    in a single file, called `my-pty.c`. We''ll start by defining `_XOPEN_SOURCE`
    (for `posix_openpt()`), and include all the header files we need:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先为这个配方编写程序。这里有很多新概念，所以代码被分成了几个步骤。将所有代码写在一个名为`my-pty.c`的单个文件中。我们将首先定义`_XOPEN_SOURCE`（用于`posix_openpt()`），并包括我们需要的所有头文件：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we''ll start the `main()` function and define some variables we''ll need:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将开始`main()`函数并定义一些我们需要的变量：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, it''s time to create the PTY device with `posix_openpt()`. This will return
    a file descriptor, which we''ll save in `master`. Then, we run `grantpt()`, which
    sets the owner of the device to the current user, the group to *tty*, and changes
    the mode of the device to `620`. We must also unlock it with `unlockpt()` before
    using it. To know where we should connect, we also print the path to the slave
    device, using `ptsname()`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候使用`posix_openpt()`创建PTY设备了。这将返回一个文件描述符，我们将保存在`master`中。然后，我们运行`grantpt()`，它将把设备的所有者设置为当前用户，组设置为*tty*，并将设备的模式更改为`620`。在使用之前，我们还必须使用`unlockpt()`进行解锁。为了知道我们应该连接到哪里，我们还使用`ptsname()`打印从属设备的路径：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we create the main loop of the program. In the loop, we read a character
    from the PTS and then write it back again to the PTS. Here, we also print the
    character to the master so that we''ll see that it''s a master/slave pair. Since
    a terminal device is rather primitive, we must manually check for a **carriage
    return** character (the *Enter* key) and instead print a **newline** and a carriage
    return to make a new line:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建程序的主循环。在循环中，我们从PTS中读取一个字符，然后再次将其写回PTS。在这里，我们还将字符打印到主设备上，以便我们知道它是主/从设备对。由于终端设备相当原始，我们必须手动检查**回车**字符（*Enter*键），并且打印**换行**和回车以换行：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If no characters are received, the device connected to the slave has disconnected.
    If that is the case, we return, and hence exit from the program:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有收到任何字符，则连接到从属设备的设备已断开。如果是这种情况，我们将返回，因此退出程序：
- en: '[PRE30]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, it''s time to compile the program so that we can run it:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候编译程序以便我们可以运行它了：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, run the program in your current terminal and make a note of the slave
    path:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在当前终端中运行程序并记下从主设备获得的从属路径：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Before we move on to connect to it, let''s examine the device. Here, we''ll
    see that my user owns it, and it''s indeed a *character special* device, common
    for terminals:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续连接之前，让我们检查一下设备。在这里，我们将看到我的用户拥有它，它确实是一个*字符特殊*设备，对终端来说很常见：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, open a new terminal and connect to the slave path you got from the master.
    In my case, it''s `/dev/pts/31`. To connect to it, we''ll use `screen`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开一个新的终端并连接到您从主设备获得的从属路径。在我的情况下，它是`/dev/pts/31`。要连接到它，我们将使用`screen`：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, we can type away, and all the characters will be printed back to us. They
    will also appear on the master. To disconnect and quit `screen`, first hit *Ctrl*
    + *A* and then type a single *K*, as in kill. A question will then present to
    you (*Really kill this window [y/n]*); type *Y* here. You'll now see *Disconnected*
    in the terminal where you started `my-pty`, and the program will exit.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以随意输入，所有字符都将被打印回给我们。它们也将出现在主设备上。要断开并退出`screen`，首先按下*Ctrl* + *A*，然后输入一个单独的*K*，如kill。然后会出现一个问题（*真的要杀死这个窗口吗[y/n]*）；在这里输入*Y*。现在您将在启动`my-pty`的终端中看到*已断开*，程序将退出。
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We open a new PTY by using the `posix_openpt()` function. We set to both read
    and write using `O_RDWR`. By opening a new PTY, a new character device is created
    in `/dev/pts/`. It is that character device we later connected to using `screen`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`posix_openpt()`函数打开一个新的PTY。我们使用`O_RDWR`设置为读和写。通过打开一个新的PTY，在`/dev/pts/`中创建了一个新的字符设备。这就是我们后来使用`screen`连接的字符设备。
- en: Since `posix_openpt()` returns a file descriptor, we can use all the regular
    system calls for file descriptors to read and write data, such as `read` and `write`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`posix_openpt()`返回一个文件描述符，我们可以使用所有常规的文件描述符系统调用来读取和写入数据，比如`read`和`write`。
- en: A terminal device, such as the one we created here, is rather primitive. If
    we press *Enter*, the cursor will return to the start of the line. No new line
    will be created first. That's actually how the *Enter* key used to work. To solve
    this in our program, we check if the character read is a carriage return (that's
    what the *Enter* key sends), and if it is, we instead first print a newline character
    and then a carriage return.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 终端设备，比如我们在这里创建的设备，相当原始。如果我们按下*Enter*，光标将返回到行的开头。首先不会创建新行。这实际上是*Enter*键以前的工作方式。为了解决这个问题，我们在程序中检查读取的字符是否是回车（*Enter*键发送的内容），如果是，我们将首先打印一个换行字符，然后是一个回车。
- en: If we only printed the newline character we would only get a new line, right
    under our current cursor. This behavior is a leftover from the old-school teletype
    devices with paper.After we have printed the current character (or newline and
    carriage return), we `fflush()`. The reason is that the character printed on the
    master end (where the `my-pty` program is running) isn't followed by a new line.
    Stdout is line-buffered, meaning it only flushes on a line break. But since we
    want to see each character as it's typed we must flush it on every character,
    using `fflush()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只打印换行符，我们只会得到一个新行，就在当前光标下面。这种行为是从旧式电传打字机设备留下的。在打印当前字符（或换行和回车）后，我们使用`fflush()`。原因是在主端打印的字符（`my-pty`程序运行的地方）后面没有新行。Stdout是行缓冲的，这意味着它只在换行时刷新。但是由于我们希望在输入每个字符时都能看到它，我们必须在每个字符上刷新它，使用`fflush()`。
- en: See also
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'There''s a lot of useful information in the manual pages. I particularly recommend
    you read the following manual pages: `man 3 posix_openpt`, `man 3 grantpt`, `man
    3 unlockpt`, `man 4 pts`, and `man 4 tty`.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 手册页面中有很多有用的信息。我特别建议您阅读以下手册页面：`man 3 posix_openpt`，`man 3 grantpt`，`man 3 unlockpt`，`man
    4 pts`和`man 4 tty`。
- en: Disabling echo for password prompts
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 禁用密码提示的回显
- en: To protect users' passwords from shoulder surfing, it's always best to hide
    what they type. The way to hide a password from being displayed is to disable
    **echoing**. In this recipe, we'll write a simple password program with echoing
    disabled.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止用户的密码被肩窥，最好隐藏他们输入的内容。隐藏密码不被显示的方法是禁用**回显**。在这个示例中，我们将编写一个简单的密码程序，其中禁用了回显。
- en: Knowing how to disable echoing is key when writing programs that take some form
    of secret input, such as a password or a key.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写需要某种秘密输入的程序（如密码或密钥）时，了解如何禁用回显是关键。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need the GCC compiler, the Make tool, and the generic
    Makefile.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你需要GCC编译器、Make工具和通用的Makefile。
- en: How to do it…
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this recipe, we'll build a small program with a password prompt
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将构建一个带有密码提示的小程序
- en: 'Since the code in this recipe will be rather long and some parts a bit arcane,
    I have split up the code into several steps. Note, however, that all code should
    go into a single file. Name the file `passprompt.c`. Let''s start with the `include`
    lines, the `main()` function, and the variables we''ll need. The struct named
    `term` of type `termios` is a special structure that holds the attributes for
    the terminal:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于本示例中的代码将会相当长，有些部分有点晦涩，我已经将代码分成了几个步骤。但请注意，所有的代码都应该放在一个文件中。将文件命名为`passprompt.c`。让我们从`include`行、`main()`函数和我们需要的变量开始。名为`term`的`termios`类型的结构是一个特殊的结构，它保存了终端的属性：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we''ll start by disabling echoing, but first, we need to get all the
    current settings of the terminal by using `tcgetattr()`. Once we have all the
    settings, we modify them to disable echoing. The way we do it is to `ECHO`. The
    `~` sign negates a value. More on this in the *How it works…* section later:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将首先禁用回显，但首先需要使用`tcgetattr()`获取终端的所有当前设置。一旦我们获得了所有设置，我们就修改它们以禁用回显。我们这样做的方式是使用`ECHO`。`~`符号否定一个值。稍后在*它是如何工作...*部分会详细介绍：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we write the code for the password prompt; nothing new here that we don''t
    already know:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们编写密码提示的代码；这里没有什么新鲜的，我们已经知道了：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, before we exit the program, we must turn on echoing again; otherwise,
    it will remain off even after the program has exited. The way to do that is to
    `ECHO`. This will reverse what we previously did:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在退出程序之前，我们必须再次打开回显；否则，即使程序退出后，回显也将保持关闭。这样做的方法是`ECHO`。这将撤销我们之前所做的事情：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s compile the program:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编译程序：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we can try the program, and we''ll notice that we don''t see what we type:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试这个程序，我们会注意到我们看不到自己输入的内容：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The way to make changes to the terminal with `tcsetattr()` is to get the current
    attributes with `tcgetattr()` and then modify them, and then finally apply those
    changed attributes to the terminal.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`tcsetattr()`对终端进行更改的方法是使用`tcgetattr()`获取当前属性，然后修改它们，最后将这些更改后的属性应用到终端上。
- en: The first argument to both `tcgetattr()` and `tcsetattr()` is the file descriptor
    we want to change. In our case, it's stdin.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcgetattr()`和`tcsetattr()`的第一个参数都是我们要更改的文件描述符。在我们的情况下，是stdin。'
- en: The second argument to `tcgetattr()` is the struct where the attributes will
    be saved.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcgetattr()`的第二个参数是属性将被保存的结构。'
- en: The second argument to `tcsetattr()` determines when the changes will have an
    effect. Here, we use `TCSAFLUSH`, which means that changes occur after all output
    is written, and all input received but not read will be discarded.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcsetattr()`的第二个参数确定更改何时生效。在这里，我们使用`TCSAFLUSH`，这意味着更改发生在所有输出被写入后，所有接收但未读取的输入将被丢弃。'
- en: The third argument to `tcsetattr()` is the struct that contains the attributes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcsetattr()`的第三个参数是包含属性的结构。'
- en: To save and set attributes, we need a structure called `termios` (the same name
    as the header file we use). That structure contains five members, four of which
    are the modes. These are input modes (`c_iflag`), output modes (`c_oflag`), control
    mode (`c_cflag`), and local mode (`c_lflag`). What we change here is the local
    mode.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存和设置属性，我们需要一个名为`termios`的结构（与我们使用的头文件同名）。该结构包含五个成员，其中四个是模式。这些是输入模式（`c_iflag`）、输出模式（`c_oflag`）、控制模式（`c_cflag`）和本地模式（`c_lflag`）。我们在这里改变的是本地模式。
- en: First, we have the current attributes in the `c_lflag` member, which is an unsigned
    integer that's built up from a bunch of bits. Those bits are the attributes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在`c_lflag`成员中有当前的属性，它是一个无符号整数，由一堆位组成。这些位就是属性。
- en: Then, to turn off a setting—for example, echoing in our case—we negate the `ECHO`
    macro ("inverting" it) and then add it back to `c_lflag` with bitwise AND (the
    `&` sign).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要关闭一个设置，例如，在我们的情况下关闭回显，我们对`ECHO`宏进行否定（"反转"它），然后使用按位与（`&`符号）将其添加回`c_lflag`。
- en: The `ECHO` macro is `010` (octal 10), or 8 in decimal, which is `00001000` in
    binary (with 8 bits). Negated, it is `11110111`. A bitwise AND operation is then
    carried out on those bits with the other bits from the original settings.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`ECHO`宏是`010`（八进制10），或者十进制8，二进制中是`00001000`（8位）。取反后是`11110111`。然后对这些位与原始设置的其他位进行按位与操作。'
- en: The result of the bitwise AND operation is then applied to the terminal with
    `tcsetattr()`, which turns off echoing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 按位与操作的结果然后应用到终端上，使用`tcsetattr()`关闭回显。
- en: Before we end the program, we reverse the process by a bitwise OR operation
    on the new value with the `ECHO` value. Then, we apply that value with `tcsetattr()`,
    turning on echoing again.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束程序之前，我们通过对新值进行按位或操作来逆转这个过程，然后使用`tcsetattr()`应用该值，再次打开回显。
- en: There's more…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are lots and lots of attributes we can set this way—for example, it's
    possible to disable flushing on interrupt and quit signals, and so on. The `man
    3 tcsetattr()` manual page has complete lists of macros to use for each of the
    modes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过这种方式设置很多属性，例如，可以禁用中断和退出信号的刷新等。`man 3 tcsetattr()`手册页中列出了每种模式使用的宏的完整列表。
- en: Reading the terminal size
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取终端大小
- en: In this recipe, we'll continue digging around our terminal. Here, we write a
    funny little program that reports the size of the terminal live. As you resize
    your terminal window (assuming you are using an X console application), you'll
    instantly see the new size being reported.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将继续深入研究我们的终端。在这里，我们编写一个有趣的小程序，实时报告终端的大小。当你调整终端窗口的大小时（假设你正在使用X控制台应用程序），你会立即看到新的大小被报告。
- en: To make this work, we'll make use of both a special `ioctl()` function.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个工作，我们将使用一个特殊的`ioctl()`函数。
- en: Knowing how to use these two tools, escape sequences, and `ioctl()` will enable
    you to do some amusing things with the terminal.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用这两个工具、转义序列和`ioctl()`将使您能够在终端上做一些有趣的事情。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To make the most of this recipe, it's best to use an `xterm`, `rxvt`, *Konsole*,
    *Gnome Terminal*, and so on.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分利用这个配方，最好使用`xterm`，`rxvt`，*Konsole*，*Gnome Terminal*等。
- en: You'll also need the GCC compiler, the Make tool, and the generic Makefile.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要GCC编译器，Make工具和通用Makefile。
- en: How to do it…
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Here, we will write a program that first clears the screen using a special
    escape sequence, then fetches the terminal''s size and prints to the screen:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写一个程序，首先使用特殊的转义序列清除屏幕，然后获取终端的大小并打印到屏幕上：
- en: 'Write the following code in a file and save it as `terminal-size.c`. The program
    uses an endless loop, so to quit the program, we must use *Ctrl* + *C*. On each
    iteration of the loop, we first clear the screen by printing a special *escape
    sequence*. Then, we get the terminal size with `ioctl()` and print the size on
    the screen:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码并将其保存为`terminal-size.c`。程序使用一个无限循环，因此要退出程序，我们必须使用*Ctrl* + *C*。在循环的每次迭代中，我们首先通过打印特殊的*转义序列*来清除屏幕。然后，我们使用`ioctl()`获取终端大小并在屏幕上打印大小：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Compile the program:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, run the program in a terminal window. As the program is running, resize
    the window. You''ll notice that the size is instantly updated. Quit the program
    with *Ctrl* + *C*:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在终端窗口中运行程序。当程序正在运行时，调整窗口大小。您会注意到大小会立即更新。使用*Ctrl* + *C*退出程序：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: How it works…
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, we define a structure name `termsize`, with the `winsize` type. We will
    save the terminal size in this structure later. The structure has two members
    (actually four, but only two are used). The members are `ws_row` for the number
    of rows and `wc_col` for the number of columns.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个名为`termsize`的结构，类型为`winsize`。我们将在这个结构中保存终端大小。该结构有两个成员（实际上有四个，但只使用了两个）。成员是`ws_row`表示行数和`wc_col`表示列数。
- en: Then, to clear the screen, we use `printf()` to print a special escape sequence,
    `\033[1;1H\033[2J`. The `\033` sequence is the escape code. After the escape code,
    we have a `[` character, then we have the actual code telling the terminal what
    to do. The first one, `1;1H`, moves the cursor to position 1,1 (the first row
    and first column). Then, we use the `\033` escape code again so that we can use
    another code. First, we have the `[` character, just as before. Then, we have
    the `[2J` code, which means to erase the entire display.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了清除屏幕，我们使用`printf()`打印一个特殊的转义序列，`\033[1;1H\033[2J`。`\033`序列是转义码。在转义码之后，我们有一个`[`字符，然后我们有实际的代码告诉终端要做什么。第一个`1;1H`将光标移动到位置1,1（第一行和第一列）。然后，我们再次使用`\033`转义码，以便我们可以使用另一个代码。首先，我们有`[`字符，就像以前一样。然后，我们有`[2J`代码，这意味着擦除整个显示。
- en: Once we have cleared the screen and moved the cursor, we use `ioctl()` to get
    the terminal size. The first argument is the file descriptor; here, we use stdout.
    The second argument is the command to send; here, it's `TIOCGWINSZ` to get the
    terminal size. These macros/commands can be found in the `man 2 ioctl_tty` manual
    page. The third argument is the `winsize` structure.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们清除了屏幕并移动了光标，我们使用`ioctl()`来获取终端大小。第一个参数是文件描述符；在这里，我们使用stdout。第二个参数是要发送的命令；在这里，它是`TIOCGWINSZ`以获取终端大小。这些宏/命令可以在`man
    2 ioctl_tty`手册页中找到。第三个参数是`winsize`结构。
- en: Once we have the sizes in the `winsize` structure, we print the values using
    `printf()`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`winsize`结构中有了尺寸，我们就使用`printf()`打印值。
- en: To avoid draining the system resources, we sleep for 0.1 seconds before the
    next iteration.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免耗尽系统资源，我们在下一次迭代之前睡眠0.1秒。
- en: There's more…
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In the `man 4 console_codes` manual page, there are lots and lots of other codes
    you can use. You can do everything from using colors to bold fonts, to moving
    the cursor, to ringing the terminal bell, and so on.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`man 4 console_codes`手册页中，有许多其他代码可以使用。您可以做任何事情，从使用颜色到粗体字体，到移动光标，到响铃终端等等。
- en: 'For example, to print *Hello* in blinking magenta and then reset to the default
    values, you can use this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要以闪烁的品红色打印*Hello*，然后重置为默认值，您可以使用以下命令：
- en: '[PRE44]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note, though, that not all terminals can blink.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，并非所有终端都能闪烁。
- en: See also
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information about `ioctl()`, see both the `man 2 ioctl` and `man 2
    ioctl_tty` manual pages. The latter contains information about the `winsize` struct
    and the macros/commands.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`ioctl()`的更多信息，请参阅`man 2 ioctl`和`man 2 ioctl_tty`手册页。后者包含有关`winsize`结构和宏/命令的信息。
