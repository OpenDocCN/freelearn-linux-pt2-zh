- en: '*Chapter 10*: Using Different Kinds of IPC'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：使用不同类型的IPC'
- en: In this chapter, we will learn about the various ways we can communicate between
    processes via so-called **inter-process communication** (**IPC**). We will write
    various programs that use different kinds of IPC, from signals and pipes to FIFOs,
    message queues, shared memory, and sockets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习通过所谓的**进程间通信**（**IPC**）的各种方式。我们将编写使用不同类型的IPC的各种程序，从信号和管道到FIFO、消息队列、共享内存和套接字。
- en: Processes sometimes need to exchange information—for example, in the case of
    a client and a server program running on the same computer. It could also be a
    process that has forked into two processes, and they need to communicate somehow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 进程有时需要交换信息-例如，在同一台计算机上运行的客户端和服务器程序的情况下。也可能是一个分叉成两个进程的进程，它们需要以某种方式进行通信。
- en: There are multiple ways in which this IPC can happen. In this chapter, we'll
    learn about some of the most common ones.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种IPC可以以多种方式进行。在本章中，我们将学习一些最常见的方式。
- en: Knowing about IPC is essential if you want to write more than the most basic
    of programs. Sooner or later, you'll have a program consisting of multiple pieces
    or multiple programs that needs to share information.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想编写不仅仅是最基本程序的程序，了解IPC是必不可少的。迟早，您将拥有由多个部分或多个程序组成的程序，需要共享信息。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Using signals for IPC—building a client for the daemon
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用信号进行IPC-为守护程序构建客户端
- en: Communicating with a pipe
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道进行通信
- en: FIFO—using it in the shell
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FIFO-在shell中使用它
- en: FIFO—building the sender
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FIFO-构建发送方
- en: FIFO—building the receiver
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FIFO-构建接收方
- en: Message queues—creating the sender
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息队列-创建发送方
- en: Message queues—creating the receiver
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息队列-创建接收方
- en: Communicating between child and parent with shared memory
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用共享内存在子进程和父进程之间进行通信
- en: Using shared memory between unrelated processes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不相关的进程之间使用共享内存
- en: Unix socket—creating the server
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix套接字-创建服务器
- en: Unix socket—creating the client
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unix套接字-创建客户端
- en: Let's get started!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you'll need the GCC compiler, the Make tool, and the generic
    Makefile from [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097), *Diving
    Deep into C in Linux*. If you haven't installed these tools yet, please see [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the Necessary Tools
    and Writing Our First Linux Programs*, for installation instructions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您将需要[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)中的GCC编译器，Make工具和通用的Makefile，*深入Linux中的C语言*。如果您尚未安装这些工具，请参阅[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)，*获取必要的工具并编写我们的第一个Linux程序*，以获取安装说明。
- en: All the code samples—and the generic Makefile—for this chapter can be downloaded
    from GitHub at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例和通用的Makefile都可以从GitHub上下载，网址为[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10)。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3u3y1C0](https://bit.ly/3u3y1C0)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接以查看代码演示视频：[https://bit.ly/3u3y1C0](https://bit.ly/3u3y1C0)
- en: Using signals for IPC – building a client for the daemon
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用信号进行IPC-为守护程序构建客户端
- en: We have already used signals several times in this book. However, when we did,
    we always used the `kill` command to send the `my-daemon-v2`, from [*Chapter 6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245),
    *Spawning Processes and Using Job Control*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经多次使用了信号。但是，当我们这样做时，我们总是使用`kill`命令来发送`my-daemon-v2`，来自[*第6章*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245)，*生成进程和使用作业控制*。
- en: This is a typical example of when signals are used for **IPC**. The daemon has
    a small "client program" that controls it, so that it can stop it, restart it,
    reload its configuration file, and so on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用信号进行**IPC**的典型示例。守护程序有一个小的“客户端程序”来控制它，以便可以停止它，重新启动它，重新加载其配置文件等。
- en: Knowing how to use signals for IPC is a solid start in writing programs that
    can communicate between them.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何使用信号进行IPC是编写可以相互通信的程序的坚实起点。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need the GCC compiler, the Make tool, and the generic
    Makefile. You will also need the `my-daemon-v2.c` file from [*Chapter 6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245),
    *Spawning Processes and Using Job Control*. There is a copy of that file in this
    chapter's GitHub directory at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你需要GCC编译器，Make工具和通用的Makefile。您还需要[*第6章*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245)中的`my-daemon-v2.c`文件，*生成进程和使用作业控制*。在本章的GitHub目录中有该文件的副本，网址为[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch10)。
- en: How to do it…
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll add a small client program to the daemon from [*Chapter
    6*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245), *Spawning Processes and Using
    Job Control*. This program will send signals to the daemon, just like the `kill`
    command does. However, this program will only send signals to the daemon, no other
    process:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将向[*第6章*](B13043_06_Final_SK_ePub.xhtml#_idTextAnchor245)中的守护程序添加一个小的客户端程序，*生成进程和使用作业控制*。这个程序将向守护程序发送信号，就像`kill`命令一样。但是，这个程序只会向守护程序发送信号，不会发送给其他进程：
- en: 'Write the following code in a file and save it as `my-daemon-ctl.c`. This program
    is a bit longer, so it''s split up into several steps. All the code goes into
    the same file, though. We''ll start with the include lines, the prototype for
    the usage function, and all the variables we''ll need:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中编写以下代码并将其保存为`my-daemon-ctl.c`。这个程序有点长，所以它分成了几个步骤。不过所有的代码都放在同一个文件中。我们将从包含行、使用函数的原型和我们需要的所有变量开始：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we want to be able to parse command-line options. We''ll only need two
    options; that is, `-h` for help and `-k` to kill the daemon. The default is to
    show the status of the daemon:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们希望能够解析命令行选项。我们只需要两个选项；即，`-h`用于帮助，`-k`用于杀死守护进程。默认情况下是显示守护进程的状态：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let''s open the `cmdline` file in `/proc`. Then, we must open that file
    and read the complete command-line path from it:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打开`/proc`中的`cmdline`文件。然后，我们必须打开该文件并从中读取完整的命令行路径：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we have both the PID and the full command line, we can double-check
    that the PID belongs to `/usr/local/sbin/my-daemon-v2` and not some other process:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们既有PID又有完整的命令行，我们可以再次检查PID是否属于`/usr/local/sbin/my-daemon-v2`而不是其他进程：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we give the `-k` option to the program, we must set the `killit` variable
    to 1\. So, at this point, we must kill the process. Otherwise, we just print a
    message stating that the daemon is running:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们给程序加上`-k`选项，我们必须将`killit`变量设置为1。因此，在这一点上，我们必须杀死进程。否则，我们只是打印一条消息，说明守护进程正在运行：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we create the function for the `printUsage()` function:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们为`printUsage()`函数创建函数：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can compile the program:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以编译程序了：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before we go any further, make sure you have disabled and stopped the `systemd`
    service for the daemon from [*Chapter 7*](B13043_07_Final_SK_ePub.xhtml#_idTextAnchor299)*,
    Using systemd to Handle Your Daemons*:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，请确保你已经禁用并停止了[*第7章*](B13043_07_Final_SK_ePub.xhtml#_idTextAnchor299)*，使用systemd管理守护进程*中的`systemd`服务：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, compile the daemon (`my-daemon-v2.c`) if you haven''t done so already:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译守护进程（`my-daemon-v2.c`），如果你还没有这样做的话：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, start the daemon manually (no `systemd` service this time):'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，手动启动守护进程（这次没有`systemd`服务）：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can try out our new program to control the daemon. Notice that we can''t
    kill the daemon as a regular user:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试使用我们的新程序来控制守护进程。请注意，我们不能像普通用户一样杀死守护进程：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we rerun the program once the daemon has been killed, it will tell us that
    there''s no PID file and that the daemon is therefore not running:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果守护进程被杀死后我们重新运行程序，它会告诉我们没有PID文件，因此守护进程没有运行：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Since the daemon creates a PID file, we can use that file to get the PID of
    the running daemon. The daemon removes the PID file when it is terminated, so
    we can assume that the daemon isn't running if there's no PID file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于守护进程创建了PID文件，我们可以使用该文件获取正在运行的守护进程的PID。当守护进程终止时，它会删除PID文件，因此如果没有PID文件，我们可以假设守护进程没有运行。
- en: If the PID file does exist, first, we read the PID from the file. Then, we use
    the PID to assemble the path to that PID's `cmdline` file in the `/proc` filesystem.
    Each process on a Linux system has a directory in the `/proc` filesystem. Inside
    each process's directory, there is a file called `cmdline`. That file contains
    the complete command line of the process. For example, if the daemon was started
    from the current directory, it contains `./my-daemon-v2`, while if it was started
    from `/usr/local/sbin/my-daemon-v2`, it contains that complete path.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果PID文件存在，首先我们从文件中读取PID。然后，我们使用PID来组装该PID的`/proc`文件系统中的`cmdline`文件的路径。Linux系统上的每个进程都在`/proc`文件系统中有一个目录。在每个进程的目录中，有一个名为`cmdline`的文件。该文件包含进程的完整命令行。例如，如果守护进程是从当前目录启动的，它包含`./my-daemon-v2`，而如果它是从`/usr/local/sbin/my-daemon-v2`启动的，它包含完整路径。
- en: For example, if the PID of the daemon is `12345`, the complete path to `cmdline`
    is `/proc/12345/cmdline`. That is what we assemble with `sprintf()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果守护进程的PID是`12345`，那么`cmdline`的完整路径是`/proc/12345/cmdline`。这就是我们用`sprintf()`组装的内容。
- en: Then, we read the content of `cmdline`. Later, we use that file's content to
    verify that the PID does match a process with the name `my-daemon-v2`. This is
    a safety measure so that we don't kill the wrong process by mistake. If the daemon
    is killed with the `KILL` signal, it has no chance to remove the PID file. If
    another process gets the same PID in the future, we run the risk of killing that
    process instead. PID numbers will eventually be reused.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们读取`cmdline`的内容。稍后，我们使用该文件的内容来验证PID是否与名称为`my-daemon-v2`的进程匹配。这是一项安全措施，以免误杀错误的进程。如果使用`KILL`信号杀死守护进程，它就没有机会删除PID文件。如果将来另一个进程获得相同的PID，我们就有可能误杀该进程。PID号最终会被重用。
- en: When we have the PID of the daemon and have verified that it does belong to
    the correct process, we will either get its status or kill it, depending on whatever
    we specified with the `-k` option.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有了守护进程的PID并验证它确实属于正确的进程时，我们将根据`-k`选项指定的内容获取其状态或将其杀死。
- en: This is how many control programs work that are used to control complex daemons.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是许多用于控制复杂守护进程的控制程序的工作方式。
- en: See also
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information about the `kill()` system call, see the `man 2 kill` manual
    page.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`kill()`系统调用的更多信息，请参阅`man 2 kill`手册页。
- en: Communicating with a pipe
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道进行通信
- en: In this recipe, we'll create a program that forks and then communicates between
    two processes using a **pipe**. Sometimes, when we **fork** a process, the **parent**
    and the **child** need a way to communicate. A pipe is often a simple way to do
    just that.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个程序，进行分叉，然后使用**管道**在两个进程之间进行通信。有时，当我们**分叉**一个进程时，**父进程**和**子进程**需要一种通信方式。管道通常是实现这一目的的简单方法。
- en: Knowing how to communicate and interchange data between a parent and a child
    process is important when you're writing more complex programs.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写更复杂的程序时，了解如何在父进程和子进程之间进行通信和交换数据是很重要的。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll only need the GCC compiler, the Make tool, and the generic
    Makefile.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们只需要GCC编译器、Make工具和通用Makefile。
- en: How to do it…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s write a simple program that forks:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的分叉程序：
- en: Write the following code in a file and name it `pipe-example.c`. We'll go through
    the code step by step. Remember that all the code goes in the same file.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入一个文件中，并将其命名为`pipe-example.c`。我们将逐步介绍代码。请记住，所有代码都在同一个文件中。
- en: 'We''ll start with the include lines and the `main()` function. Then, we''ll
    create an integer array of size 2\. The pipe will use that array later. The first
    integer in the array (0) is the file descriptor for the read end of the pipe.
    The second integer (1) is for the write end of the pipe:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从包含行和`main()`函数开始。然后，我们将创建一个大小为2的整数数组。管道将在以后使用该数组。数组中的第一个整数（0）是管道读端的文件描述符。第二个整数（1）是管道的写端：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we will create the pipe using the `pipe()` system call. We''ll give it
    the integer array as an argument. After that, we''ll fork using the `fork()` system
    call:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`pipe()`系统调用创建管道。我们将把整数数组作为参数传递给它。之后，我们将使用`fork()`系统调用进行分叉：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we are inside the parent process, we close the read end (since we only want
    to write from the parent). Then, we write a message to the pipe''s file descriptor
    (the write end) using `dprintf()`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在父进程中，我们关闭读端（因为我们只想从父进程中写入）。然后，我们使用`dprintf()`向管道的文件描述符（写端）写入消息：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside the child, we do the opposite; that is, we close the write end of the
    pipe. Then, we read the data in the pipe using the `read()` system call. Finally,
    we print the message using `printf()`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在子进程中，我们做相反的操作；也就是说，我们关闭管道的写端。然后，我们使用`read()`系统调用从管道中读取数据。最后，我们使用`printf()`打印消息：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, compile the program so that we can run it:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译程序，以便我们可以运行它：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s run the program. The parent sends the message `Hello from parent` to
    the child using a pipe. Then, it''s the child that prints that message on the
    screen:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行程序。父进程使用管道向子进程发送消息`Hello from parent`。然后，子进程在屏幕上打印该消息：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `pipe()` system call returns two file descriptors to the integer array.
    The first one, `pipefd[0]`, is the read end of the pipe, while the other, `pipefd[1]`,
    is the write end of the pipe. In the parent, we write a message to the *write
    end* of the pipe. Then, in the child process, we read that data from the *read
    end* of the pipe. But before we do any reading or writing, we close the end of
    the pipe that we're not using in the respective process.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipe()`系统调用将两个文件描述符返回给整数数组。第一个，`pipefd[0]`，是管道的读端，而另一个，`pipefd[1]`，是管道的写端。在父进程中，我们向管道的*写端*写入消息。然后，在子进程中，我们从管道的*读端*读取数据。但在进行任何读写操作之前，我们关闭在各自进程中没有使用的管道端。'
- en: Pipes are one of the more common IPC techniques around. But they do have a drawback
    in that they can only be used between related processes; that is, processes with
    a common parent (or a parent and a child).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是一种比较常见的IPC技术。但是它们有一个缺点，即它们只能在相关进程之间使用；也就是说，具有共同父进程（或父进程和子进程）的进程。
- en: 'There''s another form of pipe that overcomes this limitation: the so-called
    *named pipe*. Another name for a named pipe is FIFO. That''s what we will cover
    in the next recipe.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种形式的管道可以克服这个限制：所谓的*命名管道*。命名管道的另一个名称是FIFO。这是我们将在下一个示例中介绍的内容。
- en: See also
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: More information about the `pipe()` system call can be found in the `man 2 pipe`
    manual page.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`pipe()`系统调用的更多信息可以在`man 2 pipe`手册页中找到。
- en: FIFO – using it in the shell
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FIFO - 在shell中使用它
- en: In the previous recipe, I mentioned that there's a disadvantage to the `pipe()`
    system call—it can only be used between related processes. But there's another
    type of pipe we can use, called a **named pipe**. Another name for it is **First
    In, First Out** (**FIFO**). Named pipes can be used between any processes, related
    or not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我提到`pipe()`系统调用有一个缺点——它只能在相关进程之间使用。但是，我们可以使用另一种类型的管道，称为**命名管道**。另一个名称是**先进先出**（**FIFO**）。命名管道可以在任何进程之间使用，无论是否相关。
- en: A named pipe, or a FIFO, is actually a special kind of file. The `mkfifo()`
    function creates that file on the filesystem, just like any other file. Then,
    we use that file to read and write data between processes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 命名管道，或者FIFO，实际上是一种特殊类型的文件。`mkfifo()`函数在文件系统上创建该文件，就像创建任何其他文件一样。然后，我们可以使用该文件在进程之间读取和写入数据。
- en: There's also a command named `mkfifo`, which we can use directly from the shell
    to create named pipes. We can use this to pipe data between unrelated commands.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`mkfifo`的命令，我们可以直接从shell中使用它来创建命名管道。我们可以使用它在不相关的命令之间传输数据。
- en: In this introduction to named pipes, we'll cover the `mkfifo` command. In the
    next two recipes, we'll write a C program using the `mkfifo()` function and then
    another program to read the pipe's data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命名管道的介绍中，我们将介绍`mkfifo`命令。在接下来的两个示例中，我们将编写一个使用`mkfifo()`函数的C程序，然后再编写另一个程序来读取管道的数据。
- en: Knowing how to use named pipes will give you much more flexibility as a user,
    a system administrator, and a developer. You are no longer bound to only using
    pipes between related processes. You'll be free to pipe data between any processes
    or commands on the system—even between different users.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用命名管道将为您作为用户、系统管理员和开发人员提供更多的灵活性。您不再只能在相关进程之间使用管道。您可以自由地在系统上的任何进程或命令之间传输数据，甚至可以在不同的用户之间传输数据。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we won't write any programs, so there are no special requirements.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们不会编写任何程序，因此没有特殊要求。
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'In this recipe, we''ll explore the `mkfifo` command and learn how to use it
    to pipe data between unrelated processes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将探讨`mkfifo`命令，并学习如何使用它在不相关的进程之间传输数据：
- en: 'We''ll start by creating a named pipe—a FIFO file. We''ll create it in the
    `/tmp` directory, which is commonplace for temporary files like this. You can,
    however, create it wherever you like:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个命名管道——一个FIFO文件。我们将在`/tmp`目录中创建它，这是临时文件的常见位置。但是，您可以在任何您喜欢的地方创建它：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s confirm that''s it indeed a FIFO by using the `file` and `ls` commands.
    Note the current permission mode of my FIFO. It can be read by everyone. This
    can differ on your system, though, depending on your `umask`. But we should be
    vigilant of this in case we are going to pipe sensitive data. In that case, we
    can change it using the `chmod` command:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过使用`file`和`ls`命令来确认这确实是一个FIFO。请注意我的FIFO的当前权限模式。它可以被所有人读取。但是在您的`umask`取决于您的系统，这可能会有所不同。但是，如果我们要传输敏感数据，我们应该对此保持警惕。在这种情况下，我们可以使用`chmod`命令进行更改：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can try sending data to the pipe. Since the pipe is a file, we will
    use redirections here instead of the pipe symbol. In other words, we redirect
    data to the pipe. Here, we''ll redirect the output of the `uptime` command to
    the pipe. Once we''ve redirected the data to the pipe, the process will hang,
    which is normal since there''s no one on the other end receiving the data. It
    doesn''t actually hang; it *blocks*:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以尝试向管道发送数据。由于管道是一个文件，我们将在这里使用重定向而不是管道符号。换句话说，我们将数据重定向到管道。在这里，我们将`uptime`命令的输出重定向到管道。一旦我们将数据重定向到管道，进程将挂起，这是正常的，因为没有人在另一端接收数据。它实际上并不挂起；它*阻塞*：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Open up a new terminal and type in the following command to receive the data
    from the pipe. Note that the process in the first terminal will now finish:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并输入以下命令以从管道接收数据。请注意，第一个终端中的进程现在将结束：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can also do the reverse; that is, we can open the receiving end first and
    then send data to the pipe. This will **block** the receiving process until it
    gets some data. Run the following command to set up the receiving end, and leave
    it running:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以做相反的事情；也就是说，我们可以首先打开接收端，然后向管道发送数据。这将**阻塞**接收进程，直到获得一些数据。运行以下命令设置接收端，并让其运行：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we send data to the pipe using the same `uptime` command. Notice that
    once the data is received, the first process will end:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用相同的`uptime`命令向管道发送数据。请注意，一旦数据被接收，第一个进程将结束：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It''s also possible to send data to a FIFO from multiple processes. Open up
    three new terminals. In each terminal, type the following command but replace
    1 with 2 for the second terminal and 3 for the third:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以从多个进程向FIFO发送数据。打开三个新的终端。在每个终端中，输入以下命令，但将第二个终端替换为2，第三个终端替换为3：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, open up another terminal and type in the following command. This will
    receive all the messages:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开另一个终端并输入以下命令。这将接收所有消息：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A FIFO is simply a file on the filesystem, albeit a special file. Once we redirect
    data to a FIFO, that process will **block** (or "hang") until the data is received
    on the other end.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: FIFO只是文件系统上的一个文件，尽管是一个特殊的文件。一旦我们将数据重定向到FIFO，该进程将**阻塞**（或“挂起”），直到另一端接收到数据。
- en: Likewise, if we start the receiving process first, that process will block until
    it gets the pipe's data. The reason for this behavior is that a FIFO isn't a regular
    file that we can save data in. We can only redirect data with it; that is, it's
    just a *pipe*. So, if we send data to it, but there's nothing on the other end,
    the process will just wait there until someone receives it on the other end. The
    data has nowhere to go in the pipe until someone connects to the receiving end.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们首先启动接收进程，该进程将阻塞，直到获取管道的数据。这种行为的原因是FIFO不是我们可以保存数据的常规文件。我们只能用它重定向数据；也就是说，它只是一个*管道*。因此，如果我们向其发送数据，但另一端没有任何东西，进程将在那里等待，直到有人在另一端接收它。数据在管道中无处可去，直到有人连接到接收端。
- en: There's more…
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you have multiple users on the system, you can try sending messages to them
    using FIFOs. Doing so provides us with an easy way to copy and paste data between
    users. Note that the permission mode of the FIFO must allow other users to read
    it (and write to it, if you like). It's possible to set the desired permission
    mode directly while creating the FIFO using the `-m` option. For example, `mkfifo
    /tmp/shared-fifo -m 666` will allow any user to read and write to the FIFO.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统上有多个用户，您可以尝试使用FIFO向它们发送消息。这样做为我们提供了一种在用户之间复制和粘贴数据的简单方法。请注意，FIFO的权限模式必须允许其他用户读取它（如果需要，还可以写入它）。可以在创建FIFO时直接设置所需的权限模式，使用`-m`选项。例如，`mkfifo
    /tmp/shared-fifo -m 666`将允许任何用户读取和写入FIFO。
- en: See also
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There's a bit more information about the `mkfifo` command in the `man 1 mkfifo`
    manual page. For a more in-depth explanation about FIFOs in general, see the `man
    7 fifo` manual page.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`man 1 mkfifo`手册页中有关于`mkfifo`命令的更多信息。有关FIFO的更深入解释，请参阅`man 7 fifo`手册页。
- en: FIFO – building the sender
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FIFO - 构建发送方
- en: Now that we know what a FIFO is, we'll move on and write a program that can
    create and use a FIFO. In this recipe, we'll write a program that creates a FIFO
    and then sends a message to it. In the next recipe, we'll write a program that
    receives that message.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了FIFO是什么，我们将继续编写一个可以创建和使用FIFO的程序。在这个示例中，我们将编写一个创建FIFO然后向其发送消息的程序。在下一个示例中，我们将编写一个接收该消息的程序。
- en: Knowing how to use FIFOs programmatically will enable you to write programs
    that can communicate between themselves using a FIFO directly, without needing
    to redirect the data via the shell.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何在程序中使用FIFO将使您能够编写可以直接使用FIFO进行通信的程序，而无需通过shell重定向数据。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need the usual tools; that is, the GCC compiler, the Make tool, and the
    generic Makefile.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要常规工具；即GCC编译器、Make工具和通用Makefile。
- en: How to do it…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll write a program that creates a FIFO and sends a message
    to it:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个创建FIFO并向其发送消息的程序：
- en: 'Write the following code in a file and save it as `fifo-sender.c`. This code
    is a bit longer, so we''ll cover it step by step here. Remember that all the code
    goes in the same file. Let''s start with the `#include` lines, the prototype for
    the signal handler, and some global variables:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码并将其保存为`fifo-sender.c`。这段代码有点长，所以我们将在这里逐步介绍它。请记住，所有代码都放在同一个文件中。让我们从`#include`行、信号处理程序的原型和一些全局变量开始：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, we can start writing the `main()` function. First, we will create the
    struct for the `sigaction()` function. Then, we will check if the user provided
    a message as an argument:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始编写`main()`函数。首先，我们将为`sigaction()`函数创建结构体。然后，我们将检查用户是否提供了消息作为参数：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we must register the signal handler for all the signals we want to catch.
    We are doing this so that we can remove the FIFO when the program exits. Notice
    here that we are also registering the `SIGPIPE` signal—more on this in the *How
    it works…* section:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须为我们想要捕获的所有信号注册信号处理程序。我们这样做是为了在程序退出时删除FIFO。请注意，我们还注册了`SIGPIPE`信号——关于这一点，我们将在*它是如何工作的…*部分详细说明：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s create the FIFO with mode `644`. Since mode `644` is octal, we
    need to write it as `0644` in the C code; otherwise, it will be interpreted as
    644 decimal (any number that starts with a 0 in C is an octal number). After that,
    we must open the FIFO using the `open()` system call—the same system call we use
    to open regular files:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用模式`644`创建FIFO。由于模式`644`是八进制的，我们需要在C代码中写为`0644`；否则，它将被解释为644十进制（在C中以0开头的任何数字都是八进制数）。之后，我们必须使用`open()`系统调用打开FIFO——与我们用于打开常规文件的系统调用相同：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we must create an endless loop. Inside this loop, we will print the user-provided
    message once every second. After the loop, we will close the file descriptor and
    remove the FIFO file. We shouldn''t reach this under normal circumstances, though:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须创建一个无限循环。在这个循环内，我们将每秒打印一次用户提供的消息。循环结束后，我们将关闭文件描述符并删除FIFO文件。不过在正常情况下，我们不应该达到这一步：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we must create the `cleanUp()` function, which we registered as the
    signal handler. We use this function to clean up before the program exits. We
    must then close the file descriptor and remove the FIFO file:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须创建`cleanUp()`函数，这是我们注册为信号处理程序的函数。我们使用这个函数在程序退出之前进行清理。然后，我们必须关闭文件描述符并删除FIFO文件：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s compile the program:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译程序：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s run the program:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们运行程序：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, start another terminal so that we can receive the message using `cat`.
    The filename we used in the program is `/tmp/my-2nd-fifo`. The message will repeat
    each second. After a couple of seconds, hit *Ctrl* + *C* to exit from `cat`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，启动另一个终端，以便使用`cat`接收消息。我们在程序中使用的文件名是`/tmp/my-2nd-fifo`。消息将每秒重复一次。几秒钟后，按下*Ctrl*
    + *C*退出`cat`：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, go back to the first terminal. You'll notice that it says *The receiver
    stopped receiving*.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，返回到第一个终端。您会注意到它显示*接收器停止接收*。
- en: Start the `fifo-sender` program again in this first terminal.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一个终端中再次启动`fifo-sender`程序。
- en: 'Go to the second terminal again and restart the `cat` program in order to receive
    the messages. Leave the `cat` program running:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次转到第二个终端，并重新启动`cat`程序以接收消息。让`cat`程序继续运行：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'While the cat program is running on the second terminal, go back to the first
    one and abort the `fifo-sender` program by hitting *Ctrl* + *C*. Notice that this
    time, it says *Aborting* instead:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当第二个终端上的cat程序正在运行时，返回到第一个终端，并通过按下*Ctrl* + *C*中止`fifo-sender`程序。请注意，这次它显示*Aborting*：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `cat` program in the second terminal has now exited.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个终端中的`cat`程序现在已退出。
- en: How it works…
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this program, we register an extra signal that we haven''t seen before:
    the `SIGPIPE` signal. When the other end terminates—in our case, the `cat` program—our
    program will receive a `SIGPIPE` signal. If we hadn''t caught that signal, our
    program would have exited with signal 141, and no clean-up would have occurred.
    From this exit code, we can figure out that it was due to a `SIGPIPE` signal since
    141-128 = 13; and signal 13 is `SIGPIPE`. See *Figure 2.2* in [*Chapter 2*](B13043_02_Final_SK_ePub.xhtml#_idTextAnchor050),
    *Making Your Programs Easy to Script*, for an explanation of reserved return values.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们注册了一个之前没有见过的额外信号：`SIGPIPE`信号。当另一端终止时，在我们的情况下是`cat`程序，我们的程序将收到一个`SIGPIPE`信号。如果我们没有捕获该信号，我们的程序将以信号141退出，并且不会发生清理。从这个退出代码，我们可以推断出这是由于`SIGPIPE`信号引起的，因为141-128
    = 13；信号13是`SIGPIPE`。有关保留返回值的解释，请参见[*第2章*](B13043_02_Final_SK_ePub.xhtml#_idTextAnchor050)中的*图2.2*，*使您的程序易于脚本化*。
- en: In the `cleanUp()` function, we use that signal number (`SIGPIPE`, which is
    a macro for 13) to print a special message when the receiver has stopped receiving
    data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cleanUp()`函数中，我们使用该信号号（`SIGPIPE`，它是13的宏）在接收器停止接收数据时打印特殊消息。
- en: If we instead abort the `fifo-sender` program by hitting *Ctrl* + *C*, we get
    another message; that is, *Aborted*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改为通过按下*Ctrl* + *C*中止`fifo-sender`程序，我们会得到另一条消息；即*Aborted*。
- en: The `mkfifo()` function creates a FIFO file for us with the specified mode.
    Here, we specified the mode as an octal number. Any number in C that has a leading
    0 is an octal number.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkfifo()`函数为我们创建了一个指定模式的FIFO文件。在这里，我们将模式指定为一个八进制数。在C中，任何以0开头的数字都是八进制数。'
- en: Since we opened the FIFO using the `open()` system call, we got a `dprintf()`
    to print the user's message to the pipe. The first argument to the program—`argv[1]`—is
    the user's message.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用`open()`系统调用打开FIFO，我们得到了一个`dprintf()`来将用户的消息打印到管道中。程序的第一个参数—`argv[1]`—是用户的消息。
- en: As long as the FIFO stays open in the program, `cat` will also continue to listen.
    That's why we can repeat the message every second in the loop.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 只要FIFO在程序中保持打开状态，`cat`也将继续监听。这就是为什么我们可以在循环中每秒重复一次消息。
- en: See also
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See `man 3 mkfifo` for an in-depth explanation of the `mkfifo()` function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`mkfifo()`函数的深入解释，请参阅`man 3 mkfifo`。
- en: For a list of the possible signals, see `kill -L`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可能信号的列表，请参阅`kill -L`。
- en: To learn more about `dprintf()`, see the `man 3 dprintf` manual page.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`dprintf()`的更多信息，请参阅`man 3 dprintf`手册页。
- en: FIFO – building the receiver
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FIFO – 构建接收器
- en: In the previous recipe, we wrote a program that creates a FIFO and writes a
    message to it. We also tested it using `cat` to receive the messages. In this
    recipe, we'll write a C program that reads from the FIFO.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们编写了一个创建FIFO并向其写入消息的程序。我们还使用`cat`进行了测试以接收消息。在这个示例中，我们将编写一个C程序，从FIFO中读取。
- en: Reading from a FIFO isn't any different than reading from a regular file, or
    let's say, stdin.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从FIFO中读取与从常规文件或标准输入读取没有任何不同。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you start this recipe, it's best if you complete the previous recipe
    first. We'll use the program from the previous recipe to write data to the FIFO
    that we'll receive in this recipe.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本教程之前，最好先完成上一个教程。我们将使用上一个教程中的程序将数据写入我们将在本教程中接收的FIFO中。
- en: You'll also need the usual tools; that is, the GCC compiler, the Make tool,
    and the generic Makefile.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要常规工具；即GCC编译器、Make工具和通用Makefile。
- en: How to do it…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: 'In this recipe, we''ll write a receiving program for the sender we wrote in
    the previous recipe. Let''s get started:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将为前一个教程中编写的发送程序编写一个接收程序。让我们开始：
- en: 'Write the following code in a file and save it as `fifo-receiver.c`. We will
    open the FIFO with a file stream and then read it character by character in a
    loop until we get an **End Of File** (**EOF**):'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入文件并保存为`fifo-receiver.c`。我们将使用文件流打开FIFO，然后在循环中逐个字符读取，直到我们得到**文件结束**（**EOF**）：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Compile the program:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Start `fifo-sender` from the previous recipe and leave it running:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个教程中启动`fifo-sender`并让其运行：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Open up a second terminal and run `fifo-receiver`, which we just compiled.
    Abort it after a couple of seconds by hitting *Ctrl* + *C*:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个终端并运行我们刚刚编译的`fifo-receiver`。在几秒钟后按*Ctrl* + *C*中止它：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Since the FIFO is a file on the filesystem, we can receive data from it using
    the usual functions in C, such as file streams, `getc()`, `putchar()`, and so
    on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于FIFO是文件系统上的一个文件，我们可以使用C中的常规函数（如文件流、`getc()`、`putchar()`等）从中接收数据。
- en: This program is similar to the `stream-read.c` program from [*Chapter 5*](B13043_05_Final_SK_ePub.xhtml#_idTextAnchor182),
    *Working with File I/O and Filesystem Operations*, except that we read character
    by character here instead of line by line.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序类似于[*第5章*](B13043_05_Final_SK_ePub.xhtml#_idTextAnchor182)中的`stream-read.c`程序，*使用文件I/O和文件系统操作*，只是这里我们逐个字符读取而不是逐行读取。
- en: See also
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information about `getc()` and `putchar()`, see the `man 3 getc` and
    `man 3 putchar` manual pages, respectively.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`getc()`和`putchar()`的更多信息，请参阅`man 3 getc`和`man 3 putchar`手册页。
- en: Message queues – creating the sender
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息队列 - 创建发送程序
- en: Another popular IPC technique is **message queues**. It's pretty much what the
    name suggests. A process leaves messages in a queue, and another process reads
    them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的IPC技术是**消息队列**。这基本上就是名字所暗示的。一个进程将消息留在队列中，另一个进程读取它们。
- en: 'There are two types of message queues available on Linux: `mq_` functions,
    such as `mq_open()`, `mq_send()`, and so on.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Linux上有两种类型的消息队列：`mq_`函数，如`mq_open()`，`mq_send()`等。
- en: Knowing how to use message queues enables you to choose from among a variety
    of IPC techniques.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用消息队列使您能够从各种IPC技术中进行选择。
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll only need the GCC compiler and the Make tool.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本教程，我们只需要GCC编译器和Make工具。
- en: How to do it…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下...
- en: 'In this recipe, we''ll create the sender program. It''s this program that will
    create a new message queue and some messages to it. In the next recipe, we''ll
    receive those messages:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建发送程序。这个程序将创建一个新的消息队列并向其中添加一些消息。在下一个教程中，我们将接收这些消息：
- en: Write the following code in a file and save it as `msg-sender.c`. Since there
    are some new things in the code, I have broken it up into several steps. All the
    code goes into a single file, though, called `msg-sender.c`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入文件并保存为`msg-sender.c`。由于代码中有一些新内容，我已将其分解为几个步骤。所有代码都放在一个文件中，名为`msg-sender.c`。
- en: 'Let''s start with the header files that are required. We also define a macro
    for the maximum message size. Then, we will create a struct of the `mq_attr` type
    called `msgattr`. We will then set its members; that is, we''ll set `mq_maxmsg`
    to 10 and `mq_msgsize` to `MAX_MSG_SIZE`. The first, `mq_maxmsg`, specifies the
    total number of messages in the queue. The second one, `mq_msgsize`, specifies
    the maximum size of a message:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从所需的头文件开始。我们还为最大消息大小定义了一个宏。然后，我们将创建一个名为`msgattr`的`mq_attr`类型的结构。然后设置它的成员；也就是说，我们将`mq_maxmsg`设置为10，`mq_msgsize`设置为`MAX_MSG_SIZE`。第一个`mq_maxmsg`指定队列中的消息总数。第二个`mq_msgsize`指定消息的最大大小：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ll take the first argument to the program as the message. So, here, we''ll
    do a check to see if the user typed in an argument or not:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把程序的第一个参数作为消息。因此，在这里，我们将检查用户是否输入了参数：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, it's time to open and create the message queue with `mq_open()`. The first
    argument is the name of the queue; here, it's `/my_queue`. The second argument
    is the flags, which in our case are `O_CREATE` and `O_RDWR`. These are the same
    flags that we have seen previously, for example, with `open()`. The third argument
    is the permission mode; once again, this is the same as for files. The fourth
    and last argument is the struct we created earlier. The `mq_open()` function then
    returns a message queue descriptor to the `md` variable.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候用`mq_open()`打开并创建消息队列了。第一个参数是队列的名称；在这里，它是`/my_queue`。第二个参数是标志，我们的情况下是`O_CREATE`和`O_RDWR`。这些是我们之前见过的相同标志，例如`open()`。第三个参数是权限模式；再次，这与文件相同。第四个和最后一个参数是我们之前创建的结构。`mq_open()`函数然后将消息队列描述符返回给`md`变量。
- en: Then, finally, we send the message to the queue using `mq_send()`. Here, first,
    we give it the `md` descriptor. Then, we have the message we want to send, which
    in this case is the first argument to the program. Then, as the third argument,
    we must specify the size of the message. Finally, we must set a priority for the
    message; in this case, we will just go with 1\. It can be any positive number
    (an `unsigned int`).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`mq_send()`将消息发送到队列。这里，首先，我们给它`md`描述符。然后，我们有要发送的消息，在本例中是程序的第一个参数。然后，作为第三个参数，我们必须指定消息的大小。最后，我们必须为消息设置一个优先级；在这种情况下，我们将选择1。它可以是任何正数（无符号整数）。
- en: 'The last thing we will do before exiting the program is close the message queue
    descriptor with `mq_close()`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在退出程序之前，我们将做的最后一件事是使用`mq_close()`关闭消息队列描述符：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Compile the program. Notice that we must link against the `rt` library, which
    stands for **Realtime Extensions library**:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序。请注意，我们必须链接`rt`库，该库代表**实时扩展库**：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, run the program and send three or four messages to the queue:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行程序并向队列发送三到四条消息：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works…
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this recipe, we used the POSIX message queue functions to create a new queue
    and then sent messages to it. When we created the queue, we specified that this
    queue can contain a maximum of 10 messages using the `mq_maxmsg` member of `msgattr`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用了POSIX消息队列函数来创建一个新队列，然后向其发送消息。当我们创建队列时，我们指定该队列可以包含最多10条消息，使用`msgattr`的`mq_maxmsg`成员。
- en: We also set the maximum length of each message to 2,048 characters using the
    `mq_msgsize` member.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`mq_msgsize`成员将每条消息的最大长度设置为2,048个字符。
- en: We named the queue `/my_queue` when we called `mq_open()`. A message queue must
    start with a forward slash.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`mq_open()`时，我们将队列命名为`/my_queue`。消息队列必须以斜杠开头。
- en: Once the queue was created, we sent messages to it using `mq_send()`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 队列创建后，我们使用`mq_send()`向其发送消息。
- en: At the end of this recipe, we sent three messages to the queue. These messages
    are now queued, waiting to be received. In the next recipe, we'll learn how to
    write a program that receives these messages and prints them on the screen.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱的最后，我们向队列发送了三条消息。这些消息现在已排队，等待接收。在下一个食谱中，我们将学习如何编写一个接收这些消息并在屏幕上打印它们的程序。
- en: See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There's a great overview of the POSIX message queue functionality in Linux in
    the `man 7 mq_overview` manual page.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux的`man 7 mq_overview`手册页中有关于POSIX消息队列功能的很好的概述。
- en: Message queues – creating the receiver
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息队列 - 创建接收器
- en: In the previous recipe, we built a program that created a message queue named
    `/my_queue`, and then sent three messages to it. In this recipe, we'll create
    a program that receives the messages from that queue.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中，我们构建了一个程序，创建了一个名为`/my_queue`的消息队列，然后向其发送了三条消息。在这个食谱中，我们将创建一个接收来自该队列的消息的程序。
- en: Getting ready
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before you start this recipe, you need to have completed the previous recipe.
    Otherwise, there will be no messages for us to receive.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始这个食谱之前，您需要完成上一个食谱。否则，我们将收不到任何消息。
- en: You'll also need the GCC compiler and the Make tool for this recipe.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要GCC编译器和Make工具来完成这个食谱。
- en: How to do it…
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'In this recipe, we''ll receive the messages we sent in the previous recipe:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将接收上一个食谱中发送的消息：
- en: 'Write the following code in a file and save it as `msg-receiver.c`. This code
    is a bit longer than the code for the sending program, so it''s been broken up
    into several steps, each one explaining a bit of the code. Remember, though, that
    all the code goes into the same file. We''ll start with the header files, the
    variables, the struct, and a character pointer named `buffer`. We''ll use this
    later to allocate memory:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码，并将其保存为`msg-receiver.c`。这段代码比发送程序的代码要长一些，因此它被分成了几个步骤，每个步骤都解释了一部分代码。不过，请记住，所有代码都放在同一个文件中。我们将从头文件、变量、结构和名为`buffer`的字符指针开始。稍后我们将使用它来分配内存：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The next step is to open the message queue using `mq_open()`. This time, we
    only need to provide two arguments; the name of the queue and the flags. In this
    case, we only want to read from the queue:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用`mq_open()`打开消息队列。这次，我们只需要提供两个参数；队列的名称和标志。在这种情况下，我们只想从队列中读取：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we also want to get the attributes of the message queue using `mq_getattr()`.
    Once we have the attributes of the queue, we can use its `mq_msgsize` member to
    allocate memory for a message of that size using `calloc()`. We haven''t seen
    `calloc()` before in this book. The first argument is the number of elements we
    want to allocate memory for, while the second argument is the size of each element.
    The `calloc()` function then returns a pointer to that memory (in our case, that''s
    `buffer`):'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们还想使用`mq_getattr()`获取消息队列的属性。一旦我们有了队列的属性，我们就可以使用其`mq_msgsize`成员使用`calloc()`为该大小的消息分配内存。在本书中，我们之前没有看到`calloc()`。第一个参数是我们要为其分配内存的元素数，而第二个参数是每个元素的大小。然后，`calloc()`函数返回指向该内存的指针（在我们的情况下，就是`buffer`）：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Next, we will use another member of the `mq_attr` struct called `mq_curmsgs`,
    which contains the number of messages currently in the queue. First, we will print
    the number of messages. Then, we will loop over all the messages using a `for`
    loop. Inside the loop, first, we receive a message using `mq_receive`. Then, we
    print the message using `printf()`. Finally, before iterating over the next message,
    we reset the entire memory to NULL characters using `memset()`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`mq_attr`结构的另一个成员`mq_curmsgs`，它包含队列中当前的消息数。首先，我们将打印消息数。然后，我们将使用`for`循环遍历所有消息。在循环内部，首先使用`mq_receive`接收消息。然后，我们使用`printf()`打印消息。最后，在迭代下一条消息之前，我们使用`memset()`将整个内存重置为NULL字符。
- en: 'The first argument to `mq_receive` is the descriptor, the second argument is
    the buffer where the message goes, the third argument is the size of the message,
    and the fourth argument is the priority of the message, which in this case is
    NULL, meaning we receive all messages with the highest priority first:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`mq_receive`的第一个参数是描述符，第二个参数是消息所在的缓冲区，第三个参数是消息的大小，第四个参数是消息的优先级，在这种情况下是NULL，表示我们首先接收所有最高优先级的消息：'
- en: '[PRE49]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we have some cleanup to do. First of all, we must `free()` the memory
    being pointed to by the buffer. Then, we must close the `md` queue descriptor,
    before removing the queue from the system using `mq_unlink()`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有一些清理工作要做。首先，我们必须使用`free()`释放缓冲区指向的内存。然后，我们必须关闭`md`队列描述符，然后使用`mq_unlink()`从系统中删除队列：
- en: '[PRE50]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, it''s time to compile the program:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候编译程序了：
- en: '[PRE51]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, let''s receive the messages using our new program:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用我们的新程序接收消息：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If we try to rerun the program now, it will simply state that no such file
    or directory exists. This is because we removed the message queue with `mq_unlink()`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们现在尝试重新运行程序，它将简单地指出没有这样的文件或目录存在。这是因为我们使用`mq_unlink()`删除了消息队列：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works…
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In the previous recipe, we sent three messages to `/my_queue`. With the program
    we created in this recipe, we received those messages.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们向`/my_queue`发送了三条消息。使用本示例中创建的程序，我们接收了这些消息。
- en: To open the queue, we used the same function we used when we created it; that
    is, `mq_open()`. But this time—since we're opening an already existing queue—we
    only needed to provide two arguments; that is, the queue's name and the flags.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开队列，我们使用了创建队列时使用的相同函数；也就是`mq_open()`。但这一次——因为我们正在打开一个已经存在的队列——我们只需要提供两个参数；即队列的名称和标志。
- en: Each call to an `mq_` function is error checked. If an error occurs, we print
    the error message with `perror()` and return to the shell with 1.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对`mq_`函数的每次调用都进行错误检查。如果发生错误，我们将使用`perror()`打印错误消息，并返回到shell并返回1。
- en: Before reading the actual messages from the queue, we get the queue's attribute
    with `mq_getattr()`. With this function call, we populate the `mq_attr` struct.
    The two most important members for reading the messages are `mq_msgsize`, which
    is the maximum size of each message in the queue, and `mq_curmsgs`, which is the
    number of messages currently in the queue.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在从队列中读取实际消息之前，我们使用`mq_getattr()`获取队列的属性。通过这个函数调用，我们填充了`mq_attr`结构。对于读取消息来说，最重要的两个成员是`mq_msgsize`，它是队列中每条消息的最大大小，以及`mq_curmsgs`，它是当前队列中的消息数。
- en: We use the maximum message size from `mq_msgsize` to allocate memory for a message
    buffer using `calloc()`. The `calloc()` function returns "zeroed" memory, which
    its counterpart, `malloc()`, doesn't.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`mq_msgsize`中的最大消息大小来使用`calloc()`为消息缓冲区分配内存。`calloc()`函数返回“零化”的内存，而它的对应函数`malloc()`则不会。
- en: 'To allocate memory, we need to create a pointer to the type we want. This is
    what we did at the beginning of the program with `char *buffer`. The `calloc()`
    function takes two arguments: the number of elements to allocate and the size
    of each such element. Here, we want to number of elements to be the same as what
    the `mq_msgsize` value contains. And each element is a `char`, so the size of
    each element should be `sizeof(char)`. The function then returns a pointer to
    the memory, which in our case is saved to the `char` pointer''s `buffer`.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要分配内存，我们需要创建一个指向我们想要的类型的指针。这就是我们在程序开始时使用`char *buffer`所做的。`calloc()`函数接受两个参数：要分配的元素数量和每个元素的大小。在这里，我们希望元素的数量与`mq_msgsize`值包含的相同。而每个元素都是`char`，所以每个元素的大小应该是`sizeof(char)`。然后函数返回一个指向内存的指针，在我们的情况下保存在`char`指针的`buffer`中。
- en: Then, when we receive the queue messages, we save them in this buffer on each
    iteration of the loop.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们接收队列消息时，我们在循环的每次迭代中将它们保存在这个缓冲区中。
- en: The loop iterates through all the messages. We got the number of messages from
    the `mq_curmsgs` member.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 循环遍历所有消息。我们从`mq_curmsgs`成员中得到消息的数量。
- en: Finally, once we finished reading all the messages, we closed and deleted the
    queue.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们读完了所有的消息，我们关闭并删除了队列。
- en: See also
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information about the `mq_attr` struct, I suggest that you read the
    `man 3 mq_open` manual page.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`mq_attr`结构的更多信息，我建议你阅读`man 3 mq_open`手册页面。
- en: Each of the functions we have covered in this and the previous recipe has its
    own manual page; for example, `man 3 mq_send`, `man 3 mq_recevie`, `man 3 mq_getattr`,
    and so on.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个和上一个示例中涵盖的每个函数都有自己的手册页面；例如，`man 3 mq_send`，`man 3 mq_recevie`，`man 3 mq_getattr`等等。
- en: If you're unfamiliar with the `calloc()` and `malloc()` functions, I suggest
    that you read `man 3 calloc`. This manual page covers `malloc()`, `calloc()`,
    `free()`, and some other related functions.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对`calloc()`和`malloc()`函数不熟悉，我建议你阅读`man 3 calloc`。这个手册页面涵盖了`malloc()`，`calloc()`，`free()`和一些其他相关函数。
- en: The `memset()` function also has its own manual page; that is, `man 3 memset`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`memset()`函数也有自己的手册页面；即`man 3 memset`。'
- en: Communicating between child and parent with shared memory
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用共享内存在子进程和父进程之间通信
- en: In this recipe, we'll learn how to use **shared memory** between two related
    processes—a parent and a child. Shared memory exists in various forms and can
    be used in different ways. In this book, we'll focus on the POSIX shared memory
    functions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在两个相关的进程——父进程和子进程之间使用**共享内存**。共享内存以各种形式存在，并且可以以不同的方式使用。在本书中，我们将专注于POSIX共享内存函数。
- en: Shared memory in Linux can be used between related processes, as we are about
    to explore in this recipe, but also between unrelated processes using `/dev/shm`
    directory. We'll look at this in the next recipe.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的共享内存可以在相关进程之间使用，正如我们将在本示例中探讨的那样，还可以在无关的进程之间使用`/dev/shm`目录。我们将在下一个示例中看到这一点。
- en: In this recipe, we'll be using *anonymous* shared memory—memory not backed by
    a file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用*匿名*共享内存——即不由文件支持的内存。
- en: Shared memory is just what it sounds like—a piece of memory that is shared between
    processes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存就像它听起来的那样——一块在进程之间共享的内存。
- en: Knowing how to use shared memory will enable you to write more advanced programs.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用共享内存将使您能够编写更高级的程序。
- en: Getting ready
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll only need the GCC compiler and the Make tool.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您只需要GCC编译器和Make工具。
- en: How to do it…
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll write a program that uses shared memory. First, before
    forking, the process will write a message to the shared memory. Then, after forking,
    the child will replace the message in the shared memory. And then, finally, the
    parent process will replace the content of the shared memory once again. Let''s
    get started:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个使用共享内存的程序。首先，在分叉之前，进程将向共享内存写入一条消息。然后，在分叉之后，子进程将替换共享内存中的消息。最后，父进程将再次替换共享内存的内容。让我们开始吧：
- en: 'Write the following code in a file and name it `shm-parent-child.c`. As usual,
    I''ll break up the code into several smaller steps. All the code goes into the
    same file, though. First, we''ll write all of the header files. There are quite
    a few of them here. We will also define a macro for the size of our memory. We
    will then write our three messages as character array constants:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入一个文件中，并将其命名为`shm-parent-child.c`。像往常一样，我将把代码分成几个较小的步骤。尽管所有的代码都放在同一个文件中。首先，我们将写入所有的头文件。这里有相当多的头文件。我们还将为我们的内存大小定义一个宏。然后，我们将我们的三条消息写成字符数组常量：
- en: '[PRE54]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now comes the exciting part—mapping the shared memory space. There's a total
    of six arguments we need to provide to the memory mapping function; that is, `mmap()`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在来到令人兴奋的部分——映射共享内存空间。我们需要向内存映射函数`mmap()`提供总共六个参数。
- en: The first argument is the memory address, which we'll set to NULL—meaning the
    kernel will take care of it for us.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是内存地址，我们将其设置为NULL——这意味着内核会为我们处理它。
- en: The second argument is the size of the memory area.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是内存区域的大小。
- en: The third argument is the protection the memory should have. Here, we will set
    it to write and read.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是内存应该具有的保护。在这里，我们将其设置为可写和可读。
- en: The fourth argument is our flags, which we set to shared and anonymous—meaning
    it can be shared among processes and won't be backed by a file.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个参数是我们的标志，我们将其设置为共享和匿名——这意味着它可以在进程之间共享，并且不会由文件支持。
- en: The fifth argument is a file descriptor. But in our case, we're using anonymous,
    which means that this memory won't be backed by a file. Due to this, we will set
    it to -1 for compatibility reasons.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第五个参数是文件描述符。但在我们的情况下，我们使用的是匿名的，这意味着这块内存不会由文件支持。因此，出于兼容性原因，我们将其设置为-1。
- en: 'The last argument is the offset, which we will set to 0:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数是偏移量，我们将其设置为0：
- en: '[PRE55]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now that the memory is ready for us, we will copy our first message to it using
    `memcpy()`. The first argument to `memcpy()` is a pointer to the memory, which
    in our case is the `addr` character pointer. The second argument is the data or
    message we want to copy from, which in our case is `startmsg`. The last argument
    is the size of the data we want to copy, which in this case is the length of the
    string in `startmsg` + 1\. The `strlen()` function doesn't include the terminating
    null character; that's why we need to add 1.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在内存已经准备好了，我们将使用`memcpy()`将我们的第一条消息复制到其中。`memcpy()`的第一个参数是指向内存的指针，在我们的例子中是`addr`字符指针。第二个参数是我们要从中复制的数据或消息，在我们的例子中是`startmsg`。最后一个参数是我们要复制的数据的大小，在这种情况下是`startmsg`中字符串的长度+1。`strlen()`函数不包括终止的空字符；这就是为什么我们需要加1。
- en: 'Then, we print the PID of the process and the message in the shared memory.
    After that, we fork:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们打印进程的PID和共享内存中的消息。之后，我们进行分叉：
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If we are in the child process, we copy the child''s message to the shared
    memory. If we are in the parent process, we''ll wait for the child. Then, we can
    copy the parent message to the memory and also print both messages. Finally, we
    will clean up by unmapping the shared memory. This isn''t strictly required, though:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们在子进程中，我们将子进程的消息复制到共享内存中。如果我们在父进程中，我们将等待子进程。然后，我们可以将父进程的消息复制到内存中，并打印两条消息。最后，我们将通过取消映射共享内存来清理。尽管这并不是严格要求的：
- en: '[PRE57]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Compile the program so that we can take it for a spin. Notice that we are using
    another C standard here—`MAP_ANONYMOUS` macro, but **GNU11** does. **GNU11** is
    the **C11** standard with some extra GNU extensions. Also, note that we link against
    the *Real-Time Extensions* library:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序，以便我们可以试一试。请注意，我们在这里使用了另一个C标准——`MAP_ANONYMOUS`宏，但**GNU11**有。**GNU11**是**C11**标准，带有一些额外的GNU扩展。还要注意，我们链接了*实时扩展*库：
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we can test the program:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以测试程序了：
- en: '[PRE59]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works…
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Shared memory is a common IPC technique between unrelated processes, related
    processes, and threads. In this recipe, we saw how we could use shared memory
    between a parent and a child.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 共享内存是不相关进程、相关进程和线程之间的常见IPC技术。在这个示例中，我们看到了如何在父进程和子进程之间使用共享内存。
- en: The memory area is mapped using `mmap()`. This function returns the address
    to the mapped memory. If an error occurs, it returns the `MAP_FAILED` macro. Once
    we mapped the memory, we checked the pointer variable for `MAP_FAILED` and aborted
    it in case there was an error.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mmap()`映射内存区域。这个函数返回映射内存的地址。如果发生错误，它将返回`MAP_FAILED`宏。一旦我们映射了内存，我们就检查指针变量是否为`MAP_FAILED`，并在出现错误时中止它。
- en: Once we've mapped the memory and got a pointer to it, we used `memcpy()` to
    copy data to it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们映射了内存并获得了指向它的指针，我们就使用`memcpy()`将数据复制到其中。
- en: Finally, we unmapped the memory with `munmap()`. This isn't strictly necessary
    since it will be unmapped anyway when the last process exists. However, it's a
    bad practice not to do so. You should always clean up after yourself and free
    up any allocated memory.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`munmap()`取消映射内存。这并不是严格必要的，因为当最后一个进程退出时，它将被取消映射。但是，不这样做是一个不好的习惯。您应该始终在使用后进行清理，并释放任何分配的内存。
- en: See also
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For a more detailed explanation of `mmap()` and `munmap()`, see the `man 2 mmap`
    manual page. For a detailed explanation of `memcpy()`, see the `man 3 memcpy`
    manual page.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`mmap()`和`munmap()`的更详细解释，请参见`man 2 mmap`手册页。有关`memcpy()`的详细解释，请参见`man 3 memcpy`手册页。
- en: For a more in-depth explanation of the various C standards and what the GNU
    extensions are, see [https://gcc.gnu.org/onlinedocs/gcc/Standards.html](https://gcc.gnu.org/onlinedocs/gcc/Standards.html).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有关各种C标准及GNU扩展的更详细解释，请参见[https://gcc.gnu.org/onlinedocs/gcc/Standards.html](https://gcc.gnu.org/onlinedocs/gcc/Standards.html)。
- en: Using shared memory between unrelated processes
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不相关进程之间使用共享内存
- en: In the previous recipe, we used shared memory between a child and a parent.
    In this recipe, we'll learn how to use a file descriptor to mapped memory to share
    that memory between two unrelated processes. Using shared memory in this way automatically
    creates an underlying file for the memory in the `/dev/shm` directory, where **shm**
    stands for **shared memory**.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们在子进程和父进程之间使用了共享内存。在这个示例中，我们将学习如何使用文件描述符将映射内存共享给两个不相关的进程。以这种方式使用共享内存会自动在`/dev/shm`目录中创建内存的底层文件，其中**shm**代表**共享内存**。
- en: Knowing how to use shared memory between unrelated processes widens your use
    of this IPC technique.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何在不相关的进程之间使用共享内存扩大了您使用这种IPC技术的范围。
- en: Getting ready
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll only need the GCC compiler and the Make tool.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，您只需要GCC编译器和Make工具。
- en: How to do it…
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: First, we'll write a program that opens and creates a file descriptor for shared
    memory and also maps the memory. Then, we'll write another program that reads
    the memory area. Instead of just a message, as we did in the previous recipe,
    we'll write and retrieve an **array** of three floating-point numbers here.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个程序，打开并创建一个共享内存的文件描述符，并映射内存。然后，我们将编写另一个程序来读取内存区域。与之前的示例不同，这次我们将在这里写入和检索一个由三个浮点数组成的**数组**，而不仅仅是一个消息。
- en: Creating the writer
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建写入程序
- en: 'Let''s create the writer first:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们创建写入程序：
- en: The first step is to create a program that will create a shared memory and write
    some data to it. Write the following code in a file and save it as `write-memory.c`.
    As usual, the code will be broken up into several steps, but all the code goes
    into a single file.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建一个程序，用于创建共享内存并向其写入一些数据。将以下代码写入文件并保存为`write-memory.c`。和往常一样，代码将被分成几个步骤，但所有代码都放在一个文件中。
- en: 'Just as in the previous recipe, we''ll have a bunch of header files. Then,
    we''ll create all the variables we''ll need. Here, we''ll need a variable for
    a file descriptor. Note that even if I call it a file descriptor here, it''s a
    descriptor to a memory area. `memid` contains the name of the memory-mapped descriptor.
    Then, we must use `shm_open()` to open and create the "file descriptor":'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前的示例中一样，我们将有一堆头文件。然后，我们将创建所有需要的变量。在这里，我们需要一个文件描述符变量。请注意，即使我在这里称其为文件描述符，它实际上是一个内存区域的描述符。`memid`包含内存映射描述符的名称。然后，我们必须使用`shm_open()`来打开和创建“文件描述符”：
- en: '[PRE60]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The file-backed memory is 0 bytes in size initially. To extend it to our 128
    bytes, we must truncate it with `ftruncate()`:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件支持的内存最初大小为0字节。要将其扩展到我们的128字节，我们必须使用`ftruncate()`进行截断。
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, we must map the memory, just as we did in the previous recipe. But this
    time, we will give it the `fd` file descriptor instead of -1\. We have also left
    out the `MAP_ANONYMOUS` part, thus making this memory backed by a file. Then,
    we must copy our array of floats to memory using `memcpy()`. To let the reading
    program have a chance to read the memory, we must pause the program and wait for
    an *Enter* key with `getchar()`. Then, it''s just a matter of cleaning up by unmapping
    the memory and deleting the file descriptor and the underlying file with `shm_unlink()`:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须映射内存，就像我们在之前的示例中所做的那样。但是这次，我们将给它`fd`文件描述符，而不是-1。我们还省略了`MAP_ANONYMOUS`部分，从而使这个内存由文件支持。然后，我们必须使用`memcpy()`将我们的浮点数数组复制到内存中。为了让读取程序有机会读取内存，我们必须暂停程序，并使用`getchar()`等待*Enter*键。然后，只需要清理工作，取消映射内存，并使用`shm_unlink()`删除文件描述符和底层文件：
- en: '[PRE62]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let''s compile the program:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编译这个程序：
- en: '[PRE63]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Creating the reader
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建读取程序
- en: 'Now, let''s create the reader:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建读取程序：
- en: 'Now, we''ll write the program that will read the memory area and print the
    numbers for the array. Write the following program and save it as `read-memory.c`.
    This program is similar to `write-memory.c`, but instead of writing to memory,
    we are reading from it:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个程序，用于读取内存区域并打印数组中的数字。编写以下程序并将其保存为`read-memory.c`。这个程序类似于`write-memory.c`，但不是向内存写入，而是从内存读取：
- en: '[PRE64]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, compile this program:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译这个程序：
- en: '[PRE65]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Testing everything
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试一切
- en: 'Follow these steps:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Now, it''s time to try it all out. Open up a terminal and run the `write-memory`
    program that we compiled. Leave the program running:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候尝试一切了。打开终端并运行我们编译的`write-memory`程序。让程序保持运行：
- en: '[PRE66]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Open up another terminal and check out the file in `/dev/shm`:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个终端，查看`/dev/shm`中的文件：
- en: '[PRE67]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, run the read-memory program we just compiled. This will retrieve the three
    numbers from the shared memory and print them on the screen:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行我们刚刚编译的`read-memory`程序。这将从共享内存中检索三个数字并将它们打印在屏幕上：
- en: '[PRE68]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Go back to the terminal where the `write-memory` program is running and hit
    *Enter*. Doing so will clean up and delete the file. Once you have done this,
    let''s see if the file is still in `/dev/shm`:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回运行`write-memory`程序的终端，然后按*Enter*。这样做将清理并删除文件。完成后，让我们看看文件是否仍然在`/dev/shm`中：
- en: '[PRE69]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How it works…
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Using non-anonymous shared memory is similar to what we did in the previous
    recipe. The only exception is that we first open a special file descriptor using
    `shm_open()`. As you might have noticed, the flags are similar to those of the
    regular `open()` call; that is, `O_RDWR` for reading and writing and `O_CREATE`
    for creating the file if it doesn't exist. Using `shm_open()` in this fashion
    creates a file in the `/dev/shm` directory with the name specified as the first
    argument. Even the permission mode is set the same way as regular files—in our
    case, `0600` for reading and writing for the user, and no permissions for anyone
    else.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用非匿名共享内存与我们在之前的示例中所做的类似。唯一的例外是，我们首先使用`shm_open()`打开一个特殊的文件描述符。正如您可能已经注意到的，标志与常规的`open()`调用相似；即，`O_RDWR`用于读取和写入，`O_CREATE`用于在文件不存在时创建文件。以这种方式使用`shm_open()`会在`/dev/shm`目录中创建一个文件，文件名由第一个参数指定。甚至权限模式设置方式与常规文件相同——在我们的情况下，`0600`用于用户读写，其他人没有权限。
- en: The file descriptor we get from `shm_open()` is then passed to the `mmap()`
    call. We also left out the `MAP_ANONYMOUS` macro to the `mmap()` call, as we saw
    in the previous recipe. Skipping `MAP_ANONYMOUS` means that the memory will no
    longer be anonymous, meaning it will be backed by a file. We inspected this file
    using `ls -l` and saw that it did indeed have the name we gave it and the correct
    permissions.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`shm_open()`获得的文件描述符然后传递给`mmap()`调用。我们还在`mmap()`调用中省略了`MAP_ANONYMOUS`宏，就像我们在前面的示例中看到的那样。跳过`MAP_ANONYMOUS`意味着内存将不再是匿名的，这意味着它将由文件支持。我们使用`ls
    -l`检查了这个文件，并看到它确实有我们给它的名称和正确的权限。
- en: The next program we wrote opened the same shared memory file descriptor using
    `shm_open()`. After `mmap()`, we looped over the floating-point numbers in the
    memory area.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的下一个程序使用`shm_open()`打开了相同的共享内存文件描述符。在`mmap()`之后，我们循环遍历了内存区域中的浮点数。
- en: Finally, once we hit *Enter* in the `write-memory` program, the file in `/dev/shm`
    was removed using `shm_unlink()`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们在`write-memory`程序中按下*Enter*，`/dev/shm`中的文件将使用`shm_unlink()`被删除。
- en: See also
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: There's a lot more information about `shm_open()` and `shm_unlink()` in the
    `man 3 shm_open` manual page.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在`man 3 shm_open`手册页中有关于`shm_open()`和`shm_unlink()`的更多信息。
- en: Unix socket – creating the server
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix套接字-创建服务器
- en: '**Unix sockets** are similar to **TCP/IP** sockets, but they are only local
    and are represented by a socket file on the filesystem. But the overall functions
    that are used with Unix sockets are more or less the same as for TCP/IP sockets.
    The complete name for Unix sockets is *Unix domain sockets*.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unix套接字**类似于**TCP/IP**套接字，但它们只是本地的，并且由文件系统上的套接字文件表示。但是与Unix套接字一起使用的整体函数与TCP/IP套接字的几乎相同。Unix套接字的完整名称是*Unix域套接字*。'
- en: Unix sockets are a common way for programs to communicate locally on a machine.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Unix套接字是程序在本地机器上进行通信的常见方式。
- en: Knowing how to use Unix sockets will make it easier to write programs that need
    to communicate between them.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用Unix套接字将使编写需要在它们之间通信的程序变得更容易。
- en: Getting ready
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you'll only need the GCC compiler, the Make tool, and the generic
    Makefile.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您只需要GCC编译器、Make工具和通用Makefile。
- en: How to do it…
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll write a program that will act as a server. It will receive
    messages from a client and respond with "*Message received*" every time a message
    is received. It will also clean up after itself when either the server or the
    client exits. Let''s get started:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个充当服务器的程序。它将从客户端接收消息，并在每次接收到消息时回复“*消息已收到*”。当服务器或客户端退出时，它还会自行清理。让我们开始吧：
- en: Write the following code in a file and save it as `unix-server.c`. This code
    is a bit longer than most of our previous examples, so it's been broken up into
    several steps. All the code goes in the same file, though.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码写入文件并保存为`unix-server.c`。这段代码比我们以前的大多数示例都要长，因此它被分成了几个步骤。不过所有的代码都在同一个文件中。
- en: 'There are quite a few header files here. We''ll also define a macro for the
    maximum message length that we will accept. We will then write the prototype for
    the `cleanUp()` function, which will be used to clean up the file. This function
    will also be used as a signal handler. Then, we''ll declare some global variables
    (so that they can be reached from `cleanUp()`):'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有相当多的头文件。我们还将为我们将接受的最大消息长度定义一个宏。然后，我们将为`cleanUp()`函数编写原型，该函数将用于清理文件。这个函数也将被用作信号处理程序。然后，我们将声明一些全局变量（以便它们可以从`cleanUp()`中访问）：
- en: '[PRE70]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, it''s time to start writing the `main()` function and declaring some variables.
    Most of this should be familiar to you by now. We will also register the signal
    handler here for all the signals. What''s new is the `sockaddr_un` struct. This
    will contain the socket type and file path:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候开始编写`main()`函数并声明一些变量了。到目前为止，这大部分对您来说应该是熟悉的。我们还将在这里为所有信号注册信号处理程序。新的是`sockaddr_un`结构。这将包含套接字类型和文件路径：
- en: '[PRE71]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now that we have all the signal handlers, variables, and structures in place,
    we can create a socket file descriptor using the `socket()` function. Once that
    has been taken care of, we will set the type of connection (of the *family* type)
    and the path to the socket file. Then, we will call `bind()`, which will bind
    the socket for us so that we can use it:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了所有的信号处理程序、变量和结构，我们可以使用`socket()`函数创建一个套接字文件描述符。一旦处理好了这个问题，我们将设置连接的类型（*family*类型）和套接字文件的路径。然后，我们将调用`bind()`，这将为我们绑定套接字，以便我们可以使用它：
- en: '[PRE72]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, we will prepare the socket file descriptor for connections by calling
    `listen()`. The first argument is the socket file descriptor, while the second
    argument is the buffer size we want for the backlog. Once we''ve done that, we
    will accept a connection using `accept()`. This will give us a new socket `datafd`),
    which we will use when we send and receive data. Once a connection has been accepted,
    we can print *Client connected* to the local terminal:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过调用`listen()`准备好连接的套接字文件描述符。第一个参数是套接字文件描述符，而第二个参数是我们想要的后备大小。一旦我们做到了这一点，我们将使用`accept()`接受一个连接。这将给我们一个新的套接字（`datafd`），我们将在发送和接收数据时使用它。一旦连接被接受，我们可以在本地终端上打印*客户端已连接*：
- en: '[PRE73]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, we will start the main loop of the program. In the outer loop, we''ll
    just write a confirmation message when we received a message. In the inner loop,
    we''ll read data from the new socket file descriptor, save it in `buffer`, and
    then print it on our terminal. If `read()` returns -1, then something has gone
    wrong, and we must break out of the inner loop to read the next line. If `read()`
    returns 0, then the client has disconnected, and we must run `cleanUp()` and quit:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将开始程序的主循环。在外部循环中，我们只会在接收到消息时写一个确认消息。在内部循环中，我们将从新的套接字文件描述符中读取数据，将其保存在`buffer`中，然后在我们的终端上打印出来。如果`read()`返回-1，那么出现了问题，我们必须跳出内部循环读取下一行。如果`read()`返回0，那么客户端已断开连接，我们必须运行`cleanUp()`并退出：
- en: '[PRE74]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Finally, we must create the body for the `cleanUp()` function:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须创建`cleanUp()`函数的主体：
- en: '[PRE75]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, compile the program. This time, we''ll get a warning from GCC about an
    unused variable, `signum`, in the `cleanUp()` function. This is because we never
    used the `signum` variable inside `cleanUp()`, so we can safely ignore this warning:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在编译程序。这次，我们将从GCC得到一个关于`cleanUp（）`函数中未使用的变量`signum`的警告。这是因为我们从未在`cleanUp（）`内部使用过`signum`变量，所以我们可以安全地忽略这个警告：
- en: '[PRE76]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Run the program. Since we don''t have a client, it won''t say or do anything
    just yet. However it does create the socket file. Leave the program as-is:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。由于我们没有客户端，它暂时不会说或做任何事情。但是它确实创建了套接字文件。将程序保持不变：
- en: '[PRE77]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Open a new terminal and check out the socket file. Here, we can see that it''s
    a socket file:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端并查看套接字文件。在这里，我们可以看到它是一个套接字文件：
- en: '[PRE78]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'For now, go back to the terminal with the server program running and abort
    it with *Ctrl* + *C*. Then, see if the file is still there (it shouldn''t be):'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到运行服务器程序的终端，并使用*Ctrl* + *C*中止它。然后，看看文件是否还在那里（不应该在那里）：
- en: '[PRE79]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: How it works…
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `sockaddr_un` struct is a special structure for Unix domain sockets. There's
    another one called `sockaddr_in` for TCP/IP sockets. The `_un` ending stands for
    Unix sockets, while `_in` stands for internet family sockets.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`sockaddr_un`结构是Unix域套接字的特殊结构。还有一个称为`sockaddr_in`的结构，用于TCP/IP套接字。`_un`结尾代表Unix套接字，而`_in`代表互联网家族套接字。'
- en: 'The `socket()` function that we used to create a socket file descriptor takes
    three arguments: the address family (`AF_UNIX`), the type (`SOCK_SEQPACKET`, which
    provides a two-way communication), and the protocol. We specified the protocol
    as 0 since there aren''t any to choose from with a socket.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来创建套接字文件描述符的`socket（）`函数需要三个参数：地址族（`AF_UNIX`），类型（`SOCK_SEQPACKET`，提供双向通信），和协议。我们将协议指定为0，因为在套接字中没有可以选择的协议。
- en: There's also a general structure called `sockaddr`. When we pass our `sockaddr_un`
    structure as an argument for `bind()`, we need to typecast it to a `sockaddr`,
    the general type, since that's what the function expects—more precisely, a `sockaddr`
    pointer. The last argument that we supply for `bind()` is the size of the structure;
    that is, `sockaddr_un`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个称为`sockaddr`的一般结构。当我们将我们的`sockaddr_un`结构作为`bind（）`的参数传递时，我们需要将其强制转换为一般类型`sockaddr`，因为这是函数期望的——更确切地说，是`sockaddr`指针。我们为`bind（）`提供的最后一个参数是结构的大小；也就是`sockaddr_un`。
- en: Once we created the socket and bounded it with `bind()`, we prepared it for
    incoming connections with `listen()`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了套接字并用`bind（）`绑定了它，我们就用`listen（）`准备好接受传入的连接。
- en: Finally, we accepted incoming connections with `accept()`. This gave us a new
    socket file descriptor, which we then used to send and receive messages.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`accept（）`接受传入的连接。这给了我们一个新的套接字文件描述符，然后我们用它来发送和接收消息。
- en: See also
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'There''s some deeper information in the manual pages for the functions we used
    in this recipe. I suggest that you check them all out:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用的函数的手册页中有一些更深入的信息。我建议你把它们都看一遍：
- en: '`man 2 socket`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 2 socket`'
- en: '`man 2 bind`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 2 bind`'
- en: '`man 2 listen`'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 2 listen`'
- en: '`man 2 accept`'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man 2 accept`'
- en: Unix socket – creating the client
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unix套接字 - 创建客户端
- en: In the previous recipe, we created a Unix domain socket server. In this recipe,
    we'll create a client for that socket and then communicate between the client
    and the server.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们创建了一个Unix域套接字服务器。在这个示例中，我们将为该套接字创建一个客户端，然后在客户端和服务器之间进行通信。
- en: In this recipe, we'll see how we can use the socket to communicate between a
    server and a client. Knowing how to communicate over a socket is essential to
    using sockets.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何使用套接字在服务器和客户端之间进行通信。了解如何在套接字上进行通信对于使用套接字是至关重要的。
- en: Getting ready
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before doing this recipe, you should have finished the previous recipe; otherwise,
    you won't have a server to talk to.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在做这个示例之前，你应该已经完成了上一个示例；否则，你就没有服务器可以交谈了。
- en: You'll also need the GCC compiler, the Make tool, and the generic Makefile for
    this recipe.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你还需要GCC编译器、Make工具和通用的Makefile。
- en: How to do it…
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll write a client for the server that we wrote in the previous
    recipe. Once they are connected, the client can send messages to the server, and
    the server will respond with *Message received*. Let''s get started:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将为上一个示例中编写的服务器编写一个客户端。一旦它们连接，客户端就可以向服务器发送消息，服务器将以*收到消息*作出回应。让我们开始吧：
- en: 'Write the following code in a file and save it as `unix-client.c`. Since this
    code is also a bit longer, it''s been split up into several steps. All the code
    goes in the `unix-client.c` file, though. The first half of this program is similar
    to that of the server, except we have two buffers instead of one and no signal
    handling:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码并将其保存为`unix-client.c`。由于这段代码也有点长，它被分成了几个步骤。但所有的代码都在`unix-client.c`文件中。这个程序的前半部分与服务器的前半部分类似，只是我们有两个缓冲区而不是一个，而且没有信号处理：
- en: '[PRE80]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, instead of using `bind()`, `listen()`, and `accept()`, we will use `connect()`
    to initiate a connection to the server. The `connect()` function takes the same
    arguments as `bind()`:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`connect（）`来初始化与服务器的连接，而不是使用`bind（）`，`listen（）`和`accept（）`。`connect（）`函数接受与`bind（）`相同的参数：
- en: '[PRE81]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now that we have connected to the server, we can use `write()` to send messages
    over the socket file descriptor. Here, we will use `fgets()` to read the messages
    from the user to a buffer, convert a **newline character** into a **null character**,
    and then write the buffer to a file descriptor:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经连接到服务器，我们可以使用`write（）`来通过套接字文件描述符发送消息。在这里，我们将使用`fgets（）`将用户的消息读入缓冲区，将**换行符**转换为**空字符**，然后将缓冲区写入文件描述符：
- en: '[PRE82]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Compile the program:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译程序：
- en: '[PRE83]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Let''s try to run the program now. It won''t work since the server hasn''t
    started yet:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们尝试运行程序。由于服务器尚未启动，它不会工作：
- en: '[PRE84]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Start the server in a separate terminal and leave it running:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个单独的终端中启动服务器并让它保持运行：
- en: '[PRE85]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Go back to the terminal with the client and rerun it:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到具有客户端的终端并重新运行它：
- en: '[PRE86]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You should now see a message in the server saying *Client connected*.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该在服务器上看到一条消息，上面写着*客户端已连接*。
- en: 'Write some messages in the client program. You should see them appear in the
    server at the same time you hit *Enter*. After a couple of messages, hit *Ctrl*
    + *C*:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端程序中写一些消息。当您按下*Enter*键时，您应该会在服务器上看到它们出现。发送几条消息后，按下*Ctrl* + *C*：
- en: '[PRE87]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Switch over to the terminal with the server. You should see something similar
    to this:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到带有服务器的终端。您应该会看到类似于这样的内容：
- en: '[PRE88]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: How it works…
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In the previous recipe, we wrote a socket server. In this recipe, we wrote a
    client that connects to that server using the `connect()` system call. This system
    call takes the same argument as `bind()`. Once the connection has been established,
    both the server and the client can write and read from the socket file descriptor
    (two-way communication) using `write()` and `read()`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们编写了一个套接字服务器。在这个示例中，我们编写了一个客户端，使用`connect()`系统调用连接到该服务器。这个系统调用接受与`bind()`相同的参数。一旦连接建立，服务器和客户端都可以使用`write()`和`read()`从套接字文件描述符中写入和读取（双向通信）。
- en: So, in essence, once the connection has been established, it's not that different
    than reading and writing to a file using a file descriptor.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实质上，一旦连接建立，它与使用文件描述符读写文件并没有太大不同。
- en: See also
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information about the `connect()` system call, see the `man 2 connect`
    manual page.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`connect()`系统调用的更多信息，请参阅`man 2 connect`手册页。
