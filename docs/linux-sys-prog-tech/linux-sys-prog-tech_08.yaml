- en: '*Chapter 8*: Creating Shared Libraries'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：创建共享库'
- en: In this chapter, we will learn what libraries are and why they are such a big
    part of Linux. We also learn the differences between static libraries and dynamic
    libraries. When we know what libraries are, we start to write our own—both static
    and dynamic ones. We also take a quick peek inside a dynamic library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习库是什么，以及为什么它们是Linux的重要组成部分。我们还将了解静态库和动态库之间的区别。当我们知道库是什么时，我们开始编写我们自己的库——静态和动态的。我们还快速查看动态库的内部。
- en: The use of libraries has many benefits—for example, a developer doesn't need
    to reinvent functions over and over again as there's often an existing function
    already in a library. A big advantage with dynamic libraries is that the resulting
    program gets much smaller in size, and the libraries are upgradable even after
    the program has been compiled.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用库有许多好处，例如，开发人员不需要一遍又一遍地重新发明功能，因为通常库中已经存在一个现有的功能。动态库的一个重要优势是，生成的程序大小要小得多，并且即使在程序编译完成后，库也是可升级的。
- en: In this chapter, we'll learn how to make our own libraries with useful functions
    and install them on the system. Knowing how to make and install libraries enables
    you to share your functions with others in a standardized way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何制作具有有用功能的自己的库，并将其安装到系统上。知道如何制作和安装库使您能够以标准化的方式与他人共享您的功能。
- en: 'In this chapter, we''ll cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: The what and why of libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库的作用和意义
- en: Creating a static library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建静态库
- en: Using a static library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态库
- en: Creating a dynamic library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态库
- en: Installing the dynamic library on the system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在系统上安装动态库
- en: Using the dynamic library in a program
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序中使用动态库
- en: Compiling a statically linked program
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译一个静态链接的程序
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we'll need the **GNU Compiler Collection** (**GCC**) compiler
    and the Make tool. You'll find installation instructions for these tools in [*Chapter
    1*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020), *Getting the Necessary Tools
    and Writing Our First Linux Programs*. All the code samples for this chapter can
    be found in this chapter's GitHub directory at [https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch8](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch8).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将需要**GNU编译器集合**（**GCC**）编译器和Make工具。您可以在[*第1章*](B13043_01_Final_SK_ePub.xhtml#_idTextAnchor020)中找到这些工具的安装说明，*获取必要的工具并编写我们的第一个Linux程序*。本章的所有代码示例都可以在本章的GitHub目录中找到，网址为[https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch8](https://github.com/PacktPublishing/Linux-System-Programming-Techniques/tree/master/ch8)。
- en: 'Check out the following link to see the Code in Action video: [https://bit.ly/3fygqOm](https://bit.ly/3fygqOm)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 点击以下链接查看《代码实战》视频：[https://bit.ly/3fygqOm](https://bit.ly/3fygqOm)
- en: The what and why of libraries
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库的作用和意义
- en: 'Before we go into the details of libraries, it''s essential to understand what
    they are and why they matter to us. It''s also important to understand the difference
    between static and dynamic libraries:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解库的细节之前，了解它们是什么以及它们对我们的重要性是至关重要的。了解静态库和动态库之间的区别也很重要：
- en: This knowledge will enable you to make smarter choices when making your own
    libraries.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些知识将使您在制作自己的库时能够做出更明智的选择。
- en: A **dynamic library** is dynamically **linked** to the binary that uses it.
    What this means is that the library code isn't included in the binary. The library
    resides outside of the binary. This has several advantages. First, the resulting
    binary will be smaller in size since the library code isn't included. Second,
    the library can be updated without needing to recompile the binary. The disadvantage
    is that we can't move or delete the dynamic library from the system. If we do,
    the binary won't work anymore.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态库**是动态**链接**到使用它的二进制文件的。这意味着库代码不包含在二进制文件中。库驻留在二进制文件之外。这有几个优点。首先，由于库代码不包含在其中，生成的二进制文件大小会更小。其次，库可以在不需要重新编译二进制文件的情况下进行更新。缺点是我们不能将动态库从系统中移动或删除。如果这样做，二进制文件将不再起作用。'
- en: A **static library**, on the other hand, is included inside the binary file.
    The advantage of this is that the binary will be completely independent of the
    library once compiled. The disadvantage is that the binary will be bigger, and
    the library can't be updated without also recompiling the binary.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**静态库**包含在二进制文件中。这样做的优点是一旦编译完成，二进制文件将完全独立于库。缺点是二进制文件会更大，并且库不能在不重新编译二进制文件的情况下更新。
- en: We have already seen a short example of a dynamic library in [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*,
    Diving Deep into C in Linux*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*中看到了一个动态库的简短示例，在Linux中深入C*。
- en: In this recipe, we'll look at some common libraries. We'll also install a new
    one on the system via the package manager that we'll use in a program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看一些常见的库。我们还将通过包管理器在系统上安装一个新的库，然后在程序中使用它。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need the GCC compiler. You'll also need root access
    to the system, either via `su` or `sudo`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，您将需要GCC编译器。您还需要通过`su`或`sudo`以root访问系统。
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: In this recipe, we'll both explore some common libraries and look at where they
    live on the system, and then install a new one and peek inside a library. In this
    recipe, we'll only deal with dynamic libraries.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探索一些常见的库，看看它们在系统上的位置，然后安装一个新的库并查看库的内部。在这个配方中，我们只处理动态库。
- en: 'Let''s start by taking a look at the many libraries already on your system.
    The libraries will reside in one or more of these directories, depending on your
    distribution:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先看看您系统中已经存在的许多库。这些库将驻留在一个或多个这些目录中，具体取决于您的发行版：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we will install a new library on the system with the Linux distribution
    package manager. The library we will install is for **cURL**, an application and
    library to fetch files or data from the internet—for example, over **HyperText
    Transfer Protocol** (**HTTP**). Follow these instructions, depending on your distribution:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用Linux发行版软件包管理器在系统上安装一个新的库。我们将安装的库是用于**cURL**的，这是一个从互联网上获取文件或数据的应用程序和库，例如通过**超文本传输协议**（**HTTP**）。根据您的发行版，按照以下说明进行操作：
- en: '- **Debian/Ubuntu**:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '- **Debian/Ubuntu**:'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '- **Fedora/CentOS/Red Hat**:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '- **Fedora/CentOS/Red Hat**:'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s take a look inside the library with `nm`. But first, we need to
    find it with `whereis`. The path to the library is different on different distributions.
    This example is from a Debian 10 system. The file we are looking for is the `.so`
    file. Notice that we use `grep` with `nm` to only list lines with `T`. These are
    the functions that the library provides. If we were to remove the `grep` part,
    we would also see functions that this library depends on. We also add `head` to
    the command since the list of functions is long. If you want to see all the functions,
    leave out `head`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用`nm`来查看库的内部。但首先，我们需要使用`whereis`找到它。不同发行版的库路径是不同的。这个示例来自Debian 10系统。我们要找的文件是`.so`文件。请注意，我们使用`grep`和`nm`一起使用，只列出带有`T`的行。这些是库提供的函数。如果我们去掉`grep`部分，我们还会看到这个库依赖的函数。我们还在命令中添加了`head`，因为函数列表很长。如果您想看到所有函数，请省略`head`：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we know a bit more about the library, we can use it in a program.
    Write the following code in a file and save it as `get-public-ip.c`. The program
    will send a request to the web server at `i`[fconfig.me](http://fconfig.me) and
    give you your public **Internet Protocol** (**IP**) address. The complete manual
    for the cURL library can be found online at [https://curl.se/libcurl/c/](https://curl.se/libcurl/c/).
    Notice that we don''t print anything from cURL. The library will automatically
    print the content it receives from the server:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们对库有了更多了解，我们可以在程序中使用它。在文件中编写以下代码，并将其保存为`get-public-ip.c`。该程序将向位于`ifconfig.me`的Web服务器发送请求，并给出您的公共**Internet
    Protocol**（**IP**）地址。cURL库的完整手册可以在[https://curl.se/libcurl/c/](https://curl.se/libcurl/c/)上找到。请注意，我们不从cURL打印任何内容。库将自动打印从服务器接收到的内容：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Compile the code. Notice that we must also link against the cURL library using
    the `-l` option:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译代码。请注意，我们还必须使用`-l`选项链接到cURL库：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And now, finally, we can run the program to get our public IP address. My IP
    address is masked in the following output:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，最后，我们可以运行程序来获取我们的公共IP地址。我的IP地址在下面的输出中被掩盖了：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Here, we have looked at all the steps involved in using a library to add new
    functionality. We installed the library on the system using the package manager.
    We found its location using `whereis`, investigated which functions it contains
    using `nm`, and finally used it in a program.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经看到了使用库添加新功能所涉及的所有步骤。我们使用软件包管理器在系统上安装了库。我们使用`whereis`找到了它的位置，使用`nm`调查了它包含的函数，最后在程序中使用了它。
- en: The `nm` program provides a quick way to see which functions a library contains.
    The `-D` option, which we used in this recipe, is for dynamic libraries. We used
    `grep` to only view functions that the library provides; otherwise, we will also
    see functions that this library depends on (those lines start with a `U`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`nm`程序提供了一种快速查看库包含哪些函数的方法。我们在这个示例中使用的`-D`选项是用于动态库的。我们使用`grep`只查看库提供的函数；否则，我们还会看到这个库依赖的函数（这些行以`U`开头）。'
- en: Since this library is not part of `libc`, we needed to link against it with
    the `-l` option to `gcc`. The name of the library should be right after the `l`,
    without any spaces.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个库不是`libc`的一部分，我们需要使用`-l`选项将其链接到`gcc`。库的名称应该紧跟在`l`后面，没有任何空格。
- en: The [ifconfig.me](http://ifconfig.me) website is a site and service that returns
    the public IP of the client requesting the site.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[ifconfig.me](http://ifconfig.me) 网站是一个返回请求该站点的客户端的公共IP的站点和服务。'
- en: There's more…
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: cURL is also a program. Many Linux distributions have it pre-installed. The
    cURL library provides a convenient way of using cURL functions in your own programs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: cURL也是一个程序。许多Linux发行版都预装了它。cURL库提供了一种方便的方式，在您自己的程序中使用cURL函数。
- en: You can run `curl ifconfig.me` for the same result as the program we wrote,
    assuming you already have cURL installed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行`curl ifconfig.me`来获得与我们编写的程序相同的结果，假设您已经安装了cURL。
- en: Creating a static library
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个静态库
- en: In [*Chapter 3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097), *Diving Deep
    into C in Linux*, we saw how to create a dynamic library and how it was linked
    from the current working directory. In this recipe, we'll make a **static library**
    instead.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)中，*深入Linux中的C编程*，我们看到了如何创建动态库以及如何从当前工作目录链接它。在这个示例中，我们将创建一个**静态库**。
- en: A static library is included in the binary during compilation. The advantage
    is that the binary gets a bit more portable and independent. We can remove the
    static library after compilation, and the program will still work.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库在编译过程中包含在二进制文件中。优点是二进制文件更具可移植性和独立性。我们可以在编译后删除静态库，程序仍然可以正常工作。
- en: The downsides are that the binary will be slightly larger and that we can't
    update the library after it has been compiled into the program.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是二进制文件会稍微变大，而且在将库编译到程序中后无法更新库。
- en: Knowing how to create static libraries will make it much easier to distribute
    and reuse your functions in new programs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何创建静态库将使在新程序中分发和重用您的函数变得更加容易。
- en: Getting ready
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll need the GCC compiler. We will also use a tool called
    `ar` in this recipe. The `ar` program is almost always installed by default.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将需要GCC编译器。我们还将在这个示例中使用一个名为`ar`的工具。`ar`程序几乎总是默认安装的。
- en: How to do it…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll make a small static library. The library will contain
    two functions: one for converting Celsius to Fahrenheit and one for converting
    Celsius to Kelvin:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将制作一个小的静态库。该库将包含两个函数：一个用于将摄氏度转换为华氏度，另一个用于将摄氏度转换为开尔文：
- en: 'Let''s start by writing the library functions. Write the following code in
    a file and save it as `convert.c`. This file contains both of our functions:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从编写库函数开始。在文件中写入以下代码，并将其保存为`convert.c`。该文件包含我们的两个函数：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We also need a header file with the function prototypes for these functions.
    Create another file and write the following code in it. Save it as `convert.h`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个包含这些函数原型的头文件。创建另一个文件，并在其中写入以下代码。将其保存为`convert.h`：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first task in making the library is to compile `convert.c` into an `-c`
    option to GCC:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作库的第一步是将`convert.c`编译成GCC的`-c`选项：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We should now have a file called `convert.o` in our current directory. We can
    verify this with the `file` command, which also tells us the type of file it is:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在应该在当前目录中有一个名为`convert.o`的文件。我们可以使用`file`命令来验证这一点，它还会告诉我们文件的类型：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The last step to making it a static library is to pack it in an `ar` command.
    The `-c` option stands for *creating* the archive; the `-v` option stands for
    *verbose* output; and the `-r` option stands for *replacing* members with the
    same name. The name `libconvert.a` is the resulting filename our library will
    get:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使其成为静态库的最后一步是使用`ar`命令将其打包。`-c`选项表示*创建*存档；`-v`选项表示*详细*输出；`-r`选项表示*替换*具有相同名称的成员。名称`libconvert.a`是我们的库将得到的结果文件名：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s take a look at our static library with `nm` before we move on:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，让我们用`nm`查看我们的静态库：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As we have seen here, a static library is just an object file in an archive.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这里看到的，静态库只是存档中的一个对象文件。
- en: When we looked at the object file with the `file` command, we noticed it said
    *not stripped*, meaning that all the **symbols** are still in the file. *Symbols*
    are what expose the functions so that programs can access and use them. In the
    next recipe, we'll return to symbols and the meaning of *stripped* versus *not
    stripped*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用`file`命令查看对象文件时，我们注意到它说*not stripped*，这意味着所有的**符号**仍然在文件中。*符号*是暴露函数的东西，使得程序可以访问和使用它们。在下一个教程中，我们将回到符号和*stripped*与*not
    stripped*的含义。
- en: See also
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: There's a lot of good information about `ar` in its manual page, `man 1 ar`—for
    example, it's possible to modify and remove an already existing static library.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在其手册页`man 1 ar`中有关`ar`的大量有用信息，例如，可以修改和删除已经存在的静态库。
- en: Using a static library
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态库
- en: In this recipe, we'll use the static library created in the previous recipe
    in a program. Using a static library is a bit easier than using a dynamic library.
    We just add the static library (the archive file) to the list of files that will
    be compiled to a final binary.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将在程序中使用上一个教程中创建的静态库。使用静态库比使用动态库要容易一些。我们只需将静态库（存档文件）添加到将编译为最终二进制文件的文件列表中。
- en: Knowing how to use a static library will enable you to use other people's libraries
    and reuse your own code as static libraries.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何使用静态库将使您能够使用其他人的库并重用自己的代码作为静态库。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need both the `convert.h` file and the static library
    file, `libconvert.a`. You'll also need the GCC compiler.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，您将需要`convert.h`文件和静态库文件`libconvert.a`。您还需要GCC编译器。
- en: How to do it…
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Here, we will write a small program that uses our functions from the library
    we created in the previous recipe:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写一个小程序，该程序使用我们在上一个教程中创建的库中的函数：
- en: Write the following code in a file and save it as `temperature.c`. Notice the
    syntax for including header files from the current directory.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中写入以下代码，并将其保存为`temperature.c`。注意从当前目录包含头文件的语法。
- en: 'The program takes two arguments: an option (either `-f` or `-k` for Fahrenheit
    or Kelvin) and a Celsius degree as a floating-point value. The program will then
    convert the Celsius degree into Fahrenheit or Kelvin, depending on the option
    chosen:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序接受两个参数：一个选项（`-f`或`-k`，分别表示华氏度或开尔文）和一个摄氏度作为浮点值。然后程序将根据所选的选项将摄氏度转换为华氏度或开尔文：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s compile this program. To include the static library, we simply add it
    to the list of files to GCC. Also, make sure that the `convert.h` header file
    is in your current working directory:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编译这个程序。要包含静态库，我们只需将其添加到GCC的文件列表中。还要确保`convert.h`头文件在您当前的工作目录中：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we can test the program with some different temperatures:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以用一些不同的温度测试程序：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, take a look at the resulting `temperature` binary with `nm`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`nm`查看生成的`temperature`二进制文件：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since this binary will be used as a standalone program, we don''t need the
    symbols. It''s possible to *strip* the symbols from the binary with the `strip`
    command. This makes the program a bit smaller in size. Once we have stripped the
    binary from its symbols, let''s look at it again with `nm`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于该二进制文件将用作独立程序，我们不需要符号。可以使用`strip`命令从二进制文件中*strip*符号。这会使程序的大小变小一点。一旦我们从二进制文件中删除了符号，让我们再次用`nm`查看它：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can see if a program or library is stripped or not with the `file` command.
    Remember that a static library can''t be stripped; otherwise, the linker can''t
    see the functions, and the linking will fail:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以用`file`命令查看程序或库是否被剥离。请记住，静态库不能被剥离；否则，链接器将无法看到函数，链接将失败：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When we want to use the static library in a program, we give GCC the archive's
    filename and the program's `c` file, resulting in a binary that includes the static
    library.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在程序中使用静态库时，我们将存档文件的文件名和程序的`c`文件提供给GCC，从而生成一个包含静态库的二进制文件。
- en: In the last few steps, we examined the binary with `nm`, revealing all the symbols.
    Then we stripped—removed—those symbols, using the `strip` command. If we look
    at programs such as `ls`, `more`, `sleep`, and so on with the `file` command,
    we notice that these are also *stripped*. This means that the program has had
    its symbols removed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后几个步骤中，我们使用`nm`检查了二进制文件，显示了所有符号。然后我们使用`strip`命令剥离 - 移除 - 这些符号。如果我们使用`file`命令查看`ls`，`more`，`sleep`等程序，我们会注意到这些程序也被*剥离*。这意味着程序已经删除了其符号。
- en: A static library must have its symbols untouched. If they were removed—stripped—the
    linker wouldn't find the functions, and the linking process would fail. Therefore,
    we should never strip our static libraries.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 静态库必须保持其符号不变。如果它们被移除 - 剥离 - 链接器将找不到函数，链接过程将失败。因此，我们永远不应该剥离我们的静态库。
- en: Creating a dynamic library
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个动态库
- en: While static libraries are convenient and easy to both create and use, **dynamic
    libraries** are more common. Just as we saw at the beginning of this chapter,
    many developers choose to provide a library and not only a program—for example,
    cURL.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然静态库方便且易于创建和使用，**动态库**更常见。正如我们在本章开头看到的那样，许多开发人员选择提供库而不仅仅是程序 - 例如，cURL。
- en: In this recipe, we'll redo the library from the *Creating a static library*
    recipe that we covered earlier in this chapter so that it becomes a dynamic library.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将重新制作本章前面介绍的“创建静态库”配方中的库，使其成为一个动态库。
- en: Knowing how to create dynamic libraries enables you to distribute your code
    as easy-to-implement libraries for other developers to use.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何创建动态库使您能够将代码分发为其他开发人员易于实现的库。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need the two `convert.c` and `convert.h` files from
    the *Creating a static library* recipe earlier in this chapter. You'll also need
    the GCC compiler.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，您将需要本章前面的“创建静态库”中的两个`convert.c`和`convert.h`文件。您还需要GCC编译器。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Here, we make a dynamic library out of `convert.c` from the *Creating a static
    library* recipe earlier in this chapter:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从本章前面的“创建静态库”中的`convert.c`创建一个动态库：
- en: 'First of all, let''s remove the object file and the old static library we created
    earlier. This will make sure we don''t use the wrong object file or the wrong
    library by mistake:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们删除之前创建的对象文件和旧的静态库。这样可以确保我们不会错误地使用错误的对象文件或错误的库：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first thing we need to do is create a new object file from the `c` file.
    The `-c` option creates an object file, not the final binary. The `-fPIC` option
    tells GCC to generate what''s called `file`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是从`c`文件创建一个新的对象文件。`-c`选项创建一个对象文件，而不是最终的二进制文件。`-fPIC`选项告诉GCC生成所谓的`file`：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next step is to create a `.so` file, a `-shared` option does what it says—it
    creates a shared object. The `-Wl` option means that we want to pass all the options
    separated by commas to the linker. In this case, the option passed to the linker
    is `-soname` with the argument `libconvert.so`, which sets the name of the dynamic
    library to *libconvert.so*. Finally, the `-o` option specifies the name of the
    output file. Then, we list the symbols that this shared library provides, using
    `nm`. The symbols preceded by a `T` are the symbols provided by this library:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一个`.so`文件，`-shared`选项做了它说的 - 它创建了一个共享对象。`-Wl`选项意味着我们想要将所有逗号分隔的选项传递给链接器。在这种情况下，传递给链接器的选项是`-soname`，参数是`libconvert.so`，它将动态库的名称设置为*libconvert.so*。最后，`-o`选项指定了输出文件的名称。然后，我们使用`nm`列出了这个共享库提供的符号。由`T`前缀的符号是这个库提供的符号：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'Creating a dynamic library involves two steps: creating an object file that''s
    position-independent, and packaging that file in a `.so` file.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建动态库涉及两个步骤：创建一个位置无关的对象文件，并将该文件打包成一个`.so`文件。
- en: The code in a shared library gets loaded at runtime. Since it can't predict
    where it will end up in memory, it needs to be position-independent. That way,
    the code will work correctly, no matter where in memory it gets called.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库中的代码在运行时加载。由于它无法预测自己将在内存中的何处结束，因此需要是位置无关的。这样，代码将在内存中的任何位置正确工作。
- en: The `-Wl,-soname,libconvert.so` GCC option might need some further explanation.
    The `-Wl` option tells GCC to treat any comma-separated words as options to the
    linker. Since we can't use a space—that would be treated as a new option—we separate
    `-soname` and `libconvert.so` with a comma instead. The linker, however, sees
    it as `-soname libconvert.so`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Wl，-soname，libconvert.so` GCC选项可能需要进一步解释。`-Wl`选项告诉GCC将逗号分隔的单词视为链接器的选项。由于我们不能使用空格
    - 那将被视为一个新的选项 - 我们用逗号代替`-soname`和`libconvert.so`。然而，链接器将其视为`-soname libconvert.so`。'
- en: '`soname` is short for *shared object name*, which is an internal name in the
    library. It''s this name that is used when referring to the library.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`soname`是*共享对象名称*的缩写，它是库中的内部名称。在引用库时使用这个名称。'
- en: 'The actual filename specified with the `-o` option is sometimes called the
    *real name* of the library. It''s a standard convention to use a real name that
    contains the version number of the library, such as `1` in this example. It''s
    also possible to include a minor version—for example, `1.3`. In our example, it
    would look like this: `libconvert.so.1.3`. Both the *real name* and the *soname*
    must begin with `lib`, short for *library*. All in all, this gives us a total
    of five parts for the real name:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-o`选项指定的实际文件名有时被称为库的*真实名称*。使用包含库版本号的真实名称是一个标准约定，例如在这个例子中使用`1`。也可以包括一个次要版本
    - 例如，`1.3`。在我们的例子中，它看起来像这样：`libconvert.so.1.3`。*真实名称*和*soname*都必须以`lib`开头，缩写为*库*。总的来说，这给我们提供了真实名称的五个部分：
- en: '`lib` (short for library)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib`（库的缩写）'
- en: '`convert` (the name of the library)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convert`（库的名称）'
- en: '`.so` (the extension, short for *shared object*)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.so`（扩展名，缩写为*共享对象*）'
- en: '`.1` (the major version of the library)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.1`（库的主要版本）'
- en: '`.3` (the minor version of the library, optionally)'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.3`（库的次要版本，可选）'
- en: There's more…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Contrary to static libraries, dynamic libraries can be stripped and will still
    work. Note, however, that the stripping must then occur after creating the dynamic
    library on the `.so` file. If we were to strip the object (`.o`) file instead,
    we would lose all the symbols, making it useless for linking. But a `.so` file
    keeps the symbols in a special table called `.dynsym`, which the `strip` command
    won't touch. It's possible to view this table on a stripped dynamic library with
    the `readelf` command, using the `--symbols` option. So, if the `nm` command replies
    with *no symbols* on a dynamic library, you can try `readelf --symbols` instead.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与静态库相反，动态库可以被剥离并且仍然可以工作。但是请注意，剥离必须在创建`.so`文件的动态库之后进行。如果我们剥离对象（`.o`）文件，那么我们将丢失所有符号，使其无法链接。但是`.so`文件将符号保留在一个称为`.dynsym`的特殊表中，`strip`命令不会触及。可以使用`readelf`命令的`--symbols`选项在剥离的动态库上查看此表。因此，如果`nm`命令在动态库上回复*no
    symbols*，可以尝试使用`readelf --symbols`。
- en: See also
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '**GCC** is a massive piece of software with lots of options. There are PDF
    manuals available for each version of GCC on GNU''s website. The manuals are about
    1,000 pages long and can be downloaded from https://gcc.gnu.org/onlinedocs/.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**GCC**是一个庞大的软件，有很多选项。GNU的网站上提供了每个GCC版本的PDF手册。这些手册大约有1000页，可以从https://gcc.gnu.org/onlinedocs/下载。'
- en: Installing the dynamic library on the system
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在系统上安装动态库
- en: We have now seen how to create both static and dynamic libraries, and in [*Chapter
    3*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*, Diving Deep into C in Linux*,
    we even saw how we could use a dynamic library from our home directory. But now,
    the time has come to install a dynamic library system-wide so that any user on
    your computer can use it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到如何创建静态库和动态库，在[*第3章*](B13043_03_Final_SK_ePub.xhtml#_idTextAnchor097)*，深入Linux中的C编程*中，我们甚至看到了如何从我们的主目录中使用动态库。但现在，是时候将动态库系统范围内安装，以便计算机上的任何用户都可以使用它了。
- en: Knowing how to install a dynamic library on a system will enable you to add
    libraries system-wide for any user to use.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何在系统上安装动态库将使您能够为任何用户添加系统范围的库。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need the `libconvert.so.1` dynamic library we created
    in the previous recipe. You will also need root access to the system, either via
    `sudo` or `su`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个步骤，您将需要在上一个步骤中创建的`libconvert.so.1`动态库。您还需要root访问系统，可以通过`sudo`或`su`来获取。
- en: How to do it…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Installing a dynamic library is just a matter of moving the library file and
    header file to the correct directory and running a command. However, there are
    some conventions we should follow:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 安装动态库只是将库文件和头文件移动到正确的目录并运行命令的问题。但是，我们应该遵循一些约定：
- en: 'The first thing we need to do is to copy the library file to the correct place
    on the system. A common directory for user-installed libraries is `/usr/local/lib`,
    which we will use here. Since we are copying the file to a place outside of our
    home directory, we need to execute the command as the root user. We''ll use `install`
    here to set the user, the group, and the mode in a single command, and since it''s
    a system-wide install, we want it to be owned by root. It should also be executable
    since it will be included and executed at runtime:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将库文件复制到系统的正确位置。用户安装的库的常见目录是`/usr/local/lib`，我们将在这里使用。由于我们将文件复制到家目录之外的地方，我们需要以root用户的身份执行该命令。我们将在这里使用`install`来设置用户、组和模式，因为它是系统范围的安装，我们希望它由root拥有。它还应该是可执行的，因为它将在运行时被包含和执行：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, we must run the `ldconfig` command, which will create the necessary links
    and update the cache.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须运行`ldconfig`命令，它将创建必要的链接并更新缓存。
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We must also copy the header file to a system directory; otherwise, the user
    would have to download and keep track of the header file manually, which is less
    than ideal. A good place for user-installed header files is `/usr/local/include`.
    The word *include* is from the C language `#include` line:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还必须将头文件复制到系统目录；否则，用户将不得不手动下载并跟踪头文件，这不太理想。用户安装的头文件的一个好地方是`/usr/local/include`。单词*include*来自C语言的`#include`行：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Since we installed the library and the header file system-wide, we can go ahead
    and remove them from our current working directory. Doing so will make sure that
    we use the correct files in the next recipe:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经在整个系统中安装了库和头文件，我们可以继续从当前工作目录中删除它们。这样做将确保我们在下一个步骤中使用正确的文件：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We installed the library file and header file using `install`. This program
    is excellent for tasks such as this since it sets the user (the `-o` option),
    the group (the `-g` option), and the mode (the `-m` option) in a single command.
    If we had used `cp` to copy the file, it would have been owned by the user who
    created it. We always want system-wide installation of binaries, libraries, and
    header files owned by the root user for security purposes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`install`程序安装了库文件和头文件。这个程序非常适合这样的任务，因为它可以在单个命令中设置用户（`-o`选项）、组（`-g`选项）和模式（`-m`选项）。如果我们使用`cp`来复制文件，它将由创建它的用户拥有。我们总是希望系统范围内的二进制文件、库和头文件由root用户拥有，以确保安全。
- en: The `/usr/local` directory is a good place for user-created stuff. We placed
    our library under `/usr/local/lib` and our header file under `/usr/local/include`.
    System libraries and header files are often placed in `/usr/lib` and `/usr/include`,
    respectively.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`/usr/local`目录是用户创建的东西的一个好地方。我们将库放在`/usr/local/lib`下，将头文件放在`/usr/local/include`下。系统库和头文件通常放在`/usr/lib`和`/usr/include`中。'
- en: When we later use the library, the system will look for it in a file with a
    `.so` ending, and hence we need a symbolic link to the library with the name `libconvert.so`.
    But we didn't need to create that link ourselves; `ldconfig` took care of that
    for us.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们稍后使用库时，系统将在以`.so`结尾的文件中查找它，因此我们需要一个指向库的符号链接，名称为`libconvert.so`。但我们不需要自己创建该链接；`ldconfig`已经为我们处理了。
- en: Also, since we have placed the header file in `/usr/local/include`, we don't
    need to have that file in our current working directory anymore. We can now use
    the same syntax when including it like any other system header file. We'll see
    this in the next recipe.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，由于我们已经将头文件放在`/usr/local/include`中，我们不再需要在当前工作目录中拥有该文件。现在我们可以像包含任何其他系统头文件一样使用相同的语法。我们将在下一个示例中看到这一点。
- en: Using the dynamic library in a program
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在程序中使用动态库
- en: Now that we have created a dynamic library and installed it on our system, it's
    time to try it out in a program. We have actually been using dynamic libraries
    without even thinking about it since the very beginning of this book. Functions
    such as `printf()` and so on are all part of the standard library. In the *The
    what and why of libraries* recipe from earlier in this chapter, we used another
    dynamic library called cURL. In this recipe, we'll use our very own library that
    we installed in the previous recipe.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个动态库并将其安装在系统上，现在是时候在程序中尝试它了。实际上，自从本书的开头以来，我们一直在使用动态库而不自知。诸如`printf()`等函数都是标准库的一部分。在本章前面的*库的作用和原因*示例中，我们使用了另一个名为cURL的动态库。在这个示例中，我们将使用我们在上一个示例中安装的自己的库。
- en: Knowing how to use custom libraries will enable you to use other developers'
    code, which will speed up the development process. There's often no need to reinvent
    the wheel.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何使用自定义库将使您能够使用其他开发人员的代码，这将加快开发过程。通常没有必要重新发明轮子。
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we'll need the `temperature.c` code from the *Using a static
    library* recipe earlier in this chapter. That program will use the dynamic library.
    You'll also need to complete the previous recipe before attempting this one.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将需要本章前面的*使用静态库*示例中的`temperature.c`代码。该程序将使用动态库。在尝试此示例之前，您还需要完成上一个示例。
- en: How to do it…
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In this recipe, we''ll use the `temperature.c` code to make use of the library
    we installed in the previous recipe:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`temperature.c`代码来利用我们在上一个示例中安装的库：
- en: 'Since we will use the `/usr/local/include`, we must modify the `#include` line
    in `temperature.c`. *Line 4* in `temperature.c` currently appears as this:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用`/usr/local/include`，我们必须修改`temperature.c`中的`#include`行。`temperature.c`中的*第4行*当前显示为：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Change the preceding code to this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码更改为：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Then, save it as `temperature-v2.c`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其保存为`temperature-v2.c`。
- en: 'We can now go ahead and compile the program. GCC will use the system-wide header
    file and library file. Remember that we need to link against the library using
    the `-l` option. When we do this, we must leave out the `lib` part and `.so` ending:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以继续编译程序了。GCC将使用系统范围的头文件和库文件。请记住，我们需要使用`-l`选项链接到库。这样做时，我们必须省略`lib`部分和`.so`结尾：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, let''s try it out with some different temperatures:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们尝试一些不同的温度：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can verify which libraries are dynamically linked with `ldd`. When we run
    this tool on our program, we see our `libconvert.so` library, `libc`, and something
    called `vdso` (*virtual dynamic shared object*):'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`ldd`验证动态链接的库。当我们在我们的程序上运行此工具时，我们会看到我们的`libconvert.so`库，`libc`和称为`vdso`（*虚拟动态共享对象*）的东西：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we include local header files from our current directory, the syntax is
    `#include "file.h"`. But for system-wide header files, the syntax is `#include
    <file.h>`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从当前目录包含本地头文件时，语法是`#include "file.h"`。但对于系统范围的头文件，语法是`#include <file.h>`。
- en: Since the library is now installed in one of the system directories, we didn't
    need to specify the path to it. It was sufficient to link against the library
    with `-lconvert`. When doing so, all the common system-wide directories are being
    searched for the library. When we link with `-l`, we leave out both the `lib`
    part of the filename and the `.so` ending—the linker figures this out on its own.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于库现在安装在系统目录之一中，我们不需要指定路径。仅需使用`-lconvert`链接到库即可。这样做时，所有常见的系统范围目录都会搜索该库。当我们使用`-l`进行链接时，我们省略了文件名的`lib`部分和`.so`结尾——链接器会自行解决这个问题。
- en: In the last step, we verified that we are using the system-wide installation
    of `libconvert.so`, using `ldd`. Here, we also saw the standard C library, `libc`,
    and something called `vdso`. The standard C library has all the usual functions
    that we use time and time again, such as `printf()`. The `vdso` library, however,
    is a bit more arcane and is not something we are going to cover here. In short,
    it exports a small set of often-used system calls to userland to avoid too much
    context-switching, which would impair performance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们使用`ldd`验证了我们正在使用`libconvert.so`的系统范围安装。在这里，我们还看到了标准C库`libc`和称为`vdso`的东西。标准C库具有我们一次又一次使用的所有常用函数，例如`printf()`。然而，`vdso`库有点更加神秘，这不是我们要在这里讨论的内容。简而言之，它将一小部分经常使用的系统调用导出到用户空间，以避免过多的上下文切换，这将影响性能。
- en: There's more…
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Throughout this chapter, we've talked a lot about the `ld`. To gain a deeper
    understanding of the linker, I suggest you read its manual page with `man 1 ld`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经谈论了很多关于`ld`的内容。为了更深入地了解链接器，我建议您阅读其手册页，使用`man 1 ld`。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more information about `ldd`, see `man 1 ldd`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`ldd`的更多信息，请参阅`man 1 ldd`。
- en: For the curious mind, there's a detailed explanation of `vdso` in `man 7 vdso`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的人，可以在`man 7 vdso`中找到有关`vdso`的详细解释。
- en: Compiling a statically linked program
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译静态链接程序
- en: 'Now that we have such a deep understanding of libraries and linking, we can
    create a **statically linked** program—that is, a program with all dependencies
    compiled into it. This makes the program—more or less—dependency-free. Making
    statically linked programs isn''t common but sometimes it can be desirable—for
    example, if you for some reason need to distribute a single precompiled binary
    to many computers without worrying about installing all the libraries. But please
    note: it''s not always possible to create completely dependency-free programs.
    If a program uses a library that depends on another library, this is not easily
    accomplished.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对库和链接有了如此深刻的理解，我们可以创建一个**静态链接**程序——也就是说，一个将所有依赖项编译到其中的程序。这使得程序基本上不依赖于其他库。制作静态链接程序并不常见，但有时可能是可取的——例如，如果由于某种原因需要将单个预编译的二进制文件分发到许多计算机而不必担心安装所有的库。但请注意：并不总是可能创建完全不依赖于其他程序的程序。如果一个程序使用了依赖于另一个库的库，这就不容易实现。
- en: The downside of making and using statically linked programs is that they get
    a lot bigger in size. Also, it's no longer possible to update the program's libraries
    without recompiling the entire program. So, bear in mind that this is only used
    in rare cases.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 制作和使用静态链接程序的缺点是它们的大小变得更大。此外，不再能够更新程序的库而不重新编译整个程序。因此，请记住这只在极少数情况下使用。
- en: But, by knowing how to compile statically linked programs, you not only enhance
    your knowledge but will also be able to distribute precompiled binaries to systems
    without the necessary libraries, on many different distributions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，通过了解如何编译静态链接程序，你不仅可以增强你的知识，还可以将预编译的二进制文件分发到没有必要的库的系统上，而且可以在许多不同的发行版上实现。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need to have completed the two previous recipes—in other
    words, you need to have installed the `libconvert.so.1` library on the system,
    and you need to have compiled `temperature-v2.c`. You also need the GCC compiler,
    as usual.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，你需要完成前两个示例——换句话说，你需要在系统上安装`libconvert.so.1`库，并且需要编译`temperature-v2.c`。像往常一样，你还需要GCC编译器。
- en: How to do it…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we''ll compile a statically linked version of `temperature-v2.c`.
    We''ll then remove the library from the system and notice that the statically
    linked program still works while the other doesn''t:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编译`temperature-v2.c`的静态链接版本。然后，我们将从系统中删除库，并注意到静态链接的程序仍然可以工作，而另一个则不能：
- en: Important note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: On Fedora and CentOS, the static library for `libc` isn't included by default.
    To install it, run `sudo dnf install glibc-static`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fedora和CentOS上，默认情况下不包括`libc`的静态库。要安装它，运行`sudo dnf install glibc-static`。
- en: 'To link against the libraries statically, we need to have static versions of
    all the libraries. This means that we have to recreate the archive (`.a`) version
    of our library and install that as well. These steps are the same as from the
    *Creating a static library* recipe earlier in this chapter. First, we remove the
    object file, if we still have it. Then, we create a new one and create an archive
    from that:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了静态链接到库，我们需要所有库的静态版本。这意味着我们必须重新创建库的存档（`.a`）版本，并将其安装。这些步骤与本章前面的*创建静态库*示例中的步骤相同。首先，如果我们仍然有对象文件，我们将删除它。然后，我们创建一个新的对象文件，并从中创建一个存档：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we must install the static library on the system, preferably in the same
    location as the dynamic library. A static library doesn''t need to be executable
    since it''s included at compile time, not at runtime:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须在系统上安装静态库，最好与动态库放在同一个位置。静态库不需要可执行文件，因为它是在编译时包含的，而不是在运行时包含的：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, compile a statically linked version of `temperature-v2.c`. The `-static`
    option makes the binary statically linked, meaning it will include the library
    code in the binary:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译`temperature-v2.c`的静态链接版本。`-static`选项使二进制文件静态链接，这意味着它将在二进制文件中包含库代码：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Before we try the program, let''s examine it with `ldd`, and also its size
    with `du`. Notice that on my system, the binary is now almost 800 kilobytes (on
    another system, it''s 1.6 megabytes). Compare this to the dynamic version, which
    is only around 20 kilobytes:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们尝试这个程序之前，让我们用`ldd`来检查它，并用`du`来查看它的大小。请注意，在我的系统上，二进制文件现在几乎有800千字节（在另一个系统上，它有1.6兆字节）。与动态版本相比，动态版本只有大约20千字节：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s try the program:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试这个程序：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s remove both the static and the dynamic libraries from the system:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从系统中删除静态和动态库：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let''s try the dynamically linked binary, which shouldn''t work since
    we have removed a library that it depends on:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试动态链接的二进制文件，由于我们已经删除了它所依赖的库，所以它不应该工作：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, let''s try the statically linked binary, which should work just as
    well as before:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们尝试静态链接的二进制文件，它应该和以前一样正常工作：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: How it works…
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: A statically linked program includes all the code from all the libraries, which
    is why our binary got so huge in this example. To build a statically linked program,
    we need static versions of all the program's libraries. That's why we needed to
    recreate the static library and place it in one of the system directories. We
    also needed a static version of the standard C library, which we installed if
    we were using a CentOS or Fedora machine. On Debian/Ubuntu, it's already installed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 静态链接的程序包括所有库的所有代码，这就是为什么在这个示例中我们的二进制文件变得如此庞大。要构建一个静态链接的程序，我们需要程序所有库的静态版本。这就是为什么我们需要重新创建静态库并将其放在系统目录中的原因。我们还需要标准C库的静态版本，如果我们使用的是CentOS或Fedora机器，我们会安装它。在Debian/Ubuntu上，它已经安装好了。
