# 十五、互联网协议基础

在最后一章中，重点是维护系统的时间和日志。特别是，我们谈到了操纵系统的方法。接下来，我们研究了日志记录，并探索了常见的日志文件。最后，我们使用了远程。然后，我们在 Fedora 系统上生成测试日志，并验证我们在 Ubuntu `rsyslog`服务器上收到了这些日志。

本章重点讲的都是**互联网协议** ( **IP** )。我们从 IPv4 开始，看看地址结构和当今环境中常用的各种 IPv4 地址。然后，我们继续划分 IPv4 地址的子网，确定 IPv4 地址的网络和主机部分。接下来是 IPv6。我们看一下 IPv6 地址的结构和一些众所周知的 IPv6 地址。然后我们将重点放在减少冗长的 IPv6 地址的方法上。最后，我们的重点是协议。我们将介绍一些众所周知的协议及其各自的端口号。

我们将涵盖以下主题:

*   IPv4 寻址
*   IPv6 寻址
*   众所周知的协议

# IPv4 寻址

IP 版本 4 是 IP 的第四个版本。正如我们所知，它在互联网中起着至关重要的作用。到目前为止，IPv4 是网络内外各种设备寻址最常用的协议。关于 IP 的另一个有趣的事实是，它不像 TCP 那样面向连接；相反，IP 是无连接的。

IPv4 地址由 32 位或 4 字节长度组成。我们计算基数为 2 的地址；这给了我们 2^32，相当于 4，294，967，296 个地址。看起来好像有很多 IPv4 地址；然而，现实却不同。事实上，目前存在 IPv4 短缺。IPv4 地址以点分十进制格式表示。IPv4 地址的示例如下:

```sh
192.168.1.1
```

在这里，我们可以看到 IPv4 地址确实是以点分十进制格式表示的。点`.`作为地址之间的分隔符。数字可以是 0 到 255 之间的任何值，包括 0 到 255。IPv4 地址的每一部分都称为一个八位字节；因此，这四个数字组成了四个八位字节。当今环境中有各种类型的 IPv4 地址可用；特别是在**局域网** ( **局域网**)中，您可能会看到以下内容之一:

*   `10.0.0.0/8`
*   `172.16.0.0/12`
*   `192.16.0.0/16`

这些地址可能看起来很熟悉。这三个地址可以通过 RFC 1918 进一步解释；这指定了要在专用网络(如局域网)中使用的特定地址。

我们有五类地址空间；前四个类通常用于各种类型的环境中。这些是地址的类别:

| 甲级 | 0-127 |
| 乙类 | 128-191 |
| 丙类 | 192-223 |
| D 类 | 224-239 |
| E 级 | 240-255 |

这里，数字范围表示第一个八位字节中的占位符。我们可以分解 IPv4 地址，以便更好地理解。我们将使用第一个八位字节作为参考。首先，我们将建立一个表。IPv4 地址的每一个八位字节代表一个字节；1 字节= 8 位。然后，我们可以使用这些信息来形成我们的表格:

| seven | six | five | four | three | Two | one | Zero | = 8 位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | Eighteen | four | Two | one | = 255 |

太棒了。基于此，我们从 7 到 0 计数的原因是，当计算 IPv4 地址内八位字节的值时，我们总是从 0 开始，添加时从右向左移动。现在，我们得到这个值的方法是通过多重输入 2^x，其中 x =右边的最后一个字符。所以应该是这样的:

| seven | six | five | four | three | Two | one | Zero | = 8 位位置 |
| one | one | one | one | one | one | one | one | = 1 表示该位开启 |
| 2^ | 2^ | 2^ | 2^ | 2^ | 2^ | 2^ | 2^ | =基数 2 |
| One hundred and twenty-eight | six | Thirty-two | Sixteen | eight | four | Two | one | =每个位位置的基数为 2 的结果 |

使用 8 位内的所有值，我们得到 *128+64+32+16+8+4+2+1 = 255* 。

在此基础上，我们现在看到如何使用基数 2 来计算表。因此，在任何给定时间，只有 0-255 之间的值，包括 0 和 255，才是合法值。

# 甲级

A 类地址空间 0-127 查看第一个八位字节中唯一的前导位位置(位置 7，因为我们从 0 到 7 计数)；这被称为最高有效位位置。127 地址空间被保留；这就是所谓的环回地址空间。因此，我们只使用值 0-126。此外，0 实际上是为网络使用而保留的(稍后我们讨论子网划分时会对此进行详细说明)。现在，我们计算 A 类地址的第一个值的方法如下:

| seven | six | five | four | three | Two | one | Zero | = 8 位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | =255 |
| Zero | Zero | Zero | Zero | Zero | Zero | Zero | Zero | = 0-127 |

基于此，我们在第一个八位字节中关闭了所有八位。因此，这为我们提供了第一个八位字节中 0-126 之间的 A 类地址空间，0 为保留空间，127 为回送空间。因此，第一个八位字节中真正可用的 IPv4 地址是 1-126。然后是剩余的三个八位字节全为零。因此，甲级地址空间如下:

*   A 类`0-126.0.0.0/8`，其中第 8 位位置的前导位为 0
*   甲类预留地址空间`127.0.0.0/8`
*   A 类**自动私有 IP 地址在** g ( **APIPA** ) `169.0.0.0/8`保留

基于此，我们最多可以定义 126 个网络。A 类地址的剩余三个八位字节`0.0.0`组成主机部分；每个八位字节由八位组成。主机是可以分配 IPv4 地址的任何设备。每个定义的网络中，A 类地址允许的最大主机数量为 16，777，214 台。主机部分是 2^3 八位字节的结果(每八位字节八位 x 3 =24 位)–2 = 1677216-2 = 16，777，214 台主机/a 类网络。

# 乙类

B 类地址空间，128-191，看第 7 位和第 6 位的前导位(记住我们从 0 开始计数，从左向右移动)。第一个最高有效位(位置 7)以二进制形式开启。该位置 1，第二个最高有效位位置 6 设置为 0。这可以从我们之前创建的表中看出:

| seven | six | five | four | three | Two | one | Zero | = 8 位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | =255 |
| one | Zero | Zero | Zero | Zero | Zero | Zero | Zero | = 128 |

基于此，最高有效位被开启，第二最高有效位被关闭。这给了我们 128-191 的地址空间，其中 128 被保留用于网络使用，191 被保留作为广播地址。我们将在本章后面讨论子网划分时讨论广播地址。在 B 类地址空间中，前 16 位保留给网络使用；但是，保留了两位。这将为我们提供 2^14 =每个 b 类地址 16，384 个网络。这可以说明如下:

| seven | six | five | four | three | Two | one | Zero | = 8 位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | = 255 |
| one | Zero | Zero | Zero | Zero | Zero | Zero | Zero | = 128 |

我们必须跳过前两位，位置 7 和 6；这就给了我们 2^14 = 163864 个网络

基于此，我们看到了可用网络的最大数量，但没有看到主机的最大数量。我们计算 B 类地址的主机的方法是使用主机的最后两个八位字节；我们将使用 2^2 八位字节(每八位字节八位 x 2 = 16 位)—网络和广播的两位数= 65，536 -2 =每个 b 类网络 65，534 台主机。

# 丙类

C 类地址空间 192-223 考虑前三个最高有效位；即位置 7、6 和 5。前两个最高有效位开启；它们在二进制中设置为 1。第三位，二进制中的位置 5，被关闭；这被设置为 0。前 24 位保留给 C 类地址空间中的网络使用。然后，我们可以使用这些信息构建我们的表。这张桌子看起来是这样的:

| seven | six | five | four | three | Two | one | Zero | = 8 位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | =255 |
| one | one | Zero | Zero | Zero | Zero | Zero | Zero | = 128+64=>192 |

基于此，我们可以看到 C 类地址空间从 192 开始，到 223 结束。192 为网络保留，223 为广播保留。然后，我们可以通过使用 2^21 = 2，097，152 个网络来计算网络的数量。这可以在下表中表示:

| seven | six | five | four | three | Two | one | Zero | = 8 位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | =255 |
| one | one | Zero | Zero | Zero | Zero | Zero | Zero | =前 3 位总计 192 |

24 位保留给 c 类，24 位—三个最高有效位= 21，然后 2^21 位= 2，097，152 个网络。

最后一个八位字节`.0`(八位)保留给主机地址。这意味着 2^1 八位字节(8 位)-网络和广播的 2 位= 256 - 2 =每个 c 类地址 254 台主机。

# D 类

类别 D，224-239，地址空间是为多播使用而保留的。前三个最高有效位开启；它们被设置为 1。第四个最高有效位设为 0。D 类地址空间不用于 IP 寻址，就像前面的地址类一样。相反，D 类地址空间用于为多播组分配一个 IP 地址。这些主机是一个组的一部分，该组又共享一个组地址。下表说明了用于 D 类地址空间的位:

| seven | six | five | four | three | Two | one | Zero | = 8 位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | = 255 |
| one | one | one | Zero | Zero | Zero | Zero | Zero | =总计 224 |

基于此，D 类地址空间从`224.0.0.0`开始，到`239.255.255.255`结束。

# E 级

E 类，240-255，地址空间留作将来使用。因此，它不像以前的地址空间那样实现。前四个最高有效位开启；它们被设置为 1。E 类中唯一使用的地址是`255.255.255.255`；这就是所谓的全广播地址。下表说明了用于 E 类地址空间的位:

| seven | six | five | four | three | Two | one | Zero | = 8 位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | = 255 |
| one | one | one | one | Zero | Zero | Zero | Zero | =总计 240 |

基于此，E 类地址空间从`240.0.0.0`开始，到`255.255.255.255`结束，其中`255.255.255.255`为所有广播地址保留。

# 子网掩码

我们刚刚介绍了 IPv4 地址空间的各种类别，但有时使用这些类别的地址空间可能并不合适。事实上，如果我们对 A 类、B 类和 C 类 IP 使用默认子网掩码，它们就是有类地址空间。例如，甲类使用`255.0.0.0`子网掩码。但是等等，什么是子网掩码？首先，子网掩码标识给定 IP 地址的网络部分和主机部分。这包括 IPv4 和 IPv6。子网掩码使我们能够轻松找到给定 IP 地址的网络地址。子网掩码通常以点分十进制格式编写。但是，可以用斜线符号表示子网掩码；也就是 CIDR 符号。无类域间路由(简称 CIDR)通过将斜杠格式的网络位数附加到 IP 地址来表示子网掩码。对于 A 类地址，子网掩码如下:

```sh
255.0.0.0
```

基于此，值`255.0.0.0`意味着第一个八位字节中的所有位都被开启；它们被设置为 1。我们可以使用之前创建的表来展示这一点:

| seven | six | five | four | three | Two | one | Zero | =位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | =2^比特位置 |
| one | one | one | one | one | one | one | one | =位开启 |

128+64+32+16+8+4+2+1 = 255 位

基于此，255 的值是从所有 8 位的总和中得出的。此外，子网掩码也可以用二进制格式表示。使用 A 类地址，子网掩码可以写成如下形式:

*   **十进制甲类子网掩码** : `255.0.0.0`
*   **二进制甲类子网掩码** : `11111111.00000000.00000000.00000000`

太棒了。现在，我们可以看到子网掩码可以使用 0-255 之间的值以十进制格式表示，也可以使用 0 或 1 的值以二进制格式表示。此外，还可以用 CIDR 符号表示子网掩码。我们将使用以下内容以 CIDR 格式表示甲级地址:

*   **十进制甲类子网掩码** : `255.0.0.0`
*   **二进制甲类子网掩码** : `11111111.00000000.00000000.00000000`
*   **CIDR 甲级子网掩码** : `/8`

基于此，`/8`表示为地址的网络部分打开八位。

使用 B 类地址，我们将使用点分十进制格式以下列格式表示 B 类地址:

```sh
255.255.0.0
```

基于此，值`255.255.0.0`意味着第一个和第二个八位字节中的所有位都被开启；它们被设置为 1。我们可以使用之前创建的表来展示这一点:

第一个八位字节:

| seven | six | five | four | three | Two | one | Zero | =位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | 2^比特位置 |
| one | one | one | one | one | one | one | one | =位开启 |

128+64+32+16+8+4+2+1 = 255 位

第二个八位字节:

| seven | six | five | four | three | Two | one | Zero | =位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | 2^比特位置 |
| one | one | one | one | one | one | one | one | =位开启 |

128+64+32+16+8+4+2+1 = 255 位

在此基础上，`255.255.0.0`的值由所有 16 位的总和得出。此外，子网掩码也可以用二进制格式表示。使用 B 类地址，子网掩码可以写成如下形式:

*   **乙类子网掩码(十进制)** : `255.255.0.0`
*   **二进制 B 类子网掩码** : `11111111.11111111.00000000.00000000`

太棒了。现在，我们可以看到子网掩码可以使用 0-255 之间的值以十进制格式表示，也可以使用 0 或 1 的值以二进制格式表示。此外，还可以用 CIDR 符号表示子网掩码。我们将使用以下内容表示 CIDR 格式的 B 类地址:

*   **乙类子网掩码(十进制)** : `255.255.0.0`
*   **二进制 B 类子网掩码** : `11111111.11111111.00000000.00000000`
*   **CIDR B 类子网掩码** : `/16`

基于此，`/16`表示为地址的网络部分开启 16 位。

使用 C 类地址，我们将使用点分十进制格式以下列格式表示 C 类地址:

```sh
255.255.255.0
```

基于此，值`255.255.255.0`意味着第一个和第二个八位字节中的所有位都被开启；它们被设置为 1。我们可以使用之前创建的表来展示这一点:

第一个八位字节:

| seven | six | five | four | three | Two | one | Zero | =位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | =2^比特位置 |
| one | one | one | one | one | one | one | one | =位开启 |

128+64+32+16+8+4+2+1 = 255 位

第二个八位字节:

| seven | six | five | four | three | Two | one | Zero | =位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | =2^比特位置 |
| one | one | one | one | one | one | one | one | =位开启 |

128+64+32+16+8+4+2+1 = 255 位

第三个八位字节:

| seven | six | five | four | three | Two | one | Zero | =位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | =2^比特位置 |
| one | one | one | one | one | one | one | one | =位开启 |

128+64+32+16+8+4+2+1 = 255 位

在此基础上，`255.255.255.0`的值由所有 24 位的总和得出。此外，子网掩码也可以用二进制格式表示。使用 C 类地址，子网掩码可以写成如下形式:

*   **十进制丙类子网掩码** : `255.255.255.0`
*   **二进制的丙类子网掩码** : `11111111.11111111.11111111.00000000`

太棒了。现在，我们可以看到子网掩码可以使用 0-255 之间的值以十进制格式表示，也可以使用 0 或 1 的值以二进制格式表示。此外，还可以用 CIDR 符号表示子网掩码。我们将使用以下内容以 CIDR 格式表示丙类地址:

*   **十进制丙类子网掩码** : `255.255.255.0`
*   **二进制的丙类子网掩码** : `11111111.11111111.11111111.00000000`
*   **CIDR 丙类子网掩码** : `/24`

基于此，`/24`表示为地址的网络部分开启 24 位。

# 子网划分

正如我们刚刚看到的 A 类、B 类和 C 类，它们的子网掩码分别是`/8`、`16`和`24`，使用的是 CIDR 符号。在当今大多数环境中，这些默认子网掩码被称为有类掩码，这意味着如果我们按原样使用这些子网掩码，我们将无法执行任何类型的流量工程。当我们想要控制广播域时，这就成了一个问题。我们应该尽量减少对特定房间、办公室或部门的广播。这确保了在任何类型的网络广播中，整个网络都不会出现延迟。我们可以利用子网划分来克服有类网络的限制。例如，让我们选择一个丙类 IP 地址:

```sh
192.168.0.0/24
```

基于此，每个网络地址最多可以有 254 台主机。我们可能处于只有八个系统需要 IP 连接的情况。这将意味着我们丢失了剩余的 IP 地址，因为我们使用了默认的 C 类子网。这种情况下的要求是有八个 IP 地址，并且不要浪费剩余的 IP。我们可以通过划分子网来达到这个要求。通过从主机部分借用位，子网划分成为可能。让我们写出给定 IP 地址的子网掩码:

```sh
192.168.0.0/24 Network
```

*   **十进制子网掩码** : `255.255.255.0`
*   **二进制子网掩码** : `11111111.11111111.11111111.00000000`

基于此，前 24 位被开启。我们可以将这个地址划分为子网，以便获得对我们的 IP 地址空间的更多控制。我们要八个 IPs。我们借用位的方式是从主机位中取位。我们可以利用我们的桌子寻求帮助:

| seven | six | five | four | three | Two | one | Zero | =位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | =2^比特位置 |
| one | one | one | one | Zero | Zero | Zero | Zero | =借用 4 位 |

*   2^4bits =可以创建 16 个网络
*   2^4 -2 =每个网络 14 台主机

基于此，我们从网络的主机部分借用了四位；这使我们能够创建四个更小的子网/网络。创建的每个网络将有 14 台主机。与使用标准的 C 类`/24`网络相比，这使我们能够节省丢失的入侵防御系统的数量。因此，我们为网络部分借用了四位。我们如何用十进制和 CIDR 记数法来表示它？我们表示新创建的子网的方式是通过添加网络位的过程。下表说明了这一点:

| seven | six | five | four | three | Two | one | Zero | =位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | =2^比特位置 |
| one | one | one | one | Zero | Zero | Zero | Zero | =4 位 |

128+64+32+16 = 240

*   十进制的旧子网= `255.255.255.0`
*   CIDR 的旧子网= `/24`
*   十进制新子网= `255.255.255.240`
*   CIDR 新子网= `/28`
*   网络地址= `192.168.0.0/28`

基于此，我们可以看到十进制和 CIDR 符号的新子网掩码。下一步是使用这个新的子网掩码识别可用的子网/网络。我们可以使用下表计算可用子网:

| seven | six | five | four | three | Two | one | Zero | =位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | =2^比特位置 |
| one | one | one | one | Zero | Zero | Zero | Zero | =4 位 |

网络按位位置的基数 2 值递增:

*   **第一网** : `192.168.0.0/28`
*   **第二网** : `192.168.0.16/28`
*   **第三网** : `192.168.0.32/28`
*   **第四网** : `192.168.0.48/28`
*   **至 s**T3】ixten 网络 : `192.168.0.240/28`

基于此，我们可以看到第四个八位字节是增量发生的地方。特别是对于`/28`，子网以 16 为增量；这是因为当计算的 2^4 比特位置= 16 时，第四比特位置是`16`。最后一步是确定可分配给网络内主机的可用 IP。我们将使用以下内容作为细分:

*   **第一子网/网络** : `192.168.0.0/28`
*   **第一个可用的 IP 地址** : `192.168.0.1/28`
*   **最后可用的 IP 地址** : `192.168.0.14/28`
*   **广播 IP 地址**:T0
*   **第二子网/网络** : `192.168.0.16/28`

基于此，我们看到两个 IPs 不可用。它们是我们在计算主机入侵防御时一直考虑的因素。同样，我们可以通过使用以下细分得到第二个子网`192.168.0.16/28`的可用入侵防御系统:

*   **第二子网/网络** : `192.168.0.16/28`
*   **第一个可用的 IP 地址** : `192.168.0.17/28`
*   **最后可用的 IP 地址** : `192.168.0.30/28`
*   **广播 IP 地址** : `192.168.0.31/28`
*   **第三子网/网络** : `192.168.0.32/28`

太棒了。基于此，我们可以看到一个模式；我们最终总是得到 14 个可用的 IP 地址。此外，我们可以将 B 类地址划分为子网，并利用主机位来更好地管理我们的网络。让我们使用下面的 B 类地址:

```sh
172.16.0.0/16
Subnet mask:255.255.0.0
```

基于此，我们每个网络有超过 65，000 个主机 IP；这在大多数环境中并不理想。例如，我们希望将此 IP 划分为子网，以便拥有 500 个主机 IP。这可以通过从地址的主机部分借用一些主机位来实现。我们可以使用以下细分来帮助我们:

```sh
255.255.0.0
11111111.11111111.00000000.00000000 =/16 bits being used
```

我们计算主机的方法是从右向左移动。

第四个八位字节:

| seven | six | five | four | three | Two | one | Zero | =位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | 2^比特位置 |
| one | one | one | one | one | one | one | one | = 8 位总计 255 |

2^8 = 255-2 =每个网络 254 台主机。

第三个八位字节:

| seven | six | five | four | three | Two | one | Zero | =位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | 2^比特位置 |
| Zero | Zero | Zero | Zero | Zero | Zero | Zero | one | = 9 位开启 |

2^9 = 512 -2 =每个网络 510 台主机。

太棒了。基于此，需要 9 位才能达到要求。这意味着我们必须从第三组八位字节中借用八位来满足要求。我们可以通过使用以下内容对此进行分解:

```sh
255.255.0.0
11111111.11111111.11111110.00000000 =/23 bits being used.
```

| seven | six | five | four | three | Two | one | Zero | =位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | =2^比特位置 |
| one | one | one | one | one | one | one | Zero | =7 位开启 |

```sh
Eight bits in first octet + eight bits in second octet + seven bits in third octet =23 bits
The sum of the bits turned on in the third octet 128+64+32+16+8+4+2 =254
The new subnet mask in decimal = 255.255.254.0
```

基于这些计算，新网络将写成如下形式:

```sh
172.16.0.0/23
The total number of subnets = 2 ^ 7 = 128 subnets created
The total number of hosts per subnet/network =2^9 - 2 = 512 -2 = 510 hosts per subnet/network
Subnets = 172.16.0.0/23 , 172.16.2.0/23, 172.16.4.0/23, 172.16.6.0/23 - 172.16.254.0/23
```

基于此，我们得到了总子网和每个子网的主机。现在，我们需要计算每个子网的可用 IP 地址。这可以通过以下细分来实现:

*   **第一子网/网络** : `172.16.0.0/23`
*   **第一个可用 IP** : `172.16.0.1/23`
*   **最后可用的 IP** : `172.16.2.254/23`
*   **广播 IP** : `172.16.2.255`
*   **第二子网/网络** : `172.16.2.0/23`

基于此，我们可以看到可用的 IP 地址；`172.16.2.255`是使用`/23`子网的有效 IP。还有，`172.16.1.0/23`也是一个有效的 IP 地址。在某些操作系统中，例如 Windows，如果您尝试分配这两个 IP 中的任何一个，您可能会遇到错误。然而，在 Linux 中，一切都是公平的游戏。我们将子网增加 2，因为这是最后一个网络位的位置。

我们甚至可以将一个甲级地址划分为子网。例如，假设我们想用一个 A 类地址创建 100 个子网。我们将使用以下内容:

```sh
10.0.0.0/8
255.0.0.0
```

我们可以使用前面创建的表来实现这一点。

第二个八位字节:

| seven | six | five | four | three | Two | one | Zero | =位位置 |
| One hundred and twenty-eight | Sixty-four | Thirty-two | Sixteen | eight | four | Two | one | =2^比特位置 |
| one | one | one | one | one | one | one | Zero | =7 位开启 |

太棒了。基于此，我们可以很快得出，为了创建 100 个子网，我们需要从第二个八位字节借用 7 位。事实上，我们将有 128 个子网。这是因为我们在计算第二个八位字节中的 2^7 位。然后，我们可以用以下格式写出子网:

```sh
11111111.11111110.00000000.00000000
Subnet 255.254.0.0 /15
Subnets 10.0.0.0/15, 10.2.0.0/15, 10.4.0.0/15, 10.6.0.0/15 - 10.254.0.0/15
```

太棒了！划分 a 类子网就这么简单。现在我们需要计算每个子网的主机总数。我们可以使用以下内容:

```sh
Subnet in binary
11111111.11111110.00000000.00000000
Network bits are represented by n
Host bits are represented by h
nnnnnnnn.nnnnnnnh.hhhhhhhh.hhhhhhhh
2^17 -2 = 131072 - 2 = 131070 hosts per subnet/network
```

基于此，我们可以看到每个子网使用`/15`获得了相当多的主机。我们可以使用以下方法来导出每个子网的可用 IP:

*   **第一子网/网络** : `10.0.0.0/15`
*   **第一个可用 IP** : `10.0.0.1/15`
*   **最后可用的 IP** : `10.2.255.254/15`
*   **广播 IP** : `10.2.255.255`
*   **第二子网/网络** : `10.2.0.0/15`

太棒了！计算任一子网的最简单方法是总是将网络位乘以 2。为了计算主机总数，请始终将主机位乘以 2，然后减去网络和广播地址的 2。

# IPv6 寻址

**互联网协议第 6 版** ( **IPv6** )，由**互联网工程任务组** ( **IETF** )开发。IPv6 地址旨在解决 IPv4 地址不足的问题。IPv4 已经完全耗尽，公司现在愿意用他们的 IPv4 地址块换取巨额资金。IPv6 地址长度为 128 位或 16 字节。这给了我们 IPv6 地址的 2^128。IPv6 地址以十六进制格式表示。IPv6 地址有三种类型。

# 单播

单播地址为设备上的单个接口指定一个标识符，类似于 IPv4 地址。使用 IPv6，很可能所有 IPv6 流量将主要基于单播。

# 多点传送

IPv6 多播地址的概念类似于 IPv4 地址。数据包被发送到 IPv6 多播地址，属于多播组的接收器将接收该多播数据包。

# 任播

IPv6 中引入了这种地址类型。任播的概念是通过为多个设备分配相同的任播 IPv6 地址来工作的。当发送方将数据包发送到任意播 IPv6 地址时，该任意播数据包将通过路由协议路由到距离发送方最近的主机。

以下是 IPv6 地址的示例:

```sh
2001:0db8:0000:0000:0000:ff00:0042:8329
```

基于此，我们可以看到 IPv6 地址由八组 16 位或 2 字节值组成，用冒号分隔。这就是我们如何导出 128 位或 16 字节长度的。写一个 IPv6 地址可能看起来很长，但是我们可以使用一些方法来使 IPv6 地址小一点。

# 删除前导零

我们可以删除 IPv6 地址的前导零，从而使其更具可读性:

```sh
2001:0db8:0000:0000:0000:ff00:0042:8329
2001:db8:0:0:0:ff00:42:8329
```

太棒了。基于此，我们使 IPv6 地址更具代表性。但是等等，我们也可以通过使用下面描述的技术使它变得更小。

# 移除连续的零

我们可以删除 IPv6 地址中连续的零，并用双冒号替换这些零。这只能进行一次:

```sh
2001:db8::ff0:42:8329
```

太好了。正如我们所看到的，IPv6 地址现在可读性更强了。此外，在浏览器中输入 IPv6 地址时，我们会执行以下操作:

```sh
http://[ 2001:db8::ff0:42:8329]/
```

基于此，我们将把一个 IPv6 地址放在方括号中。有一些特殊类型的单播 IPv6 地址值得一提:

*   **全球单播地址**:这些地址以`2000::/3`开头，如 RFC 4291 中所规定。它们是类似于公共 IPv4 地址的公共可路由地址。
*   **链接-本地地址**:这些地址以`fe80::/10`开头；它们仅在本地物理链路上有效。
*   **站点本地地址**:这些地址以`fec::/10`开头；它们仅在单个站点内有效。他们已被 RFC 机构劝阻。
*   **唯一-本地地址**:这些地址以`fc00::/7`开头；它们意味着在一组合作站点内被路由。这是为了取代本地地址。唯一本地地址的一个有趣特点是，它们降低了地址冲突的风险。

有一些类似于 IPv4 的特殊 IPv6 地址。以下是一些保留的 IPv6 地址:

| `2000::/3` | 全球单播 |
| `::/128` | 未指定的地址 |
| `::/0` | 默认路由 |
| `::1/128` | 环回地址 |
| `FF00::/8` | 多播地址 |

太棒了。在识别子网方面，我们必须剖析一个 IPv6 地址。我们可以使用以下方法对其进行分解:

```sh
2001:db8:0000:0000:0000:ff0:42:8329
```

| 全局路由前缀 | 子网络 | 主机标识 |
| `2001:db8:0000:` | `0000:` | `0000:ff0:42:8329` |
| 48 位或 3 字节 | 16 位或 2 字节 | 64 位或 8 字节 |

基于此，全局路由前缀由 48 位组成。子网由接下来的 16 位组成。主机标识符由最后 64 位组成。

# 众所周知的协议

在我们的环境中，我们需要了解许多众所周知的协议。首先，当我们浏览互联网时，我们实际上是在使用 HTTP 协议来查看网页。此外，当我们从服务器复制文件并提供身份验证时；在后端，我们使用的是某种类型的 FTP 协议。同样，当我们键入一个网址时，我们实际上是在使用域名系统进行名称解析。正如我们所看到的，我们在环境中使用了许多协议。接下来将介绍一些众所周知的协议及其各自的端口号。

# 传输控制协议（Transmission Control Protocol）

**传输控制协议** ( **TCP** )是一种面向连接的协议，提供多种服务，包括错误检查和排序等。它运行在现场视察模型的第 4 层，即传输层。

# 超文本传送协议

**超文本传输协议** ( **HTTP** )按需提供网页；它是通过互联网上的网址进行数据通信的协议。它使用端口`80`进行通信。此外，它骑在 TCP 之上。

# HTTPS

**超文本传输协议安全** ( **HTTPS** )为互联网上的网址提供安全通信。它使用端口`443`进行通信。而且它的通信使用**传输层安全** ( **TLS** )。它位于 TCP 之上。

# 文件传送协议

**文件传输协议** ( **文件传输协议**，用于在客户端和服务器之间传输文件。这可以在局域网内本地进行，也可以通过互联网进行。但是，由于 FTP 支持身份验证，所有传输都以明文形式发送；没有内置的安全性。FTP 使用 TCP 端口`20`进行数据流量，使用端口`21`进行命令流量。

# 用户数据报协议(User Datagram Protocol)

**用户数据报协议** ( **UDP** )是一种无连接协议，提供速度，但不进行任何类型的错误检查。它运行在现场视察模型的第 4 层，即传输层。

# 域名服务器(Domain Name Server)

**域名系统** ( **域名系统**)提供了将 IP 地址转换为用户可以关联的用户友好名称的方法。它通常使用 UDP 端口`53`，但每当请求或响应大于单个数据包时，它也会使用 TCP 端口`53`。

# 普通文件传送协议(Trivial File Transfer Protocol)

**tr 小瓶文件传输协议** ( **TFTP** )用于快速传输数据。不支持任何身份验证方法；此外，没有错误检查。TFTP 使用 UDP 端口`69`。

# 网间控制报文协议(Internet Control Messages Protocol)

**互联网控制消息协议** ( **ICMP** )是网络环境中使用的另一种协议。它通常用于通过局域网或互联网在各种网络设备之间发送消息来排除故障。还有 ICMPv6，用于 IPv6。ICMP 使用 IP 协议`1`，而 ICMPv6 使用 IP 协议`58`。

# 摘要

在这一章中，我们深入探讨了 IPv4 和 IPv6 的世界。除此之外，我们还介绍了子网掩码以及识别子网掩码的方法。接下来，我们讨论了子网划分。我们通过几个例子说明了获得所需主机数量和所需子网数量的技术。最后，我们使用了众所周知的协议。我们介绍了一些最广泛使用的协议及其端口号。

在下一章中，我们将继续讨论网络配置和故障排除。我们将在 Linux 盒子上工作，分配 IPv4 地址和 IPv6 地址，查看排除网络连接故障的各种方法。

# 问题

1.  哪个地址是甲级地址？

A.`192.0.0.1`
b .`172.0.0.1`
c .`10.0.0.1`T5】D .以上都不是

2.  哪个地址是丙类地址？

A.`128.0.0.1`
b .`100.0.0.2`
c .`192.168.0.1`T5】d .以上都不是

3.  哪个地址被称为 IPv4 环回地址？

A.`127.0.0.1`T4【b .】`169.0.0.1`T5【c .】`172.16.0.1`T6【d .`192.1.1.1`

4.  哪个地址是 APIPA 地址？

A.`169.0.0.1`T4【b .】`172.16.0.1`T5【c .】`10.1.1.1`T6【d .`192.168.1.1`

5.  哪个地址是 B 类地址？

A.`128.0.0.1`
公元前`10.11.1.1`T4【公元前】T2
公元 223.0.0.1

6.  IPv6 多播地址以什么开头？

A.`fc0e::/8`T4【b .】`fce::/7`T5【c .】`ff00::/8`T6【d .`fd0:/9`

7.  哪个地址是 IPv6 默认路由？

A.`::1/0`T3】b .`::/0`T4【c .`01A:00000000:00000000:00000000:00000000::9`T5】d .::1/128

8.  哪个地址是 IPv6 环回地址？

A.`::0/1`T4【b .】`::0/0`T5【c .】`::1/128`T6【d .`::128/128`

9.  本地链接地址以什么开头？

A.`ff00::/8` B. `fc00::/10` C. `fcd00::128` D. `fe80::/10`

10.  HTTP 使用哪个端口？

A.TCP〔t0〕b . UDP〔t1〕c . TCP〔T2〕d . UDP〔T3〕

# 进一步阅读

*   该网站提供了关于 IP 的有用信息:[https://tools.ietf.org](https://tools.ietf.org)
*   该网站提供了关于子网划分的有用信息:[https://www.quora.com](https://www.quora.com)
*   本网站提供了关于 IPv6 的有用信息:[https://www.ipv6.com](https://www.ipv6.com)