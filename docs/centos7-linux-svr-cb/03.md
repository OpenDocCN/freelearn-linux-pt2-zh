# 三、管理系统

在本章中，我们将涵盖以下主题:

*   了解和管理后台服务
*   后台服务故障排除
*   使用日记帐跟踪系统资源
*   配置日志使其持久化
*   管理用户及其组
*   使用 cron 计划任务
*   使用 rsync 同步文件和完成更多工作
*   维护备份和拍摄快照
*   监控重要的服务器基础架构
*   用 Git 和 Subversion 控制

# 简介

本章是一个食谱的集合，提供了维护基于性能的服务器解决方案的需求。从监控您的可用磁盘空间，到使用系统服务和管理远程文件的同步，本章的目的是向您展示如何快速轻松地完成服务器维护任务。

# 了解并管理您的后台服务

Linux 系统服务是每个 Linux 服务器最基本的概念之一。它们是在您的系统中连续运行的程序，等待外部事件处理某件事或一直做这件事。通常，当使用您的服务器时，系统用户不会注意到这种正在运行的服务的存在，因为它是作为后台进程运行的，因此不可见。在任何 Linux 服务器上，都有许多服务一直在运行。这些可以是网络服务器、数据库、文件传输协议、SSH 或打印、DHCP 或 LDAP 服务器等。在这个食谱中，我们将向您展示如何管理和使用它们。

## 做好准备

要完成此方法，您需要安装具有 root 权限的 CentOS 7 操作系统，一个您选择的基于控制台的文本编辑器，以及一个到互联网的连接，以便于下载额外的软件包。这里显示的一些命令在输出中使用了*较少的*导航。阅读[第二章](02.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c "Chapter 2. Configuring the System")、*配置系统*中的*少用*食谱导航文本文件，了解如何浏览。

## 怎么做...

`systemctl`是一个程序，我们将使用它来管理 CentOS 7 系统中的所有后台服务任务。在这里，我们将向您展示如何使用它，并以 Apache 网络服务器服务为例来熟悉它。有关 Apache 的完整解释，请阅读[第 12 章](12.html#2TEN41-4cf34a6d07944734bb93fb0cd15cce8c "Chapter 12. Providing Web Services")、*提供网络服务*:

1.  首先，我们以 root 用户身份登录，安装 Apache web 服务器包:

    ```sh
    yum install httpd

    ```

2.  接下来我们将检查 Apache 的服务状态:

    ```sh
    systemctl status httpd.service

    ```

3.  在后台启动 webserver 服务，再次打印出它的状态:

    ```sh
    systemctl start httpd.service
    systemctl status httpd.service

    ```

4.  接下来，让我们打印出当前在系统后台运行的所有服务的列表；在这个列表中，您应该识别刚刚开始的`httpd`服务:

    ```sh
    systemctl -t service -a --state running

    ```

5.  现在，让我们备份一下 Apache 配置文件:

    ```sh
    cp /etc/httpd/conf/httpd.conf /etc/httpd/conf/httpd.conf.BAK

    ```

6.  现在，我们将使用 sed:

    ```sh
    sed -i 's/Options Indexes FollowSymLinks/Options -Indexes +FollowSymLinks/g' /etc/httpd/conf/httpd.conf

    ```

    对主 Apache 配置文件进行一些更改
7.  现在，键入以下命令来停止和启动服务并应用我们的更改:

    ```sh
    systemctl stop httpd.service
    systemctl start httpd.service
    systemctl status httpd.service

    ```

8.  接下来，让我们启用`httpd`服务，在启动时自动启动:

    ```sh
    systemctl enable httpd.service

    ```

9.  最后一个命令将显示如何重新启动服务:

    ```sh
    systemctl restart httpd.service

    ```

## 它是如何工作的...

正如我们所看到的， `systemctl`实用程序可以用来完全控制您系统的服务。`systemctl`是`systemd`的控制程序，它是 CentOS 7 Linux 中的系统和服务管理器。`systemctl`命令也可以用于各种其他任务，但是这里我们专注于管理服务。

那么，我们从这次经历中学到了什么？

我们通过以 root 用户身份登录并安装 Apache 网络服务器包来开始这个食谱，因为我们想用它来展示如何使用`systemctl`程序来管理服务。阿帕奇或`systemd`所称的`httpd.service`，只是我们将要使用的一个例子；其他可能在基本服务器环境中运行的重要服务可能是`sshd.service`、`mariadb.service`、`crond.service`等等。之后，我们用`systemctl status`命令参数检查 httpd 的当前状态。输出向我们显示了两个字段:**加载的**和**激活的**。 **Loaded** 字段告诉我们当前是否加载，开机时是否会自动启动；**激活**字段表示服务当前是否正在运行。接下来，我们展示了如何使用`systemctl`启动服务。该命令对服务的确切启动语法是`systemctl start <name of the service>.service`。

### 注

通过启动一个服务，程序通过分出一个新的进程从终端分离出来，这个进程被移动到后台，在那里它作为一个非交互后台进程运行。这有时被称为**守护进程**。

接下来，在我们启动 Apache webserver 守护程序后，我们再次使用 systemctl 的`status`参数来显示如果我们运行它，状态会如何变化。输出显示它当前已加载，但在重新启动时被禁用。我们还看到它正在运行，以及该服务的最新日志输出和关于该过程的其他详细信息。要查看系统上所有服务的所有状态信息，请使用`systemctl --type service --all`。A `systemctl`服务不能一直运行。它的状态也可以被停止、降级、保持等等。接下来，我们使用以下命令获取系统上当前正在运行的所有服务的列表:

```sh
systemctl -t service -a --state running

```

正如您在这里看到的，我们使用了`-t`标志，以便只过滤类型服务单位。你可能猜到了，`systemctl`不仅可以处理服务单位，还可以处理很多其他单位类型。`systemd`单元是`systemd`可以使用配置文件管理的资源，它封装了关于服务、监听套接字、保存的系统状态快照、挂载设备和其他与系统相关的对象的信息。要获得所有可能单位类型的列表，请键入`systemctl -t help`。这些配置单元文件驻留在系统中的特殊文件夹中，可以从扩展名中读取它们所属的类型；所有服务单元文件都有文件扩展名，`.service`(例如，设备单元文件有扩展名，`.device`)。系统存储的地方有两个。基础系统在安装过程中安装的所有`systemd`单元文件都在`/usr/lib/systemd/system`中，其他所有来自于安装 Apache 等软件包的服务或者针对你自己的配置都应该去`/etc/systemd/system`。我们可以在`/usr/lib/systemd/system/httpd.service`找到我们的 Apache 服务配置文件。接下来，我们使用语法`systemctl stop <name of the service>`向用户展示了如何停止服务，这与启动服务相反。最后，作为最后一步，我们使用了 systemctl 的`restart`参数，该参数只需一步处理服务的停止和启动，只需较少的输入。如果服务挂起且没有响应，并且您需要快速重置它以使其工作，这通常很有用。在展示如何停止和重启服务之前，我们做了另一件重要的事情。在 Apache 服务运行时，我们使用`sed`命令更改了它的主服务配置文件，添加了一个`-Indexes`选项，禁用目录网站文件列表，这是提高您的网络服务器安全性的常用措施。由于 Apache web 服务器已经在运行，并在服务启动期间将其配置加载到内存中，因此运行中的服务将永远无法识别对此文件的任何更改。

### 注

通常，要应用任何配置文件更改，运行服务需要完全重新启动服务，因为配置文件通常只会在启动初始化期间加载。

现在，假设您的网络服务器可以从互联网上访问，此时有很多人并行访问您的网页或应用程序。如果您正常重启 Apache，网络服务器将在一段时间内不可访问(只要重启服务器所需的时间)，因为该过程将实际结束，然后重新开始。如果所有当前用户在那个时候请求什么，他们会得到 HTML 404 错误页面。此外，所有当前会话信息都将消失；假设你有一个网上商店，人们使用购物车或登录。所有这些信息也会消失。为了避免重要服务(如 Apache 网络服务器)的中断，其中一些服务有一个`reload`选项(但不是每个服务都有这个功能！)我们可以应用来代替`restart`参数。该选项只是重新加载和应用服务的配置文件，而服务本身保持在线，并且在执行过程中不会被中断。对于 Apache，您可以使用以下命令行:`systemctl reload httpd.service`。要获得具有重新加载功能的所有服务的列表，请使用以下行:

```sh
grep -l "ExecReload" /usr/lib/systemd/system/*.service /etc/systemd/system/*.service

```

所以，完成了这个食谱，我们可以说现在知道如何使用基本的`systemctl`参数来管理服务了。它可以是一个非常强大的程序，可以用于比仅仅启动和停止服务更多的用途。此外，在这个配方中，我们使用了不同的名称，它们都表示相同的意思:系统服务、后台进程或守护进程。

## 还有更多...

还有一个重要的单位类型叫做`target`。目标也是单元文件，在你的系统中已经有相当多的目标可用。要显示它们，请使用以下命令:

```sh
ls -a /usr/lib/systemd/system/*.target /etc/systemd/system/*.target

```

简单地说，目标是单元文件的集合，如服务或其他目标。它们可以用来创建类似运行级的环境，您可能从早期的 CentOS 版本中了解到这一点。运行级别定义了应该在哪个系统状态下加载哪些服务。例如，有图形状态，或救援模式状态，等等。要查看公共运行级别如何对应于我们的目标，请运行以下命令，它向我们显示了它们之间的所有符号链接:

```sh
ls -al /lib/systemd/system | grep runlevel

```

目标可以依赖于其他目标；为了更好地了解目标依赖关系，我们可以运行以下命令来显示从多用户目标到所有其他目标的所有依赖关系(绿色表示活动，红色表示非活动):

```sh
systemctl list-dependencies multi-user.target

```

您可以显示我们目前所处的当前目标:

```sh
systemctl get-default

```

您也可以切换到另一个目标:

```sh
systemctl set-default multi-user.target

```

# 后台服务故障排除

通常，每个系统管理员的工作很大一部分是在出现问题时对服务器进行故障排除。对于您的系统服务来说尤其如此，因为它们一直在运行和处理信息。服务可能依赖于其他服务和服务器的系统，并且在管理员的生活中会出现系统服务失败或拒绝启动的情况。在这里，在这个食谱中，我们将向您展示如何排除故障。

## 做好准备

要完成这个食谱，您将需要一个具有 root 权限的 CentOS 7 操作系统的工作安装和一个您选择的基于控制台的文本编辑器；您还应该已经完成了本章中的*了解和管理您的后台服务*配方，我们在这里安装了 Apache 网络服务器。

## 怎么做...

为了向您展示如何排除服务故障，我们将在 Apache 服务的配置文件中引入一个随机错误，然后向您展示如何排除和修复它:

1.  以 root 用户身份登录，并键入以下命令将内容追加到`httpd.conf` :

    ```sh
    echo "THIS_IS_AN_ERRORLINE" >> /etc/httpd/conf/httpd.conf

    ```

2.  接下来，重新加载`httpd`服务并显示其输出:

    ```sh
    systemctl reload httpd.service
    systemctl status httpd.service -l

    ```

3.  让我们恢复这条错误线:

    ```sh
    sed -i 's/THIS_IS_AN_ERRORLINE//g' /etc/httpd/conf/httpd.conf

    ```

4.  现在，再次重启服务:

    ```sh
    systemctl reload httpd.service
    systemctl status httpd.service

    ```

## 它是如何工作的...

在这个相当短的食谱中，我们向您展示了如果示例服务包含错误，它将如何表现，以及您可以做些什么来修复它以让您开始。当服务出现故障时，有很多不同的场景会出现问题，解决这些问题可能是系统管理员工作的一大部分。

那么，我们从这次经历中学到了什么？

我们通过在主 Apache 配置文件中引入一行文本来开始这个食谱，该文本不包含任何有效的配置语法，因此`httpd`服务无法解释它。然后，我们使用`systemctl reload`参数重新加载服务器的配置文件。如前所述，并非所有服务都有重新加载选项，因此如果您感兴趣的服务不支持该选项，请改用`restart`参数。由于 Apache 将尝试用我们当前的更改重新加载配置文件，它将拒绝接受新的配置，因为我们引入了错误的语法。由于我们只是重新加载配置，正在运行的 Apache 进程将不会受到这个问题的影响，并将使用其原始配置保持在线。`systemctl`参数将打印出以下错误信息，提示我们下一步该做什么:

```sh
Job for httpd.service failed. Take a look at systemctl status httpd.service and journalctl -xe for details.

```

正如错误输出所建议的那样，`systemctl`状态参数是一个非常强大的工具，可以查看该服务的幕后情况，并尝试找出任何失败的原因(在这里您还可以看到 Apache 仍在运行)。如果你用`-l`标志启动`systemctl` `status`，它会打印出一个更长版本的输出，这可以帮助你更多。

该命令的输出向我们显示了配置重新加载失败的确切原因，因此我们可以很容易地追踪问题的原因(输出被截断):

```sh
AH00526: Syntax error on line 354 of /etc/httpd/conf/httpd.conf:
Invalid command ERRORLINE, perhaps misspelled or defined by a module, is not included in the server configuration.

```

该输出是完整的`journald`日志信息的一部分。如果你想了解更多，请参考本章食谱中的*追踪系统资源。因此，利用输出中的这些非常有用的信息，我们可以很容易地发现问题，并使用`sed`命令重做`ERRORLINE`的介绍，然后再次重新加载服务；这次一切都会好的。*

因此，总结来说，我们可以说`systemctl status`命令是一个非常舒适的命令，可以极大地帮助您发现服务中的问题。大多数服务对语法错误非常敏感，有时可能只是一个放错位置的空格字符导致服务拒绝工作。因此，系统管理员必须始终精确地工作。

# 跟踪记录的系统资源

日志文件包含系统消息以及服务、内核和各种运行应用的输出。它们在许多情况下非常有用，例如，对系统问题进行故障排除和监控服务或其他系统资源，或者在安全漏洞后进行安全取证。在本食谱中，您将学习如何使用 journald 使用日志服务的基础知识。

## 做好准备

要完成这个方法，您需要一个具有 root 权限的 CentOS 7 操作系统的工作安装和一个您选择的基于控制台的文本编辑器。此外，正确设置时间和日期对于整个日志概念非常重要，因此在使用此配方之前，请应用[第 2 章](02.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c "Chapter 2. Configuring the System")、*中的*将系统时钟与 NTP 同步和计时套件*配方。此外，系统和单位的基础知识可能是有利的。这在本章的*了解和管理后台服务*配方中有所介绍。Journalctl 少用*少用*导航显示输出；如果您不知道如何使用，请阅读[第 2 章](02.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c "Chapter 2. Configuring the System")、*配置系统*中的*导航少了*配方的文本文件。*

## 怎么做...

在 CentOS 7 上，我们可以在两个名为`rsyslog`的日志机制和`journald`日志系统之间进行选择，后者是新的`systemd`系统管理器的一个组件，用于查看和管理日志信息。在这里，我们将向您展示如何使用`journalctl`命令，它是`journald`守护程序的控制客户端:

1.  首先，以 root 用户身份登录，并键入以下命令查看整个日志:

    ```sh
    journalctl

    ```

2.  接下来，我们希望只显示特定时间范围内的消息(相应地更改日期):

    ```sh
    journalctl --since "2015-07-20 6:00:00" --until "2015-07-20 7:30:00"

    ```

3.  之后，我们希望通过来自 ssh 服务的所有消息来过滤日志系统:

    ```sh
    journalctl -u sshd.service --since "yesterday"

    ```

4.  现在，我们只想显示带有类型错误的消息:

    ```sh
    journalctl -p err -b

    ```

5.  要获得最详细版本的`journalctl`，使用`verbose`选项:

    ```sh
    journalctl -p err -b -o verbose

    ```

6.  要在日志输出中获得当前*视图，请使用以下命令(这不是*减*导航-使用组合键 *Ctrl* + *C* 退出此视图):

    ```sh
    journalctl -f

    ```* 

## 它是如何工作的...

在 CentOS 7 中，我们可以使用新的`journald`日志记录系统，这是`systemd`系统管理的一部分。它是一个集中的工具，可以记录系统上的所有信息，包括从早期内核引导到服务的所有输出和所有程序消息。相对于其他日志记录机制的主要优势在于，您不必为您的每个服务或其他资源配置日志记录，因为已经为通过集中式`systemd`系统控制和运行的所有应用程序设置了一切。

那么，我们从这次经历中学到了什么？

我们通过运行`journalctl`命令开始我们的旅程，该命令在没有任何参数的情况下应用时会向我们显示完整的日志，其中包括从启动系统和捕获第一个引导日志条目到最新系统消息的所有内容，按照它们出现的顺序，将新消息附加到底部(时间顺序)。如果您的系统已经运行了一段时间，它可能包含几十万行日志数据，以这种原始形式工作是非常不切实际的。

这个输出会不断被`journald`守护进程捕获，但不会像`rsyslog`等其他日志系统那样写入文本文件。相反，它使用结构化和索引化的二进制文件，该文件存储了许多附加的元信息，如用户 Id、时间戳等，这使得它很容易转换成各种不同的输出格式。如果您想通过其他工具进一步处理日志信息，这可能非常方便。由于您无法读取二进制文件，因此您将需要客户端`journalctl`进行读取，该客户端用于查询`journald`数据库。由于几乎不可能手动解析这么多的数据，因此我们利用了 journalctl 丰富的过滤选项。首先，我们使用`--since`和`--until`参数提取特定时间范围内的所有日志消息。这里指定时间和日期的语法非常灵活，理解`yesterday`或`now`这样的短语，但是我们坚持使用简单的日期语法`YYYY-MM-DD HH:MM:SS`。接下来，我们使用 journalctl 的`-u`参数来过滤特定单元类型的日志消息。我们用它来过滤来自 ssh 守护服务的消息。我们使用`--since`参数添加了另一个过滤器，它进一步收紧了`-u`单元过滤器的结果，只输出昨天发生的 sshd 服务结果。我们应用的下一个过滤器是使用参数字符串`-p err -b`，它按优先级或日志级别过滤日志数据库。每个日志消息都可以有一个相关的优先级，它决定了消息的重要性。要了解不同日志级别的更多信息，请使用命令行`man 3 syslog`参考手册(如果没有本手册，请通过键入`yum install man-pages`安装)。我们的命令将打印出所有标记为`error`或以上的日志消息，包括:`error`、`critical`、`alert`或`emergency`。

接下来，我们使用相同的命令参数，但是添加了`-o verbose`，这给出了最详细的日志信息输出。最后，我们展示了`-f`参数(如下图)，它将为我们提供最新日志消息的*实时*视图，并保持该连接打开，当新消息出现时，将它们附加到输出的末尾。如果您当前正在测试设置或启动/停止服务，这通常有助于了解系统的反应。

综上所述，可以说，在 CentOS 7 上，两个日志系统确实共存:较旧的`rsyslog`和较新的`journald`，后者是您对系统进行故障排除的首选工具。但是请记住，在 CentOS 7 上，`journald`并不能完全替代`rsyslog`。有一些`rsyslog`功能在`journald`中缺失，也有很多工具和脚本，比如日志消化工具或监控套件，比如 Nagios，专门用于`rsyslog`。

系统管理员经常面临着排除系统错误或意外服务器行为的巨大挑战。通常，在应用正则表达式搜索或 Linux 命令行功夫的同时，通过搜索大量不同的日志文件文本来找到单个故障点并不容易。Journald 提供了一个非常方便的选择，它提供了一个功能强大且定义良好的集中查询系统，可以快速高效地完成日志文件分析！

# 配置日志以使其持久化

Journald 的优势相对于其他日志记录系统如`rsyslog`的优势在于，它非常高效，可以自动记录系统中的所有信息，而不需要配置任何东西，因为它是`systemd`套件的一部分。主要缺点是系统重启后所有`journald`日志信息都会丢失。日志记录会产生大量数据，默认情况下，所有日志记录信息只保存在内存中，如果您需要访问较旧的日志信息或分析系统崩溃重启的原因，这是不太可行的。这里，在这个食谱中，我们向您展示如何配置`journald`使其持久化。

## 做好准备

要完成此方法，您将需要最低限度地安装具有 root 权限的 CentOS 7 操作系统和您选择的基于控制台的文本编辑器。

## 怎么做...

为了开始这个方法，我们需要创建一个存放我们的持久日志数据库的位置:

1.  以 root 用户身份登录，创建以下目录:

    ```sh
    mkdir /var/log/journal

    ```

2.  接下来，将新目录添加到`journald`以将其用作存储位置并固定权限:

    ```sh
    systemd-tmpfiles --create --prefix /var/log/journal

    ```

3.  现在，重启`journald` :

    ```sh
    systemctl restart systemd-journald

    ```

4.  最后，要检查日志是否在重新启动后仍然存在，请重新启动计算机并键入以下内容:

    ```sh
    journalctl --boot=-1

    ```

## 它是如何工作的...

我们通过创建新目录`/var/log/journal`开始这个食谱。默认情况下，`journald`将其日志数据库写入`/run/log/journal`，这是一个仅用于运行时信息的目录，其内容不会在系统重新启动后继续存在。之后，我们使用`systemd-tmpfiles`命令为`journald`设置新目录。最后，我们重新启动`journald`服务器守护程序，将我们的更改应用到系统中。要测试持久性是否有效，请重启服务器，然后使用`journalctl –boot=-1`。这将向我们显示自上次引导以来的所有日志信息。如果持久性不起作用，它将打印出以下错误；否则，它将正确显示上次引导前的所有日志消息:

```sh
Failed to look up boot -1: Cannot assign requested address

```

在这个相当简单的配方中，我们已经展示了如何在系统重启时使`journald`持久化。如果您需要查看过去的旧日志文件，这非常有用，这有时可以帮助您找出问题，例如，过去硬件故障的根源。

# 管理用户及其群组

在本食谱中，我们将学习如何在 CentOS 7 上管理您系统的用户和组。基本用户和组管理技能是 CentOS 系统管理员最重要的基础之一。

## 做好准备

要完成这个方法，您需要一个具有 root 权限的 CentOS 7 操作系统的工作安装和一个您选择的基于控制台的文本编辑器。

## 怎么做...

本食谱通过学习如何添加、删除和修改用户和组，向您展示了如何管理用户和组:

1.  要开始这个食谱，我们以 root 用户身份登录，并键入以下命令来获得系统已知的所有用户的列表:`cat /etc/passwd`。
2.  现在，显示根用户 ID ( **UID** )和组 ID ( **GID** ):

    ```sh
    id root

    ```

3.  接下来，我们将运行以下命令向系统添加新用户(用您选择的用户名交换`your_new_username`:

    ```sh
    useradd your_new_username

    ```

4.  However, in order to complete this process, you will be expected to provide a suitable password. To do this, type the following command (change `your_new_username` with a username of choice) than enter a secure password when prompted:

    ```sh
    passwd your_new_username

    ```

    ### 注

    密码不应少于六个字符，但不应超过十六个字符。它们应该由字母数字值组成，出于显而易见的原因，您必须避免使用空格。不要使用基于词典的单词，也不要使用已知或明显的短语。

5.  接下来，创建一个新组，并给它一个特殊名称:

    ```sh
    groupadd your_new_group

    ```

6.  然后，我们将新用户添加到这个新组中:

    ```sh
    usermod -G your_new_group your_new_username

    ```

7.  最后，让我们打印新用户的用户标识和组标识，看看有什么变化:

    ```sh
    id your_new_username

    ```

## 它是如何工作的...

这个食谱的目的是创建一个新的用户和组，并展示如何将他们连接在一起。

那么，我们从这次经历中学到了什么？

首先，我们打印出文件`/etc/passwd`的内容，显示系统中所有的当前用户。该列表不仅包含属于真实人物的普通用户帐户，还包含用于控制和拥有特定应用程序或服务的帐户。然后，我们使用`id`命令来显示我们现有用户根的唯一用户 UID 和 GID。在 Linux 中，每个用户都可以通过他们的 UID 和 GID 来识别，并且文件系统中的每个文件都有特定的权限设置来管理其对文件所有者、组所有者和其他用户的访问。对于这三个组中的每一个，您可以使用命令`chmod`启用或禁用读、写和执行权限(使用`man chmod`了解更多信息，也可以查看`man chown`)。所有者和组权限对应于我们可以使用`ls -l`为每个文件显示的 UID 和 GID。

接下来，我们发出`useradd`命令，要求我们为新用户提供一个合适的名称，这反过来将使服务器能够用一组默认的值和标准建立新的身份，包括用户标识、主目录、主组(GID)，并将默认 Shell 设置为 bash。完成这个过程只是确认一个合适的密码。要删除用户，有相反的命令`userdel`，其工作原理类似，但是可以选择`-f`删除主目录，而不是将其留在系统中。接下来，我们使用`groupadd`命令，顾名思义，它将创建一个新的组，并将其与一个新的唯一 GID 相关联。之后，我们让我们的用户成为我们在使用`usermod -G`命令之前创建的新组的成员。如前所述，每个用户都有一个唯一的 UID 和 GID。第一组是主要组，是强制性的；然而，一个用户可以属于多个不同的组，这些组被称为次级组。创建新文件时需要主组，因为它将设置创建它的用户的 GID 和 UID。要删除一个组，我们可以使用`groupdel`命令。最后，我们在新用户上再次使用`id`命令来显示其 UID、主 GID 和我们添加到其中的新辅助 GID 组。

您现在只需几个命令就可以完全控制您的用户和组:`useradd`、`usermod`、`userdel`、`groupadd`、`groupmod`和`groupdel`。

# 用 cron 调度任务

在本食谱中，我们将通过向您介绍基于时间的作业调度程序 cron 来研究服务器自动化的作用以及在预定义的时间段运行特定任务的便利性。Cron 允许通过实现任务的自动化，使管理员能够基于任何时间、任何日期或任何月份确定预定义的时间表。它是 CentOS 操作系统的标准组件，本食谱的目的是向您介绍管理重复任务的概念，以便利用这一宝贵的工具，并使 CentOS 为您服务。

## 做好准备

要完成此方法，您将需要最低限度安装具有 root 权限的 CentOS 7 操作系统，以及您选择的基于控制台的文本编辑器。`crontab`程序使用 Vim 进行文件编辑。如果您不知道如何使用 Vim，请查看[第 2 章](02.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c "Chapter 2. Configuring the System")、*配置系统*中 Vim 简介中的教程。

## 怎么做...

这个食谱的目的是创建一个脚本，每五分钟将你选择的几个单词的时间和日期写入一个文本文件。这似乎是一个相对简单的练习，但的意图是向您展示，从这种简单性来看，cron 可以用来做更多的事情，这将使与 CentOS 的合作成为一种绝对的乐趣。

1.  要开始此食谱，请以 root 用户身份登录，并通过键入以下命令创建您的第一个 cron 作业:

    ```sh
    crontab -e

    ```

2.  我们现在将创建一个简单的 cron 作业，每五分钟将带有单词`hello world`的日期和时间写入位于`/root/cron-helloworld.txt`的文件。为此，添加以下行:

    ```sh
    */5 * * * * echo `date` "Hello world" >>$HOME/cron-helloworld.txt

    ```

3.  完成后，只需保存文件并退出编辑器。系统现在将响应以下消息:

    ```sh
    crontab: installing
     new crontab

    ```

4.  前面的消息通知您，服务器正在创建新的`cron`作业，并将自动激活它。您可以通过查看在`/root/cron-helloworld.txt`找到的文件(您必须等待 5 分钟)或通过监控在`/var/log/cron`找到的日志文件(使用`tail -f /var/log/cron`和`Ctrl+C`退出)来查看脚本的输出。

## 它是如何工作的...

Cron 是一个程序的名称，它使 CentOS 用户能够在指定的时间和日期自动执行命令或脚本。Cron 的设置保存在一个名为`crontab`的用户特定文件中，正如我们在本食谱中看到的，该文件可以根据需要进行编辑以创建自动化任务。

那么我们从这次经历中学到了什么呢？

所用的例子非常简单，但在许多方面这就是这个食谱的目的。Crontab 使用后台程序`crond`，它在后台持续运行，每分钟检查一次，看是否有任何计划的作业需要执行。如果找到一个任务，cron 将执行它。要编辑现有的`crontab`文件或创建新的`crontab`，我们使用`crontab -e`命令。要查看当前 cron 工作的列表，您可以键入`crontab -l`。或者，要查看其他用户的当前作业列表，您可以键入`crontab -u username -l`。任务或作业通常被称为 cron 作业，通过避免我们第一个脚本中的复杂性，它旨在向您展示命令构造的本质非常简单。cron 作业的形成如下所示:

```sh
<minute> <hour> <day of the month> <month of the year> <day of the week> <command>

```

条目由单个空格或制表符分隔，允许的值主要是数字(即一分钟的`0-59`、一小时的`0-23`、一个月中的一天的`1-31`、一年中的一个月的`1-12`和一周中的一天的 `0-7`)。然而，在这样说的同时，也可以说有更多特定的操作符(`/`、`-`)和 cron 特定的快捷方式(即`@yearly`、`@daily`、`@hourly`和`@weekly`)确实允许额外的控制。例如`/`操作符用于单步执行指定的单元时，可以读作*每隔*，所以在我们的食谱中`*/5`的使用每五分钟运行一次任务，而`*/1`的使用每分钟运行一次任务。除此之外，您应该知道，使用这种语法将会对齐整点的所有命令。因此，考虑到这一点，对于任何想要编写第一份`cron`工作的人来说，最合适的模板或起点是以一系列五个星号后跟命令开始，如下所示:

```sh
* * * * * /absolute/path/to/script.sh

```

然后，根据需要继续配置分钟、小时、天、月和星期几的值。例如，如果您希望特定的 PHP 脚本在每个工作日(周一至周五)的晚上 8 点(20:00 小时)运行，它可能如下所示:

```sh
0 20 * * 1-5 /full/path/to/your/php/script.php

```

因此，考虑到这一点，通过完成这个食谱，您可以看到如何使用 cron 来管理数据库备份、运行计划的系统备份、通过以预定义的时间间隔激活脚本来为网站提供支持，或者运行各种 bash 脚本等等。

## 还有更多...

要删除或禁用 cron 作业，只需从单个用户的 cron 文件中删除指令，或者在行首放置一个散列(`#`)。在`/var/spool/cron/<username>`可以找到单独的 cron 文件，散列的使用将禁用 cron 作业或允许您编写注释。要完全删除一个`crontab`文件，也可以使用`crontab -r`。例如，如果您想要删除在主配方中创建的 cron 作业，您可以以 root 用户身份登录，并通过键入命令`crontab -e`开始。此时，您可以删除整行或注释掉它，如下所示:

```sh
# */15 * * * * echo `date` "Hello world" >>$HOME/cron-helloworld.txt

```

接下来，保存文件。对于系统范围的 cron 作业，文件系统中还有一些特殊的 cron 目录，如果您将脚本文件放入其中，它会在某个时间点自动运行。这些文件夹在`/etc`目录中被称为`cron.daily`、`cron.hourly`、`cron.weekly`和`cron.monthly`，它们的名称指的是它们运行的时间点。如果您不想再执行脚本，只需从文件夹中删除它。以*监控重要服务器基础设施*食谱为例。

# 同步文件并使用 rsync 做更多事情

`rsync`是一个程序，可以用来同步各种本地和远程位置的文件和目录。它可以与多个操作系统交互，通过 SSH 工作，提供增量备份，在远程机器上执行命令，并取代对`cp`和`scp`命令的需求。对于任何打算运行服务器或管理计算机网络的系统管理员来说，`rsync`程序都是一项无价的资产，因为它不仅简化了一般的备份过程，而且可以用来实施完整的备份解决方案。因此，这个食谱的目的是为一个小工具提供一个合适的起点，它将很快成为你值得信赖的朋友。

## 做好准备

要完成此方法，您需要安装具有 root 权限的 CentOS 7 操作系统、您选择的基于控制台的文本编辑器以及互联网连接，以便于下载其他软件包。

## 怎么做...

在此制作过程中，将假设您知道希望同步的源文件和目录的位置，并且有合适的目标可用:

1.  要开始此食谱，请以 root 用户身份登录并通过键入:

    ```sh
    yum install rsync

    ```

    安装`rsync`
2.  现在，为我们的同步创建一个目标目录(适当更改文件夹名称):

    ```sh
    mkdir ~/sync-target

    ```

3.  要开始同步过程，只需重复以下命令，用更适合您需要的东西修改用于`/path/to/source/files/`的值:

    ```sh
    rsync -avz --delete /path/to/source/files/  ~/sync-target

    ```

4.  使用*返回*键确认前面的指令后，您的系统现在会以正在复制的内容的实时报告进行响应。当这个过程完成后，您可以比较两个目录，看内容是否完全相同。为此，请使用`diff`命令(如果两者相同，则不会写入输出):

    ```sh
    diff -r /path/to/source/files/ ~/sync-target

    ```

## 它是如何工作的...

在这个食谱中，我们考虑了通过命令行使用`rsync`。当然，这只是使用该工具的众多方法之一，但是通过使用这种方法，我们能够探索这个非常有价值的工具所提供的一些特性。

那么，我们从这次经历中学到了什么？

Rsync 不是为了复杂。这是一个快速高效的文件同步工具，旨在通过让您完全访问命令行上的一系列功能来实现多功能性。它可以用于在同一台机器上或完全不同的系统上维护 `source`目录的精确副本(或镜像)，它是通过复制所有文件一次，然后在下次运行时只更新已经更改的文件来实现的。这可以节省大量带宽，应该是您通过网络复制数据的主要工具。短语`--delete`的使用很重要，因为它指示`rsync`删除源中不存在的目标上的文件，而选择的标志暗示`rsync`应该使用`-a`存档模式，以便递归复制文件和目录，同时保留所有权限和基于时间的信息；`–v`)冗长模式，让你可以看到正在发生的事情；和`–z`在文件传输过程中压缩数据，以节省带宽，减少完成整个过程所需的时间。

如您所见，`rsync`非常灵活，有许多选项超出了本食谱的目的，但是如果您想排除某些文件，您可以通过调用`--exclude`标志来扩展原始指令。通过这样做，你告诉`rsync`备份整个目录，但确保它不包括文件和文件夹的预定义模式。例如，如果您正在将文件从服务器复制到 USB 设备，并且不想包含大文件(如`.iso`图像)或 ZIP 文件，则您的命令可能类似于以下内容:

```sh
rsync --delete -avz --exclude="*.zip" --exclude="*.iso"  /path/to/source/ /path/to/external/disk/

```

最后，还有冗长的话题。冗长是非常有用的，但是倾向于使用字节作为它的主要度量单位可能会造成混乱。因此，为了改变这一点，您可以使用`–h`(或人类可读的)选项调用`rsync`，如下所示:

```sh
rsync -avzh --exclude="home/path/to/file.txt" /home/ /path/to/external/disk/

```

# 维护备份和拍摄快照

在这个食谱中，我们将向您展示如何定期进行数据备份，这将使用`crond`守护程序拍摄系统目录的快照。这将定期运行`rsync`程序，以实施全自动备份解决方案。

## 做好准备

要完成此方法，您需要安装具有 root 权限的 CentOS 7 操作系统和您选择的基于控制台的文本编辑器。如果您已经阅读了本章中的*同步文件并使用 rsync* 和*使用 cron* 方法安排任务来更深入地理解所使用的命令，这也是非常有利的。

## 怎么做...

在继续这个食谱之前，在你的服务器上安装程序是很重要的。

1.  首先，以 root 用户身份登录，并创建一个目录，我们的备份将放在这里:

    ```sh
    mkdir /backups

    ```

2.  现在，我们将创建以下 shell 脚本文件并打开它进行编辑:

    ```sh
    mkdir ~/bin;vi ~/bin/mybackup.sh

    ```

3.  输入以下内容，将环境变量`DEST`和`SOURCE`中的`/backups`替换为您想要备份的以及收件人的`EMAIL` :

    ```sh
    #!/bin/bash
    SBJT="cron backup report for `hostname -s` from $(date +%Y%m%d:%T)"
    FROM=root@domain
    EMAIL=johndoe@internet.com
    SOURCE=/root
    DEST=/backups
    LFPATH=/tmp
    LF=$LFPATH/$(date +%Y%m%d_%T)_logfile.log
    rsync --delete --log-file=$LF -avzq $SOURCE $DEST
    (echo "$SBJT"; echo; cat $LF ) | sendmail -f $FROM -t $EMAIL

    ```

4.  使脚本可执行:

    ```sh
    chmod a+x /root/bin/mybackup.sh

    ```

5.  现在，使用

    ```sh
    crontab -e

    ```

    打开`crontab`
6.  接下来，通过在文档末尾添加以下行来创建以下条目，然后保存并关闭它:

    ```sh
    30 20 * * * /root/bin/mybackup.sh

    ```

## 它是如何工作的...

在这个配方中，我们为单个系统目录创建了一个全自动备份解决方案，它将在某个时间点创建文件的快照。备份过程完成时，您将收到一封电子邮件，通知您备份已经完成，并对所采取的措施进行了简要回顾。

那么我们从这次经历中学到了什么呢？

我们通过创建一个目录来放置我们的备份，从而开始了这个方法。接下来，我们创建了实际的脚本并用一些命令填充它。第 1 行将文件定义为一个 bash 脚本，第 2-6 行是您可以修改和定制以满足自己需求的变量。第 7-8 行根据日期为日志文件创建路径和名称，第 9 行调用`rsync`，它将把我们所有的源文件同步到目标目录/备份。它使用一个特殊的`--log-file`参数，将所有输出写入给定的文件。最后一行(10)将此日志文件的内容发送到电子邮件地址。

请记住，您应该根据需要自定义这些值(即，更改使用的电子邮件地址、选择源目录以及选择目标目录，等等)。).在它可以被`cron`使用和执行之前，我们让它可以执行。最后，我们将该脚本添加为 cron 作业，每天 20:30 运行。但是，由于这可能需要几个小时，如果您现在想要测试您的脚本，可以使用以下命令在命令行上执行它:

```sh
/root/bin/mybackup.sh

```

总之，不言而喻，备份应该位于外部驱动器或单独的分区上，但是在完成此介绍后，我想您会同意`rsync`的理想定位是，它将使任何服务器管理员能够制定自己的策略来维护重要数据的有效备份。

# 监控重要的服务器基础设施

在这个食谱中，我们将使用一个小脚本，它将使用 cron 定期监控可用文件系统的磁盘空间，如果它超过某个百分比阈值，该脚本将发送一封带有警告消息的邮件。

## 做好准备

要完成此方法，您需要安装具有 root 权限的 CentOS 7 操作系统和您选择的基于控制台的文本编辑器。你应该已经阅读了*用 cron* 安排任务的食谱，对 cron 系统背后的原理有了基本的了解。

## 怎么做...

1.  要开始这个配方，以 root 用户身份登录，创建包含我们的监控脚本的以下文件:

    ```sh
    vi /etc/cron.daily/monitor_disk_space.sh

    ```

2.  现在，输入以下内容:

    ```sh
    #!/bin/bash
    EMAIL="root@localhost"
    THRESHOLD=70
    df -H | grep -vE '^Filesystem|tmpfs|cdrom' | awk '{ print $5 " " $6 }' | while read output;
    do
     usep=$(echo $output | awk '{ print $1}' | cut -d'%' -f1  )
     partition=$(echo $output | awk '{ print $2 }' )
     if [ $usep -ge $THRESHOLD ]; then
     (echo "Subject: Alert: Free space low on `hostname -s`, $usep % used on $partition"; echo)| 
     sendmail -t $EMAIL
     fi
    done

    ```

3.  现在，保存文件并使其可执行:

    ```sh
    chmod +x /etc/cron.daily/monitor_disk_space.sh

    ```

## 它是如何工作的...

我们使这个脚本可执行，并将其放在`/etc/cron.daily`目录中，这是我们每天通过`crond`服务自动运行这个脚本所需要做的一切。

这个简单的脚本向我们展示了构建监控脚本是多么容易，这可以成为安装和配置大型监控套件(如 Nagios)的真正替代方案。您可以使用显示的脚本作为起点进行扩展，进一步添加对监控很重要的资源，如 CPU 负载、可用内存等。

我们使用了一个执行 Linux 命令`df`的脚本，这是一个报告文件系统磁盘空间使用情况的工具。从这个命令的输出中，脚本解析了`USE%`列(使用 Unix 工具`awk`和`cut`，这给了我们使用的总磁盘百分比。然后，该数字将与用户通过编辑脚本和更改环境变量`THRESHOLD`设置的阈值进行比较。如果提取的百分比数字高于我们的阈值，将会有一封电子邮件发送到用环境变量`EMAIL`定义的电子邮件地址(如果需要，可以适当更改)。

# 用 GIT 和 Subversion 控制

文档修订控制系统或版本控制系统，有时被称为，用于文档变更的管理。这些系统现在变得越来越重要，因为现代工作经常将来自全球各地的人联系起来，在各种文档(例如，软件源代码)上进行协作和协作，这使得由不同的人使用修订版来管理文件更改变得非常重要。在这个食谱中，我们将向您展示如何使用现代版本控制系统，如 GIT 和 Subversion 来管理配置文件的版本控制。

## 做好准备

要完成此方法，您需要安装具有 root 权限的 CentOS 7 操作系统，并连接到互联网，以便于下载其他软件包。

## 怎么做...

在本食谱中，我们将把完整的主 Linux 配置目录`/etc/`置于 Git 存储库的版本控制之下，以跟踪我们对配置文件的所有更改:

1.  首先，以 root 用户身份登录，安装 Git，并通过提供电子邮件地址和用户名进行配置(请用真实姓名替换`your_username`和【T1):

    ```sh
    yum install git
    git config --global user.email  "your_email_address"
    git config --global user.name "your_username"

    ```

2.  现在，让我们在`/etc`目录下创建一个新的存储库:

    ```sh
    cd /etc/
    git init

    ```

3.  现在，在我们有了新的存储库之后，让我们添加版本控制下的`/etc/`目录中的所有文件:

    ```sh
    git add *

    ```

4.  要将文件提交到创建您的第一个版本的存储库中，请键入以下内容:

    ```sh
    git commit -a -m "inital commit of the full /etc/ directory"

    ```

5.  现在，让我们更改一个文件:

    ```sh
    echo "FILE HAS CHANGED" >> yum.conf

    ```

6.  接下来，显示对存储库的更改:

    ```sh
    git status

    ```

7.  接下来，我们将提交这些更改并创建它的新版本:

    ```sh
    git commit -a -m "changing yum.conf files"

    ```

8.  接下来，显示到目前为止的所有提交:

    ```sh
    git log --pretty=oneline --abbrev-commit

    ```

9.  这将在我的系统上输出以下提交(您的系统上的哈希数会有所不同):

    ```sh
    8069c4a changing yum.conf
    5f0d50a inital commit of the full /etc directory

    ```

10.  根据前一步的输出，我们现在将显示两个修订号之间的所有差异(根据前一步的输出更改系统上的数字哈希):

    ```sh
    git diff 8069c4a 5f0d50a

    ```

11.  为了完成这个配方，我们将把我们的更改恢复到原始文件版本(初始提交):

    ```sh
    git checkout 5f0d50a

    ```

## 它是如何工作的

在本食谱中，我们向您展示了如何使用 Git 来管理`/etc`目录中系统配置文件的更改。这可能很重要，例如，如果您正在进行测试，那么将会对一些配置文件进行大量的更改，并且您希望跟踪您的更改，这很好，因为如果您以后必须恢复更改或返回到特定的修订版本，或者比较不同的文件版本，则不需要记住您所采取的每一个步骤。

那么，我们从这次经历中学到了什么？

我们从安装 Git 开始，并在其配置中添加了一个用户名和一个电子邮件地址，这对于在过程的后期使用它是必不可少的。然后，我们转到`/etc`目录，并在那里初始化(使用`init`参数)一个新的空 Git 项目，该项目被称为存储库，并跟踪与其相关联的所有文件。该命令将向其中添加一个隐藏的`.git`目录，该目录将包含完整的文件更改和修订信息。接下来，我们添加了这个目录中的所有文件(使用通配符`*`操作符)，包括下一个版本的所有子目录。修订版就像文件在给定时间点的状态，由一个唯一的散列标识来标识，如`8069c4a`。然后，我们实际上使用提交参数创建了一个新的修订版，并使用`-m`参数提供了一个有意义的消息。在我们建立了 Git 存储库并向其中添加了所有文件之后，文件的每一个变化都会在`/etc`目录中被关注。接下来，我们通过使用 echo `>>`命令在主 YUM 配置文件的末尾添加一个随机字符串来更改存储库中的主 YUM 配置文件。如果我们现在再次使用 git 的`status`参数，我们会在输出中看到 Git 系统已经通知该文件已被更改。我们现在可以通过再次使用 git 的`commit`参数，使用已更改的文件创建一个新的修订版本，在这里使用另一个有意义的消息来声明`yum.conf`已更改。然后我们使用 git `log`命令。这将向我们显示所有提交的修订及其唯一的`md5`散列字符串标识。有了这个标识，我们可以使用 git `diff`命令查看两个版本之间的所有文件更改。要了解输出格式的更多信息，请使用`man git-diff-files`并阅读其章节`COMBINED DIFF FORMAT`。在最后一步中，我们使用 checkout 命令转到一个特定的文件版本；在这里，我们恢复了所有更改，回到了原始文件状态。

Git 是一个非常强大的版本管理工具，在这个食谱中，我们只是触及了它的表面。要了解更多关于 Git 的精彩技术，如分支、合并、拉取请求等，从 Git 教程页面开始，输入`man gittutorial`。

## 还有更多...

您也可以使用 Subversion 程序将您的`/etc`目录置于版本控制之下。Subversion 是另一个常见的文档修订控制系统，它与 Git 的主要区别在于它使用一个集中的服务器来跟踪文件的更改。Git 是分布式的，这意味着每个从事 Git 项目的人都将在他们的计算机上拥有完整的存储库。在这里，我们将向您展示为此目的使用 Subversion 而不是 Git 所需的确切步骤:

1.  首先，安装 Subversion 并为我们的`/etc`存储库配置一个新的服务器目录:

    ```sh
    yum install subversion
    mkdir -p /var/local/svn/etc-repos
    svnadmin create --fs-type fsfs /var/local/svn/etc-repos

    ```

2.  现在，将`/etc`文件系统就地导入到我们的新存储库中:

    ```sh
    svn mkdir file:///var/local/svn/etc-repos/etc 
    -m "Make a directory in the repository to correspond to /etc"

    ```

3.  现在，切换到`/etc`目录，将所有文件添加到新版本:

    ```sh
    cd /etc
    svn checkout  file:///var/local/svn/etc-repos/etc ./
    svn add *

    ```

4.  现在，创建您的第一个提交:

    ```sh
    svn commit -m "inital commit of the full /etc/ directory"

    ```

5.  接下来，更改文件:

    ```sh
    echo "FILE HAS CHANGED" >> yum.conf

    ```

6.  将您的更改提交到新的文件版本:

    ```sh
    svn commit -m "changing yum.conf files"

    ```

7.  现在，显示更改日志:

    ```sh
    svn log -r 1:HEAD

    ```

8.  显示我们两次提交之间的文件差异(第一次提交是`/etc`导入):

    ```sh
    svn diff -r 2:3

    ```

9.  最后，回到我们`yum.conf`文件的第一次修订:

    ```sh
    svn update -r 2 yum.conf

    ```