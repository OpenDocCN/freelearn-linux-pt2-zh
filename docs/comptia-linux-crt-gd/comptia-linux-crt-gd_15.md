# 第十五章：互联网协议基础知识

在上一章中，重点是维护系统的时间和日志记录。特别是，我们触及了可以操纵系统的方法。接下来，我们处理了日志记录并探讨了常见的日志文件。最后，我们使用远程。然后我们在我们的 Fedora 系统上生成了测试日志，并验证我们在 Ubuntu 的`rsyslog`服务器上收到了日志。

本章的重点是**Internet Protocol**（**IP**）。我们从 IPv4 开始，查看地址结构和今天环境中常用的各种 IPv4 地址。然后我们转向对 IPv4 地址进行子网划分，确定 IPv4 地址的网络和主机部分。然后是 IPv6。我们看一下 IPv6 地址的结构和一些知名的 IPv6 地址。然后我们关注如何缩短冗长的 IPv6 地址。最后，我们的重点是协议。我们将介绍一些知名的协议及其相应的端口号。

我们将涵盖以下主题：

+   IPv4 寻址

+   IPv6 寻址

+   知名协议

# IPv4 寻址

IP 版本 4 是 IP 的第四个版本。它在我们所知的互联网中扮演着至关重要的角色。到目前为止，IPv4 是在网络和互联网中为各种设备寻址最常用的协议。关于 IP 的另一个有趣的事实是，它不像 TCP 那样是面向连接的；相反，IP 是无连接的。

IPv4 地址由 32 位或 4 字节组成。我们使用 2 进制计算地址；这给我们 2³²，相当于 4,294,967,296 个地址。看起来 IPv4 地址很多；然而，现实并非如此。事实上，目前存在 IPv4 短缺。IPv4 地址以点分十进制格式表示。IPv4 地址的一个示例如下：

```
192.168.1.1
```

在这里，我们可以看到 IPv4 地址确实是以点分十进制格式表示的。点`.`充当地址之间的分隔符。数字可以在 0 到 255 之间的任何位置，包括 0 和 255。IPv4 地址的每部分称为一个八位组；因此，这四个数字组成了四个八位组。在今天的环境中有各种类型的 IPv4 地址；特别是在**局域网**（**LAN**）中，您可能会看到以下之一：

+   `10.0.0.0/8`

+   `172.16.0.0/12`

+   `192.16.0.0/16`

这些地址可能看起来很熟悉。这三个地址可以通过 RFC 1918 进一步解释；这个规范了一些应在私人网络中使用的地址，比如 LAN。

我们有五类地址空间；前四类地址在各种环境中常用。这些是地址类：

| Class A |  0-127 |
| --- | --- |
| Class B |  128-191 |
| Class C  | 192-223 |
| Class D | 224-239 |
| Class E |  240-255 |

在这里，数字范围代表第一个八位组中的占位符。我们可以分解 IPv4 地址以便更好地理解。我们将使用第一个八位组作为参考。首先，我们将建立一个表。IPv4 地址的每个八位组代表 1 个字节；1 个字节 = 8 位。然后我们可以使用这些信息来形成我们的表：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 18 | 4 | 2 | 1 |  = 255 |

太棒了！基于这一点，我们从 7 数到 0 的原因是因为在计算 IPv4 地址中的一个八位组的值时，我们总是从 0 开始，并且在添加时从右向左移动。现在，我们得到值的方式是通过乘以 2^x，其中 x = 最右边的字符。因此，它将如下所示：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 1 表示该位被打开 |
| 2^ | 2^ | 2^ | 2^ | 2^ | 2^ | 2^ | 2^ |  = 2 进制 |
| 128 |  6 | 32 |  16 |   8  | 4    |  2  |  1  |  = 每个位位置的 2 进制结果 |

使用 8 位中的所有值，我们得到*128+64+32+16+8+4+2+1 = 255*。

基于这一点，我们现在看到表是如何使用二进制进行计算的。因此，在任何给定时间，只有 0-255 之间的值，包括 0 和 255，才是合法值。

# A 类

A 类地址空间 0-127，只看第一个八位字节中的领先位（因为我们从 0 到 7 进行计数）；这被称为最重要的位位置。127 地址空间被保留；这被称为环回地址空间。因此，我们只使用值 0-126。此外，0 实际上是保留用于网络使用（稍后在我们讨论子网划分时会详细介绍）。现在，我们计算 A 类地址的第一个值的方式如下：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  = 0-127 |

基于这一点，我们在第一个八位字节中关闭了所有八位。因此，这给了我们类 A 地址空间，即第一个八位字节在 0-126 之间，0 被保留，127 被保留为环回空间。因此，第一个八位字节中真正可用的 IPv4 地址是 1-126。然后，接下来的三个八位字节都是零。因此，类 A 地址空间将如下所示：

+   A 类`0-126.0.0.0/8`，其中第 8 位位置为 0

+   A 类保留地址空间`127.0.0.0/8`

+   A 类**自动私有 IP 地址**（APIPA）`169.0.0.0/8`保留

基于这一点，我们可以定义最多 126 个网络。A 类地址的剩余三个八位字节`0.0.0`组成了主机部分；每个八位字节由八位组成。主机是可以分配 IPv4 地址的任何设备。A 类地址允许的最大主机数量是每个网络的 1677216-2 = 16,777,214 个主机。主机部分是 2³ 个八位字节的结果（每个八位字节 8 位 x 3 = 24 位）- 2 = 1677216-2 =每个 A 类网络的 16,777,214 个主机。

# B 类

B 类地址空间 128-191，查看领先位位置 7 和 6（记住我们从 0 开始计数，从左到右移动）。最重要的位，位置 7，在二进制中被打开。这被设置为 1，第二最重要的位，位置 6，被设置为 0。这可以通过我们之前创建的表来看到：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  = 128 |

基于这一点，最重要的位被打开，第二最重要的位被关闭。这给了我们地址空间为 128-191，其中 128 被保留用于网络使用，191 被保留为广播地址。我们将在本章后面讨论广播地址时讨论。在 B 类地址空间中，前 16 位被保留用于网络使用；然而，有两位被保留。这将给我们每个 B 类地址的 16384 个网络。这可以如下所示：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 255 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  = 128 |

我们必须跳过前两位，位置 7 和 6；这样我们就得到了 2¹⁴ = 163864 个网络

基于这一点，我们看到了可用网络的最大数量，但我们没有看到最大主机数量。我们计算 B 类地址的主机的方式是使用最后两个八位字节作为主机；我们将进行 2² 个八位字节（每个八位字节 8 位 x 2 = 16 位）-两位用于网络和广播= 65,536-2 =每个 B 类网络的 65,534 个主机。

# C 类

类 C 地址空间，192-223，考虑了前三位最重要的位；即，位置 7、6 和 5。前两位最重要的位被打开；它们在二进制中设置为 1。第三位，二进制中的位置 5，被关闭；这被设置为 0。前 24 位被保留用于类 C 地址空间中的网络使用。然后我们可以使用这些信息构建我们的表。表格如下：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |
| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  = 128+64=>192 |

基于此，我们可以看到类 C 地址空间从 192 开始，到 223 结束。192 保留为网络，223 保留为广播。然后我们可以通过使用 2²¹ = 2,097,152 个网络来计算网络的数量。这可以用以下表格表示：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |
| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  = 前 3 位总共 192 |

24 位被保留用于类 C，24 位—三个最重要的位= 21，然后 2²¹ 位= 2,097,152 个网络。

最后一个八位`.0`保留用于主机地址。这意味着每个 C 类地址有 2¹ 个八位（8 位）- 2 位用于网络和广播= 256 - 2 = 254 个主机。

# 类 D

类 D，224-239，地址空间保留用于多播。前三位最重要的位被打开；它们被设置为 1。第四位最重要的位设置为 0。类 D 地址空间不用于 IP 寻址，就像前几个地址空间一样。相反，类 D 地址空间用于为多播组分配 IP 地址。然后主机是多播组的一部分，反过来共享一个组地址。以下表格说明了用于类 D 地址空间的位：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 255 |
| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |  = 总共 224 |

基于此，类 D 地址空间从`224.0.0.0`开始，到`239.255.255.255`结束。

# 类 E

类 E，240-255，地址空间保留用于将来使用。因此，它不像以前的地址空间那样被实现。前四位最重要的位被打开；它们被设置为 1。在类 E 中唯一使用的地址是`255.255.255.255`；这就是所谓的所有广播地址。以下表格说明了用于类 E 地址空间的位：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 255 |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  = 总共 240 |

基于此，类 E 地址空间从`240.0.0.0`开始，到`255.255.255.255`结束，其中`255.255.255.255`保留为所有广播地址。

# 子网掩码

我们刚刚介绍了 IPv4 地址空间的各种类别，但在某些情况下，使用这些地址空间的类别可能不合适。事实上，如果我们使用这些 IP 地址类别的默认子网掩码，那么 A 类、B 类和 C 类都是有类别的地址空间。例如，A 类使用子网掩码`255.0.0.0`。但是，等等，什么是子网掩码？首先，子网掩码标识给定 IP 地址的网络部分和主机部分。这包括 IPv4 和 IPv6。子网掩码使我们能够轻松地找出给定 IP 地址的网络地址。子网掩码通常以点分十进制格式编写。但是，也可以用斜杠表示法来表示子网掩码；即 CIDR 表示法。CIDR（无类别域间路由）简称，通过在 IP 地址后附加网络位数的斜杠格式来表示子网掩码。对于 A 类地址，子网掩码如下：

```
255.0.0.0
```

基于此，值`255.0.0.0`表示前八位组中的所有位都被打开；它们被设置为 1。我们可以用之前创建的表来表示这一点：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ 位位置 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 打开的位数 |

128+64+32+16+8+4+2+1 = 255 位

基于此，255 的值来源于所有八位都被打开的总和。除此之外，子网掩码也可以用二进制格式表示。使用 A 类地址，子网掩码可以写成如下形式：

+   **十进制格式的 A 类子网掩码**：`255.0.0.0`

+   **二进制格式的 A 类子网掩码**：`11111111.00000000.00000000.00000000`

太棒了！现在我们可以看到子网掩码可以用 0-255 之间的值以十进制格式表示，也可以用 0 或 1 的值以二进制格式表示。此外，还可以用 CIDR 表示子网掩码。我们可以用以下格式表示 CIDR 格式的 A 类地址：

+   **十进制格式的 A 类子网掩码**：`255.0.0.0`

+   **二进制格式的 A 类子网掩码**：`11111111.00000000.00000000.00000000`

+   **CIDR 格式的 A 类子网掩码**：`/8`

基于此，`/8`表示地址的网络部分有八位被打开。

使用 B 类地址，我们可以用点分十进制格式表示 B 类地址如下：

```
255.255.0.0
```

基于此，值`255.255.0.0`表示前两个八位组中的所有位都被打开；它们被设置为 1。我们可以用之前创建的表来表示这一点：

第一个八位组：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ 位位置 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 打开的位数 |

128+64+32+16+8+4+2+1 = 255 位

第二个八位组：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ 位位置 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 打开的位数 |

128+64+32+16+8+4+2+1 = 255 位

基于此，值`255.255.0.0`来源于所有 16 位都被打开的总和。除此之外，子网掩码也可以用二进制格式表示。使用 B 类地址，子网掩码可以写成如下形式：

+   **十进制格式的 B 类子网掩码**：`255.255.0.0`

+   **二进制格式的 B 类子网掩码**：`11111111.11111111.00000000.00000000`

太棒了！现在我们可以看到子网掩码可以用 0-255 之间的值以十进制格式表示，也可以用 0 或 1 的值以二进制格式表示。此外，还可以用 CIDR 表示子网掩码。我们可以用以下格式表示 CIDR 格式的 B 类地址：

+   **十进制格式的 B 类子网掩码**：`255.255.0.0`

+   **二进制格式的 B 类子网掩码**：`11111111.11111111.00000000.00000000`

+   **CIDR 格式的 B 类子网掩码**：`/16`

基于此，`/16`表示地址的网络部分有十六位被打开。

使用 C 类地址，我们可以用点分十进制格式表示 C 类地址如下：

```
255.255.255.0
```

基于此，值`255.255.255.0`表示前两个八位组中的所有位都被打开；它们被设置为 1。我们可以用之前创建的表来表示这一点：

第一个八位组：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ 位位置 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 打开的位数 |

128+64+32+16+8+4+2+1 = 255 位

第二个八位组：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ 位位置 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 打开的位数 |

128+64+32+16+8+4+2+1 = 255 位

第三个八位组：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ 位位置 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 打开的位数 |

128+64+32+16+8+4+2+1 = 255 位

基于此，`255.255.255.0`的值是由所有 24 位打开的总和得出的。此外，子网掩码也可以用二进制格式表示。使用 C 类地址，子网掩码可以写成以下形式：

+   **十进制中的 C 类子网掩码**：`255.255.255.0`

+   **二进制中的 C 类子网掩码**：`11111111.11111111.11111111.00000000`

太棒了！现在，我们可以看到子网掩码可以用 0-255 之间的值以十进制格式表示，也可以用 0 或 1 的值以二进制格式表示。此外，可以用 CIDR 表示子网掩码。我们可以用以下方式用 CIDR 格式表示 C 类地址：

+   **十进制中的 C 类子网掩码**：`255.255.255.0`

+   **二进制中的 C 类子网掩码**：`11111111.11111111.11111111.00000000`

+   **CIDR 中的 C 类子网掩码**：`/24`

基于这一点，`/24`表示地址的网络部分有 24 位打开。

# 子网划分

正如我们刚刚看到的 A、B 和 C 类，它们的子网掩码分别使用 CIDR 表示为`/8`、`16`和`24`。在今天的大多数环境中，这些默认子网掩码被称为类别，这意味着如果我们使用这些子网掩码，我们将无法执行任何形式的流量工程。当我们想要控制广播域时，这就成了一个问题。我们应该尽量减少广播到特定的房间、办公室或部门。这确保在任何类型的网络广播事件发生时，整个网络不会开始出现延迟。我们可以利用子网划分来克服类别网络的限制。例如，让我们选择一个 C 类 IP 地址：

```
192.168.0.0/24
```

基于此，每个网络地址最多可以有 254 个主机。我们可能会遇到这样的情况，我们只有八个系统需要 IP 连接。这意味着我们正在失去那些剩余的 IP 地址，因为我们使用了默认的 C 类子网。在这种情况下的要求是有八个 IP 地址，而不是浪费剩下的 IP 地址。我们可以通过子网划分来实现这个要求。子网划分是通过从主机部分借用位来实现的。让我们写出给定 IP 地址的子网掩码：

```
192.168.0.0/24 Network
```

+   **十进制中的子网掩码**：`255.255.255.0 `

+   **二进制中的子网掩码**：`11111111.11111111.11111111.00000000 `

基于此，前 24 位被打开。我们可以对这个地址进行子网划分，以便更好地控制我们的 IP 地址空间。我们想要八个 IP 地址。我们借用位的方式是从主机位中取位。我们可以使用我们的表格来帮助：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ 位位置 |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  =借用了 4 位  |

+   2⁴ 位 = 可以创建 16 个网络

+   2⁴ -2 =每个网络 14 个主机

基于此，我们从网络的主机部分借用了四位；这使我们能够创建四个更小的子网/网络。然后，每个创建的网络将有 14 个主机。这使我们能够节省 IP 地址的数量，而不是使用标准的 C 类`/24`网络。因此，我们从网络部分借用了四位。我们如何用十进制和 CIDR 表示这一点呢？嗯，我们表示新创建的子网的方式是通过添加网络位。这可以在以下表格中说明： 

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ 位位置 |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  =4 位  |

128+64+32+16 = 240

+   旧的十进制子网 = `255.255.255.0`

+   老子网在 CIDR = `/24`

+   新的十进制子网 = `255.255.255.240`

+   新的 CIDR 子网 = `/28`

+   网络地址 = `192.168.0.0/28`

基于此，我们可以看到新的子网掩码的十进制和 CIDR 表示。下一步是使用这个新的子网掩码来识别可用的子网/网络。我们可以使用以下表格来计算可用的子网：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^位位置 |
| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  = 4 位 |

网络按位位置的 2 进制值递增：

+   **第一个网络**：`192.168.0.0/28`

+   **第二个网络**：`192.168.0.16/28`

+   **第三个网络**：`192.168.0.32/28`

+   **第四个网络**：`192.168.0.48/28`

+   **直到第十六个网络**：`192.168.0.240/28`

基于这一点，我们可以看到第四个八位组是增量发生的地方。特别是对于`/28`，子网增量为 16；这是因为计算得到的 2⁴ 位位置=16。最后一步是确定可以分配给网络内主机的可用 IP。我们将使用以下作为分解：

+   **第一个子网/网络**：`192.168.0.0/28`

+   **第一个可用 IP 地址**：`192.168.0.1/28`

+   **最后一个可用 IP 地址**：`192.168.0.14/28`

+   **广播 IP 地址**：`192.168.0.15/28`

+   **第二个子网/网络**：`192.168.0.16/28`

基于这一点，我们可以看到有两个 IP 是不可用的。这些是我们在计算主机 IP 时考虑的因素。同样，我们可以通过以下分解来获得第二个子网`192.168.0.16/28`的可用 IP：

+   **第二个子网/网络**：`192.168.0.16/28`

+   **第一个可用 IP 地址**：`192.168.0.17/28`

+   **最后一个可用 IP 地址**：`192.168.0.30/28`

+   **广播 IP 地址**：`192.168.0.31/28`

+   **第三个子网/网络**：`192.168.0.32/28`

太棒了！基于这一点，我们可以看到一个模式；我们总是最终得到 14 个可用的 IP 地址。此外，我们可以对 B 类地址进行子网划分，并利用主机位来更好地管理我们的网络。让我们使用以下 B 类地址：

```
172.16.0.0/16
Subnet mask:255.255.0.0
```

基于这一点，每个网络有超过 65,000 个主机 IP；这在大多数环境中都不理想。例如，我们想要对这个 IP 进行子网划分，以获得 500 个主机 IP。这可以通过从地址的主机部分借用一些主机位来实现。我们可以使用以下分解来帮助我们：

```
255.255.0.0
11111111.11111111.00000000.00000000 =/16 bits being used
```

我们计算主机的方法是从右到左移动。

第四个八位组：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^位位置 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 8 位总共 255 |

2⁸ = 255-2 = 每个网络 254 个主机。

第三个八位组：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^位位置 |
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |  = 9 位打开 |

2⁹ = 512 -2 = 每个网络 510 个主机。

太棒了！基于这一点，为了满足要求，需要九位。这意味着我们将不得不从第三个八位组借用八位来满足要求。我们可以通过以下方式进行分解：

```
255.255.0.0
11111111.11111111.11111110.00000000 =/23 bits being used.
```

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^位位置 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 |  = 7 位打开 |

```
Eight bits in first octet + eight bits in second octet + seven bits in third octet =23 bits
The sum of the bits turned on in the third octet 128+64+32+16+8+4+2 =254
The new subnet mask in decimal = 255.255.254.0
```

基于这些计算，新网络将被写成如下：

```
172.16.0.0/23
The total number of subnets = 2 ^ 7 = 128 subnets created
The total number of hosts per subnet/network =2⁹ - 2 = 512 -2 = 510 hosts per subnet/network
Subnets = 172.16.0.0/23 , 172.16.2.0/23, 172.16.4.0/23, 172.16.6.0/23 - 172.16.254.0/23
```

基于这一点，我们有每个子网的总子网和主机。现在，我们需要计算每个子网的可用 IP 地址。这可以通过以下分解来完成：

+   **第一个子网/网络**：`172.16.0.0/23`

+   **第一个可用 IP**：`172.16.0.1/23`

+   **最后一个可用 IP**：`172.16.2.254/23`

+   **广播 IP**：`172.16.2.255`

+   **第二个子网/网络**：`172.16.2.0/23`

基于这一点，我们可以看到可用的 IP 地址；`172.16.2.255`是使用`/23`子网的有效 IP。同样，`172.16.1.0/23`也是有效的 IP 地址。在一些操作系统中，比如 Windows，如果你尝试分配这两个 IP 中的任何一个，可能会遇到错误。然而，在 Linux 中，一切都是公平的。我们通过增量子网 2 来增量，因为这是最后一个网络位的位置。

我们甚至可以对 A 类地址进行子网划分。例如，假设我们想要从单个 A 类地址创建 100 个子网。我们将使用以下：

```
10.0.0.0/8
255.0.0.0
```

我们可以使用之前创建的表来做到这一点。

第二个八位组：

| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | = 位位置 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | = 2^位位置 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | = 7 位打开 |

太棒了！基于此，我们可以快速推导出我们需要从第二个八位组借用七位来创建 100 个子网。实际上，我们将有 128 个子网。这是因为我们正在计算第二个八位组中的 2⁷ 位。然后我们可以按以下格式写出我们的子网：

```
11111111.11111110.00000000.00000000
Subnet 255.254.0.0 /15
Subnets 10.0.0.0/15, 10.2.0.0/15, 10.4.0.0/15, 10.6.0.0/15 - 10.254.0.0/15
```

太棒了！这么容易就对 A 类进行子网划分。现在我们需要计算每个子网的主机总数。我们可以使用以下方法：

```
Subnet in binary
11111111.11111110.00000000.00000000
Network bits are represented by n
Host bits are represented by h
nnnnnnnn.nnnnnnnh.hhhhhhhh.hhhhhhhh
2¹⁷ -2 = 131072 - 2 = 131070 hosts per subnet/network
```

基于此，我们可以看到使用`/15`每个子网获得了相当多的主机。我们可以使用以下方法来推导每个子网的可用 IP：

+   第一个子网/网络：`10.0.0.0/15`

+   第一个可用 IP：`10.0.0.1/15`

+   最后一个可用 IP：`10.2.255.254/15`

+   广播 IP：`10.2.255.255`

+   第二个子网/网络：`10.2.0.0/15`

太棒了！计算任何一个子网的最简单方法是始终将网络位乘以 2。要计算总主机数，始终将主机位乘以 2，然后减去 2 得到网络和广播地址。

# IPv6 寻址

互联网协议第 6 版（IPv6），由互联网工程任务组（IETF）开发。IPv6 地址旨在解决 IPv4 地址短缺问题。IPv4 已经完全耗尽，公司现在愿意以巨额资金交换他们的 IPv4 地址块。IPv6 地址长度为 128 位或 16 字节。这给了我们 2¹²⁸ 个 IPv6 地址。IPv6 地址以十六进制格式表示。有三种类型的 IPv6 地址。

# 单播

单播地址指定设备上单个接口的标识符，类似于 IPv4 地址。使用 IPv6，很可能所有 IPv6 流量大多是基于单播的。

# 多播

IPv6 多播地址的概念类似于 IPv4 地址。数据包被发送到 IPv6 多播地址，属于多播组的接收者将接收多播数据包。

# 单播

这种地址类型是在 IPv6 中引入的。任播的概念是通过将多个设备分配相同的任播 IPv6 地址来工作。当发送者向任播 IPv6 地址发送数据包时，任播数据包通过路由协议路由到距离发送者最近的主机。

以下是 IPv6 地址的示例：

```
2001:0db8:0000:0000:0000:ff00:0042:8329
```

基于此，我们可以看到 IPv6 地址由八组 16 位或 2 字节值组成，用冒号分隔。这就是我们得到 128 位或 16 字节长度的方法。写 IPv6 地址可能看起来很长，但我们可以使用一些方法使 IPv6 地址变得更小。

# 删除前导零

我们可以删除 IPv6 地址中的前导零，从而使其更易读：

```
2001:0db8:0000:0000:0000:ff00:0042:8329
2001:db8:0:0:0:ff00:42:8329
```

太棒了！基于此，我们使 IPv6 地址更加易于呈现。但是，请等一下，我们还可以通过使用下面描述的技术使其更小。

# 删除连续的零

我们可以删除 IPv6 地址中连续的零，并用双冒号替换这些零。这只能做一次：

```
2001:db8::ff0:42:8329
```

太棒了！正如我们所看到的，IPv6 地址现在更易读。此外，在浏览器中输入 IPv6 地址时，我们会执行以下操作：

```
http://[ 2001:db8::ff0:42:8329]/
```

基于此，我们会用方括号括起 IPv6 地址。有一些特殊类型的单播 IPv6 地址值得一提：

+   全局单播地址：这些地址以`2000::/3`开头，如 RFC 4291 中所述。它们是类似于公共 IPv4 地址的可公开路由地址。

+   链路本地地址：这些地址以`fe80::/10`开头；它们仅在本地物理链路上有效。

+   站点本地地址：这些地址以`fec::/10`开头；它们仅在单个站点内有效。它们已被 RFC 机构弃用。

+   **唯一本地地址**：这些地址以`fc00::/7`开头；它们旨在在一组合作站点内进行路由。它们旨在取代站点本地地址。唯一本地地址的一个有趣特点是它们减少了地址冲突的风险。

有一些类似于 IPv4 的特殊 IPv6 地址。以下是一些保留的 IPv6 地址：

| `2000::/3` | 全局单播 |
| --- | --- |
| `::/128` | 未指定地址 |
| `::/0` | 默认路由 |
| `::1/128` | 回环地址 |
| `FF00::/8` | 多播地址 |

太棒了！在识别子网方面，我们需要解析 IPv6 地址。我们可以使用以下方法进行分解：

```
2001:db8:0000:0000:0000:ff0:42:8329
```

| 全局路由前缀 | 子网 | 主机 ID |
| --- | --- | --- |
| `2001:db8:0000:` | `0000:` | `0000:ff0:42:8329` |
| 48 位或 3 字节 | 16 位或 2 字节 | 64 位或 8 字节 |

基于此，全局路由前缀由 48 位组成。子网由接下来的 16 位组成。主机标识符由最后的 64 位组成。

# 知名协议

我们在环境中使用许多我们需要了解的知名协议。首先，当我们浏览互联网时，实际上是使用 HTTP 协议来查看网页。此外，当我们从服务器复制文件并提供身份验证时；在后台，我们使用某种 FTP 协议。同样，当我们输入 URL 时，实际上是使用 DNS 进行名称解析。正如我们所看到的，我们在我们的环境中使用了许多协议。接下来描述了一些知名协议及其相应的端口号。

# TCP

**传输控制协议**（**TCP**）是一种面向连接的协议，提供了许多服务，包括错误检查和排序等。它在 OSI 模型的第 4 层，即传输层上运行。

# HTTP

**超文本传输协议**（**HTTP**）按需提供网页；这是互联网上通过 URL 进行数据通信的协议。它使用端口`80`进行通信。此外，它建立在 TCP 之上。

# HTTPS

**超文本传输安全协议**（**HTTPS**）为互联网上的 URL 提供安全通信。它使用端口`443`进行通信。此外，它的通信使用**传输层安全**（**TLS**）。它建立在 TCP 之上。

# FTP

**文件传输协议**（**FTP**）用于在客户端和服务器之间传输文件。这可以在局域网内或通过互联网进行。FTP 支持身份验证，但所有传输都是明文发送的；没有内置安全性。FTP 使用 TCP 端口`20`进行数据传输和端口`21`进行命令传输。

# UDP

**用户数据报协议**（**UDP**）是一种无连接协议，提供速度但不进行任何错误检查。它在 OSI 模型的第 4 层，即传输层上运行。

# DNS

**域名系统**（**DNS**）提供了将 IP 地址转换为用户友好的名称的手段，用户可以与之相关联。它通常使用 UDP 端口`53`，但每当请求或响应大于一个数据包时，也使用 TCP 端口`53`。

# TFTP

**简单文件传输协议**（**TFTP**）用于以快速速率传输数据。不支持任何身份验证方法；也没有错误检查。TFTP 使用 UDP 端口`69`。

# ICMP

**互联网控制消息协议**（**ICMP**）是网络环境中使用的另一种协议。通常用于通过局域网或互联网在各种网络设备之间发送消息进行故障排除。还有 ICMPv6，用于 IPv6。ICMP 使用 IP 协议`1`，而 ICMPv6 使用 IP 协议`58`。

# 总结

在本章中，我们深入研究了 IPv4 和 IPv6 的世界。除此之外，我们还涵盖了子网掩码和识别子网掩码的方法。接下来，我们介绍了子网划分。我们通过了一些示例，并说明了推导所需主机数量和所需子网数量的技术。最后，我们使用了一些知名的协议。我们涵盖了一些最广泛使用的协议及其端口号。

在下一章中，我们将继续进行网络配置和故障排除。我们将在 Linux 系统上工作，分配 IPv4 地址和 IPv6 地址，并查看各种网络连接故障排除的方法。

# 问题

1.  哪个地址是 A 类地址？

A. `192.0.0.1`

B. `172.0.0.1`

C. `10.0.0.1`

D. 以上都不是

1.  哪个地址是 C 类地址？

A. `128.0.0.1`

B. `100.0.0.2`

C. `192.168.0.1`

D. 以上都不是

1.  哪个地址被称为 IPv4 环回地址？

A. `127.0.0.1`

B. `169.0.0.1`

C. `172.16.0.1`

D. `192.1.1.1`

1.  哪个地址是 APIPA 地址？

A. `169.0.0.1`

B. `172.16.0.1`

C. `10.1.1.1`

D. `192.168.1.1`

1.  哪个地址是 B 类地址？

A. `128.0.0.1`

B. `10.11.1.1`

C. `127.0.0.1`

D. 223.0.0.1

1.  IPv6 组播地址以什么开头？

A. `fc0e::/8`

B. `fce::/7`

C. `ff00::/8`

D. `fd0:/9`

1.  哪个地址是 IPv6 默认路由？

A. `::1/0`

B. `::/0`

C. `01A:00000000:00000000:00000000:00000000::9`

D. ::1/128

1.  哪个地址是 IPv6 环回地址？

A. `::0/1`

B. `::0/0`

C. `::1/128`

D. `::128/128`

1.  链路本地地址以什么开头？

A.`ff00::/8` B.`fc00::/10` C.`fcd00::128` D.`fe80::/10`

1.  HTTP 使用哪个端口？

A.TCP `10` B.UDP `80` C.TCP `80` D.UDP `69`

# 进一步阅读

+   这个网站提供了有关 IP 的有用信息：[`tools.ietf.org`](https://tools.ietf.org)

+   这个网站提供了有关子网划分的有用信息：[`www.quora.com`](https://www.quora.com)

+   这个网站提供了有关 IPv6 的有用信息：[`www.ipv6.com`](https://www.ipv6.com)
