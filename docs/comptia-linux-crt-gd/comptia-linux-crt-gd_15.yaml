- en: Fundamentals of Internet Protocol
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互联网协议基础知识
- en: In the last chapter, the focus was on maintaining the system's time and logging.
    Particularly, we touched on ways in which we could manipulate the system. Next,
    we worked with logging and explored the common log files. Finally, we worked with
    remote. We then generated test logs over on our Fedora system and verified that
    we received the logs over on our Ubuntu `rsyslog` server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，重点是维护系统的时间和日志记录。特别是，我们触及了可以操纵系统的方法。接下来，我们处理了日志记录并探讨了常见的日志文件。最后，我们使用远程。然后我们在我们的Fedora系统上生成了测试日志，并验证我们在Ubuntu的`rsyslog`服务器上收到了日志。
- en: In this chapter, the focus is all about **Internet Protocol** (**IP**). We start
    off with IPv4, looking at the address structure and the various IPv4 addresses
    commonly used in today's environment. We then move on to subnetting an IPv4 address,
    determining the network and host portion of an IPv4 address. This is then followed
    up with IPv6\. We look at the structure of an IPv6 address and some well-known
    IPv6 addresses. Then we focus on ways by which we can reduce the lengthy IPv6
    address. Finally, our focus is on the protocols. We will cover some well-known
    protocols and their respective port numbers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是**Internet Protocol**（**IP**）。我们从IPv4开始，查看地址结构和今天环境中常用的各种IPv4地址。然后我们转向对IPv4地址进行子网划分，确定IPv4地址的网络和主机部分。然后是IPv6。我们看一下IPv6地址的结构和一些知名的IPv6地址。然后我们关注如何缩短冗长的IPv6地址。最后，我们的重点是协议。我们将介绍一些知名的协议及其相应的端口号。
- en: 'We will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: IPv4 addressing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv4寻址
- en: IPv6 addressing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv6寻址
- en: Well-known protocols
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知名协议
- en: IPv4 addressing
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv4寻址
- en: IP version 4 is the fourth version of IP. It plays a vital role in the internet
    as we know it. By far, IPv4 is the most commonly used protocol for addressing
    various devices within a network and out on the internet. Another interesting
    fact about IP is that it's not connection-oriented as is the case for TCP; instead,
    IP is connectionless.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: IP版本4是IP的第四个版本。它在我们所知的互联网中扮演着至关重要的角色。到目前为止，IPv4是在网络和互联网中为各种设备寻址最常用的协议。关于IP的另一个有趣的事实是，它不像TCP那样是面向连接的；相反，IP是无连接的。
- en: 'An IPv4 address is made of 32 bits or 4-bytes in length. We calculate the addresses
    in base 2; this gives us 2^32, which equals 4,294,967,296 addresses. It may seem
    as though there are plenty of IPv4 addresses; however, the reality differs. In
    fact, there is currently an IPv4 shortage. An IPv4 address is represented in dotted
    decimal format. An example of an IPv4 address is as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4地址由32位或4字节组成。我们使用2进制计算地址；这给我们2^32，相当于4,294,967,296个地址。看起来IPv4地址很多；然而，现实并非如此。事实上，目前存在IPv4短缺。IPv4地址以点分十进制格式表示。IPv4地址的一个示例如下：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we can see that an IPv4 address is indeed represented in a dotted decimal
    format. The dots `.` act as separators between the address. The numbers can be
    anywhere between 0 and 255, including the 0 and 255\. Each portion of an IPv4
    address is known as an octet; thus, the four numbers make up four octets. There
    are various types of IPv4 addresses available in today''s environment; particularly
    within a** local area network** (**LAN**), you may see one of the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到IPv4地址确实是以点分十进制格式表示的。点“.”充当地址之间的分隔符。数字可以在0到255之间的任何位置，包括0和255。IPv4地址的每部分称为一个八位组；因此，这四个数字组成了四个八位组。在今天的环境中有各种类型的IPv4地址；特别是在**局域网**（**LAN**）中，您可能会看到以下之一：
- en: '`10.0.0.0/8`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.0.0.0/8`'
- en: '`172.16.0.0/12`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`172.16.0.0/12`'
- en: '`192.16.0.0/16`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.16.0.0/16`'
- en: The addresses may look familiar. These three addresses can be further explained
    by the RFC 1918; this specifies certain addresses that are to be used within a
    private network, such as a LAN.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些地址可能看起来很熟悉。这三个地址可以通过RFC 1918进一步解释；这个规范了一些应在私人网络中使用的地址，比如LAN。
- en: 'We have five classes of address space; the first four classes are commonly
    used in various types of environment. These are classes of addresses:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有五类地址空间；前四类地址在各种环境中常用。这些是地址类：
- en: '| Class A |  0-127 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| Class A |  0-127 |'
- en: '| Class B |  128-191 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| Class B |  128-191 |'
- en: '| Class C  | 192-223 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| Class C  | 192-223 |'
- en: '| Class D | 224-239 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Class D | 224-239 |'
- en: '| Class E |  240-255 |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| Class E |  240-255 |'
- en: 'Here, the number range represents the place holder in the first octet. We can
    break down an IPv4 address in order to gain a better understanding. We will use
    the first octet as reference. First, we will build a table. Every octet of an
    IPv4 address represents 1 byte; 1 byte = 8 bits. We can then use this information
    to form our table:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，数字范围代表第一个八位组中的占位符。我们可以分解IPv4地址以便更好地理解。我们将使用第一个八位组作为参考。首先，我们将建立一个表。IPv4地址的每个八位组代表1个字节；1个字节
    = 8位。然后我们可以使用这些信息来形成我们的表：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit positions |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8位位置 |'
- en: '| 128 | 64 | 32 | 16 | 18 | 4 | 2 | 1 |  = 255 |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 18 | 4 | 2 | 1 |  = 255 |'
- en: 'Awesome! Based on this, the reason we counted from 7 to 0 is because we always
    start at 0 when calculating a value for an octet inside an IPv4 address and move
    from right to left when adding. Now, the way we got the value was by multiputting
    2^x, where x = the last character to the right. So it would be as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！基于这一点，我们从7数到0的原因是因为在计算IPv4地址中的一个八位组的值时，我们总是从0开始，并且在添加时从右向左移动。现在，我们得到值的方式是通过乘以2^x，其中x
    = 最右边的字符。因此，它将如下所示：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8-bit position |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8位位置 |'
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 1 means that the bit is turned on |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 1表示该位被打开 |'
- en: '| 2^ | 2^ | 2^ | 2^ | 2^ | 2^ | 2^ | 2^ |  = base 2 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 2^ | 2^ | 2^ | 2^ | 2^ | 2^ | 2^ | 2^ |  = 2进制 |'
- en: '| 128 |  6 | 32 |  16 |   8  | 4    |  2  |  1  |  = Result of base 2 for each
    bit position |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 128 |  6 | 32 |  16 |   8  | 4    |  2  |  1  |  = 每个位位置的2进制结果 |'
- en: Using all of the values inside the 8 bits, we get *128+64+32+16+8+4+2+1 = 255*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用8位中的所有值，我们得到*128+64+32+16+8+4+2+1 = 255*。
- en: Based on this, we now see how the table is built using base 2 for calculation.
    Hence, at any given time, only values between 0-255, including the 0 and 255,
    are legal values.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一点，我们现在看到表是如何使用二进制进行计算的。因此，在任何给定时间，只有0-255之间的值，包括0和255，才是合法值。
- en: Class A
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: A类
- en: 'The Class A address space, 0-127, looks at the only leading bit position (position
    7 because we count from 0 to 7) in the first octet; this is known as the most
    significant bit position. The 127 address space is reserved; this is known as
    the loopback address space. Hence, we are only using the values 0-126\. Moreover,
    the 0 is actually reserved for network use (more on this later when we cover subnetting).
    For now, the way we calculate the first values for a Class A address is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: A类地址空间0-127，只看第一个八位字节中的领先位（因为我们从0到7进行计数）；这被称为最重要的位位置。127地址空间被保留；这被称为环回地址空间。因此，我们只使用值0-126。此外，0实际上是保留用于网络使用（稍后在我们讨论子网划分时会详细介绍）。现在，我们计算A类地址的第一个值的方式如下：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |'
- en: '| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  = 0-127 |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  = 0-127 |'
- en: 'Based on this, we have all eight bits turned off in the first octet. This,
    therefore, gives us the Class A address space which is between 0-126 in first
    octet, 0 being reserved and 127 being the loopback space. Hence, the real usable
    IPv4 addresses in the first octet are 1-126\. This is then followed by the three
    remaining octets being all zeros. So the Class A address space would be as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一点，我们在第一个八位字节中关闭了所有八位。因此，这给了我们类A地址空间，即第一个八位字节在0-126之间，0被保留，127被保留为环回空间。因此，第一个八位字节中真正可用的IPv4地址是1-126。然后，接下来的三个八位字节都是零。因此，类A地址空间将如下所示：
- en: Class A `0-126.0.0.0/8`, where the leading bit is 0 in the 8th bit position
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A类`0-126.0.0.0/8`，其中第8位位置为0
- en: Class A reserved address space `127.0.0.0/8`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A类保留地址空间`127.0.0.0/8`
- en: Class A **Automatic Private IP Addressin**g (**APIPA**) `169.0.0.0/8` reserved
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A类**自动私有IP地址**（APIPA）`169.0.0.0/8`保留
- en: Based on this, we are given a maximum of up to 126 networks that we can define.
    The remaining three octets of the Class A address `0.0.0` makes up the host portion;
    each octet is made up of eight bits. A host is any device that can be assigned
    an IPv4 address(s). The maximum number of hosts allowed in a Class A address is
    16,777,214 hosts per network defined. The host portion is the result of 2^3 octets
    (eight bits per octet x 3 =24 bits) – 2 = 1677216-2 = 16,777,214 hosts per Class
    A network.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一点，我们可以定义最多126个网络。A类地址的剩余三个八位字节`0.0.0`组成了主机部分；每个八位字节由八位组成。主机是可以分配IPv4地址的任何设备。A类地址允许的最大主机数量是每个网络的1677216-2
    = 16,777,214个主机。主机部分是2^3个八位字节的结果（每个八位字节8位x 3 = 24位）- 2 = 1677216-2 =每个A类网络的16,777,214个主机。
- en: Class B
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: B类
- en: 'The Class B address spaces, 128-191, look at the leading bits position 7 and
    6 (remember that we start counting from 0, moving from left to right). The first
    most significant bit, position 7, is turned on in binary. This is set to 1 and
    the second most significant bit, position 6, is set to 0\. This can be seen using
    the table that we created earlier:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: B类地址空间128-191，查看领先位位置7和6（记住我们从0开始计数，从左到右移动）。最重要的位，位置7，在二进制中被打开。这被设置为1，第二最重要的位，位置6，被设置为0。这可以通过我们之前创建的表来看到：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |'
- en: '| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  = 128 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  = 128 |'
- en: 'Based on this, the most significant bit is turned on and the second most significant
    bit is turned off. This gives us the address space of 128-191, where the 128 is
    reserved for network use and the 191 is reserved as the broadcast address. We
    will discuss broadcast addresses later in this chapter when we cover subnetting.
    In a Class B address space, the first 16 bits are reserved for network use; however,
    two bits are reserved. This would then give us 2^14 = 16,384 networks per Class
    B address. This can be illustrated as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一点，最重要的位被打开，第二最重要的位被关闭。这给了我们地址空间为128-191，其中128被保留用于网络使用，191被保留为广播地址。我们将在本章后面讨论广播地址时讨论。在B类地址空间中，前16位被保留用于网络使用；然而，有两位被保留。这将给我们每个B类地址的16384个网络。这可以如下所示：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 255 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 255 |'
- en: '| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  = 128 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |  = 128 |'
- en: We have to skip the first two bits, positions 7 and 6; this then gives us 2^14
    = 163864 networks
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须跳过前两位，位置7和6；这样我们就得到了2^14 = 163864个网络
- en: Based on this, we see the maximum amount of the networks available but we don't
    see the maximum amount of hosts. Well, the way we calculate the hosts for a Class
    B address is to use the last two octets for the hosts; we would do 2^2 octets
    (eight bits per octets x 2 = 16 bits)—two bits for network and broadcast = 65,536
    -2 = 65,534 hosts per Class B network.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一点，我们看到了可用网络的最大数量，但我们没有看到最大主机数量。我们计算B类地址的主机的方式是使用最后两个八位字节作为主机；我们将进行2^2个八位字节（每个八位字节8位x
    2 = 16位）-两位用于网络和广播= 65,536-2 =每个B类网络的65,534个主机。
- en: Class C
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C类
- en: 'The Class C address space, 192-223, takes the first three most significant
    bits in to consideration; namely, positions 7,6, and 5\. The first two most significant
    bits are turned on; they are set to 1 in binary. The third bit, position 5 in
    binary, is turned off; this is set to 0\. The first 24 bits are reserved for network
    use in a Class C address space. We can then construct our table using this information.
    This is how the table would look:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 类C地址空间，192-223，考虑了前三位最重要的位；即，位置7、6和5。前两位最重要的位被打开；它们在二进制中设置为1。第三位，二进制中的位置5，被关闭；这被设置为0。前24位被保留用于类C地址空间中的网络使用。然后我们可以使用这些信息构建我们的表。表格如下：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |'
- en: '| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  = 128+64=>192 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  = 128+64=>192 |'
- en: 'Based on this, we can then see that the Class C address space starts at 192
    and ends at 223\. The 192 is reserved for the network and the 223 is reserved
    as the broadcast. We can then calculate the number of networks by using 2^21 =
    2,097,152 networks. This can be represented in the following table:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们可以看到类C地址空间从192开始，到223结束。192保留为网络，223保留为广播。然后我们可以通过使用2^21 = 2,097,152个网络来计算网络的数量。这可以用以下表格表示：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =255 |'
- en: '| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  = first 3 bits total 192 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |  = 前3位总共192 |'
- en: 24 bits are reserved for Class C, 24 bits—three most significant bits = 21 then
    2^21 bits = 2,097,152 networks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 24位被保留用于类C，24位—三个最重要的位= 21，然后2^21位= 2,097,152个网络。
- en: The last octet `.0` (eight bits) is reserved for the host addresses. This then
    means 2^1 octet (8 bits) – 2 bits for network and broadcast = 256 - 2 = 254 hosts
    per Class C address.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个八位`.0`保留用于主机地址。这意味着每个C类地址有2^1个八位（8位）- 2位用于网络和广播= 256 - 2 = 254个主机。
- en: Class D
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类D
- en: 'The Class D, 224-239, address space is reserved for multicast use. The first
    three most significant bits are turned on; they are set to 1\. The fourth most
    significant bit is set to 0\. The Class D address space is not used for IP addressing,
    as is the case in the previous classes of address. Instead, the Class D address
    space is used to assign an IP address to a multicast group. The hosts then are
    part of a group that in turn shares a group address. The following table illustrates
    the bits that are used for the Class D address space:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 类D，224-239，地址空间保留用于多播。前三位最重要的位被打开；它们被设置为1。第四位最重要的位设置为0。类D地址空间不用于IP寻址，就像前几个地址空间一样。相反，类D地址空间用于为多播组分配IP地址。然后主机是多播组的一部分，反过来共享一个组地址。以下表格说明了用于类D地址空间的位：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 255 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 255 |'
- en: '| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |  = total 224 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |  = 总共224 |'
- en: Based on this, the Class D address space starts at `224.0.0.0` and ends at `239.255.255.255`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，类D地址空间从`224.0.0.0`开始，到`239.255.255.255`结束。
- en: Class E
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类E
- en: 'The Class E, 240-255, address space is reserved for future use. As such, it
    is not implemented as is the previous address space. The first four most significant
    bits are turned on; they are set to 1\. The only address that is used in a Class
    E is the `255.255.255.255`; this is what is known as the all broadcast address.
    The following table illustrates the bits that are used for the Class E address
    space:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类E，240-255，地址空间保留用于将来使用。因此，它不像以前的地址空间那样被实现。前四位最重要的位被打开；它们被设置为1。在类E中唯一使用的地址是`255.255.255.255`；这就是所谓的所有广播地址。以下表格说明了用于类E地址空间的位：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8 bit position |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 8位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 255 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 255 |'
- en: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  = total 240 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  = 总共240 |'
- en: Based on this, the Class E address space starts at `240.0.0.0` and ends at `255.255.255.255`,
    where `255.255.255.255` is reserved for the all broadcast address.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，类E地址空间从`240.0.0.0`开始，到`255.255.255.255`结束，其中`255.255.255.255`保留为所有广播地址。
- en: Subnet masks
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子网掩码
- en: 'We''ve just covered the various classes of IPv4 address spaces, but there are
    times when using those classes of address space might not be appropriate. The
    fact of the matter is that Class A, B, and C are classful address spaces if we
    use the default subnet mask for those classes of IPs. For instance, a Class A
    uses a subnet mask of `255.0.0.0`. But wait, what is a subnet mask? To begin with,
    a subnet mask identifies the network portion and the host portion of a given IP
    address. This includes both IPv4 and IPv6\. A subnet mask enables us to easily
    find out the network address for a given IP address. A subnet mask is often written
    in dotted decimal format. However, it is possible to represent a subnet mask in
    a slash notation; namely, the CIDR notation. Classless Inter Domain Routing, or
    CIDR for short, represents a subnet mask by appending the number of network bits
    in a slash format to an IP address. For a Class A address, a subnet mask will
    be as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了IPv4地址空间的各种类别，但在某些情况下，使用这些地址空间的类别可能不合适。事实上，如果我们使用这些IP地址类别的默认子网掩码，那么A类、B类和C类都是有类别的地址空间。例如，A类使用子网掩码`255.0.0.0`。但是，等等，什么是子网掩码？首先，子网掩码标识给定IP地址的网络部分和主机部分。这包括IPv4和IPv6。子网掩码使我们能够轻松地找出给定IP地址的网络地址。子网掩码通常以点分十进制格式编写。但是，也可以用斜杠表示法来表示子网掩码；即CIDR表示法。CIDR（无类别域间路由）简称，通过在IP地址后附加网络位数的斜杠格式来表示子网掩码。对于A类地址，子网掩码如下：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Based on this, the value `255.0.0.0` means that all of the bits in the first
    octets are turned on; they are set to 1\. We can present this using the table
    that we created earlier:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，值`255.0.0.0`表示前八位组中的所有位都被打开；它们被设置为1。我们可以用之前创建的表来表示这一点：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ 位位置 |'
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  =bits turned on |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 打开的位数 |'
- en: 128+64+32+16+8+4+2+1 = 255 bits
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 128+64+32+16+8+4+2+1 = 255位
- en: 'Based on this, the value of 255 is derived from the sum of all eight bits being
    turned on. Adding to this, the subnet mask can also be represented in binary format.
    Using the Class A address, the subnet mask could be written as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，255的值来源于所有八位都被打开的总和。除此之外，子网掩码也可以用二进制格式表示。使用A类地址，子网掩码可以写成如下形式：
- en: '**Class A subnet mask in decimal**: `255.0.0.0`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十进制格式的A类子网掩码**：`255.0.0.0`'
- en: '**Class A subnet mask in binary**: `11111111.00000000.00000000.00000000`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制格式的A类子网掩码**：`11111111.00000000.00000000.00000000`'
- en: 'Awesome! Now, we can see that a subnet mask can be represented in either decimal
    format using values between 0-255 or in binary format using values of either 0
    or 1\. Furthermore, it is possible to represent a subnet mask in CIDR notation.
    We would represent a Class A address in CIDR format using the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们可以看到子网掩码可以用0-255之间的值以十进制格式表示，也可以用0或1的值以二进制格式表示。此外，还可以用CIDR表示子网掩码。我们可以用以下格式表示CIDR格式的A类地址：
- en: '**Class A subnet mask in decimal**: `255.0.0.0`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十进制格式的A类子网掩码**：`255.0.0.0`'
- en: '**Class A subnet mask in binary**: `11111111.00000000.00000000.00000000`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制格式的A类子网掩码**：`11111111.00000000.00000000.00000000`'
- en: '**Class A subnet mask in CIDR**: `/8`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CIDR格式的A类子网掩码**：`/8`'
- en: Based on this, the `/8` means that eight bits are turned on for the network
    portion of an address.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，`/8`表示地址的网络部分有八位被打开。
- en: 'Using a Class B address, we would represent a Class B address in the following
    format using the dotted decimal format:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用B类地址，我们可以用点分十进制格式表示B类地址如下：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Based on this, the value `255.255.0.0` means that all of the bits in the first
    and second octets are turned on; they are set to 1\. We can present this using
    the table that we created earlier:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，值`255.255.0.0`表示前两个八位组中的所有位都被打开；它们被设置为1。我们可以用之前创建的表来表示这一点：
- en: 'First octet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个八位组：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ bit position |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ 位位置 |'
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = bits turned on |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 打开的位数 |'
- en: 128+64+32+16+8+4+2+1 = 255 bits
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 128+64+32+16+8+4+2+1 = 255位
- en: 'Second octet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个八位组：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ bit position |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ 位位置 |'
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = bits turned on |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 打开的位数 |'
- en: 128+64+32+16+8+4+2+1 = 255 bits
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 128+64+32+16+8+4+2+1 = 255位
- en: 'Based on this, the value of `255.255.0.0` is derived from the sum of all 16
    bits being turned on. Adding to this, the subnet mask can also be represented
    in binary format. Using the Class B address, the subnet mask could be written
    as the follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，值`255.255.0.0`来源于所有16位都被打开的总和。除此之外，子网掩码也可以用二进制格式表示。使用B类地址，子网掩码可以写成如下形式：
- en: '**Class B subnet mask in decimal**: `255.255.0.0`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十进制格式的B类子网掩码**：`255.255.0.0`'
- en: '**Class B subnet mask in binary**: `11111111.11111111.00000000.00000000`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制格式的B类子网掩码**：`11111111.11111111.00000000.00000000`'
- en: 'Awesome! Now, we can see that a subnet mask can be represented in either decimal
    format using values between 0-255 or in binary format using values of either 0
    or 1\. Furthermore, it is possible to represent a subnet mask in CIDR notation.
    We would represent a Class B address in CIDR format using the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们可以看到子网掩码可以用0-255之间的值以十进制格式表示，也可以用0或1的值以二进制格式表示。此外，还可以用CIDR表示子网掩码。我们可以用以下格式表示CIDR格式的B类地址：
- en: '**Class B subnet mask in decimal**: `255.255.0.0`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十进制格式的B类子网掩码**：`255.255.0.0`'
- en: '**Class B subnet mask in binary**: `11111111.11111111.00000000.00000000`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制格式的B类子网掩码**：`11111111.11111111.00000000.00000000`'
- en: '** Class B subnet mask in CIDR**: `/16`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CIDR格式的B类子网掩码**：`/16`'
- en: Based on this, the `/16` means that 16 bits are turned on for the network portion
    of an address.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，`/16`表示地址的网络部分有十六位被打开。
- en: 'Using a Class C address, we would represent a Class C address in the following
    format using the dotted decimal format:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用C类地址，我们可以用点分十进制格式表示C类地址如下：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Based on this, the value `255.255.255.0` means that all of the bits in the
    first and second octets are turned on; they are set to 1\. We can present this
    using the table that we created earlier:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，值`255.255.255.0`表示前两个八位组中的所有位都被打开；它们被设置为1。我们可以用之前创建的表来表示这一点：
- en: 'First octet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个八位组：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ 位位置 |'
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  =bits turned on |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 打开的位数 |'
- en: 128+64+32+16+8+4+2+1 = 255 bits
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 128+64+32+16+8+4+2+1 = 255位
- en: 'Second octet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个八位组：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ 位位置 |'
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  =bits turned on |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 打开的位数 |'
- en: 128+64+32+16+8+4+2+1 = 255 bits
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 128+64+32+16+8+4+2+1 = 255位
- en: 'Third octet:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个八位组：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ 位位置 |'
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  =bits turned on |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 打开的位数 |'
- en: 128+64+32+16+8+4+2+1 = 255 bits
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 128+64+32+16+8+4+2+1 = 255位
- en: 'Based on this, the value of `255.255.255.0` is derived from the sum of all
    24 bits being turned on. Adding to this, the subnet mask can also be represented
    in binary format. Using the Class C address, the subnet mask could be written
    as the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，`255.255.255.0`的值是由所有24位打开的总和得出的。此外，子网掩码也可以用二进制格式表示。使用C类地址，子网掩码可以写成以下形式：
- en: '**Class C subnet mask in decimal**: `255.255.255.0`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十进制中的C类子网掩码**：`255.255.255.0`'
- en: '**Class C subnet mask in binary**: `11111111.11111111.11111111.00000000`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制中的C类子网掩码**：`11111111.11111111.11111111.00000000`'
- en: 'Awesome! Now, we can see that a subnet mask can be represented in either decimal
    format using values between 0-255 or in binary format using values of either 0
    or 1\. Furthermore, it is possible to represent a subnet mask in CIDR notation.
    We would represent a Class C address in CIDR format using the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在，我们可以看到子网掩码可以用0-255之间的值以十进制格式表示，也可以用0或1的值以二进制格式表示。此外，可以用CIDR表示子网掩码。我们可以用以下方式用CIDR格式表示C类地址：
- en: '**Class C subnet mask in decimal**: `255.255.255.0`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十进制中的C类子网掩码**：`255.255.255.0`'
- en: '**Class C subnet mask in binary**: `11111111.11111111.11111111.00000000`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制中的C类子网掩码**：`11111111.11111111.11111111.00000000`'
- en: '** Class C subnet mask in CIDR**: `/24`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CIDR中的C类子网掩码**：`/24`'
- en: Based on this, the `/24` means that 24 bits are turned on for the network portion
    of an address.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一点，`/24`表示地址的网络部分有24位打开。
- en: Subnetting
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子网划分
- en: 'As we''ve just seen with the Classes A, B, and C, their subnet masks are `/8`,
    `16`, and `24`, respectively, using CIDR notation. In most environments today,
    these default subnet masks are known as classful, meaning if we use these subnet
    masks as they are, we would not be able to perform any sort of traffic engineering.
    This becomes an issue when we want to control the broadcast domain. We should
    try to minimize the broadcast to a given room, office, or department. This ensures
    that in the event of any type of network broadcast, the entire network does not
    start to experience latency. We can leverage subnetting in order to overcome the
    limitation of classful networks. For instance, let''s pick a Class C IP address:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚看到的A、B和C类，它们的子网掩码分别使用CIDR表示为`/8`、`16`和`24`。在今天的大多数环境中，这些默认子网掩码被称为类别，这意味着如果我们使用这些子网掩码，我们将无法执行任何形式的流量工程。当我们想要控制广播域时，这就成了一个问题。我们应该尽量减少广播到特定的房间、办公室或部门。这确保在任何类型的网络广播事件发生时，整个网络不会开始出现延迟。我们可以利用子网划分来克服类别网络的限制。例如，让我们选择一个C类IP地址：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Based on this, we can have up to 254 hosts per network address. We might be
    in a situation where we only have eight systems that require IP connectivity.
    This would mean that we are losing those remaining IP addresses because we''ve
    used a default Class C subnet. The requirement in this scenario is to have eight
    IP addresses and not to waste the remaining IPs. We can achieve this requirement
    by subnetting. Subnetting is made possible by borrowing bits from the host portion.
    Let''s write out the subnet mask for the given IP address:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，每个网络地址最多可以有254个主机。我们可能会遇到这样的情况，我们只有八个系统需要IP连接。这意味着我们正在失去那些剩余的IP地址，因为我们使用了默认的C类子网。在这种情况下的要求是有八个IP地址，而不是浪费剩下的IP地址。我们可以通过子网划分来实现这个要求。子网划分是通过从主机部分借用位来实现的。让我们写出给定IP地址的子网掩码：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Subnet mask in decimal**: `255.255.255.0 `'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十进制中的子网掩码**：`255.255.255.0 `'
- en: '**Subnet mask in binary**: `11111111.11111111.11111111.00000000 `'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制中的子网掩码**：`11111111.11111111.11111111.00000000 `'
- en: 'Based on this, the first 24 bits are turned on. We can subnet this address
    in order to gain more control over our IP address space. We want eight IPs. The
    way we borrow bits is by taking bits from the host bits. We can use our table
    for assistance:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，前24位被打开。我们可以对这个地址进行子网划分，以便更好地控制我们的IP地址空间。我们想要八个IP地址。我们借用位的方式是从主机位中取位。我们可以使用我们的表格来帮助：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ 位位置 |'
- en: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  =4 bits borrowed |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  =借用了4位  |'
- en: 2^4bits = 16 network networks can be created
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2^4位 = 可以创建16个网络
- en: 2^4 -2 =14 hosts per network
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2^4 -2 =每个网络14个主机
- en: 'Based on this, we''ve borrowed four bits from the host portion of the network;
    this enables us to create four smaller subnets/networks. Each network created
    would then have 14 hosts per network. This allows us to save on the amount of
    IPs being lost as opposed to using a standard Class C `/24` network. So, we''ve
    borrowed four bits for the network portion. How would we represent this in decimal
    and CIDR notation? Well, the way we represent the newly created subnet is by a
    process of adding the network bits. This can by illustrated in the following table:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '基于此，我们从网络的主机部分借用了四位；这使我们能够创建四个更小的子网/网络。然后，每个创建的网络将有14个主机。这使我们能够节省IP地址的数量，而不是使用标准的C类`/24`网络。因此，我们从网络部分借用了四位。我们如何用十进制和CIDR表示这一点呢？嗯，我们表示新创建的子网的方式是通过添加网络位。这可以在以下表格中说明： '
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ 位位置 |'
- en: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  =4 bits  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  =4位  |'
- en: 128+64+32+16 = 240
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 128+64+32+16 = 240
- en: Old subnet in decimal = `255.255.255.0`
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧的十进制子网 = `255.255.255.0`
- en: Old subnet in CIDR = `/24`
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 老子网在CIDR = `/24`
- en: New subnet in decimal = `255.255.255.240`
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的十进制子网 = `255.255.255.240`
- en: New subnet in CIDR = `/28`
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的CIDR子网 = `/28`
- en: Network address = `192.168.0.0/28`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络地址 = `192.168.0.0/28`
- en: 'Based on this, we can see the new subnet mask in both decimal and CIDR notation.
    The next step would be to identify the usable subnets/networks using this new
    subnet mask. We can calculate the usable subnets by using the following table:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们可以看到新的子网掩码的十进制和CIDR表示。下一步是使用这个新的子网掩码来识别可用的子网/网络。我们可以使用以下表格来计算可用的子网：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^位位置 |'
- en: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  =4 bits |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 |  = 4位 |'
- en: 'The networks are incremented by the bit position''s base 2 value:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 网络按位位置的2进制值递增：
- en: '**First network**: `192.168.0.0/28`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个网络**：`192.168.0.0/28`'
- en: '**Second network**: `192.168.0.16/28`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二个网络**：`192.168.0.16/28`'
- en: '**Third network**: `192.168.0.32/28`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三个网络**：`192.168.0.32/28`'
- en: '**Fourth network**: `192.168.0.48/28`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第四个网络**：`192.168.0.48/28`'
- en: '**Till s****ixteen network**: `192.168.0.240/28`'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直到第十六个网络**：`192.168.0.240/28`'
- en: 'Based on this, we can see that the fourth octet is where the increments are
    taking place. In particular, for a `/28`, the subnets are increments by 16; this
    is due to the fact that the fourth bit position is `16` when the calculated 2^4
    bit position = 16\. The last step would be to identify the usable IPs that can
    be assigned to hosts within the network. We will use the following as a breakdown:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一点，我们可以看到第四个八位组是增量发生的地方。特别是对于`/28`，子网增量为16；这是因为计算得到的2^4位位置=16。最后一步是确定可以分配给网络内主机的可用IP。我们将使用以下作为分解：
- en: '**First subnet/network**: `192.168.0.0/28`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个子网/网络**：`192.168.0.0/28`'
- en: '**First usable IP address**: `192.168.0.1/28`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个可用IP地址**：`192.168.0.1/28`'
- en: '**Last usable IP address**: `192.168.0.14/28`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最后一个可用IP地址**：`192.168.0.14/28`'
- en: '**Broadcast IP addres**s: `192.168.0.15/28`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广播IP地址**：`192.168.0.15/28`'
- en: '**Second subnet/network**: `192.168.0.16/28`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二个子网/网络**：`192.168.0.16/28`'
- en: 'Based on this, we see that two IPs are not usable. They are what we''ve been
    taking into consideration when we were calculating the hosts IPs. Similarly, we
    can get the usable IPs for the second subnet `192.168.0.16/28`, by using the following
    breakdown:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一点，我们可以看到有两个IP是不可用的。这些是我们在计算主机IP时考虑的因素。同样，我们可以通过以下分解来获得第二个子网`192.168.0.16/28`的可用IP：
- en: '**Second subnet/network**: `192.168.0.16/28`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二个子网/网络**：`192.168.0.16/28`'
- en: '**First usable IP address**: `192.168.0.17/28`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个可用IP地址**：`192.168.0.17/28`'
- en: '**Last usable IP address**: `192.168.0.30/28`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最后一个可用IP地址**：`192.168.0.30/28`'
- en: '**Broadcast IP address**: `192.168.0.31/28`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广播IP地址**：`192.168.0.31/28`'
- en: '**Third subnet/network**: `192.168.0.32/28`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三个子网/网络**：`192.168.0.32/28`'
- en: 'Awesome! Based on this, we can see a pattern; we always end up with 14 usable
    IP addresses. Also, we can subnet a Class B address and make use of host bits
    to better manage our network. Let''s use the following Class B address:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！基于这一点，我们可以看到一个模式；我们总是最终得到14个可用的IP地址。此外，我们可以对B类地址进行子网划分，并利用主机位来更好地管理我们的网络。让我们使用以下B类地址：
- en: '[PRE6]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Based on this, we have over 65,000 host IPs per network; this is not ideal
    in most environments. For instance, we want to subnet this IP in order to have
    500 host IPs. This can be achieved by borrowing some host bits from the hosts
    portion of the address. We can use the following breakdown to assist us:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一点，每个网络有超过65,000个主机IP；这在大多数环境中都不理想。例如，我们想要对这个IP进行子网划分，以获得500个主机IP。这可以通过从地址的主机部分借用一些主机位来实现。我们可以使用以下分解来帮助我们：
- en: '[PRE7]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The way we calculate the host is by moving from right to left.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算主机的方法是从右到左移动。
- en: 'Fourth octet:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个八位组：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ bit position |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^位位置 |'
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 8 bits total 255 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |  = 8位总共255 |'
- en: 2^8 = 255-2 = 254 hosts per network.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 2^8 = 255-2 = 每个网络254个主机。
- en: 'Third octet:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个八位组：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^ bit position |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^位位置 |'
- en: '| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |  = 9 bit turned on |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |  = 9位打开 |'
- en: 2^9 = 512 -2 = 510 hosts per network.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 2^9 = 512 -2 = 每个网络510个主机。
- en: 'Awesome! Based on this, it will take nine bits in order to achieve the requirements.
    This then would mean that we will have to borrow eight bits from the third octets
    to meet the requirements. We can break this down by using the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！基于这一点，为了满足要求，需要九位。这意味着我们将不得不从第三个八位组借用八位来满足要求。我们可以通过以下方式进行分解：
- en: '[PRE8]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = 位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  = 2^位位置 |'
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 |  =7 bit turned on |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 |  = 7位打开 |'
- en: '[PRE9]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Based on these calculations, the new network would be written as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些计算，新网络将被写成如下：
- en: '[PRE10]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Based on this, we have the total subnet and hosts per subnets. Now, we need
    to calculate the usable IP addresses per subnet. This can be done using the following
    breakdown:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一点，我们有每个子网的总子网和主机。现在，我们需要计算每个子网的可用IP地址。这可以通过以下分解来完成：
- en: '**First subnet/network**: `172.16.0.0/23`'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个子网/网络**：`172.16.0.0/23`'
- en: '**First usable IP**: `172.16.0.1/23`'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一个可用IP**：`172.16.0.1/23`'
- en: '**Last usable IP**: `172.16.2.254/23`'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最后一个可用IP**：`172.16.2.254/23`'
- en: '**Broadcast IP**: `172.16.2.255`'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**广播IP**：`172.16.2.255`'
- en: '**Second subnet/network**: `172.16.2.0/23`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二个子网/网络**：`172.16.2.0/23`'
- en: Based on this, we can see the usable IP addresses; `172.16.2.255` is a valid
    IP using a `/23` subnet. Also, `172.16.1.0/23` is also a valid IP address. In
    some operating systems, such as Windows, if you try to assign either of these
    two IPs, you may encounter an error. However, in Linux, everything is fair game.
    We increment the subnets by 2 because that is where the last network bit position
    ends.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一点，我们可以看到可用的IP地址；`172.16.2.255`是使用`/23`子网的有效IP。同样，`172.16.1.0/23`也是有效的IP地址。在一些操作系统中，比如Windows，如果你尝试分配这两个IP中的任何一个，可能会遇到错误。然而，在Linux中，一切都是公平的。我们通过增量子网2来增量，因为这是最后一个网络位的位置。
- en: 'We can even subnet a Class A address. For instance, let''s say we want to create
    100 subnets out of a single class A address. We will use the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以对A类地址进行子网划分。例如，假设我们想要从单个A类地址创建100个子网。我们将使用以下：
- en: '[PRE11]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can do this using the table we created earlier.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用之前创建的表来做到这一点。
- en: 'Second octet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个八位组：
- en: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |  = bit position |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | = 位位置 |'
- en: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 |  =2^ bit position |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | = 2^位位置 |'
- en: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 |  =7 bit turned on |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 0 | = 7位打开 |'
- en: 'Awesome! Based on this, we can quickly derive that we would need to borrow
    seven bits from the second octet in order to create 100 subnets. In fact, we will
    have 128 subnets. This is because we''re calculating 2^7 bits in the second octet.
    We can then write out our subnets in the following format:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！基于此，我们可以快速推导出我们需要从第二个八位组借用七位来创建100个子网。实际上，我们将有128个子网。这是因为我们正在计算第二个八位组中的2^7位。然后我们可以按以下格式写出我们的子网：
- en: '[PRE12]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Excellent! It''s that easy to subnet a Class A. Now we need to calculate the
    total hosts per subnet. We can use the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这么容易就对A类进行子网划分。现在我们需要计算每个子网的主机总数。我们可以使用以下方法：
- en: '[PRE13]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Based on this, we can see that we garner quite a number of hosts per subnet
    using a `/15`. We can use the following in order to derive the usable IPs per
    subnet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们可以看到使用`/15`每个子网获得了相当多的主机。我们可以使用以下方法来推导每个子网的可用IP：
- en: '**First subnet/network**: `10.0.0.0/15`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个子网/网络：`10.0.0.0/15`
- en: '**First usable IP**: `10.0.0.1/15`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个可用IP：`10.0.0.1/15`
- en: '**Last usable IP**: `10.2.255.254/15`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个可用IP：`10.2.255.254/15`
- en: '**Broadcast IP**: `10.2.255.255`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广播IP：`10.2.255.255`
- en: '**Second subnet/network**: `10.2.0.0/15`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个子网/网络：`10.2.0.0/15`
- en: Excellent! The easiest way to calculate either of the subnets is to always multiple
    the network bits by 2\. For calculating the total hosts, always multiply the hosts
    bits by 2 and then minus 2 for the network and broadcast address.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！计算任何一个子网的最简单方法是始终将网络位乘以2。要计算总主机数，始终将主机位乘以2，然后减去2得到网络和广播地址。
- en: IPv6 addressing
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6寻址
- en: '**Internet Protocol version 6** (**IPv6**), was developed by the **Internet
    Engineering Task Force** (**IETF**). The IPv6 address was meant to address the
    shortage of IPv4 addresses. IPv4 has been completely exhausted, and companies
    are now willing to trade their IPv4 block of addresses for huge sums of mony.
    An IPv6 address is 128 bits or 16 bytes in length. This gives us 2^128 of IPv6
    addresses. An IPv6 address is represented in hexadecimal format. There are three
    types of IPv6 address.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网协议第6版（IPv6），由互联网工程任务组（IETF）开发。IPv6地址旨在解决IPv4地址短缺问题。IPv4已经完全耗尽，公司现在愿意以巨额资金交换他们的IPv4地址块。IPv6地址长度为128位或16字节。这给了我们2^128个IPv6地址。IPv6地址以十六进制格式表示。有三种类型的IPv6地址。
- en: Unicast
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单播
- en: A unicast address specifies an identifier for a single interface on a device
    similar to an IPv4 address. Using IPv6, it's likely that all IPv6 traffic will
    be mostly unicast based.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 单播地址指定设备上单个接口的标识符，类似于IPv4地址。使用IPv6，很可能所有IPv6流量大多是基于单播的。
- en: Multicast
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多播
- en: The concept of an IPv6 multicast address is similar to that of an IPv4 address.
    Packets are sent to an IPv6 multicast address and receivers that are part of a
    multicast group would receive the multicast packet.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6多播地址的概念类似于IPv4地址。数据包被发送到IPv6多播地址，属于多播组的接收者将接收多播数据包。
- en: Anycast
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单播
- en: This address type was introduced in IPv6\. The concept of anycast works by multiple
    devices being assigned the same anycast IPv6 address. When a sender sends a packet
    to an anycast IPv6 address, the anycast packet is routed via a routing protocol
    to the nearest host from the sender.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这种地址类型是在IPv6中引入的。任播的概念是通过将多个设备分配相同的任播IPv6地址来工作。当发送者向任播IPv6地址发送数据包时，任播数据包通过路由协议路由到距离发送者最近的主机。
- en: 'Here is an example of an IPv6 address:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是IPv6地址的示例：
- en: '[PRE14]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Based on this, we can see that an IPv6 address is made up of eight sets of 16-bit
    or 2-byte values separated by colons. This is how we derive 128 bits or 16 bytes
    in length. It may seem lengthy to write an IPv6 address, but we can use a few
    methods to make an IPv6 address a bit smaller.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们可以看到IPv6地址由八组16位或2字节值组成，用冒号分隔。这就是我们得到128位或16字节长度的方法。写IPv6地址可能看起来很长，但我们可以使用一些方法使IPv6地址变得更小。
- en: Removing leading zeros
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除前导零
- en: 'We can remove the leading zeros from an IPv6 address, thus making it more readable:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以删除IPv6地址中的前导零，从而使其更易读：
- en: '[PRE15]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Awesome! Based on this, we made the IPv6 address much more presentable. But
    wait, we can also make it even smaller by using the technique described next.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！基于此，我们使IPv6地址更加易于呈现。但是，请等一下，我们还可以通过使用下面描述的技术使其更小。
- en: Removing consecutive zeros
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除连续的零
- en: 'We can remove zeros that are contiguous in an IPv6 address and replace the
    zeros with a double colon. This can only be done once:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以删除IPv6地址中连续的零，并用双冒号替换这些零。这只能做一次：
- en: '[PRE16]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Great! As we can see, the IPv6 address is now much more readable. Also, when
    entering an IPv6 address in a browser, we would do the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！正如我们所看到的，IPv6地址现在更易读。此外，在浏览器中输入IPv6地址时，我们会执行以下操作：
- en: '[PRE17]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Based on this, we would enclose an IPv6 address in square brackets. There are
    some special type of unicast IPv6 addresses that are worth mentioning:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，我们会用方括号括起IPv6地址。有一些特殊类型的单播IPv6地址值得一提：
- en: '**Global unicast addresses**: These addresses begin with `2000::/3`, as specified
    in RFC 4291\. They are publicly routable addresses that are similar to public
    IPv4 addresses.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局单播地址：这些地址以`2000::/3`开头，如RFC 4291中所述。它们是类似于公共IPv4地址的可公开路由地址。
- en: '**Link-local addresses**: These addresses begin with `fe80::/10`; they are
    only valid on the local physical link.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链路本地地址：这些地址以`fe80::/10`开头；它们仅在本地物理链路上有效。
- en: '**Site-local addresses**: These addresses begin with `fec::/10`; they are valid
    only within a single site. They have been discouraged by the RFC body.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 站点本地地址：这些地址以`fec::/10`开头；它们仅在单个站点内有效。它们已被RFC机构弃用。
- en: '**Unique-local addresses**: These addresses begin with `fc00::/7`; they are
    meant to be routed within a set of cooperating sites. There were meant to replace
    the site-local addresses. An interesting feature of the unique-local addresses
    is that the fact that they reduce the risk of address conflict.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**唯一本地地址**：这些地址以`fc00::/7`开头；它们旨在在一组合作站点内进行路由。它们旨在取代站点本地地址。唯一本地地址的一个有趣特点是它们减少了地址冲突的风险。'
- en: 'There are some special IPv6 addresses similar to IPv4\. Here are some reserved
    IPv6 addresses:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些类似于IPv4的特殊IPv6地址。以下是一些保留的IPv6地址：
- en: '| `2000::/3    ` |  Global Unicast |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `2000::/3` | 全局单播 |'
- en: '| `::/128      ` |  Unspecified address |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `::/128` | 未指定地址 |'
- en: '| `::/0        ` |  Default route |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `::/0` | 默认路由 |'
- en: '| `::1/128     ` | Loopback address |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `::1/128` | 回环地址 |'
- en: '| `FF00::/8     ` |  Multicast addresses |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `FF00::/8` | 多播地址 |'
- en: 'Awesome! In terms of identifying the subnet, we would have to dissect an IPv6
    address. We can break it down using the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！在识别子网方面，我们需要解析IPv6地址。我们可以使用以下方法进行分解：
- en: '[PRE18]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| Global routing prefix   |          Subnet       |     Host ID |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 全局路由前缀 | 子网 | 主机ID |'
- en: '|  `2001:db8:0000: `              |        ` 0000:`            |       `0000:ff0:42:8329`
    |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `2001:db8:0000:` | `0000:` | `0000:ff0:42:8329` |'
- en: '| 48 bits or 3bytes           |          16 bits or 2bytes      |        64
    bits   or 8 bytes |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 48位或3字节 | 16位或2字节 | 64位或8字节 |'
- en: Based on this, the global routing prefix consists of 48 bits. The subnet is
    made of the next 16 bits. The host identifier is made up of the last 64 bits.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，全局路由前缀由48位组成。子网由接下来的16位组成。主机标识符由最后的64位组成。
- en: Well-known protocols
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 知名协议
- en: There are a number of well-known protocols that we use in our environment that
    we need to be aware of. For starters, when we browse the internet, we are in fact
    use the HTTP protocol in order to view a web page. Additionally, when we are copying
    a file from a server and providing authentication; in the backend, we are using
    some type of FTP protocol. Likewise, when we type out a URL, we are in fact using
    DNS for name resolution. As we can see, we are using a number of protocols in
    our environments. Some well-known protocols and their respective port numbers
    are described next.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在环境中使用许多我们需要了解的知名协议。首先，当我们浏览互联网时，实际上是使用HTTP协议来查看网页。此外，当我们从服务器复制文件并提供身份验证时；在后台，我们使用某种FTP协议。同样，当我们输入URL时，实际上是使用DNS进行名称解析。正如我们所看到的，我们在我们的环境中使用了许多协议。接下来描述了一些知名协议及其相应的端口号。
- en: TCP
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP
- en: '**Transmission Control Protocol** (**TCP**) is a connection-oriented protocol
    that offers a number of services, including error checking and sequencing, to
    name a few. It operates at layer 4 of the OSI model, the transport layer.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输控制协议**（**TCP**）是一种面向连接的协议，提供了许多服务，包括错误检查和排序等。它在OSI模型的第4层，即传输层上运行。'
- en: HTTP
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP
- en: The **Hyper Text Transfer Protocol** (**HTTP**) serves up web pages on demand;
    it's the protocol for data communication via URLs on the internet. It uses port
    `80` for communication. Moreover, it rides on top of TCP.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本传输协议**（**HTTP**）按需提供网页；这是互联网上通过URL进行数据通信的协议。它使用端口`80`进行通信。此外，它建立在TCP之上。'
- en: HTTPS
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS
- en: The **Hyper Text Transfer Protocol Secure** (**HTTPS**) offers secure communications
    for URLs on the internet. It uses port `443` for communication. Moreover, its
    communication uses **Transport Layer Security** (**TLS**). It rides on top of
    TCP.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**超文本传输安全协议**（**HTTPS**）为互联网上的URL提供安全通信。它使用端口`443`进行通信。此外，它的通信使用**传输层安全**（**TLS**）。它建立在TCP之上。'
- en: FTP
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP
- en: The **File Transfer Protocol** (**FTP**), is used for transferring files between
    a client and a server. This could be locally within a LAN or via the internet.
    With FTP support authentication, however, all transmissions are sent in clear
    text; there is no security built in. FTP uses TCP port `20` for data traffic and
    port `21` for command traffic.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件传输协议**（**FTP**）用于在客户端和服务器之间传输文件。这可以在局域网内或通过互联网进行。FTP支持身份验证，但所有传输都是明文发送的；没有内置安全性。FTP使用TCP端口`20`进行数据传输和端口`21`进行命令传输。'
- en: UDP
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP
- en: The **User Datagram Protocol** (**UDP**) is a connectionless protocol that offers
    speed but does not do any sort of error checking. It operates at layer 4 of the
    OSI model, the transport layer.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户数据报协议**（**UDP**）是一种无连接协议，提供速度但不进行任何错误检查。它在OSI模型的第4层，即传输层上运行。'
- en: DNS
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DNS
- en: The **Domain Name System** (**DNS**) provides the means for translating IP addresses
    into user-friendly names that users can relate to. It usually uses UDP port `53`
    but also uses TCP port `53` whenever a request or response is larger than a single
    packet.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**域名系统**（**DNS**）提供了将IP地址转换为用户友好的名称的手段，用户可以与之相关联。它通常使用UDP端口`53`，但每当请求或响应大于一个数据包时，也使用TCP端口`53`。'
- en: TFTP
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TFTP
- en: '**Trvial File Transfer Protocol** (**TFTP**) is used for transferring date
    at a fast rate. No authentication methods are supported; also, there is no error
    checking. TFTP uses UDP port `69`.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单文件传输协议**（**TFTP**）用于以快速速率传输数据。不支持任何身份验证方法；也没有错误检查。TFTP使用UDP端口`69`。'
- en: ICMP
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ICMP
- en: The **Internet Control Message Protocol** (**ICMP**) is another protocol used
    in the networking environment. It is usually used for troubleshooting by sending
    messages between various networking devices on a LAN or via the internet. There
    is also ICMPv6, which is used for IPv6\. ICMP uses IP protocol `1`, whereas ICMPv6
    uses IP protocol `58`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**互联网控制消息协议**（**ICMP**）是网络环境中使用的另一种协议。通常用于通过局域网或互联网在各种网络设备之间发送消息进行故障排除。还有ICMPv6，用于IPv6。ICMP使用IP协议`1`，而ICMPv6使用IP协议`58`。'
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took took quite an in-depth look into the world of IPv4,
    and IPv6\. In addition to this, we covered subnet masks and ways to identify a
    subnet mask. Next, we covered subnetting. We worked through a few examples and
    illustrated the techniques to derive the required number of hosts and also the
    required number of subnets. Finally, we worked with well-known protocols. We covered
    some of the most widely-used protocols and their port numbers.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入研究了IPv4和IPv6的世界。除此之外，我们还涵盖了子网掩码和识别子网掩码的方法。接下来，我们介绍了子网划分。我们通过了一些示例，并说明了推导所需主机数量和所需子网数量的技术。最后，我们使用了一些知名的协议。我们涵盖了一些最广泛使用的协议及其端口号。
- en: In the next chapter, we will move on to network configuration and troubleshooting.
    We will work on the Linux boxes, assigning IPv4 addresses and also IPv6 addresses,
    looking at various ways of troubleshooting network connectivity.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续进行网络配置和故障排除。我们将在Linux系统上工作，分配IPv4地址和IPv6地址，并查看各种网络连接故障排除的方法。
- en: Questions
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which address is a Class A address?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个地址是A类地址？
- en: A. `192.0.0.1`
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: A. `192.0.0.1`
- en: B. `172.0.0.1`
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: B. `172.0.0.1`
- en: C. `10.0.0.1`
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: C. `10.0.0.1`
- en: D.None of the above
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: D. 以上都不是
- en: Which address is a Class C address?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个地址是C类地址？
- en: A. `128.0.0.1`
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: A. `128.0.0.1`
- en: B. `100.0.0.2`
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: B. `100.0.0.2`
- en: C. `192.168.0.1`
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: C. `192.168.0.1`
- en: D. None of the above
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: D. 以上都不是
- en: Which address is known as an IPv4 loopback address?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个地址被称为IPv4环回地址？
- en: A. `127.0.0.1`
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: A. `127.0.0.1`
- en: B. `169.0.0.1`
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: B. `169.0.0.1`
- en: C. `172.16.0.1`
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: C. `172.16.0.1`
- en: D. `192.1.1.1`
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: D. `192.1.1.1`
- en: Which address is an APIPA address?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个地址是APIPA地址？
- en: A. `169.0.0.1`
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: A. `169.0.0.1`
- en: B. `172.16.0.1`
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: B. `172.16.0.1`
- en: C. `10.1.1.1`
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: C. `10.1.1.1`
- en: D. `192.168.1.1`
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: D. `192.168.1.1`
- en: Which address is a class B address?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个地址是B类地址？
- en: A. `128.0.0.1`
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: A. `128.0.0.1`
- en: B. `10.11.1.1`
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: B. `10.11.1.1`
- en: C. `127.0.0.1`
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: C. `127.0.0.1`
- en: D. 223.0.0.1
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: D. 223.0.0.1
- en: What does a IPv6 multicast address start with?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IPv6组播地址以什么开头？
- en: A. `fc0e::/8`
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: A. `fc0e::/8`
- en: B. `fce::/7`
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: B. `fce::/7`
- en: C. `ff00::/8`
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: C. `ff00::/8`
- en: D. `fd0:/9`
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: D. `fd0:/9`
- en: Which address is an IPv6 default route?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个地址是IPv6默认路由？
- en: A. `::1/0`
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: A. `::1/0`
- en: B. `::/0`
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: B. `::/0`
- en: C. `01A:00000000:00000000:00000000:00000000::9`
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: C. `01A:00000000:00000000:00000000:00000000::9`
- en: D. ::1/128
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: D. ::1/128
- en: Which address is an IPv6 loopback address?
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个地址是IPv6环回地址？
- en: A. `::0/1`
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: A. `::0/1`
- en: B. `::0/0`
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: B. `::0/0`
- en: C. `::1/128`
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: C. `::1/128`
- en: D. `::128/128`
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: D. `::128/128`
- en: What does a link-local address starts with?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 链路本地地址以什么开头？
- en: A.`ff00::/8` B.`fc00::/10` C.`fcd00::128` D.`fe80::/10`
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: A.`ff00::/8` B.`fc00::/10` C.`fcd00::128` D.`fe80::/10`
- en: Which port does HTTP uses?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP使用哪个端口？
- en: A.TCP `10` B.UDP `80` C.TCP `80` D.UDP `69`
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: A.TCP `10` B.UDP `80` C.TCP `80` D.UDP `69`
- en: Further reading
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: This site gives useful information about the IP: [https://tools.ietf.org](https://tools.ietf.org)
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个网站提供了有关IP的有用信息：[https://tools.ietf.org](https://tools.ietf.org)
- en: This site gives useful information about subnetting: [https://www.quora.com](https://www.quora.com)
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个网站提供了有关子网划分的有用信息：[https://www.quora.com](https://www.quora.com)
- en: This site gives useful information about IPv6: [https://www.ipv6.com](https://www.ipv6.com)
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个网站提供了有关IPv6的有用信息：[https://www.ipv6.com](https://www.ipv6.com)
