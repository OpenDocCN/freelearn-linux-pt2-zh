- en: Chapter 2. Getting Hands-on with I/O, Redirection Pipes, and Filters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。开始使用I/O、重定向管道和过滤器
- en: In day-to-day work, we come across different kinds of files such as text files,
    source code files from different programming languages (for example, `file.sh`,
    `file.c`, and `file.cpp`), and so on. While working, we often perform various
    operations on files or directories such as searching for a given string or pattern,
    replacing strings, printing few lines of a file, and so on. Performing these operations
    is not easy if we have to do it manually. Manual searching for a string or pattern
    in a directory having thousands of files can take months, and has high chances
    of making errors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常工作中，我们会遇到不同类型的文件，比如文本文件、来自不同编程语言的源代码文件（例如`file.sh`、`file.c`和`file.cpp`）等。在工作时，我们经常对文件或目录执行各种操作，比如搜索给定的字符串或模式、替换字符串、打印文件的几行等。如果我们必须手动执行这些操作，那是很困难的。在一个包含成千上万个文件的目录中手动搜索字符串或模式可能需要几个月的时间，并且很容易出错。
- en: Shell provides many powerful commands to make our work easier, faster, and error-free.
    Shell commands have the ability to manipulate and filter text from different streams
    such as standard input, file, and so on. Some of these commands are `grep`, `sed`,
    `head`, `tr`, `sort`, and so on. Shell also comes with a feature of redirecting
    output from one command to another with the pipe ('`|`'). Using pipe helps to
    avoids creation of unnecessary temporary files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Shell提供了许多强大的命令，可以使我们的工作更轻松、更快速、更无误。Shell命令有能力从不同的流（如标准输入、文件等）中操作和过滤文本。其中一些命令是`grep`、`sed`、`head`、`tr`、`sort`等。Shell还具有将一个命令的输出重定向到另一个命令的功能，使用管道（`|`）。使用管道有助于避免创建不必要的临时文件。
- en: One of the best qualities of these commands is that they come along with the
    `man` pages. We can directly go to the `man` page and see what all features they
    provide by running the `man` command. Most of the commands have options such as
    `--help` to find the help usage and `--version` to know the version number of
    the command.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令中最好的一个特点是它们都有`man`页面。我们可以直接转到`man`页面，并通过运行`man`命令查看它们提供的所有功能。大多数命令都有选项，比如`--help`来查找帮助用法，以及`--version`来了解命令的版本号。
- en: 'This chapter will cover the following topics in detail:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细介绍以下主题：
- en: Standard I/O and error streams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准I/O和错误流
- en: Redirecting the standard I/O and error streams
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向标准I/O和错误流
- en: Pipe and pipelines—connecting commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道和管道——连接命令
- en: Regular expressions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Filtering output using `grep`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`grep`过滤输出
- en: Editing output using `sed`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sed`编辑输出
- en: Duplicating a stream using `tee`
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tee`复制流
- en: Sorting and finding unique text
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序和查找唯一文本
- en: Character-based translation using `tr`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tr`进行基于字符的翻译
- en: Filtering based on lines—`head` and `tail`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于行的过滤——`head`和`tail`
- en: Cut-based selection
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于切割的选择
- en: Standard I/O and error streams
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准I/O和错误流
- en: In shell programming, there are different ways to provide an input (for example,
    via a keyboard and terminal) and display an output (for example, terminal and
    file) and error (for example, terminal), if any, during the execution of a command
    or program.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell编程中，有不同的方式来提供输入（例如，通过键盘和终端）和显示输出（例如，终端和文件）以及执行命令或程序时的错误（例如，终端）。
- en: 'The following examples show the input, output, and error while running the
    commands:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了运行命令时的输入、输出和错误：
- en: 'The input from a user by a keyboard and the input obtained by a program via
    a standard input stream, that is terminal, is taken as follows:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过键盘由用户输入和通过标准输入流（即终端）由程序获取的输入如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output printed on the standard output stream, that is terminal, is as follows:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印在标准输出流（即终端）上的输出如下：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The error message printed on the standard error stream, that is terminal, is
    as follows:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印在标准错误流（即终端）上的错误消息如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When a program executes, by default, three files get opened with it which are
    `stdin`, `stdout`, and `stderr`. The following table provides a short description
    of each of these:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行时，默认情况下会打开三个文件，它们是`stdin`、`stdout`和`stderr`。以下表格提供了这三个文件的简要描述：
- en: '| File descriptor number | File name | Description |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 文件描述符编号 | 文件名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `0` | `stdin` | This is standard input being read from the terminal |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `0` | `stdin` | 这是从终端读取的标准输入 |'
- en: '| `1` | `stdout` | This is standard output to the terminal |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `stdout` | 这是标准输出到终端 |'
- en: '| `2` | `stderr` | This is standard error to the terminal |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `2` | `stderr` | 这是标准错误输出到终端 |'
- en: File descriptors
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件描述符
- en: File descriptors are integer numbers representing opened files in an operating
    system. The unique file descriptor numbers are provided to each opened files.
    File descriptors' numbers go up from `0`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符是表示操作系统中打开文件的整数编号。每个打开的文件都有唯一的文件描述符编号。文件描述符的编号从`0`开始递增。
- en: Whenever a new process in Linux is created, then standard input, output, and
    error files are provided to it along with other needed opened files to process.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中创建新进程时，会为其提供标准输入、输出和错误文件，以及其他所需的打开文件。
- en: 'To know what all open file descriptors are associated with a process, we will
    consider the following example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道与进程相关联的所有打开文件描述符，我们将考虑以下示例：
- en: 'Run an application and get its process ID first. Consider running `bash` as
    an example to get PID of bash:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先运行一个应用程序并获取其进程ID。考虑运行`bash`作为一个例子来获取bash的PID：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We see that multiple bash processes are running. Take one of the bash PID example,
    `2508`, and run the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到有多个bash进程正在运行。以bash PID示例`2508`为例，运行以下命令：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We see that 0, 1, and 2 opened file descriptors are associated with process
    bash. Currently, all of them are pointing to `/dev/pts/5`. `pts`, which is pseudo
    terminal slave.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到0、1和2这三个打开的文件描述符与bash进程相关联。目前，它们都指向`/dev/pts/5`。`pts`是伪终端从属。
- en: So, whatever we will do in this bash, input, output, and error related to this
    PID, output will be written to the `/dev/pts/5` file. However, the `pts` files
    are pseudo files and contents are in memory, so you won't see anything when you
    open the file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论我们在这个bash中做什么，与此PID相关的输入、输出和错误都将被写入`/dev/pts/5`文件。但是，`pts`文件是伪文件，内容在内存中，因此当您打开文件时，您看不到任何内容。
- en: Redirecting the standard I/O and error streams
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向标准I/O和错误流
- en: 'We have an option to redirect standard input, output, and errors, for example,
    to a file, another command, intended stream, and so on. Redirection is useful
    in different ways. For example, I have a bash script whose output and errors are
    displayed on a standard output—that is, terminal. We can avoid mixing an error
    and output by redirecting one of them or both to a file. Different operators are
    used for redirection. The following table shows some of operators used for redirection,
    along with its description:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有选项可以重定向标准输入、输出和错误，例如到文件、另一个命令、预期的流等。重定向在不同方面非常有用。例如，我有一个bash脚本，其输出和错误显示在标准输出上，也就是终端上。我们可以通过将其中一个或两者重定向到文件来避免混合错误和输出。用于重定向的不同运算符。以下表格显示了一些用于重定向的运算符及其描述：
- en: '| Operator | Description |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `>` | This redirects a standard output to a file |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `>` | 这将标准输出重定向到文件中 |'
- en: '| `>>` | This appends a standard output to a file |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `>>` | 这将标准输出附加到文件中 |'
- en: '| `<` | This redirects a standard input from a file |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `<` | 这将标准输入从文件中重定向 |'
- en: '| `>&` | This redirects a standard output and error to a file |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `>&` | 这将标准输出和错误重定向到文件中 |'
- en: '| `>>&` | This appends a standard output and error to a file |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `>>&` | 这将标准输出和错误附加到文件中 |'
- en: '| `&#124;` | This redirects an output to another command |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 这将输出重定向到另一个命令 |'
- en: Redirecting standard output
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向标准输出
- en: An output of a program or command can be redirected to a file. Saving an output
    to a file can be useful when we have to look into the output in the future. A
    large number of output files for a program that runs with different inputs can
    be used in studying program output behavior.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 程序或命令的输出可以重定向到文件。将输出保存到文件中在将来查看输出时非常有用。对于使用不同输入运行的程序的大量输出文件，可以用于研究程序输出行为。
- en: 'For example, showing redirecting echo output to `output.txt` is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将echo输出重定向到`output.txt`的示例如下：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can see that no output is displayed on the terminal. This is because output
    was redirected to `output.txt`. The operator ''`>`'' (greater than) tells the
    shell to redirect the output to whatever filename mentioned after the operator.
    In our case, it''s `output.txt`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到终端上没有显示任何输出。这是因为输出被重定向到`output.txt`。运算符'>'（大于）告诉shell将输出重定向到运算符后面提到的任何文件名。在我们的情况下，它是`output.txt`：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s add some more output to the `output.txt` file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向`output.txt`文件添加一些更多的输出：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We noticed that the previous content of the `output.txt` file got erased and
    it only has the latest redirected content. To retain the previous content and
    append the latest redirected output to a file, use the operator ''`>>`'':'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到`output.txt`文件的先前内容被擦除了，现在只有最新重定向的内容。要保留先前的内容并将最新的重定向输出附加到文件中，使用运算符'>>'：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also redirect an output of a program/command to another command in bash
    using the operator ''`|`'' (pipe):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在bash中使用运算符' | '（管道）将程序/命令的输出重定向到另一个命令：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, we gave the output of `ls` to the `grep` command using the
    ''`|`'' (pipe) operator, and `grep` gave the matching search result of the `libc.so`
    library:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用' | '（管道）运算符将`ls`的输出传递给`grep`命令，`grep`给出了`libc.so`库的匹配搜索结果：
- en: Redirecting standard input
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向标准输入
- en: 'Instead of getting an input from a standard input to a command, it can be redirected
    from a file using the < (less than) operator. For example, we want to count the
    number of words in the `output.txt` file created from the *Redirecting standard
    output* section:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 不是从标准输入获取输入到命令，而是使用<（小于）运算符从文件中重定向输入。例如，我们想要计算从*重定向标准输出*部分创建的`output.txt`文件中的单词数：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can sort the content of `output.txt`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对`output.txt`的内容进行排序：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also give a `patch` file as an input to the `patch` command in order
    to apply a `patch.diff` in a source code. The command `patch` is used to apply
    additional changes made in a file. Additional changes are provided as a `diff`
    file. A `diff` file contains the changes between the original and the modified
    file by running the `diff` command. For example, I have a patch file to apply
    on `output.txt`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将`patch`文件作为`patch`命令的输入，以便在源代码中应用`patch.diff`。`patch`命令用于应用对文件进行的额外更改。额外的更改以`diff`文件的形式提供。`diff`文件包含通过运行`diff`命令对原始文件和修改后文件之间的更改。例如，我有一个要应用在`output.txt`上的补丁文件：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Redirecting standard errors
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重定向标准错误
- en: 'There is a possibility of getting an error while executing a command/program
    in bash because of different reasons such as invalid input, insufficient arguments,
    file not found, bug in program, and so on:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在bash中执行命令/程序时可能会出现错误，原因可能是无效输入、参数不足、文件未找到、程序中的错误等：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In general, errors are printed on a terminal so that it''s easy for us to know
    the reason for an error. Printing both the errors and output on the terminal can
    be annoying because we have to manually look into each line and check whether
    the program encountered any error:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，错误会打印在终端上，这样我们就可以很容易地知道错误的原因。在终端上打印错误和输出可能会很烦人，因为我们必须手动查看每一行，并检查程序是否遇到任何错误：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We ran a series of commands in the preceding section. First `cd` to `/`, `ls`
    content of `/`, cat file `hello.txt`, `cd` to `/bin` and see files matching `*.py`
    and `*.sh` in `/bin/`. The output will be as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的部分运行了一系列命令。首先`cd`到`/`，`ls`查看`/`的内容，cat文件`hello.txt`，`cd`到`/bin`并查看`/bin`中匹配`*.py`和`*.sh`的文件。输出如下：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We see that `hello.txt` doesn''t exist in the `/` directory and because of
    this there is an error printed on the terminal as well, along with other output.
    We can redirect the error as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`hello.txt`在`/`目录中不存在，因此终端上打印了一个错误，以及其他输出。我们可以按如下方式重定向错误：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can see that the error has been redirected to the `error.txt` file. To verify,
    check the `error.txt` content:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到错误已重定向到`error.txt`文件。要验证，请检查`error.txt`的内容：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Multiple redirection
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重重定向
- en: We can redirect `stdin`, `stdout`, and `stderr` together in a command or script
    or a combination of some of them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在命令或脚本中重定向`stdin`，`stdout`和`stderr`，或者它们的一些组合。
- en: 'The following command redirects both `stdout` and `stder`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令重定向了`stdout`和`stder`：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, `stdout` is redirected to `log.txt` and error messages are redirected
    to `log.txt` as well. In `2>&1`, `2>` means redirect an error and `&1` means redirect
    to `stdout`. In our case, we have already redirected `stdout` to the `log.txt`
    file. So, now both the `stdout` and `stderr` outputs will be written into `log.txt`
    and nothing will be printed on the terminal. To verify, we will check the content
    of `log.txt`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`stdout`被重定向到`log.txt`，错误消息也被重定向到`log.txt`。在`2>&1`中，`2>`表示重定向错误，`&1`表示重定向到`stdout`。在我们的情况下，我们已经将`stdout`重定向到`log.txt`文件。因此，现在`stdout`和`stderr`的输出都将写入`log.txt`，并且不会打印在终端上。要验证，我们将检查`log.txt`的内容：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following example shows the `stdin`, `stdout`, and `stderr` redirection:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了`stdin`，`stdout`和`stderr`的重定向：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the `.bashrc` file present in the `home` directory acts as an input to
    the `cat` command and its output is redirected to the `out.txt` file. Any error
    encountered in between is redirected to the `err.txt` file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`home`目录中的`.bashrc`文件作为`cat`命令的输入，并且其输出被重定向到`out.txt`文件。在中间遇到的任何错误都被重定向到`err.txt`文件。
- en: 'The following `bash` script will explain `stdin`, `stdout`, `stderr`, and their
    redirection with even more clarity:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`bash`脚本将更清楚地解释`stdin`，`stdout`，`stderr`及其重定向：
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This script saves two snapshots of all running processes in the system and
    generates `diff`. The output after running the process will look somewhat as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本保存系统中所有运行进程的两个快照，并生成`diff`。运行进程后的输出将如下所示：
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Pipe and pipelines – connecting commands
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道和管道 - 连接命令
- en: The outputs of the programs are generally saved in files for further use. Sometimes,
    temporary files are created in order to use an output of a program as an input
    to another program. We can avoid creating temporary files and feed the output
    of a program as an input to another program using bash pipe and pipelines.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出通常保存在文件中以供进一步使用。有时，为了将一个程序的输出用作另一个程序的输入，会创建临时文件。我们可以使用bash管道和管道来避免创建临时文件，并将一个程序的输出作为另一个程序的输入。
- en: Pipe
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道
- en: The pipe denoted by the operator `|` connects the standard output of a process
    in the left to the standard input in the right process by inter process communication
    mechanism. In other words, the `|` (pipe) connects commands by providing the output
    of a command as the input to another command.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由运算符`|`表示的管道将左侧进程的标准输出连接到右侧进程的标准输入，通过进程间通信机制。换句话说，`|`（管道）通过将一个命令的输出作为另一个命令的输入来连接命令。
- en: 'Consider the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, the `cat` command, instead of displaying the content of the `/proc/cpuinfo`
    file on `stdout`, passes its output as an input to the `less` command. The `less`
    command takes the input from `cat` and displays on the `stdout` per page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`cat`命令不是在`stdout`上显示`/proc/cpuinfo`文件的内容，而是将其输出作为`less`命令的输入。`less`命令从`cat`获取输入，并在每页上显示在`stdout`上。
- en: 'Another example using pipe is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用管道的示例如下：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Pipeline
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道
- en: 'Pipeline is a sequence of programs/commands separated by the operator '' `|`
    '' where the output of execution of each command is given as an input to the next
    command. Each command in a pipeline is executed in a new subshell. The syntax
    will be as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是由运算符'`|`'分隔的程序/命令序列，每个命令的执行输出都作为下一个命令的输入。管道中的每个命令都在一个新的子shell中执行。语法如下：
- en: '`command1 | command2 | command3 …`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`command1 | command2 | command3 …`'
- en: 'Examples showing pipeline are as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示管道的示例：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we are first getting a list of files from the `/usr/lib64` directory that
    has the `.so` extension. The output obtained is passed as an input to the next
    `grep` command to look for the `libc` string. The output is further given to the
    `wc` command to count the number of lines.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先从`/usr/lib64`目录中获取具有`.so`扩展名的文件列表。获得的输出被传递给下一个`grep`命令，以查找`libc`字符串。输出进一步传递给`wc`命令以计算行数。
- en: Regular expressions
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Regular expression (also known as regex or regexp) provides a way of specifying
    a pattern to be matched in a given big chunk of text data. It supports a set of
    characters to specify the pattern. It is widely used for a text search and string
    manipulation. A lot of shell commands provide an option to specify regex such
    as `grep`, `sed`, `find`, and so on.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式（也称为regex或regexp）提供了一种指定要在给定的大块文本数据中匹配的模式的方法。它支持一组字符来指定模式。它被广泛用于文本搜索和字符串操作。许多shell命令提供了指定正则表达式的选项，如`grep`，`sed`，`find`等。
- en: The regular expression concept is also used in other programming languages such
    as C++, Python, Java, Perl, and so on. Libraries are available in different languages
    to support regular expression's features.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式概念也用于其他编程语言，如C++，Python，Java，Perl等。不同语言中都有库来支持正则表达式的特性。
- en: Regular expression metacharacters
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式元字符
- en: 'The metacharacters used in regular expressions are explained in the following
    table:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式中使用的元字符在下表中解释：
- en: '| Metacharacters | Description |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 元字符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| * (Asterisk) | This matches zero or more occurrences of the previous character
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| *（星号）| 这匹配前一个字符的零个或多个出现 |'
- en: '| + (Plus) | This matches one or more occurrences of the previous character
    |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| +（加号）| 这匹配前一个字符的一个或多个出现 |'
- en: '| ? | This matches zero or one occurrence of the previous element |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| ? | 这匹配前一个元素的零次或一次出现 |'
- en: '| . (Dot) | This matches any one character |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| . (Dot) | 这匹配任何一个字符 |'
- en: '| ^ | This matches the start of the line |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| ^ | 这匹配行的开头 |'
- en: '| $ | This matches the end of line |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| $ | 这匹配行尾 |'
- en: '| [... ] | This matches any one character within a square bracket |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| [... ] | 这匹配方括号内的任何一个字符 |'
- en: '| [^... ] | This matches any one character that is not within a square bracket
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| [^... ] | 这匹配不在方括号内的任何一个字符 |'
- en: '| &#124; (Bar) | This matches either the left side or the right side element
    of &#124; |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| &#124; (Bar) | 这匹配&#124;的左侧或右侧元素 |'
- en: '| \{X\} | This matches exactly X occurrences of the previous element |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| \{X\} | 这匹配前一个元素的确切X次出现 |'
- en: '| \{X,\} | This matches X or more occurrences of the previous element |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| \{X,\} | 这匹配前一个元素的X次或更多出现 |'
- en: '| \{X,Y\} | This matches X to Y occurrences of the previous element |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| \{X,Y\} | 这匹配前一个元素的X到Y次出现 |'
- en: '| \(...\) | This groups all the elements |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| \(...\) | 这将所有元素分组 |'
- en: '| \< | This matches the empty string at the beginning of a word |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| \< | 这匹配单词的开头的空字符串 |'
- en: '| \> | This matches the empty string at the end of a word |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| \> | 这匹配单词的末尾的空字符串 |'
- en: '| \ | This disables the special meaning of the next character |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| \ | 这禁用下一个字符的特殊含义 |'
- en: Character ranges and classes
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符范围和类
- en: When we look into a human readable file or data, its major content contains
    alphabets (a to z) and numbers (0 to 9). While writing regex for matching a pattern
    consisting of alphabets or numbers, we can make use character ranges or classes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看人类可读的文件或数据时，其主要内容包含字母（a到z）和数字（0到9）。在编写用于匹配由字母或数字组成的模式的正则表达式时，我们可以使用字符范围或类。
- en: Character ranges
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符范围
- en: We can use character ranges in a regular expression as well. We can specify
    a range by a pair of characters separated by a hyphen. Any characters that fall
    in between that range, inclusive, are matched. Character ranges are enclosed inside
    square brackets.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在正则表达式中使用字符范围。我们可以通过一个连字符分隔的一对字符来指定范围。匹配介于该范围内的任何字符，包括在内。字符范围被包含在方括号内。
- en: 'The following table shows some of character ranges:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了一些字符范围：
- en: '| Character range | Description |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: 字符范围 | 描述 |
- en: '| --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `[a-z]` | This matches any single lowercase letter from a to z |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `[a-z]` | 这匹配a到z的任何单个小写字母 |'
- en: '| `[A-Z]` | This matches any single uppercase letter from A to Z |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `[A-Z]` | 这匹配从A到Z的任何单个大写字母 |'
- en: '| `[0-9]` | This matches any single digit from 0 to 9 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `[0-9]` | 这匹配0到9的任何单个数字 |'
- en: '| `[a-zA-Z0-9]` | This matches any single alphabetic or numeric characters
    |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `[a-zA-Z0-9]` | 这匹配任何单个字母或数字字符 |'
- en: '| `[h-k]` | This matches any single letter from h to k |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `[h-k]` | 这匹配从h到k的任何单个字母 |'
- en: '| `[2-46-8j-lB-M]` | This matches any single digit from 2 to 4 or 6 to 8 or
    any letter from j to l or B to M |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `[2-46-8j-lB-M]` | 这匹配从2到4或6到8的任何单个数字，或从j到l或从B到M的任何字母 |'
- en: '**Character classes**: Another way of specifying a range of character matches
    is by using Character classes. It is specified within the square brackets [:class:].
    The possible class value is mentioned in the following table:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符类**：指定一系列字符匹配的另一种方法是使用字符类。它在方括号[:class:]内指定。可能的类值在下表中提到：'
- en: '| Character Class | Description |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: 字符类 | 描述 |
- en: '| --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `[:alnum:]` | This matches any single alphabetic or numeric character; for
    example, [a-zA-Z0-9] |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `[:alnum:]` | 这匹配任何单个字母或数字字符；例如，[a-zA-Z0-9] |'
- en: '| `[:alpha:]` | This matches any single alphabetic character; for example,
    [a-zA-Z] |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `[:alpha:]` | 这匹配任何单个字母字符；例如，[a-zA-Z] |'
- en: '| `[:digit:]` | This matches any single digit; for example, [0-9] |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `[:digit:]` | 这匹配任何单个数字；例如，[0-9] |'
- en: '| `[:lower:]` | This matches any single lowercase alphabet; for example, [a-z]
    |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `[:lower:]` | 这匹配任何单个小写字母；例如，[a-z] |'
- en: '| `[:upper:]` | This matches any single uppercase alphabet; for example, [A-Z]
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `[:upper:]` | 这匹配任何单个大写字母；例如，[A-Z] |'
- en: '| `[:blank:]` | This matches a space or tab |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `[:blank:]` | 这匹配空格或制表符 |'
- en: '| `[:graph:]` | This matches a character in the range of ASCII—for example
    33-126—excluding a space character |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `[:graph:]` | 这匹配ASCII范围内的字符—例如33-126—不包括空格字符 |'
- en: '| `[:print:]` | This matches a character in the range of ASCII—for example.
    32-126—including a space character |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `[:print:]` | 这匹配ASCII范围内的字符—例如32-126—包括空格字符 |'
- en: '| `[:punct:]` | This matches any punctuation marks such as ''?'', ''!'', ''.'',
    '','', and so on |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `[:punct:]` | 这匹配任何标点符号，如''?''、''!''、''.''、'',''等 |'
- en: '| `[:xdigit:]` | This matches any hexadecimal characters; for example, [a-fA-F0-9]
    |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `[:xdigit:]` | 这匹配任何十六进制字符；例如，[a-fA-F0-9] |'
- en: '| `[:cntrl:]` | This matches any control characters |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `[:cntrl:]` | 这匹配任何控制字符 |'
- en: '**Creating your own regex**: In the previous sections of regular expression,
    we discussed about metacharacters, character ranges, character class, and their
    usage. Using these concepts, we can create powerful regex that can be used to
    filter out text data as per our need. Now, we will create a few regex using the
    concepts we have learned.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建您自己的正则表达式**：在正则表达式的前几节中，我们讨论了元字符、字符范围、字符类及其用法。使用这些概念，我们可以创建强大的正则表达式，用于根据我们的需要过滤文本数据。现在，我们将使用我们学到的概念创建一些正则表达式。'
- en: Matching dates in mm-dd-yyyy format
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配mm-dd-yyyy格式的日期
- en: 'We will consider our valid date starting from UNIX Epoch—that is, 1st January
    1970\. In this example, we will consider all the dates between UNIX Epoch and
    30th December 2099 as valid dates. An explanation of forming its regex is given
    in the following subsections:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑从UNIX纪元开始的有效日期—即1970年1月1日。在这个例子中，我们将考虑从UNIX纪元到2099年12月30日之间的所有日期都是有效日期。形成其正则表达式的解释在以下小节中给出：
- en: Matching a valid month
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 匹配有效的月份
- en: 0[1-9] matches 01st to 09th month
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0[1-9] 匹配01到09月
- en: 1[0-2] matches 10th, 11th, and 12th month
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1[0-2] 匹配第10、11和12个月
- en: '''|'' matches either left or right expression'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''|'' 匹配左侧或右侧表达式'
- en: Putting it all together, the regex for matching a valid month of date will be
    **0[1-9]|1[0-2]**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一起，匹配日期的有效月份的正则表达式将是**0[1-9]|1[0-2]**。
- en: Matching a valid day
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 匹配有效的日期
- en: 0[1-9] matches 01st to 09th day
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0[1-9] 匹配01到09日
- en: '[12][0-9] matches 10th to 29th day'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12][0-9] 匹配10到29日'
- en: 3[0-1] matches 30th to 31st day
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3[0-1] 匹配30到31日
- en: '''|'' matches either left or right expression'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''|'' 匹配左侧或右侧表达式'
- en: '**0[1-9]|[12][0-9]|3[0-1]** matches all the valid days in a date'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0[1-9]|[12][0-9]|3[0-1]** 匹配日期中的所有有效日期'
- en: Matching the valid year in a date
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 匹配日期中的有效年份
- en: 19[7-9][[0-9] matches years from 1970 to 1999
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 19[7-9][[0-9] 匹配从1970年到1999年的年份
- en: 20[0-9]{2} matches years from 2000 to 2099
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 20[0-9]{2} 匹配从2000年到2099年的年份
- en: '''|'' matches either left or right expression'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '''|'' 匹配左侧或右侧表达式'
- en: '**19[7-9][0-9]|20[0-9]{2}** matches all the valid years between 1970 to 2099'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**19[7-9][0-9]|20[0-9]{2}** 匹配1970年到2099年之间的所有有效年份'
- en: Combining valid months, days, and years regex to form valid dates
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将有效的月份、日期和年份正则表达式组合成有效日期
- en: 'Our date will be in mm-dd-yyyy format. By putting together regex formed in
    the preceding sections for months, days, and years, we will get regex for the
    valid date:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的日期将以mm-dd-yyyy格式。通过将前面部分形成的月份、日期和年份的正则表达式放在一起，我们将得到有效日期的正则表达式：
- en: (0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[0-1])-(19[7-9][0-9]|20[0-9]{2})
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: （0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[0-1])-(19[7-9][0-9]|20[0-9]{2）
- en: 'There is a nice website, [http://regexr.com/](http://regexr.com/), where you
    can also validate regular expression. The following screenshot shows the matching
    of the valid date among the given input:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个很好的网站，[http://regexr.com/](http://regexr.com/)，您也可以验证正则表达式。以下屏幕截图显示了在给定输入中匹配有效日期：
- en: '![Combining valid months, days, and years regex to form valid dates](img/4335_02_01.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![将有效的月份、日期和年份正则表达式组合成有效日期](img/4335_02_01.jpg)'
- en: Regex for a valid shell variable
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有效shell变量的正则表达式
- en: In [Chapter 1](ch01.html "Chapter 1. The Beginning of the Scripting Journey"),
    *Beginning of Scripting Journey*, we learned nomenclature of variables in shell.
    A valid variable name can contain a character from alphanumeric and underscore,
    and the first letter of the variable can't be a digit.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。脚本之旅的开始")中，*脚本之旅的开始*，我们学习了shell中变量的命名规则。有效的变量名可以包含来自字母数字和下划线的字符，并且变量的第一个字母不能是数字。
- en: 'Keeping these rules in mind, a valid shell variable regex can be written as
    follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这些规则，可以编写有效的shell变量正则表达式如下：
- en: ^[_a-zA-Z][_a-zA-Z0-9]*$
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ^[_a-zA-Z][_a-zA-Z0-9]*$
- en: Here, ^ (caret) matches the start of a line.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，^（插入符号）匹配行的开头。
- en: The regex [_a-zA-Z] matches _ or any upper or lower case alphabet [_a-zA-Z0-9]*
    matches zero or multiple occurrences of _,any digit or upper and lower case alphabet
    $ (Dollar) matches the end of the line.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式[_a-zA-Z]匹配_或任何大写或小写字母[_a-zA-Z0-9]*匹配_、任何数字或大写和小写字母的零次或多次出现$（美元符号）匹配行的结尾。
- en: In character class format, we can write regex as **^[_[:alpha:]][_[:alnum:]]*$**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符类格式中，我们可以将正则表达式写成**^[_[:alpha:]][_[:alnum:]]*$**。
- en: 'The following screenshot shows valid shell variables using regex formed:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了使用正则表达式形成的有效shell变量：
- en: '![Regex for a valid shell variable](img/4335_02_02.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![有效shell变量的正则表达式](img/4335_02_02.jpg)'
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Enclose regular expression in single quotes (') to avoid pre-shell expansion.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将正则表达式放在单引号（'）中，以避免预先shell扩展。
- en: Use back slash (\) before a character to escape the special meaning of metacharacters.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字符前使用反斜杠（\）来转义元字符的特殊含义。
- en: Metacharacters such as ?, +, {, |, (, and ) are known to be extended regex.
    They lose their special meaning when used in basic regex. To avoid this, use them
    with backslash '\?', '\+', '\{', '\|', '\(', and '\)'.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元字符，如？、+、{、|、（和）被认为是扩展的正则表达式。当在基本正则表达式中使用时，它们失去了特殊含义。为了避免这种情况，使用反斜杠'\?'、'\+'、'\{'、'\|'、'\('和'\)'。
- en: Filtering an output using grep
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用grep过滤输出
- en: One of the powerful and widely used command in shell is `grep`. It searches
    in an input file and matches lines in which the given pattern is found. By default,
    all the matched patterns are printed on `stdout` that is usually terminal. We
    can also redirect the matched output to other streams such as file. Instead of
    giving an input from a file, `grep` can also take the input from the redirected
    output of the command executed on the left-hand side of '`|`'.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: shell中一个强大且广泛使用的命令是`grep`。它在输入文件中搜索并匹配包含给定模式的行。默认情况下，所有匹配的模式都打印在通常是终端的`stdout`上。我们还可以将匹配的输出重定向到其他流，例如文件。`grep`也可以从左侧执行的命令的重定向输出中获取输入，而不是从文件中获取输入。
- en: Syntax
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法
- en: 'The syntax of using the `grep` command is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`grep`命令的语法如下：
- en: '`grep [OPTIONS] PATTERN [FILE...]`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep [OPTIONS] PATTERN [FILE...]`'
- en: Here, `FILE` can be multiple files for a search. If no file is given as an input
    for a search, it will search the standard input.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`FILE`可以是搜索的多个文件。如果没有给定文件作为搜索的输入，它将搜索标准输入。
- en: '`PATTERN` can be any valid regular expression. Put `PATTERN` within single
    quotes ('') or double quotes (") as per need. For example, use single quotes ('')
    to avoid any bash expansion and double quotes (") for expansion.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATTERN`可以是任何有效的正则表达式。根据需要将`PATTERN`放在单引号（''）或双引号（"）中。例如，使用单引号（''）避免任何bash扩展，使用双引号（"）进行扩展。'
- en: 'A lot of `OPTIONS` are available in `grep`. Some of the important and widely
    used options are discussed in the following table:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`中有很多`OPTIONS`。以下表格讨论了一些重要和广泛使用的选项：'
- en: '| Option | Usage |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 用法 |'
- en: '| --- | --- |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| -i | This enforces case insensitive match in both pattern and input file(s)
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| -i | 这强制在模式和输入文件中进行不区分大小写的匹配 |'
- en: '| `-v` | This displays the non-matching line |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `-v` | 显示不匹配的行 |'
- en: '| `-o` | This displays only the matched part in the matching line |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `-o` | 仅显示匹配行中的匹配部分 |'
- en: '| `-f FILE` | This obtains a pattern from a file, one per line |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `-f FILE` | 从文件中获取一个模式，每行一个 |'
- en: '| `-e PATTERN` | This specifies multiple search pattern |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `-e PATTERN` | 指定多个搜索模式 |'
- en: '| `-E` | This considers pattern as an extended regex (egrp) |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `-E` | 将模式视为扩展的正则表达式（egrp） |'
- en: '| `-r` | This reads all the files in a directory recursively, excluding resolving
    of symbolic links unless explicitly specified as an input file |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|`-r`|这会递归读取目录中的所有文件，不包括解析符号链接，除非显式指定为输入文件|'
- en: '| `-R` | This reads all the files in a directory recursively and resolving
    symbolic if any |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|`-R`|这会递归读取目录中的所有文件，并解析任何符号链接|'
- en: '| `-a` | This processes binary file as a text file |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|`-a`|这会将二进制文件处理为文本文件|'
- en: '| `-n` | This prefixes each matched line along with a line number |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|`-n`|这会在每个匹配行前加上行号|'
- en: '| `-q` | Don''t print anything on stdout |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|`-q`|不要在stdout上打印任何内容|'
- en: '| `-s` | Don''t print error messages |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|`-s`|不要打印错误消息|'
- en: '| `-c` | This prints the count of matching lines of each input file |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|`-c`|这会打印每个输入文件的匹配行数|'
- en: '| `-A NUM` | This prints NUM lines after the actual string match. (No effect
    with the -o option) |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|`-A NUM`|这会打印实际字符串匹配后的NUM行。（与`-o`选项无效）|'
- en: '| `-B NUM` | This prints NUM lines before the actual string match. (No effect
    with the -o option) |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|`-B NUM`|这会打印实际字符串匹配之前的NUM行。（与`-o`选项无效）|'
- en: '| `-C NUM` | This prints NUM lines after and before the actual string match.
    (No effect with the -o option) |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|`-C NUM`|这会打印实际字符串匹配前后的NUM行。（与`-o`选项无效）|'
- en: Looking for a pattern in a file
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在文件中查找模式
- en: 'A lot of times we have to search for a given string or a pattern in a file.
    The `grep` command provides us the capability to do it in a single line. Let''s
    see the following example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，我们必须在文件中搜索给定的字符串或模式。`grep`命令为我们提供了在一行中执行此操作的能力。让我们看下面的例子：
- en: 'The input file for our example will be `input1.txt`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例的输入文件将是`input1.txt`：
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will try to get the following information from the `input1.txt` file using
    the `grep` command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用`grep`命令从`input1.txt`文件中获取以下信息：
- en: Number of lines
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行数
- en: Line starting with a capital letter
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以大写字母开头的行
- en: Line ending with a period (.)
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以句点（.）结尾的行
- en: Number of sentences
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 句子的数量
- en: Searching sub-string `sent lines` that don't have a `periodNumber` of times
    the string `file` is used
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索子字符串`sent lines`，不包含`periodNumber`次使用字符串`file`的行
- en: 'The following shell script demonstrates how to do the above mentioned tasks:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本演示了如何执行上述任务：
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output after running the `pattern_search.sh` shell script will be as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`pattern_search.sh` shell脚本后的输出如下：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Looking for a pattern in multiple files
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在多个文件中查找模式
- en: 'The `grep` command also allows us to search for a pattern in multiple files
    as an input. To explain this in detail, we will head directly to the following
    example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`命令还允许我们在多个文件中搜索模式作为输入。为了详细解释这一点，我们将直接看以下示例：'
- en: The input files, in our case, will be `input1.txt` and `input2.txt`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，输入文件将是`input1.txt`和`input2.txt`。
- en: 'We will reuse the content of the `input1.txt` file from the previous example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用先前示例中`input1.txt`文件的内容：
- en: 'The content of `input2.txt` is as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`input2.txt`的内容如下：'
- en: '[PRE34]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We will try to get the following information from the `input1.txt` and `input2.txt`
    files using the `grep` command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试使用`grep`命令从`input1.txt`和`input2.txt`文件中获取以下信息：
- en: Search for the string `command`
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索字符串`command`
- en: Case-insensitive search of the string `command`
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不区分大小写地搜索字符串`command`
- en: Print the line number where the string `grep` matches
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印字符串`grep`匹配的行号
- en: Search for punctuation marks
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索标点符号
- en: Print one line followed by the matching lines while searching for the string
    `important`
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印一个匹配行后面的一行，同时搜索字符串`important`
- en: 'The following shell script demonstrates how to follow the preceding steps:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本演示了如何执行前面的步骤：
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following screenshot is the output after running the shell script `pattern_search.sh`.
    The matched pattern string has been highlighted:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 运行shell脚本`pattern_search.sh`后的输出如下截图。匹配的模式字符串已被突出显示：
- en: '![Looking for a pattern in multiple files](img/4335_02_03.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![在多个文件中查找模式](img/4335_02_03.jpg)'
- en: A few more grep usages
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些更多的`grep`用法
- en: The following subsections will cover a few more usages of the `grep` command.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将涵盖`grep`命令的一些更多用法。
- en: Searching in a binary file
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在二进制文件中搜索
- en: So far, we have seen all the `grep` examples running on text files. We can also
    search for a pattern in binary files using `grep`. For this, we have to tell the
    `grep` command to treat a binary file as a text file too. The option `-a` or `–text`
    tells `grep` to consider a binary file as a test file.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到所有`grep`示例在文本文件上运行。我们也可以使用`grep`在二进制文件中搜索模式。为此，我们必须告诉`grep`命令将二进制文件也视为文本文件。选项`-a`或`-text`告诉`grep`将二进制文件视为文本文件。
- en: We know that the `grep` command itself is a binary file that executes and gives
    a search result.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`grep`命令本身是一个二进制文件，执行并给出搜索结果。
- en: 'One of the option in `grep` is `--text`. The string `--text` should be somewhere
    available in the `grep` binary file. Let''s search for it as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`中的一个选项是`--text`。字符串`--text`应该在`grep`二进制文件中的某个地方可用。让我们按照以下方式搜索它：'
- en: '[PRE37]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We saw that the string `--text` is found in the search path `/usr/bin/grep`.
    The character backslash ('`\`') is used to escape its special meaning.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到字符串`--text`在搜索路径`/usr/bin/grep`中找到了。反斜杠（'`\`'）字符用于转义其特殊含义。
- en: Now, let's search for the `-w` string in the `wc` binary. We know that the `wc`
    command has an option `-w` that counts the number of words in an input text.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`wc`二进制文件中搜索`-w`字符串。我们知道`wc`命令有一个`-w`选项，用于计算输入文本中的单词数。
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Searching in a directory
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在目录中搜索
- en: We can also tell `grep` to search into all files/directories in a directory
    recursively using the option `-R`. This avoids the hassle of specifying each file
    as an input text file to `grep`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以告诉`grep`使用选项`-R`递归地搜索目录中的所有文件/目录，而无需指定每个文件作为`grep`的输入文本文件。
- en: 'For example, we are interested in knowing at how many places `#include <stdio.h>`
    is used in a standard `include` directory:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有兴趣知道标准`include`目录中`#include <stdio.h>`被使用了多少次：
- en: '[PRE39]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This means that the `#include <stdio.h>` string is found at `77` places in the
    `/usr/include` directory.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`#include <stdio.h>`字符串在`/usr/include`目录中有`77`个匹配位置。
- en: 'In another example, we want to know how many Python files (the extension `.py`)
    in `/usr/lib64/python2.7/` does `"import os"`. We can check that as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个例子中，我们想知道`/usr/lib64/python2.7/`目录中有多少个Python文件（扩展名为`.py`）包含`"import os"`。我们可以这样检查：
- en: '[PRE40]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Excluding files/directories from a search
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从搜索中排除文件/目录
- en: We can also specify the `grep` command to exclude a particular directory or
    file from search. This is useful when we don't want `grep` to look into a file
    or directory that has some confidential information. This is also useful in the
    case where we are sure that searching into a certain directory will be of no use.
    So, excluding them will reduce search time.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以指定`grep`命令来排除特定的目录或文件进行搜索。当我们不希望`grep`查找包含一些机密信息的文件或目录时，这是很有用的。这在我们确定搜索某个目录毫无用处的情况下也很有用。因此，排除它们将减少搜索时间。
- en: 'Suppose, there is a source code directory called `s0`, which uses the `git`
    version control. Now, we are interested in searching for a text or pattern in
    source files. In this case, searching in the `.git` subdirectory will be of no
    use. We can exclude `.git` from search as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个名为`s0`的源代码目录，它使用`git`版本控制。现在，我们有兴趣在源文件中搜索文本或模式。在这种情况下，在`.git`子目录中搜索将毫无用处。我们可以通过以下方式排除`.git`进行搜索：
- en: '[PRE41]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we are searching for the `search_string` string in the `s0` directory
    and telling `grep` to not to search in the `.git` directory.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在在`s0`目录中搜索`search_string`字符串，并告诉`grep`不要在`.git`目录中搜索。
- en: Instead of excluding a directory, to exclude a file, use the `--exclude-from=FILE`
    option.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 不要排除一个目录，要排除一个文件，使用`--exclude-from=FILE`选项。
- en: Display a filename with a matching pattern
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示具有匹配模式的文件名
- en: In some use-case, we don't bother with where the search matched and at how many
    places the search matched in a file. Instead, we are interested in knowing only
    the filename where at least one search matched.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些用例中，我们不关心搜索匹配的位置以及在文件中匹配了多少个位置。相反，我们只关心至少有一个搜索匹配的文件名。
- en: 'For example, I want to save filenames that have a particular search pattern
    found in a file, or redirect to some other command for further processing. We
    can achieve this using the `-l` option:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我想保存包含特定搜索模式的文件名，或者重定向到其他命令进行进一步处理。我们可以使用`-l`选项来实现这一点：
- en: '[PRE42]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This example gets name of the file in which `import os` is written and saves
    result in file `search_result.txt`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子获取了写有`import os`的文件的文件名，并将结果保存在文件`search_result.txt`中。
- en: Matching an exact word
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配精确单词
- en: The exact matching of the word is also possible using word boundary that is
    `\b` on both the sides of the search pattern.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用单词边界`\b`来实现单词的精确匹配。
- en: 'Here, we will reuse the `input1.txt` file and its content:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将重用`input1.txt`文件及其内容：
- en: '[PRE44]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `--color` option allows colored printing of the matched search result.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`--color`选项允许匹配搜索结果进行彩色打印。'
- en: The `"\ba\b"` option tells `grep` to only look for the character **a** that
    is alone. In search results, it won't match the character `a` present as a sub-string
    in a string.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`"\ba\b"`选项告诉`grep`只查找独立的字符**a**。在搜索结果中，它不会匹配作为子字符串出现的字符`a`。'
- en: 'The following screenshot shows the output:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了输出：
- en: '![Matching an exact word](img/4335_02_04.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![匹配精确单词](img/4335_02_04.jpg)'
- en: Editing output using sed
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用sed编辑输出
- en: 'The `sed` command is a non-interactive stream editor that allows you to modify
    the content of the standard input or file. It performs an operation on each line
    in a pipeline. The syntax will be:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`命令是一个非交互式流编辑器，允许您修改标准输入或文件的内容。它在管道中对每一行执行一个操作。语法将是：'
- en: '`sed [OPTIONS]... {script} [input-file …]`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed [OPTIONS]... {script} [input-file …]`'
- en: By default, the output is displayed on `stdout`, but can be redirected to a
    file if specified.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，输出显示在`stdout`上，但如果指定了，可以将其重定向到文件。
- en: The `input-file` are the files on which `sed` needs to be run. If no files are
    specified, it reads from `stdin`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`input-file`是需要运行`sed`的文件。如果没有指定文件，它将从`stdin`读取。'
- en: 'The `script` can be a command or a file with multiple commands to pass to `sed`,
    and `OPTIONS` to `sed` are described in the following table:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`script`可以是一个命令，也可以是一个包含多个命令的文件，要传递给`sed`，`sed`的`OPTIONS`在下表中描述：'
- en: '| Option | Description |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| -n | This suppresses automatic printing of pattern space |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| -n | 这会抑制模式空间的自动打印 |'
- en: '| -e script | This allows multiple scripts to be executed |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| -e script | 这允许执行多个脚本 |'
- en: '| -r | This uses the extended regex in the script |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| -r | 这在脚本中使用扩展的正则表达式 |'
- en: '| -l N | This specifies line wrap length |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| -l N | 这指定换行长度 |'
- en: '| --posix | This disables all GNU extensions |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| --posix | 这将禁用所有GNU扩展 |'
- en: '| -u | This loads the minimal amounts of data from input and flushes output
    buffers frequently |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| -u | 这从输入中加载最小量的数据并频繁刷新输出缓冲区 |'
- en: String substitution using s
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`s`进行字符串替换
- en: The `sed` command is widely used for string substitution in a text file. Programmers
    frequently use this feature while renaming a variable in a huge source code. It
    saves a lot of programmers' time by avoiding manual renaming.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`sed`命令广泛用于文本文件中的字符串替换。程序员经常在重命名大型源代码中的变量时使用此功能。它通过避免手动重命名节省了许多程序员的时间。'
- en: 'The substitution command `s` has the following field:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 替换命令`s`具有以下字段：
- en: '`s/regex/replacement/`'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`s/regex/replacement/`'
- en: Here, `s` means perform substitution, `/` acts as separator, and `regex` is
    a regular expression that needs to be replaced. A simple string can also be specified
    here. The last field `replacement` is with what matched results should be replaced.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`s`表示执行替换，`/`充当分隔符，`regex`是需要替换的正则表达式。这里也可以指定一个简单的字符串。最后一个字段`replacement`是匹配结果应该被替换成什么。
- en: By default, `sed` will replace only the first occurrence of a matched pattern
    in a line. To replace all occurrences, use the `g` flag after the end of `/—`,
    that is, `s/regex/replacement/g`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`sed`只会替换行中匹配模式的第一次出现。要替换所有出现，可以在`/—`的末尾使用`g`标志，即`s/regex/replacement/g`。
- en: 'Some of the flags that can be used are mentioned in the following table:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格中提到了一些可以使用的标志：
- en: '| Flag | Description |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 描述 |'
- en: '| --- | --- |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `g` | This applies replacement to all the matches in a line |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `g` | 这将在一行中应用替换到所有匹配项 |'
- en: '| `p` | This prints a new pattern space, if substitution occurs |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `p` | 如果发生替换，这将打印一个新的模式空间 |'
- en: '| `w filename` | This writes substituted pattern space to a filename |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `w filename` | 这将替换的模式空间写入文件名 |'
- en: '| `N` | This replaces only the Nth matched result in a matched line |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `N` | 这只替换匹配行中的第N个匹配结果 |'
- en: 'We have the `sed.sh` file for our example. The content of this file is as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`sed.sh`的文件作为示例。该文件的内容如下：
- en: '[PRE45]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is a shell script, where the variable `var1` has been used at four places.
    Now, we want to rename the variable `var1` to `variable`. We can do this very
    easily using the `sed` command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个shell脚本，其中变量`var1`已经在四个地方使用了。现在，我们想要将变量`var1`重命名为`variable`。我们可以使用`sed`命令很容易地做到这一点：
- en: '[PRE47]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, the `-i` option is used to replace an input file.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`-i`选项用于替换输入文件。
- en: Multiple substitutions
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个替换
- en: We can also specify multiple commands to be executed for substitution using
    `-e` followed by a command.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`-e`后跟一个命令来指定要执行的多个替换命令。
- en: 'For example, consider the `sed.txt` file. The content of this file is as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`sed.txt`文件。该文件的内容如下：
- en: '[PRE49]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we want to replace ''`.`'' with ''`,`'' and delete the line containing
    a string `manual`:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要将'`.`'替换为'`,`'并删除包含字符串`manual`的行：
- en: '[PRE50]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In `sed.txt` file, the `s/\./,/g` command first replaces '`.`' with '`,`' and
    `/manual/d` deletes further the line containing the string `manual`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在`sed.txt`文件中，`s/\./,/g`命令首先将'`.`'替换为'`,`'，`/manual/d`删除了包含字符串`manual`的行。
- en: Duplicating a stream using tee
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tee复制流
- en: 'In some cases, it''s necessary to print an output on `stdout` and save an output
    in a file. In general, command output can either be printed or can be saved in
    a file. To solve it, the `tee` command is used. This command reads from the standard
    input and writes to both standard output and files. The syntax of `tee` will be
    as follows:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，有必要在`stdout`上打印输出并将输出保存在文件中。一般来说，命令输出可以打印，也可以保存在文件中。为了解决这个问题，使用`tee`命令。该命令从标准输入读取，并同时写入标准输出和文件。`tee`的语法如下：
- en: '`tee [OPTION] [FILE …]`'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`tee [OPTION] [FILE …]`'
- en: 'The `tee` command copies the output to each `FILE` and also to `stdout`. The
    `OPTIONS` can be as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`tee`命令将输出复制到每个`FILE`，并且也复制到`stdout`。`OPTIONS`可以如下：'
- en: '| Option | Description |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-a, --append` | This appends to the `FILE` instead of overwriting |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `-a, --append` | 这将附加到`FILE`而不是覆盖 |'
- en: '| `-i, --ignore-interrupts` | This ignores interrupt signals, if any |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `-i, --ignore-interrupts` | 如果有的话，这将忽略中断信号 |'
- en: 'Writing an output to `stdout` and file: In general, to write an output to `stdout`
    and file, we will call the same command twice, with and without redirection. For
    example, the following command shows how to print an output on `stdout` and save
    it to a file:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出写入`stdout`和文件：一般来说，要将输出写入`stdout`和文件，我们将调用相同的命令两次，一次进行重定向，一次不进行重定向。例如，以下命令显示了如何在`stdout`上打印输出并将其保存到文件中：
- en: '[PRE51]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can do both the tasks by running the `ls` command once using the `tee` command
    as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`tee`命令一次运行`ls`命令来完成这两个任务，如下所示：
- en: '[PRE52]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can also specify multiple filenames to `tee` for an output to be written
    in each file. This copies the output to all files:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为`tee`指定多个文件名，以便将输出写入每个文件。这将复制输出到所有文件：
- en: '[PRE53]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'By running the above commands, the output will be also written to the `out1.txt`
    and `out2.txt` files:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行上述命令，输出也将写入`out1.txt`和`out2.txt`文件：
- en: '[PRE54]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Writing an output to stdout and appending to a file
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将输出写入stdout并附加到文件
- en: The `tee` command also allows you to append the output to a file instead of
    overwriting a file. This can be done using the `-a` option with `tee`. Appending
    an output to a file is useful when we want to write an output of various commands
    or an error log of different command execution in a single file.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`tee`命令还允许您将输出附加到文件而不是覆盖文件。这可以使用`tee`的`-a`选项来实现。将输出附加到文件在我们想要将各种命令的输出或不同命令执行的错误日志写入单个文件时非常有用。'
- en: 'For example, if we want to keep the output of running the `ls` and `echo` commands
    in the `out3.txt` file and also display results on `stdout`, we can do as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要将运行`ls`和`echo`命令的输出保留在`out3.txt`文件中，并且还在`stdout`上显示结果，我们可以这样做：
- en: '[PRE55]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Sending an output to multiple commands
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将输出发送到多个命令
- en: 'We can also use the `tee` command to provide an output of a command as an input
    to multiple commands. This is done by sending the `tee` output to pipe:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`tee`命令将命令的输出作为多个命令的输入。这是通过将`tee`输出发送到管道来完成的。
- en: '[PRE56]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, the output of the `df -h` command is saved to the `out4.txt` file, the
    `stdout` output is redirected to the `grep` command, and the output of the search
    result from `grep` is further redirected to the `wc` command. At the end, the
    result of `wc` is printed on `stdout`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`df -h`命令的输出保存到`out4.txt`文件中，`stdout`输出被重定向到`grep`命令，并且来自`grep`的搜索结果的输出进一步被重定向到`wc`命令。最后，`wc`的结果被打印到`stdout`上。
- en: Sorting and finding unique text
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序和查找唯一文本
- en: Shell provides different ways to sort the input text using the `sort` command.
    It's also possible to remove repeated lines from sorted/unsorted input text using
    the `uniq` command. The input text to sort and `uniq` commands can be given from
    a file, or redirected from another command.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Shell提供了不同的方法来使用`sort`命令对输入文本进行排序。还可以使用`uniq`命令从排序/未排序的输入文本中删除重复的行。可以从文件中给出要排序和`uniq`命令的输入文本，或者从另一个命令重定向。
- en: Sorting an input text
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对输入文本进行排序
- en: 'The lines in the input text are sorted in the following order:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 输入文本中的行按以下顺序排序：
- en: Numbers from 0 to 9
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从0到9的数字
- en: Uppercase letters from A to Z
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从A到Z的大写字母
- en: Lowercase letters from a to z
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从a到z的小写字母
- en: 'The syntax will be as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '`sort [OPTION] [FILE …]`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort [OPTION] [FILE …]`'
- en: Single or multiple input files can be provided to sort for sorting.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 可以提供单个或多个输入文件进行排序。
- en: 'The `sort` command takes multiple options to provide flexibility in sorting.
    The popular and important `OPTION` to sort have been discussed in the following
    table:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`命令采用多个选项以提供排序的灵活性。在以下表中讨论了排序的流行和重要的`OPTION`：'
- en: '| Option | Description |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-b` | This ignores leading blanks |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `-b` | 这忽略前导空格 |'
- en: '| `-d` | This considers only blanks and alphanumeric characters |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `-d` | 这仅考虑空格和字母数字字符 |'
- en: '| `-f` | This ignores a case |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `-f` | 这忽略了大小写 |'
- en: '| `-i` | This ignores a non-printable character |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `-i` | 这忽略了不可打印的字符 |'
- en: '| `-M` | This compares months that are unknown (for example, < JAN < FEB… <
    DEC) |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `-M` | 这比较未知的月份（例如，< JAN < FEB… < DEC） |'
- en: '| `-n` | This sorts on the basis of numerical values |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `-n` | 这根据数值进行排序 |'
- en: '| `-r` | This sorts in reverse order |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `-r` | 这以相反的顺序排序 |'
- en: '| `-h` | This sorts on human-readable numbers; for example, 9K, 5M, 1G, and
    so on. |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `-h` | 这根据可读性强的数字进行排序；例如，9K，5M，1G等。'
- en: '| `-u` | This gets unique lines |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `-u` | 这获取唯一行 |'
- en: '| `-o file` | This writes an output to a file instead of stdout |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `-o file` | 这将输出写入文件而不是stdout |'
- en: '| `-m` | This merges the already sorted file without resorting it |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `-m` | 这合并已排序的文件而不重新排序 |'
- en: '| `-k n` | This sorts data according to the given column n |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `-k n` | 这根据给定的列n对数据进行排序 |'
- en: Now, we will see with the help of examples, how different sorting can be done
    on the input text data.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过示例看看如何对输入文本数据进行不同的排序。
- en: Sorting a single file
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对单个文件进行排序
- en: 'In our example, we will consider the `sort1.txt` file for sorting. The content
    of this file is as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将考虑`sort1.txt`文件进行排序。该文件的内容如下：
- en: '[PRE57]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To sort the content alphabetically, we can use the `sort` command without any
    option:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 要按字母顺序对内容进行排序，可以使用没有任何选项的`sort`命令：
- en: '[PRE58]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To sort the content in reverse order, we can use the `–r` option:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要以相反的顺序对内容进行排序，我们可以使用`-r`选项：
- en: '[PRE59]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**Sorting multiple files**: We can also sort multiple files collectively, and
    the sorted output can be used for further queries.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**排序多个文件**：我们还可以集体对多个文件进行排序，并且排序后的输出可以用于进一步的查询。'
- en: 'For example, consider `sort1.txt` and `sort2.txt` files. We will reuse the
    content of the `sort1.txt` file from the previous example. The content of `sort2.txt`
    is as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`sort1.txt`和`sort2.txt`文件。我们将重用先前示例中的`sort1.txt`文件的内容。`sort2.txt`的内容如下：
- en: '[PRE60]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can sort both the files together alphabetically as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按字母顺序对两个文件一起进行排序，如下所示：
- en: '[PRE61]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can also use the `-o` option to save the sorted output of files in a file
    instead of displaying it on `stdout`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`-o`选项将文件的排序输出保存到文件中，而不是在`stdout`上显示它：
- en: '[PRE62]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Redirecting output to sort
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将输出重定向到sort
- en: 'We can sort an output redirected from another command. The following example
    shows the sorting of the `df -h` command output:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对从另一个命令重定向的输出进行排序。以下示例显示了对`df -h`命令输出进行排序：
- en: '[PRE63]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '![Redirecting output to sort](img/4335_02_05.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![将输出重定向到sort](img/4335_02_05.jpg)'
- en: 'The following command sorts output of `df` by its 2nd column content:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令按其第二列内容对`df`的输出进行排序：
- en: '[PRE64]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '![Redirecting output to sort](img/4335_02_06.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![将输出重定向到sort](img/4335_02_06.jpg)'
- en: 'We can sort the `ls -l` output according to the last modification day and month:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据最后修改的日期和月份对`ls -l`的输出进行排序：
- en: '[PRE65]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![Redirecting output to sort](img/4335_02_07.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![将输出重定向到sort](img/4335_02_07.jpg)'
- en: 'To sort the `ls -l` output, first sort according to the month that is the 6th
    field using the `-M` option, and if the month for two or more row is the same,
    then sort according to the day that is the 7th field using `-n` for numerical
    sort:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 要对`ls -l`的输出进行排序，首先按照第6个字段的月份使用`-M`选项进行排序，如果两个或更多行的月份相同，则按照第7个字段的日期使用`-n`进行排序：
- en: '[PRE66]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '![Redirecting output to sort](img/4335_02_08.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![将输出重定向到sort](img/4335_02_08.jpg)'
- en: Filtering unique elements
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤唯一元素
- en: 'In many use-case, we need to remove duplicate items and keep only one occurrence
    of items. It is very useful when the output of a command or input file is too
    big, and it contains lot of duplicate lines. To get unique lines from a file or
    redirected output, the shell command `uniq` is used. One important point to note
    is that, in order to get the `uniq` output, input should be sorted, or first run
    the sort command to make it sorted. The syntax will be as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多用例中，我们需要删除重复的项目并仅保留项目的一次出现。当命令或输入文件的输出太大并且包含大量重复行时，这非常有用。要从文件或重定向的输出中获取唯一行，使用shell命令`uniq`。一个重要的要点是，为了获得`uniq`输出，输入应该是排序的，或者首先运行sort命令使其排序。语法如下：
- en: '`sort [OPTION] [INPUT [OUTPUT]]`'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort [OPTION] [INPUT [OUTPUT]]`'
- en: An input to `uniq` can be given from a file or another command's output.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`uniq`的输入可以来自文件或另一个命令的输出。'
- en: If an input file is provided, then an optional output file can also be specified
    on a command line. If no output file is specified, the output will be printed
    on `stdout`.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了输入文件，则还可以在命令行上指定可选的输出文件。如果未指定输出文件，则输出将打印在`stdout`上。
- en: 'The options that `uniq` supports are discussed in the following table:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表中讨论了`uniq`支持的选项：
- en: '| Option | Description |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-c` | This prefixes lines with the number of occurrences |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `-c` | 这在行前加上出现次数 |'
- en: '| `-d` | This prints duplicate lines only once |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `-d` | 这仅打印重复行一次 |'
- en: '| `-f N` | This skips the comparison of the first N fields |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `-f N` | 这跳过了前N个字段的比较 |'
- en: '| `-i` | This is case-insensitive comparison of items |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `-i` | 这是项目的不区分大小写比较 |'
- en: '| `-u` | This prints only unique lines |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| `-u` | 仅打印唯一行 |'
- en: '| `-s N` | This avoids comparing the first N characters in line |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| `-s N` | 这避免比较行中的前N个字符 |'
- en: '| `-w N` | This compares only N characters in line |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| `-w N` | 仅比较行中的N个字符 |'
- en: Unique elements in a file
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件中的唯一元素
- en: 'Consider the `unique.txt` file as an example on which we will run the `uniq`
    command with its options. The content of `unique.txt` is as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 以`unique.txt`文件为例，我们将使用`uniq`命令及其选项运行。`unique.txt`的内容如下：
- en: '[PRE67]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To remove duplicate lines from the `unique.txt` file, we can do the following:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`unique.txt`文件中删除重复行，我们可以执行以下操作：
- en: 'Firstly, sort the file and then redirect the sorted text to the `uniq` command:'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先对文件进行排序，然后将排序后的文本重定向到`uniq`命令：
- en: '[PRE68]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Use the `-u` option with the `sort` command:'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-u`选项与`sort`命令：
- en: '[PRE69]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The output from running either of the commands will be the same, as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 运行任何一个命令的输出将是相同的，如下所示：
- en: '![Unique elements in a file](img/4335_02_09.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![文件中的唯一元素](img/4335_02_09.jpg)'
- en: 'We can use the `-c` option to print the number of occurrences of each line
    in the input file:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-c`选项来打印输入文件中每行的出现次数：
- en: '[PRE70]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '![Unique elements in a file](img/4335_02_10.jpg)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![文件中的唯一元素](img/4335_02_10.jpg)'
- en: 'Using the options `-c` and `-i` will print the `uniq` lines along with the
    occurrence count. A comparison for unique line will be done case-insensitive:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-c`和`-i`选项将打印`uniq`行以及出现次数。将进行不区分大小写的唯一行比较：
- en: '[PRE71]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '![Unique elements in a file](img/4335_02_11.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![文件中的唯一元素](img/4335_02_11.jpg)'
- en: 'To get only those lines in file that have appeared only once, the `-u` option
    is used:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅获取文件中仅出现一次的行，使用`-u`选项：
- en: '[PRE72]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Similarly, to get the lines that have been appeared more than once in a file,
    `-d` is used:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，要获取文件中出现多次的行，使用`-d`：
- en: '[PRE73]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can also tell the `uniq` command to find unique lines based on comparing
    only the first N character of the line:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以告诉`uniq`命令根据仅比较行的前N个字符来查找唯一行：
- en: '[PRE74]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Note
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The uniq command does not detect the repeated lines unless they are adjacent.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uniq`命令不会检测重复的行，除非它们是相邻的。'
- en: To find unique lines, first sort the input using the sort command and then apply
    the uniq command
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要查找唯一行，首先使用`sort`命令对输入进行排序，然后应用`uniq`命令
- en: Character-based translation using tr
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`tr`进行基于字符的翻译
- en: 'Another interesting shell command is `tr`. This translates, squeezes, or deletes
    characters from the standard input. The syntax will be as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的shell命令是`tr`。它可以从标准输入中翻译、挤压或删除字符。语法如下：
- en: '`tr [OPTION]... SET1 [SET2]`'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr [OPTION]... SET1 [SET2]`'
- en: 'The options for the `tr` commands are explained in the following table:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`命令的选项在下表中解释：'
- en: '| Option | Description |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-c, -C` | Use complement of SET1 |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| `-c, -C` | 使用SET1的补集 |'
- en: '| `-d` | This deletes a range of characters specified in SET1. |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| `-d` | 这将删除SET1中指定的字符范围。'
- en: '| `-s` | This replaces consecutive multiple occurrences of characters in SET1
    with a single occurrence. |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| `-s` | 这将用SET1中字符的单个出现替换连续多次出现的字符。'
- en: '| `-t` | This truncates SET1 to the length of SET2\. Any extra characters in
    SET1 will be not considered for translation. |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| `-t` | 这将SET1截断为SET2的长度。SET1中的任何额外字符都不会被考虑进行翻译。'
- en: 'SETs are a string of characters that can be specified using the following:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: SET是一串可以使用以下方式指定的字符：
- en: 'A character class: `[:alnum:]`, `[:digit:]`, `[:alpha:]` and so on'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符类：`[:alnum:]`、`[:digit:]`、`[:alpha:]`等等
- en: 'A character range: `''a-z''`, `''A-Z''`, and `''0-9''`'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符范围：`'a-z'`、`'A-Z'`和`'0-9'`
- en: 'An escape character: `\\`, `\b`, `\r`, `\n`, `\f`, `\v`, and `\t`'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转义字符：`\\`、`\b`、`\r`、`\n`、`\f`、`\v`和`\t`
- en: 'To provide an input text from a file and an output to a file, we can use the
    file redirection operators: `<` (less than for input) and `>` (greater than for
    output).'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件提供输入文本并将输出重定向到文件，我们可以使用文件重定向运算符：`<`（输入的小于）和`>`（输出的大于）。
- en: Deleting input characters
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除输入字符
- en: 'Sometimes, removing a few unnecessary characters from an input text is important.
    For example, our input text is in the `tr.txt` file:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，从输入文本中删除一些不必要的字符是很重要的。例如，我们的输入文本在`tr.txt`文件中：
- en: '[PRE75]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Suppose we want to remove all the caps letters from this file. We can use the
    `-d` option with `SET1` as `''A-Z''`:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从这个文件中删除所有大写字母。我们可以使用`SET1`为`'A-Z'`的`-d`选项：
- en: '[PRE76]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We see that the output doesn''t have any caps letter. We can also removed a
    new line and space from a file as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到输出没有任何大写字母。我们还可以从文件中删除换行符和空格如下：
- en: '[PRE77]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Here, we have redirected the output to `tr_out1.txt`:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已将输出重定向到`tr_out1.txt`：
- en: '[PRE78]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Squeezing to a single occurrence
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挤压到单个出现
- en: The `-s` option is useful when we don't want to delete a character throughout
    the input text, instead we want to squeeze down to a single occurrence if consecutive
    multiple occurrences of the given character is there.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不想在输入文本中删除字符时，而是想要将给定字符的连续多次出现挤压到单个出现时，`-s`选项就很有用。
- en: 'One of the use-case where it will prove useful is when we have multiple spaces
    in between two words that we want to bring down to a single space between any
    two words/strings in the input text. Consider the `tr1.txt` file as an example:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个用例是当我们在两个单词之间有多个空格时，我们希望将其减少到输入文本中任意两个单词/字符串之间的单个空格。以`tr1.txt`文件为例：
- en: '[PRE79]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'By looking into this file, it''s quite clear that texts are not properly aligned.
    There are multiple spaces between two words. We can squeeze multiple spaces to
    one space using the `tr` option with `-s`:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看这个文件，很明显文本没有对齐。两个单词之间有多个空格。我们可以使用`tr`选项和`-s`将多个空格挤压为一个空格：
- en: '[PRE80]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Inverting a character set to be translated
  id: totrans-484
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反转要翻译的字符集
- en: Command `tr` also provides the `-c` or `-C` options to invert a character set
    to be translated. This is useful when we know what is not to be translated.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`tr`命令还提供了`-c`或`-C`选项来反转要翻译的字符集。当我们知道不需要翻译什么时，这是很有用的。'
- en: For example, we want to keep only alphanumeric, newline, and white-space in
    the text string. Everything should be deleted from the input text. Here, it's
    easy to specify what not to delete rather than what to delete.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们只想在文本字符串中保留字母数字、换行符和空格。输入文本中的所有内容都应该被删除。在这里，指定不删除而不是删除会更容易。
- en: 'For example, consider the `tr2.txt` file whose content is as follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑`tr2.txt`文件，其内容如下：
- en: '[PRE81]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To delete characters other than alphanumeric, newline, and white-space, we
    can run the following command:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字母数字、换行和空格之外的字符，我们可以运行以下命令来删除：
- en: '[PRE82]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Filtering based on lines—head and tail
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于行的过滤-头和尾
- en: To display the content of a file, we will use the `cat` command. The `cat` command
    displays the whole file content on `stdout`. However, sometimes, we are interested
    in viewing only a few lines of a file. In this case, using `cat` will be tedious
    because we will have to scroll down to particular lines that we are interested
    in.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示文件的内容，我们将使用`cat`命令。`cat`命令将整个文件内容显示在`stdout`上。但是，有时我们只对查看文件的几行感兴趣。在这种情况下，使用`cat`将很麻烦，因为我们必须滚动到我们感兴趣的特定行。
- en: Shell provides us the `head` and `tail` commands to print only the lines in
    which we are interested in. The main difference between both the commands is,
    `head` prints the lines from the beginning of the files, and tail prints the lines
    from the end of the files.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: Shell为我们提供了`head`和`tail`命令，以仅打印我们感兴趣的行。两个命令之间的主要区别是，`head`从文件开头打印行，而`tail`从文件末尾打印行。
- en: Printing lines using head
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用head打印行
- en: 'The syntax is as follows:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '`head [OPTION] [FILE …]`'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '`head [OPTION] [FILE …]`'
- en: By default, `head` prints first 10 lines of each FILE to `stdout`. If no file
    is mentioned or '`-`' is specified, the input is taken from `stdin`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`head`将每个文件的前10行打印到`stdout`。如果没有提到文件或指定了'`-`'，则输入来自`stdin`。
- en: 'The options available in head can be used to change how much of the content
    to be printed. The options available are described in the following table:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 头部中可用的选项可用于更改要打印的内容量。可用选项在以下表中描述：
- en: '| Option | Description |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-c [-] K` | This prints first K bytes of a file. If -K is used, then you
    can output all contents except the last K bytes. |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| `-c [-] K` | 这将打印文件的前K个字节。如果使用了-K，则可以输出除最后K个字节之外的所有内容。|'
- en: '| `-n [-]K` | This prints first K lines of each file. If -K is used, then you
    can output all lines except the last n lines. |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| `-n [-]K` | 这将打印每个文件的前K行。如果使用了-K，则可以输出除最后n行之外的所有行。|'
- en: '| `-q` | This prevents name of input files from being printed. |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| `-q` | 这将阻止打印输入文件的名称。|'
- en: '| `-v` | This always outputs the header having the filename of each file. |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '| `-v` | 这总是输出每个文件的文件名标题。|'
- en: Printing the first few lines
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印前几行
- en: 'Let''s see how many files `/usr/lib64/` directory contains `-`:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`/usr/lib64/`目录包含多少个文件`-`：
- en: '[PRE83]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We see that `/usr/lib64` has 3954 files. Suppose, we don''t want all the libraries
    names, but just the first five library names. We can use a head command for this
    as follows:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`/usr/lib64`有3954个文件。假设我们不想要所有的库名称，而只想要前五个库名称。我们可以使用以下命令进行头部操作：
- en: '[PRE84]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Printing the first few bytes
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印前几个字节
- en: 'We use the `-c` option to print the first few bytes of a file, as follows:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`-c`选项来打印文件的前几个字节，如下所示：
- en: '[PRE85]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This first prints 50 bytes of the `/usr/share/dict/linux.words` and `/usr/share/dict/words`
    files.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这首先打印`/usr/share/dict/linux.words`和`/usr/share/dict/words`文件的前50个字节。
- en: 'We can eliminate the printing of the header having a filename using `–q`:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`–q`来消除具有文件名的标题的打印：
- en: '[PRE86]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'For a single file, command `head` doesn''t print name of file in output. To
    see it, use `–v` option:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单个文件，`head`命令不会在输出中打印文件名。要查看它，请使用`–v`选项：
- en: '[PRE87]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Printing lines using tail
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用tail打印行
- en: 'The syntax for `tail` is as follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail`的语法如下：'
- en: '`tail [OPTION] [FILE …]`'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail [OPTION] [FILE …]`'
- en: By default, `tail` prints the last 10 lines of each `FILE` to `stdout`. If no
    file is mentioned or '`-`' is specified, the input is taken from `stdin`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`tail`将每个`FILE`的最后10行打印到`stdout`。如果没有提到文件或指定了'`-`'，则输入来自`stdin`。
- en: 'The options available in `tail` can be used to change how much of the content
    to be printed. The available options are described in the following table:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail`中的可用选项可用于更改要打印的内容量。可用选项在以下表中描述：'
- en: '| Option | Description |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-c [+]K` | This prints the last `K` byte of each file. If `+K` is used,
    then print from `Kth` byte of each file. |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
  zh: '| `-c [+]K` | 这将打印每个文件的最后`K`字节。如果使用了`+K`，则从每个文件的第`K`字节开始打印。|'
- en: '| `-n [+]K` | This prints the last `K` lines of each file. If +K is used, then
    output from Kth line of each file. |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
  zh: '| `-n [+]K` | 这将打印每个文件的最后`K`行。如果使用+K，则从每个文件的第`K`行开始输出。|'
- en: '| `-f [{name&#124;descriptor}]` | The outputs the appended data as the file
    grows. |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
  zh: '| `-f [{name&#124;descriptor}]` | 输出随着文件增长而追加的数据。|'
- en: '| `--retry` | This keeps trying to open a file if it is inaccessible. |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
  zh: '| `--retry` | 如果文件无法访问，将继续尝试打开文件。|'
- en: '| `--max-unchanged-stats=N` | With the `-f` name, reopen the file that has
    not opened. This shows the changed size after `N` iterations (default 5). |'
  id: totrans-529
  prefs: []
  type: TYPE_TB
  zh: '| `--max-unchanged-stats=N` | 使用`-f`名称，重新打开未打开的文件。这显示`N`次迭代后的更改大小（默认为5）。|'
- en: '| `--pid=PID` | With `-f`, terminate if `PID` dies. |'
  id: totrans-530
  prefs: []
  type: TYPE_TB
  zh: '| `--pid=PID` | 使用`-f`，如果`PID`死亡，则终止。|'
- en: '| `-q` | Don''t output header having filename of each file. |'
  id: totrans-531
  prefs: []
  type: TYPE_TB
  zh: '| `-q` | 不要输出每个文件的文件名的标题。|'
- en: '| `-F` | This is the same as the `-f` name `--retry` option. |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '| `-F` | 这与`-f`名称`--retry`选项相同。|'
- en: '| `-s N` | This sleeps for `N` seconds between iterations. With `–pid`=`PID`,
    check the process at least once in `N` seconds. |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '| `-s N` | 在迭代之间休眠`N`秒。使用`–pid`=`PID`，每隔`N`秒至少检查一次进程。|'
- en: '| `-v` | This always outputs the header having a filename of each file. |'
  id: totrans-534
  prefs: []
  type: TYPE_TB
  zh: '| `-v` | 这总是输出每个文件的文件名标题。|'
- en: Checking log entries
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查日志条目
- en: The `tail` command is frequently used to check the error or message log for
    the last few run of commands. With each new run, logs are appended at the end
    of the line.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '`tail`命令经常用于检查最近几次命令的错误或消息日志。每次新运行时，日志都会追加到行的末尾。'
- en: 'We will see in following example that kernel log entries are made when a new
    USB drive is added and when it is removed:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下示例中看到，当添加新的USB驱动器和移除它时，内核日志条目被创建：
- en: '[PRE88]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We saw that when USB was unmounted, a new log entry was added:`[120110.466498]
    sdb:` detected capacity change from `1011875840` to `0` To check the last 10 yum
    logs in an RPM-based system, we can do the following:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到当USB卸载时，会添加一个新的日志条目：`[120110.466498] sdb:`检测到容量从`1011875840`变为`0`。要在基于RPM的系统中检查最后10个yum日志，我们可以这样做：
- en: '[PRE92]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'To see real-time logs, we can use the `-f` option. For example, the `/var/log/messages`
    file shows the general system activities. With `tail -f`, appended log messages
    in `/var/log/messages` will be printed on `stdout` as well:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看实时日志，我们可以使用`-f`选项。例如，`/var/log/messages`文件显示一般系统活动。使用`tail -f`，`/var/log/messages`中追加的日志消息也将打印在`stdout`上：
- en: '[PRE94]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The command prompt won't return back. Instead, the output will keep getting
    updated whenever there is new content in `/var/log/messages`.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 命令提示符不会返回。相反，每当`/var/log/messages`中有新内容时，输出将持续更新。
- en: Finding any line in a file
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在文件中查找任何行
- en: We can use head and tail to find any line of a file.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用head和tail来查找文件的任何行。
- en: We will consider the `/usr/share/dict/words` file as an example.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑`/usr/share/dict/words`文件作为示例。
- en: 'Now, to find the 10th line of this file, we can do the following:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要找到这个文件的第10行，我们可以这样做：
- en: '[PRE96]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The Cut-based selection
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Cut的选择
- en: 'We can also select a text from each line of single/multiple files using the
    `cut` command. The `cut` command allows us to select a column based on delimiters.
    By default, `TAB` is used as delimiter. We can also select a portion of the text
    in a line by specifying the characters or range. The syntax is as follows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`cut`命令从单个/多个文件的每一行中选择文本。`cut`命令允许我们基于分隔符选择列。默认情况下，使用TAB作为分隔符。我们还可以通过指定字符或范围来选择行中的一部分文本。语法如下：
- en: '`cut OPTION [FILE …]`'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut OPTION [FILE …]`'
- en: The `cut` command works on the single and multiple files. By default, the output
    is printed on `stdout`.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut`命令适用于单个和多个文件。默认情况下，输出打印在`stdout`上。'
- en: 'The options for the `cut` command are explained in the following table:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`cut`命令的选项在下表中解释：'
- en: '| Option | Description |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-560
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-b LIST` | This selects bytes that are specified in LIST. |'
  id: totrans-561
  prefs: []
  type: TYPE_TB
  zh: '| `-b LIST` | 这会选择列表中指定的字节。 |'
- en: '| `-c LIST` | This selects characters that are specified in LIST. |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| `-c LIST` | 这会选择列表中指定的字符。 |'
- en: '| `-d DELIM` | This uses delimiter as DELIM instead of TAB. It also prints
    lines that don''t have a delimiter. |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| `-d DELIM` | 这使用DELIM作为分隔符，而不是TAB。它还打印没有分隔符的行。 |'
- en: '| `-f LIST` | This only selects fields specified in LIST. |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| `-f LIST` | 这只选择列表中指定的字段。 |'
- en: '| `--complement` | This complements a set of selected bytes, characters, or
    fields. |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| `--complement` | 这是对所选字节、字符或字段集的补集。 |'
- en: '| `-s` | Don''t print lines that don''t have a delimiter. |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| `-s` | 不打印没有分隔符的行。 |'
- en: '| `--output-delimiter=STRING` | This uses STRING as the output delimiter. By
    default, the input delimiter is used. |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| `--output-delimiter=STRING` | 这使用STRING作为输出分隔符。默认情况下，使用输入分隔符。 |'
- en: 'LIST is made up of a range or many ranges separated by a comma. A range is
    specified as follows:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: LIST由一个范围或多个由逗号分隔的范围组成。范围的指定方式如下：
- en: '| Range | Meaning |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
  zh: '| 范围 | 含义 |'
- en: '| --- | --- |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `N` | This is the Nth byte, character, or field, counted from 1 |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
  zh: '| `N` | 这是第N个字节、字符或字段，从1开始计数 |'
- en: '| `N-` | This is from the Nth byte, character, or field, to the end of the
    line |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| `N-` | 这是从第N个字节、字符或字段到行尾 |'
- en: '| `N-M` | This is from the Nth to Mth byte (including M and N), character,
    or field. |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| `N-M` | 这是从第N到第M个字节（包括M和N）、字符或字段。 |'
- en: '| `-M` | This is from the first to Mth (include) byte, character, or field.
    |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| `-M` | 这是从第一个到第M个（包括）字节、字符或字段。 |'
- en: Cutting across columns
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨列切割
- en: A lot of Linux command outputs are formatted in such a way that the results
    have multiple fields and each field is separated by space or tabs. The outputs
    of each field can be viewed by looking down into a particular field column.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Linux命令的输出格式都是这样的，结果有多个字段，每个字段由空格或制表符分隔。可以通过查看特定字段列来查看每个字段的输出。
- en: 'Execute the `ls -l ~` command and observe the following output:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`ls -l ~`命令并观察以下输出：
- en: '[PRE97]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '![Cutting across columns](img/4335_02_12.jpg)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![跨列切割](img/4335_02_12.jpg)'
- en: 'Now, we are interested only in knowing the modification time and filename.
    To achieve this, we will need the column `6` to `9`:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只对修改时间和文件名感兴趣。为了实现这一点，我们将需要列`6`到`9`：
- en: '[PRE98]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '![Cutting across columns](img/4335_02_13.jpg)'
  id: totrans-582
  prefs: []
  type: TYPE_IMG
  zh: '![跨列切割](img/4335_02_13.jpg)'
- en: By default, `TAB` is used as a delimiter. Here, there are multiple spaces between
    any two columns in the `ls -l` output. So, first using `tr -s`, we will squeeze
    multiple whitespace into single whitespace and then we will cut the column field
    range `6-9` with a delimiter as whitespace.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用TAB作为分隔符。在`ls -l`输出中，任何两列之间有多个空格。因此，首先使用`tr -s`，我们将多个空格压缩为单个空格，然后我们将使用空格作为分隔符切割列字段范围`6-9`。
- en: Text selection in files
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件中的文本选择
- en: 'Consider the `cut1.txt` file as an example. The content of the file is as follows:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 以`cut1.txt`文件为例。文件的内容如下：
- en: '[PRE99]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The output will be:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '![Text selection in files](img/4335_02_14.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![文件中的文本选择](img/4335_02_14.jpg)'
- en: 'Now, we are interested in knowing the names of the students. We can get this
    by fetching the first column. Here, each column is separated by *Tab*. So, we
    will not have to specify the delimiter in our command:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们对学生的姓名感兴趣。我们可以通过获取第一列来获得这个。在这里，每一列都是由*Tab*分隔的。因此，在我们的命令中，我们不必指定分隔符：
- en: '[PRE100]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Another interesting thing to do is to get unique department names. We can do
    this by using the following set of commands on the `cut1.txt` file:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件有趣的事情是获取唯一的部门名称。我们可以通过在`cut1.txt`文件上使用以下一组命令来实现这一点：
- en: '[PRE101]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We can see that there are four unique departments mentioned in the `cut1.txt`
    file.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在`cut1.txt`文件中提到了四个唯一的部门。
- en: 'Another interesting thing we can do is find out who received the highest marks,
    as follows:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以做的另一件有趣的事情是找出谁获得了最高分，如下所示：
- en: '[PRE102]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: To find out who scored the highest mark, we first select the first and third
    column from the `cut1.txt` file. Then, we exclude the first line using `tail -n
    +2`, which tells us what this file is about, because we do not need this. After
    that, we do numerical sorting of the second column in reverse order, which contains
    the marks of all the students. Now, we know that the first column contains the
    details of those who scored the highest marks.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出谁得分最高，我们首先从`cut1.txt`文件中选择第一列和第三列。然后，我们使用`tail -n +2`排除第一行，这告诉我们这个文件是关于什么的，因为我们不需要这个。之后，我们对第二列进行数字排序，以逆序排列，其中包含所有学生的分数。现在，我们知道第一列包含得分最高的人的详细信息。
- en: Knowing the speed of your system processor is interesting in order to know the
    various details of your system. Among all, one of them knows the speed of your
    processor. The first thing to know is that all processor details are available
    in the `/proc/cpuinfo` file. You can open this file and see what all details are
    available. For example, we know that the processor's speed is mentioned in the
    `"model name"` field.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 了解系统处理器的速度是有趣的，以便了解系统的各种细节。其中之一就是了解处理器的速度。首先要知道的是，所有处理器的详细信息都在`/proc/cpuinfo`文件中。你可以打开这个文件，看看都有哪些详细信息。例如，我们知道处理器的速度在`"model
    name"`字段中提到。
- en: 'The following shell script will show the speed of the processor:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本将显示处理器的速度：
- en: '[PRE103]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Running this script will output the processor speed of your system:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个脚本将输出你系统的处理器速度：
- en: '[PRE104]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We can also do without using temporary files:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以不使用临时文件：
- en: '[PRE105]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Summary
  id: totrans-604
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After reading this chapter, you should know how to provide an input to commands
    and print or save its result. You should also be familiar with redirecting an
    output and input from one command to another. Now, you can easily search, replace
    strings or pattern in a file, and filter out data based on needs.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你应该知道如何向命令提供输入并打印或保存其结果。你还应该熟悉将一个命令的输出和输入重定向到另一个命令。现在，你可以轻松地在文件中搜索、替换字符串或模式，并根据需要过滤数据。
- en: From this chapter, we now have a good control on transforming/filtering text
    data. In next chapter, we will learn how to write more powerful and useful shell
    scripts by learning loops, conditions, switch, and the most important function
    in shell. We will also know how important it is to know the exit status of a command.
    In the next chapter, we will also see more advanced examples of commands that
    we have learned in this chapter.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一章中，我们现在可以很好地控制文本数据的转换/过滤。在下一章中，我们将学习如何通过学习循环、条件、开关和shell中最重要的函数来编写更强大和有用的shell脚本。我们还将了解知道命令的退出状态有多重要。在下一章中，我们还将看到本章中学到的命令的更高级的例子。
