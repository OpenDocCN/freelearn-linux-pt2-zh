- en: Chapter 4. Modularizing and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 模块化和调试
- en: In the real world, when you write code, you either maintain it forever or someone
    takes ownership of it later and makes changes into it. It is very important that
    you write a good quality shell script so that it's easier to maintain it further.
    It is also important that the shell script is bug-free in order to get the work
    done as expected. Scripts running on production systems are very critical because
    any error or wrong behavior of the script may cause minor or major damage. To
    solve such critical issues, it is important to get it fixed as soon as possible.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，当你编写代码时，你要么永远维护它，要么以后有人接管它并对其进行更改。非常重要的是，您编写一个质量良好的shell脚本，以便更容易进一步维护它。同样重要的是，shell脚本没有错误，以便按预期完成工作。在生产系统上运行的脚本非常关键，因为脚本的任何错误或错误行为可能会造成轻微或重大的损害。为了解决这些关键问题，重要的是尽快解决问题。
- en: In this chapter, we will see how we can write modular and reusable code so that
    maintaining and updating our shell script application can be done quickly and
    without any hassle. We will also see how easily and quickly bugs in shell scripts
    can be solved using different debugging techniques. We will see how we can provide
    our users different choices for different tasks by providing support for command
    line options in a script. The knowledge of how to provide command line completion
    in a script will even increase the ease of using the script.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何编写模块化和可重用的代码，以便快速和无需任何麻烦地维护和更新我们的shell脚本应用程序。我们还将看到如何使用不同的调试技术快速轻松地解决shell脚本中的错误。我们将看到如何通过在脚本中提供命令行选项的支持为不同的任务提供不同的选择。了解如何在脚本中提供命令行完成甚至会增加使用脚本的便利性。
- en: 'This chapter will cover the following topics in detail:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细介绍以下主题：
- en: Modularizing your scripts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的脚本模块化
- en: Passing command line parameters to script
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令行参数传递给脚本
- en: Debugging your scripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试您的脚本
- en: Command completion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令完成
- en: Modularizing your scripts
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的脚本模块化
- en: While writing a shell script, there is one stage when we feel that a shell script
    file has become too big to read and manage. To avoid such a scenario in our shell
    script, it is very important to keep the script modular.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写shell脚本时，有一个阶段我们会觉得一个shell脚本文件变得太大，难以阅读和管理。为了避免这种情况发生在我们的shell脚本中，保持脚本模块化非常重要。
- en: 'In order to keep the script modular and maintainable, you can do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持脚本的模块化和可维护性，您可以执行以下操作：
- en: Create functions instead of writing the same code again and again
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建函数而不是一遍又一遍地写相同的代码
- en: Write a common set of functions and variables in a separate script and then
    source to use it
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个单独的脚本中编写一组通用的函数和变量，然后源来使用它
- en: We have already seen how to define and use a function in [Chapter 3](ch03.html
    "Chapter 3. Effective Script Writing"), *Effective Script Writing*. Here, we will
    see how to divide a bigger script into smaller shell script modules and then use
    them by sourcing. In other words, we can say creating libraries in `bash`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何在[第3章](ch03.html "第3章 有效脚本编写") *有效脚本编写*中定义和使用函数。在这里，我们将看到如何将一个更大的脚本分成更小的shell脚本模块，然后通过源使用它们。换句话说，我们可以说在`bash`中创建库。
- en: Source to a script file
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源到脚本文件
- en: Source is a shell built in command that reads and executes a script file in
    the current shell environment. If a script calls a source on another script file,
    all functions and variables available in that file will be loaded for use in calling
    script.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 源是一个shell内置命令，它在当前shell环境中读取并执行脚本文件。如果一个脚本调用另一个脚本文件的源，那么该文件中可用的所有函数和变量将被加载以供调用脚本使用。
- en: Syntax
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语法
- en: 'The syntax of using the source is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源的语法如下：
- en: '`source <script filename> [arguments]`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`source <script filename> [arguments]`'
- en: 'OR:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '`. <script filename> [arguments]`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`. <script filename> [arguments]`'
- en: The `script filename` can be with or without a path name. If the absolute or
    relative path is provided, it will look only into that path. Otherwise, a filename
    will be searched in the directories specified in the `PATH` variable.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`脚本文件名`可以带有或不带有路径名。如果提供了绝对或相对路径，它将仅在该路径中查找。否则，将在`PATH`变量中指定的目录中搜索文件名。'
- en: The `arguments` are treated as positional parameters to the script filename.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`被视为脚本文件名的位置参数。'
- en: The exit status of the `source` command will be the exit code of the last command
    executed in the script filename. If the script filename doesn't exist or there
    is no permission, then the exit status will be `1`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`source`命令的退出状态将是在脚本文件中执行的最后一个命令的退出代码。如果脚本文件不存在或没有权限，则退出状态将为`1`。'
- en: Creating a shell script library
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个shell脚本库
- en: A library provides a collection of features that can be reused by another application
    without rewriting from scratch. We can create a library in shell by putting our
    functions and variables to be reused in a shell script file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 库提供了一个功能集合，可以被另一个应用程序重用，而无需从头开始重写。我们可以通过将我们的函数和变量放入一个shell脚本文件中来创建一个shell库，以便重用。
- en: 'The following `shell_library.sh` script is an example of a shell library:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的`shell_library.sh`脚本是一个shell库的例子：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding `shell_library.sh` shell script contains the `is_regular_file`
    and `is_directory_file` global variables that can be used to know whether a given
    file is a regular file or directory after invoking the `file_type()`function.
    Furthermore, depending upon the type of the file, useful detailed information
    can be printed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`shell_library.sh` shell脚本包含了`is_regular_file`和`is_directory_file`全局变量，可以在调用`file_type()`函数后用于知道给定的文件是普通文件还是目录。此外，根据文件的类型，可以打印有用的详细信息。
- en: Loading a shell script library
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载一个shell脚本库
- en: Creating shell libraries are of no use unless it is used in another shell script.
    We can either use a shell script library directly in shell or within another script
    file. To load a shell script library, we will use the source command or. (period
    character) followed by shell script library.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建shell库是没有用的，除非它在另一个shell脚本中使用。我们可以直接在shell中使用shell脚本库，也可以在另一个脚本文件中使用。要加载shell脚本库，我们将使用source命令或.（句点字符），然后是shell脚本库。
- en: Calling a shell library in bash
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在bash中调用shell库
- en: 'To use the `shell_library.sh` script file in shell, we can do the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要在shell中使用`shell_library.sh`脚本文件，我们可以这样做：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'OR:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 或：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Calling any of them will make functions and variables available for use in
    the current shell:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 调用它们中的任何一个将使函数和变量可用于当前shell中使用：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the `file_type /usr/bin` command is executed, the `file_type()`function
    with the `/usr/bin` parameter will be called. As a result, the global variable
    `is_directory_file` or `is_regular_file` will get set to `1` (`true`), depending
    upon the type of the `/usr/bin` path. Using the shell `if` condition, we test
    whether the `is_directory_file` variable is set to `1` or not. If set to `1`,
    then call the `print_directory_details()` function with `/usr/bin` as a parameter
    to print its details.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`file_type /usr/bin`命令时，将调用带有`/usr/bin`参数的`file_type()`函数。结果是，全局变量`is_directory_file`或`is_regular_file`将设置为`1`（`true`），取决于`/usr/bin`路径的类型。使用shell的`if`条件，我们测试`is_directory_file`变量是否设置为`1`。如果设置为`1`，则调用`print_directory_details()`函数，参数为`/usr/bin`，以打印其详细信息。
- en: Calling shell library in another shell script
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在另一个shell脚本中调用shell库
- en: 'The following example explains the usage of the shell library in a shell script
    file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例解释了在shell脚本文件中使用shell库的用法：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output after running the `shell_library_usage.sh` script is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`shell_library_usage.sh`脚本后，得到以下输出：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To load a shell script library, use `source` or `.` followed by `script_filename`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载shell脚本库，使用`source`或`.`，然后是`script_filename`。
- en: Both source and `.`(period character) execute a script in the current shell.
    `./script` is not the same as `. script` because `./script` executes the script
    in a subshell, while `. script` executes in a shell from where it was invoked.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`source`和`.`（句点字符）都在当前shell中执行脚本。`./script`与`. script`不同，因为`./script`在子shell中执行脚本，而`.
    script`在调用它的shell中执行。'
- en: Passing command line parameters to script
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将命令行参数传递给脚本
- en: So far, we have seen the usage of the commands such as `grep`, `head`, `ls`,
    `cat`, and many more. These commands also support passing arguments to a command
    via a command line. Some of command line arguments are input files, output files,
    and options. Arguments are provided as per output needs. For example, `ls -l filename`
    is executed to get a long listing output, while `ls -R filename` is used to display
    recursively the contents of a directory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了诸如`grep`、`head`、`ls`、`cat`等命令的用法。这些命令还支持通过命令行传递参数给命令。一些命令行参数是输入文件、输出文件和选项。根据输出的需要提供参数。例如，执行`ls
    -l filename`以获得长列表输出，而使用`ls -R filename`用于递归显示目录的内容。
- en: Shell script also supports providing command line arguments that we can process
    further by a shell script.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本还支持提供命令行参数，我们可以通过shell脚本进一步处理。
- en: 'The command line arguments can be given as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数可以如下给出：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `script_file` is a shell script file to be executed, and `arg1`, `arg2`,
    `arg3`, `argN`, and so on, are command line parameters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`script_file`是要执行的shell脚本文件，`arg1`、`arg2`、`arg3`、`argN`等是命令行参数。
- en: Reading arguments in scripts
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在脚本中读取参数
- en: Command line arguments are passed to a shell script as positional parameters.
    So, `arg1` will be accessed in a script as `$1`, `arg2` as `$2`, and so on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数作为位置参数传递给shell脚本。因此，`arg1`在脚本中将被访问为`$1`，`arg2`为`$2`，依此类推。
- en: 'The following shell demonstrates the usage of the command line arguments:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell演示了命令行参数的用法：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following output is obtained after running the `command_line_arg.sh` script
    with arguments:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在带有参数运行`command_line_arg.sh`脚本后，得到以下输出：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following table shows special variables that are useful to get more information
    about command line parameters:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了有用的特殊变量，用于获取有关命令行参数的更多信息：
- en: '| Special variables | Description |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 特殊变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `$#` | Number of the command line arguments |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '`$#` | 命令行参数的数量'
- en: '| `$*` | Complete set of command line arguments in a single string—that is,
    `''$1 $2 … $n''` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '`$*` | 以单个字符串的形式包含所有命令行参数的完整集合，即`''$1 $2 … $n''`'
- en: '| `$@` | Complete set of command line arguments, but each argument is enclosed
    in separate quotes—that is, `''$1'' ''$2'' … ''$n''` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '`$@` | 完整的命令行参数集合，但每个参数都用单独的引号括起来，即`''$1'' ''$2'' … ''$n''`'
- en: '| `$0` | Name of the shell script itself |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '`$0` | shell脚本本身的名称'
- en: '| `$1, $1, … $N` | Refers to argument1, argument2, …, argumentN, respectively
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '`$1, $1, … $N` | 分别指代参数1、参数2、…、参数N'
- en: Using `$#` in a script to check the number of command line arguments will be
    very helpful to process arguments further.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中使用`$#`来检查命令行参数的数量将非常有助于进一步处理参数。
- en: 'The following is another shell script example that takes command line arguments:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个接受命令行参数的shell脚本示例：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following output is obtained after executing the `command_line_arg2.sh`
    script:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`command_line_arg2.sh`脚本后，得到以下输出：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Shifting command line arguments
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动命令行参数
- en: 'To shift command line arguments towards the left, the `shift` built in can
    be used. The syntax is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要将命令行参数向左移动，可以使用`shift`内置命令。语法如下：
- en: '`shift N`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`shift N`'
- en: Here, `N` is the number of arguments by which it can shift to the left.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`N`是它可以向左移动的参数个数。
- en: For example, suppose the current command line arguments are `arg1`, `arg2`,
    `arg3`, `arg4` and `arg5`. They can be accessed in a shell script as `$1`, `$2`,
    `$3`, `$4`, and `$5`, respectively; the `$#` value is `5`. When we call `shift
    3`, arguments get shifted by `3`. Now, `$1` contains `arg4` and `$2` contains
    `arg5`. Also, the `$#` value is `now 2`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设当前的命令行参数是`arg1`，`arg2`，`arg3`，`arg4`和`arg5`。它们可以在shell脚本中分别作为`$1`，`$2`，`$3`，`$4`和`$5`访问；`$#`的值为`5`。当我们调用`shift
    3`时，参数会被移动`3`个位置。现在，`$1`包含`arg4`，`$2`包含`arg5`。此外，`$#`的值现在是`2`。
- en: 'The following shell script demonstrates the usage of `shift`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本演示了`shift`的用法：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following output is obtained after running the `shift_argument.sh` script
    with the arguments `a b c d e f`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数`a b c d e f`运行`shift_argument.sh`脚本后获得以下输出：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Processing command line options in a script
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在脚本中处理命令行选项
- en: Providing command line options make shell scripts more interactive. From the
    command line arguments, we can also parse options for further processing by a
    shell script.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 提供命令行选项使shell脚本更具交互性。从命令行参数中，我们还可以解析选项以供shell脚本进一步处理。
- en: 'The following shell script shows the command line usage with options:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本显示了带有选项的命令行用法：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following output is obtained after executing the `myprint.sh` script:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`myprint.sh`脚本后获得以下输出：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Debugging your scripts
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试您的脚本
- en: We write different shell scripts to perform different tasks. Have you ever encountered
    any errors while executing a shell script? The answer would be mostly yes! This
    is to be expected as it is practically impossible to always write perfect shell
    scripts, without errors or bugs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写不同的shell脚本来执行不同的任务。在执行shell脚本时，您是否曾遇到过任何错误？答案很可能是肯定的！这是可以预料的，因为几乎不可能总是编写完美的shell脚本，没有错误或漏洞。
- en: 'For example, the following shell script is a buggy script while execution:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下shell脚本在执行时是有错误的：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following output is obtained after executing `buggy_script.sh`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`buggy_script.sh`后获得以下输出：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'From the output, we see that the error `[: a: integer expression expected`
    occurred at line 6\. It''s not always possible to know the reason of the error
    by just looking into an error message, especially when seeing an error for the
    first time. Also, looking manually into the code and rectifying an error is difficult
    when dealing with a lengthy shell script.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '从输出中，我们看到错误`[: a: integer expression expected`发生在第6行。仅仅通过查看错误消息，通常不可能知道错误的原因，特别是第一次看到错误时。此外，在处理冗长的shell脚本时，手动查看代码并纠正错误是困难的。'
- en: 'To overcome all kinds of troubles while resolving an error or bug in a shell
    script, it''s preferred to debug code. Debugging ways to debug a shell script
    are as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服在解决shell脚本中的错误或漏洞时遇到的各种麻烦，最好调试代码。调试shell脚本的方法如下：
- en: Using `echo` in an expected buggy area of a script to print the contents of
    the variables or commands to be executed
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在脚本的预期错误区域使用`echo`打印变量或要执行的命令的内容。
- en: Debugging an entire script using `-x` while running a script
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行脚本时使用`-x`调试整个脚本
- en: Debugging a section of a script using set builtin command with the `-x` and
    `+x` options inside the script
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用set内置命令在脚本内部使用`-x`和`+x`选项调试脚本的一部分
- en: Debugging using echo
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用echo进行调试
- en: The `echo` command is very useful as it prints whatever arguments are provided
    to it. When we encounter an error while executing a script, we know the line number
    with an error message. In such a case, we can use `echo` to print what is going
    to be executed before the actual execution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo`命令非常有用，因为它打印提供给它的任何参数。当我们在执行脚本时遇到错误时，我们知道带有错误消息的行号。在这种情况下，我们可以使用`echo`在实际执行之前打印将要执行的内容。'
- en: 'In our previous example, `buggy_script.sh`, we got an error at line 6—that
    is `if [ a -gt $b ]`—while execution. We can use the `echo` statement to print
    what is actually going to be executed at line 6\. The following shell script adds
    `echo` in line 6, to see what will be executed finally at line 6:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子`buggy_script.sh`中，我们在第6行得到了一个错误——即`if [ a -gt $b ]`——在执行时。我们可以使用`echo`语句打印实际将在第6行执行的内容。以下shell脚本在第6行添加了`echo`，以查看最终将在第6行执行的内容：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will now execute the `debugging_using_echo.sh` script as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将按以下方式执行`debugging_using_echo.sh`脚本：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can see that the character `a` is getting compared with `8`, while we were
    expecting the value of the variable `a`. This means that, by mistake, we forgot
    to use `$` with `a` to extract the value of the variable `a`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到字符`a`正在与`8`进行比较，而我们期望的是变量`a`的值。这意味着我们错误地忘记了在`a`中使用`$`来提取变量`a`的值。
- en: Debugging an entire script using -x
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用-x调试整个脚本
- en: Using `echo` to debug is easy if the script is small, or if we know where exactly
    the problem is. Another disadvantage of using `echo` is that every time we make
    changes, we will have to open a shell script and modify the `echo` command accordingly.
    After debugging, we will have to remember to delete the extra `echo` lines added
    for the purposes of debugging.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`echo`进行调试很容易，如果脚本很小，或者我们知道问题出在哪里。使用`echo`的另一个缺点是，每次我们进行更改，都必须打开一个shell脚本，并相应地修改`echo`命令。调试后，我们必须记住删除为调试目的添加的额外`echo`行。
- en: To overcome these problems, bash provides the `-x` option that can be used while
    executing a shell script. Running a script with the `-x` option runs a script
    in the debug mode. This prints all the commands that are going to be executed
    along with the output of the script.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，bash提供了`-x`选项，可以在执行shell脚本时使用。使用`-x`选项运行脚本会以调试模式运行脚本。这会打印所有要执行的命令以及脚本的输出。
- en: 'Consider the following shell script as an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下shell脚本为例：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we will run the preceding script as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将按以下方式运行前述脚本：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It gives an error that the `/tmp/` directory already exists. By looking into
    the error, we can''t say why it is trying to create the `/tmp` directory. To trace
    the entire code, we can run the `debug_entire_script.sh` script with the `-x`
    option:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它会给出`/tmp/`目录已经存在的错误。通过查看错误，我们无法知道为什么它要创建`/tmp`目录。为了跟踪整个代码，我们可以使用带有`-x`选项运行`debug_entire_script.sh`脚本：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can see that `dir2` is `/tmp/`. This means that no input is given to create
    the second directory.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`dir2`是`/tmp/`。这意味着没有输入来创建第二个目录。
- en: 'Using the `-v` option along with `-x` makes debugging even more verbose because
    `-v` displays input lines as it is:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-v`选项以及`-x`使得调试更加详细，因为`-v`会显示输入行：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With verbose output, it is quite clear that the dir1 and dir2 variables are
    expecting a command line argument. So, two arguments must be provided from a command
    line:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过详细输出，很明显`dir1`和`dir2`变量期望从命令行参数中提供两个参数。因此，必须从命令行提供两个参数：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, the script works without any errors.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，脚本可以正常运行而不会出现任何错误。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of passing the `-xv` options to bash from a command line, we can add
    it in the `shebang` line in the script file—that is, `#!/bin/bash -xv`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不再需要从命令行传递`-xv`选项给bash，我们可以在脚本文件的`shebang`行中添加它，即`#!/bin/bash -xv`。
- en: Debugging sections of a script using the set options
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用设置选项调试脚本的部分
- en: 'To debug a shell script, it''s not necessary to debug the entire script all
    the time. Sometimes, debugging a partial script is more useful and time-saving.
    We can achieve partial debugging in a shell script using the `set` builtin command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 调试shell脚本时，并不总是需要一直调试整个脚本。有时，调试部分脚本更有用且节省时间。我们可以使用`set`内置命令在shell脚本中实现部分调试：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can use `set +x` and `set -x` inside a shell script at multiple places depending
    upon the need. When a script is executed, commands in between them are printed
    along with the output.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在shell脚本的多个位置使用`set +x`和`set -x`，具体取决于需要。当执行脚本时，它们之间的命令将与输出一起打印出来。
- en: 'Consider the following shell script as an example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下shell脚本作为示例：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Executing this script gives the following output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本会得到以下输出：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We get the syntax error with an expression that is most likely the third expression—that
    is, `expr $a * $b`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个语法错误，最有可能是第三个表达式，即`expr $a * $b`。
- en: To debug, we will use `set -x` before and `set +x` after `expr $a * $b`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试，在`expr $a * $b`之前使用`set -x`，之后使用`set +x`。
- en: 'Another script `partial_debugging.sh` with partial debugging is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个带有部分调试的脚本`partial_debugging.sh`如下：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following output is obtained after executing the `partial_debugging.sh`
    script:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`partial_debugging.sh`脚本后得到以下输出：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: From the preceding output, we can see that `expr $a * $b` is executed as `expr
    23 eval.sh partial_debugging.sh 6`. This means, instead of doing multiplication,
    bash is expanding the behavior of `*` as anything available in the current directory.
    So, we need to escape the behavior of the character `*` from getting expanded—that
    is, `expr $a \* $b`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中，我们可以看到`expr $a * $b`被执行为`expr 23 eval.sh partial_debugging.sh 6`。这意味着，bash在执行乘法时，扩展了`*`作为当前目录中的任何内容的行为。因此，我们需要转义字符`*`的行为，以防止其被扩展，即`expr
    $a \* $b`。
- en: 'The following script `eval_modified.sh` is a modified form of the `eval.sh`
    script:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本`eval_modified.sh`是`eval.sh`脚本的修改版本：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, the output of running `eval_modified.sh` will be as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`eval_modified.sh`的输出将如下所示：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The script runs perfectly now without any errors.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本现在可以完美运行而不会出现任何错误。
- en: Other than what we have learned in debugging, you can also use the `bashdb`
    debugger for even better debugging of the shell script. The source code and documentation
    for `bashdb` can be found at [http://bashdb.sourceforge.net/](http://bashdb.sourceforge.net/).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在调试中学到的内容，您还可以使用`bashdb`调试器来更好地调试shell脚本。`bashdb`的源代码和文档可以在[http://bashdb.sourceforge.net/](http://bashdb.sourceforge.net/)找到。
- en: Command completion
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令完成
- en: 'While working on a command line, everyone has to do a common task such as typing,
    which includes commands, its options, input/output file path, and other arguments.
    Sometimes, we write a wrong command name because of a spelling error in the command
    name. Also, typing a long file path will be very difficult to remember. For example,
    if we want to look recursively into the contents of a directory present at the
    path `/dir1/dir2/dir3/dir4/dir5/dir6`, we will have to run the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行上工作时，每个人都必须执行一些常见任务，比如输入命令、选项、输入/输出文件路径和其他参数。有时，由于命令名称中的拼写错误，我们会写错命令名称。此外，输入一个很长的文件路径将很难记住。例如，如果我们想要递归查看路径为`/dir1/dir2/dir3/dir4/dir5/dir6`的目录的内容，我们将不得不运行以下命令：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We can see that the path of this directory is very long and there is a high
    chance of making an error while typing the full path. Due to these issues, working
    on a command line will take a longer time than expected.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个目录的路径非常长，很容易在输入完整路径时出错。由于这些问题，使用命令行将花费比预期更长的时间。
- en: To solve all these problems, shell supports a very nice feature called command
    completion. Along with the other shell, bash also has a very good support of command
    completion.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决所有这些问题，shell支持一个非常好的功能，称为命令完成。除了其他shell外，bash也非常好地支持命令完成。
- en: Most of the Linux distributions, for example, Fedora, Ubuntu, Debian, and CentOS
    have a pre-installed bash completion for core commands. If not available, it can
    be downloaded using the corresponding distribution package manager with the package
    name `bash-completion`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Linux发行版，例如Fedora、Ubuntu、Debian和CentOS，都预先安装了核心命令的bash完成。如果没有可用，可以使用相应的发行版软件包管理器下载，软件包名称为`bash-completion`。
- en: Command completion in shell allows you to autocomplete the rest of the characters
    of the partially typed command, suggesting possible options associated with the
    given command. It also suggests and autocompletes the partially typed file path.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: shell中的命令完成允许您自动完成部分输入的命令的其余字符，提供与给定命令相关的可能选项。它还建议并自动完成部分输入的文件路径。
- en: To enable autocompletion feature in bash, the *Tab* key is used. While typing
    a command, a single `TAB` autocompletes the command if the single command matches,
    and double `[TAB]` lists all the possible commands starting with a partially typed
    command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要在bash中启用自动完成功能，使用*Tab*键。在输入命令时，如果单个命令匹配，单个`TAB`将自动完成命令，双[TAB]将列出所有以部分输入的命令开头的可能命令。
- en: 'For example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, suppose we want to see the contents of the `/usr/share/man/` directory,
    we will have to type `ls /usr/share/man/`. Using bash completion, type the following
    command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要查看`/usr/share/man/`目录的内容，我们将不得不输入`ls /usr/share/man/`。使用bash完成，输入以下命令：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Bash completion will auto-complete the missing partial path and the command
    will become:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Bash完成将自动完成缺少的部分路径，命令将变为：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Managing bash completion with complete
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用complete管理bash完成
- en: The `complete` is a shell builtin that can be used to see the available bash
    completion specification for the available commands in a system. It is also used
    to modify, delete, and create bash completion.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`complete`是一个内置的shell，可用于查看系统中可用命令的bash完成规范。它还用于修改、删除和创建bash完成。'
- en: Viewing the existing bash completion
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看现有的bash完成
- en: 'To know the existing bash completion, use the `complete` command with or without
    the`–p` option:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解现有的bash完成，请使用`complete`命令，带有或不带`-p`选项：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following are some of the outputs of the preceding command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述命令的一些输出：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To see bash completion on these commands, type the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要在这些命令上看到bash完成，输入以下命令：
- en: 'This lists all files/directories, including hidden files/directories:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出所有文件/目录，包括隐藏的文件/目录：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This lists all files/directories, including hidden files/directories:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出所有文件/目录，包括隐藏的文件/目录：
- en: $ cat [TAB][TAB]
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: $ 猫[TAB][TAB]
- en: This tries to list all the available commands in a system. Pressing *y* will
    display commands and *n* will display nothing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这尝试列出系统中所有可用的命令。按下*y*将显示命令，按下*n*将不显示任何内容。
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Modifying default bash completion behavior
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改默认的bash完成行为
- en: We can also modify the existing bash completion behavior of a given command
    using the complete shell builtin command.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用complete shell内置命令修改给定命令的现有bash完成行为。
- en: 'The following command is used to change the behavior of the `which` command
    to not display any options:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令用于更改`which`命令的行为，不显示任何选项：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following command is used to change the `ls` command tab behavior to show
    only the directories list as bash completion:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令用于更改`ls`命令的标签行为，仅显示目录列表作为bash完成：
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Removing bash completion specification
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除bash完成规范
- en: We can remove bash completion specification for a command using the shell builtin
    `complete` with the `–r` option.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用shell内置的`complete`命令和`-r`选项删除命令的bash完成规范。
- en: 'The syntax is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Consider the following as an example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容视为示例：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If no `command_name` is given as an argument to complete `-r`, all the completion
    specifications are removed:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有给出`command_name`作为`complete -r`的参数，所有完成规范都将被删除：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Writing bash completion for your own application
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为自己的应用程序编写bash完成
- en: The bash-completion package doesn't provide autocompletion feature for any external
    tools. Suppose that we want to create a tool that has multiple options and arguments.
    To add a bash-completion feature to its options, we will have to create our own
    bash completion file and source into it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: bash-completion包不为任何外部工具提供自动完成功能。假设我们想创建一个具有多个选项和参数的工具。要为其选项添加bash完成功能，我们必须创建自己的bash完成文件并将其源化。
- en: 'For example, package managers such as `dnf` and `apt-get` have its own bash
    completion file to support autocompletion for its options:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，软件包管理器如`dnf`和`apt-get`都有自己的bash完成文件，以支持其选项的自动完成：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Consider the following shell script as an example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下shell脚本视为示例：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To know about the supported options in `bash_completion_example.sh`, we will
    run the `--help` option:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解`bash_completion_example.sh`中支持的选项，我们将运行`--help`选项：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: So, the supported options are `-h`, `--help`, `-v`, `--version`, `-p`, and `--print`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，支持的选项是`-h`，`--help`，`-v`，`--version`，`-p`和`--print`。
- en: 'To write bash completion, information of the following bash internal variables
    are required:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写bash完成，需要以下bash内部变量的信息：
- en: '| Bash variables | Description |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| Bash变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `COMP_WORDS` | An array of words that is typed on the command line |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `COMP_WORDS` | 在命令行上键入的单词数组 |'
- en: '| `COMP_CWORD` | An index of the word containing the current cursor position.
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `COMP_CWORD` | 包含当前光标位置的单词的索引。 |'
- en: '| `COMPREPLY` | An array that holds the completion results that get displayed
    after pressing [TAB][TAB] |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `COMPREPLY` | 一个数组，它保存在按下[TAB][TAB]后显示的完成结果 |'
- en: The `compgen` is a shell builtin command that displays the possible completions
    depending on the options. It is used in shell functions to generate possible completions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`compgen`是一个内置的shell命令，根据选项显示可能的完成。它用于在shell函数中生成可能的完成。'
- en: An example of bash completion
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: bash完成的示例
- en: 'A bash-completion file for our shell script `bash_completion_example` will
    be as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的shell脚本`bash_completion_example`的bash完成文件将如下所示：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As per convention, a bash-completion function name should start with an underscore
    (_) followed by the name of the application—that is, `_bash_completion_example`.
    Furthermore, we reset the bash variable `COMPREPLY` to clean up any previous left
    out data. Then, we declare and set the `cur` variable to the current word of the
    command line and the `prev` variable to the previous word in the command line.
    Another variable `opts` is declared and initialized with all the options that
    are recognized by an application; in our case, they are `-h -v -p --help --verbose
    –print`. The condition `if [[ ${cur} == -* ]]` checks whether the current word
    is equal to `-*` because our option starts with `-` followed by any other character.
    If `true`, then display all the matching options using the `compgen` shell builtin
    with the `-W` option.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 根据惯例，bash完成函数名称应以下划线(_)开头，后跟应用程序的名称，即`_bash_completion_example`。此外，我们将bash变量`COMPREPLY`重置为清除任何先前遗留的数据。然后，我们声明并设置`cur`变量为命令行的当前单词，`prev`变量为命令行中的前一个单词。另一个变量`opts`被声明并初始化为应用程序识别的所有选项；在我们的情况下，它们是`-h
    -v -p --help --verbose –print`。条件`if [[ ${cur} == -* ]]`检查当前单词是否等于`-*`，因为我们的选项以`-`开头，后跟任何其他字符。如果为`true`，则使用`compgen`
    shell内置和`-W`选项显示所有匹配的选项。
- en: Running the created bash completion
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行创建的bash完成。
- en: 'In order to run the created bash completion, the easiest way is to source into
    `source bash_completion_example shell script` and then run the script or command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行创建的bash完成，最简单的方法是将其源到`source bash_completion_example shell script`，然后运行脚本或命令：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, `--p[TAB]` gets auto-completed to `-–print`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`--p[TAB]`会自动完成为`-–print`。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After reading this chapter, you should now able to write a shell script that
    can be easy to maintain and modify by others. Now, you know how to use an existing
    shell script library in your own script by using the `source` command. You also
    got familiarity with fixing errors and bugs in a shell script by making use of
    the different debugging techniques. You should also know how to write a script
    by taking command line arguments and providing bash completion features for it.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你现在应该能够编写一个易于维护和修改的shell脚本。现在，你知道如何在自己的脚本中使用现有的shell脚本库，使用`source`命令。你还熟悉了使用不同的调试技术来修复shell脚本中的错误和bug。你还应该知道如何通过接受命令行参数并为其提供bash完成功能来编写脚本。
- en: In the next chapter, we will see how to view, change, create, and delete environment
    variables in order to meet the requirement of running our applications.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何查看、更改、创建和删除环境变量，以满足运行我们的应用程序的要求。
