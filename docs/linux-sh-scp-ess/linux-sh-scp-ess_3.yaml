- en: Chapter 3. Effective Script Writing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 有效的脚本编写
- en: To write an effective script in shell, it is very important to know about the
    different utilities that shell provides. Similar to other programming languages,
    shell programming also requires a way to specify skipping or running certain commands
    under certain conditions. To perform a certain task on the list of elements, looping
    constructs are needed in shell as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要在shell中编写有效的脚本，非常重要的是要了解shell提供的不同实用工具。与其他编程语言类似，shell编程也需要一种在特定条件下指定跳过或运行某些命令的方法。在shell中也需要循环结构来执行元素列表上的某些任务。
- en: In this chapter, we will cover topics such as `if`, `else`, `case`, and `select`
    that can be used to run a certain block of commands according to the condition.
    We will see the `for`, `while`, and `until` constructs, which are used to loop
    over a certain block of commands in a script. We will see how the exit code, after
    the execution of a command or script, plays an important role in knowing whether
    a command was executed successfully or not. We will also see how a function can
    be defined in shell, which will allow us to write modular and reusable code from
    now on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖诸如`if`、`else`、`case`和`select`之类的主题，这些主题可根据条件运行一定的命令块。我们将看到`for`、`while`和`until`结构，用于在脚本中循环执行一定的命令块。我们将看到在命令或脚本执行后，退出代码如何在了解命令是否成功执行方面发挥重要作用。我们还将看到如何在shell中定义函数，从而使我们能够从现在开始编写模块化和可重用的代码。
- en: 'This chapter will cover the following topics in detail:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细介绍以下主题：
- en: Exiting from scripts and exit codes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出脚本和退出代码
- en: Testing expressions with a test
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试测试表达式
- en: Using conditional statements with `if` and `else`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`if`和`else`的条件语句
- en: Indexed arrays and associative arrays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引数组和关联数组
- en: Looping around with `for`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for`循环
- en: The `select`, `while`, and `until` loops
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select`、`while`和`until`循环'
- en: Switching to your choice
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换到您的选择
- en: Using functions and positional parameters
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数和位置参数
- en: Passing `stdout` as a parameter using `xargs`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`xargs`将`stdout`作为参数传递
- en: Aliases
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 别名
- en: '`pushd` and `popd`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pushd`和`popd`'
- en: Exiting from scripts and exit codes
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退出脚本和退出代码
- en: We are now well familiar with shell script files, commands, and running them
    in `bash` to get the desired output. Until now, whatever shell script examples
    we have seen, they run line by line until the end of the file. While writing real-world
    shell scripts, it may not always be the case. We may need to exit a script in
    between, for example, when some error occurs, doesn't satisfy a certain condition,
    and so on. To exit from the script, the `exit` shell builtin is used with an optional
    return value. The return value tells the exit code, which is also known as return
    status or exit status.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对shell脚本文件、命令以及在`bash`中运行它们以获得所需的输出非常熟悉。到目前为止，我们所见过的shell脚本示例都是按行运行直到文件末尾。在编写真实世界的shell脚本时，情况可能并非总是如此。例如，当发生错误时，不满足某些条件时等等，我们可能需要在脚本中间退出。要退出脚本，使用带有可选返回值的`exit`
    shell内置命令。返回值告诉退出代码，也称为返回状态或退出状态。
- en: Exit codes
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退出代码
- en: Every command returns an exit code when it gets executed. Exit code is one of
    the ways to know whether a command is executed successfully or if some error has
    occurred. As per the **POSIX** (**Portable Operating System Interface**) standard
    convention, a command or program with successful execution returns `0`, and `1`
    or a higher value for failed execution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令在执行时都会返回一个退出代码。退出代码是了解命令是否成功执行或是否发生了错误的一种方式。根据**POSIX**（**可移植操作系统接口**）标准约定，成功执行的命令或程序返回`0`，而失败执行返回`1`或更高的值。
- en: In bash, to see the exit status of the last command executed, we can use "`$?`".
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在bash中，要查看上一个命令的退出状态，可以使用“`$?`”。
- en: 'The following example shows the exit code of the successful command execution:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了成功执行命令的退出代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, to see the exit code of the last executed command, that is, `ls /home`,
    we will run the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要查看上一个执行的命令的退出代码，即`ls /home`，我们将运行以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We see that the exit status of the `ls` command execution is `0`, which means
    it has executed successfully.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`ls`命令执行的退出状态为`0`，这意味着它已成功执行。
- en: 'Another example showing the exit code of the unsuccessful command execution
    is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例显示了不成功执行命令的退出代码如下：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The exit status code is `2`, which is higher than `0`, representing unsuccessful
    execution.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 退出状态代码为`2`，高于`0`，表示执行不成功。
- en: Exit codes with a special meaning
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有特殊含义的退出代码
- en: 'In different situations, a different exit code is returned by a script or command.
    Knowing the meaning of the exit code is useful while debugging a script or command.
    The following table explains which exit code is conventionally returned in different
    conditions of command or script execution:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的情况下，脚本或命令返回不同的退出代码。在调试脚本或命令时，了解退出代码的含义是有用的。以下表格解释了在命令或脚本执行的不同条件下惯例返回哪个退出代码：
- en: '| Exit code | Description |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 退出代码 | 描述 |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0 | Successful execution |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 成功执行 |'
- en: '| 1 | General error |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 一般错误 |'
- en: '| 2 | Error when using shell builtin commands |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 使用shell内置命令时出错 |'
- en: '| 126 | Permission issues while executing a command; we can''t invoke the requested
    command |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 126 | 在执行命令时出现权限问题；我们无法调用请求的命令 |'
- en: '| 127 | Could not invoke requested command |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 127 | 无法调用请求的命令 |'
- en: '| 128 | Specifying invalid argument to exit in script. Only value from 0 to
    255 is valid exit code |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 128 | 在脚本中指定无效参数退出。只有0到255之间的值是有效的退出代码 |'
- en: '| 128+n | Fatal error with the signal ''n'' |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 128+n | 信号''n''的致命错误 |'
- en: '| 130 | Terminating script using Ctl + C |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 130 | 使用Ctl + C终止脚本 |'
- en: '| 255* | Out of the range exit code |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 255* | 超出范围的退出代码 |'
- en: Exit codes 0, 1, 126-165, and 255 are reserved and we should use other than
    these numbers when we return the exit code in script files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 保留退出代码0、1、126-165和255，我们在脚本文件中返回退出代码时应使用除这些数字之外的其他数字。
- en: 'The following examples show the different exit codes returned by commands:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示命令返回的不同退出代码：
- en: '**Exit code 0**: The following is the successful execution of the `echo` command:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出代码0**：以下是`echo`命令的成功执行：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Exit code 1**: Copying files from `/root` have no permissions as shown:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出代码1**：从`/root`复制文件没有权限，如下所示：'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Exit code 2**: Use read shell builtin with an invalid parameter as follows:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出代码2**：使用无效参数读取shell内置如下：'
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Exit code 126**: Run a `/usr/bin` directory as a command that is actually
    not a command:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出代码126**：将`/usr/bin`目录作为实际上不是命令的命令运行：'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Exit code 127**: Run a command named `foo` that is not actually present in
    the system:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出代码127**：运行一个名为`foo`的命令，实际上并不存在于系统中：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Exit code 128+n**: Terminate a script by pressing *Ctrl* + *C*:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出代码128+n**：通过按*Ctrl* + *C*终止脚本：'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, *Ctrl* + *C* sends the `SIGQUIT` signal whose value is `2`. So, the exit
    code is `130` (128 + 2).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*Ctrl* + *C*发送`SIGQUIT`信号，其值为`2`。因此，退出代码为`130`（128 + 2）。
- en: Script with exit codes
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有退出代码的脚本
- en: We can also exit shell builtin along with an exit code to know whether a script
    ran successfully or it encountered any error. Different error codes can be used
    to know the actual reason of an error while debugging your own script.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以退出shell内置命令，并附带退出代码，以了解脚本是否成功运行或遇到任何错误。在调试自己的脚本时，可以使用不同的错误代码来了解错误的实际原因。
- en: 'When we don''t provide any exit code in a script, the exit code of the script
    is determined by the last executed command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在脚本中不提供任何退出代码时，脚本的退出代码由最后执行的命令决定：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding script doesn''t specify any exit code; running this script will
    give the following output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本没有指定任何退出代码；运行此脚本将得到以下输出：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The exit code of this script is `1` because we didn't specify any exit code
    and the last executed command was `cd /root`, which failed due to a permission
    issue.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的退出代码为`1`，因为我们没有指定任何退出代码，最后执行的命令是`cd /root`，由于权限问题而失败。
- en: 'Taking the next example that returns the exit code `0`, irrespective of any
    error that occurs—that is, script ran successfully:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的示例返回退出代码`0`，无论发生任何错误，即脚本成功运行：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Running this script will give the following result:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本将得到以下结果：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, the script file returns the exit code as `0`. We now know what a difference
    adding an exit code in script can make.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，脚本文件返回退出代码为`0`。我们现在知道在脚本中添加退出代码会有什么不同。
- en: 'Another example with the exit status code is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个具有退出状态代码的示例如下：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output after running this script is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后的输出如下：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If no exit code is specified in a script, the exit code will be the exit status
    of the last command ran in the script.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在脚本中未指定退出代码，则退出代码将是脚本中运行的最后一个命令的退出状态。
- en: Testing expressions with a test
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试检查测试表达式
- en: The shell builtin command `test` can be used to check file types and compare
    expressions value. The syntax is `test EXPRESSION` or the `test` command is also
    equivalent to **[ EXPRESSION ]**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: shell内置命令`test`可用于检查文件类型和比较表达式的值。语法为`test EXPRESSION`或`test`命令也等同于**[ EXPRESSION
    ]**。
- en: It returns the exit code `1` (`false`) if the `EXPRESSION` result is `0`, and
    `0` (`true`) for a non-zero `EXPRESSION` result.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“EXPRESSION”结果为“0”，则返回退出代码`1`（`false`），对于非零的“EXPRESSION”结果，返回`0`（`true`）。
- en: If no `EXPRESSION` is provided, the exit status is set to `1` (false).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未提供`EXPRESSION`，则退出状态设置为`1`（false）。
- en: File checks
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件检查
- en: Different kinds of checks can be done on the file using the `test` command;
    for example, file existence test, directory test, regular file check, symbolic
    link check, and so on.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`test`命令对文件进行不同类型的检查；例如，文件存在性检查，目录检查，常规文件检查，符号链接检查等。
- en: 'The options available to do various checks on a file are explained in the following
    table:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下表格中的选项对文件进行各种检查：
- en: '| Option | Description |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| -e | fileChecks whether the file exists |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| -e | fileChecks文件是否存在 |'
- en: '| -f file | The file is a regular fil |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| -f file | 文件是常规文件 |'
- en: '| -d file | The file exists and is a directory |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| -d file | 文件存在且为目录 |'
- en: '| -h, -L file | The file is a symbolic link |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| -h，-L file | 文件是符号链接 |'
- en: '| -b file | The file is block special |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| -b file | 文件是块特殊文件 |'
- en: '| -c file | The file is character special |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| -c file | 文件是字符特殊文件 |'
- en: '| -S file | The file is a socket |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| -S file | 文件是套接字 |'
- en: '| -p file | The file is a named pipe |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| -p file | 文件是命名管道 |'
- en: '| -k file | Sticky bit of the file is set |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| -k file | 文件的粘着位已设置 |'
- en: '| -g file | set-group-ID (sgid) bit of the file is set |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| -g file | 文件的设置组ID（sgid）位已设置 |'
- en: '| -u file | set-user-id (suid) bit of the file is set |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| -u file | 文件的设置用户ID（suid）位已设置 |'
- en: '| -r file | Read permission on the file exists |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| -r file | 文件具有读权限 |'
- en: '| -w file | Write permission on the file exists |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| -w file | 文件具有写权限 |'
- en: '| -x file | Execute permission on the file exists |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| -x file | 文件具有执行权限 |'
- en: '| -t fd | File descriptor fd is open on terminal |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| -t fd | 文件描述符fd在终端上打开 |'
- en: '| file1 -ef file2 | file1 is hard link to file2 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| file1 -ef file2 | file1是file2的硬链接 |'
- en: '| file1 -nt file2 | file1 is more recent compared to file2 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| file1 -nt file2 | file1比file2更近 |'
- en: '| file1 -ot file2 | The modification time of file1 is older than file2 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| file1 -ot file2 | file1的修改时间早于file2 |'
- en: 'Shell script performs different checks on the files as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本对文件执行不同的检查，如下所示：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of running this script is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本的输出如下：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In our output, `0` and `1` are the `exist` status after running a test command
    on files. The output `1` means the test failed and `0` means the test was successfully
    passed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的输出中，`0`和`1`是在文件上运行测试命令后的`存在`状态。输出`1`表示测试失败，`0`表示测试成功通过。
- en: Arithmetic checks
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术检查
- en: 'We can also perform arithmetic checks between integer numbers. Comparison possible
    on integers is explained to following table:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在整数之间执行算术检查。可以在整数上进行的比较在以下表中解释：
- en: '| Comparison | Description |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | 描述 |'
- en: '| --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `INTEGER1 -eq INTEGER2` | INTEGER1 is equal to INTEGER2 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `INTEGER1 -eq INTEGER2` | INTEGER1等于INTEGER2 |'
- en: '| `INTEGER1 -ne INTEGER2` | INTEGER1 is not equal to INTEGER2 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `INTEGER1 -ne INTEGER2` | INTEGER1不等于INTEGER2 |'
- en: '| `INTEGER1 -gt INTEGER2` | INTEGER1 is greater than INTEGER2 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `INTEGER1 -gt INTEGER2` | INTEGER1大于INTEGER2 |'
- en: '| `INTEGER1 -ge INTEGER2` | INTEGER1 is greater than or equal to INTEGER2 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `INTEGER1 -ge INTEGER2` | INTEGER1大于或等于INTEGER2 |'
- en: '| `INTEGER1 -lt INTEGER2` | INTEGER1 is lesser than INTEGER2 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `INTEGER1 -lt INTEGER2` | INTEGER1小于INTEGER2 |'
- en: '| `INTEGER1 -le INTEGER2` | INTEGER1 is lesser than or equal to INTEGER2 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `INTEGER1 -le INTEGER2` | INTEGER1小于或等于INTEGER2 |'
- en: 'Shell script shows various arithmetic checks between two integers as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本显示了两个整数之间的各种算术检查，如下所示：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of running this script is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后的输出如下：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Also, here the test returns the exit status after running a comparison test
    between integers, and returns `0` (true) on success and `1` (false) if the test
    fails.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此处的测试在整数之间运行比较测试后返回退出状态，并在成功时返回`0`（true），在测试失败时返回`1`（false）。
- en: String checks
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串检查
- en: 'A command test also allows you to perform checks on and between strings. The
    possible checks are described in the following table:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 命令测试还允许您对字符串进行检查。可能的检查在下表中描述：
- en: '| Comparison | Description |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | 描述 |'
- en: '| --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `-z STRING` | The length of the string is zero |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `-z STRING` | 字符串的长度为零 |'
- en: '| `-n STRING` | The length of the string is non-zero |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `-n STRING` | 字符串的长度不为零 |'
- en: '| `STRING1 = STRING2` | STRING1 and STRING2 are equal |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `STRING1 = STRING2` | STRING1和STRING2相等 |'
- en: '| `SRING1 != STRING2` | STRING1 and STRING2 are not equal |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `SRING1 != STRING2` | STRING1和STRING2不相等 |'
- en: 'Shell script shows various string checks on and between strings as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本显示了字符串之间的各种字符串检查，如下所示：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of running this script is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后的输出如下：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, the test returns `0` exit status if the string checks are true, else returns
    `1`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果字符串检查为真，则测试返回`0`退出状态，否则返回`1`。
- en: Expression checks
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式检查
- en: 'The `test` command also allows you to perform checks on and between expressions.
    An expression itself can contain multiple expressions to evaluate as well. The
    possible checks done are explained in the following table:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`命令还允许您对表达式进行检查。表达式本身也可以包含多个要评估的表达式。可能的检查如下表所示：'
- en: '| Comparison | Description |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | 描述 |'
- en: '| --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `( EXPRESSION )` | This EXPRESSION is true |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `( EXPRESSION )` | 此表达式为真 |'
- en: '| `! EXPRESSION` | This EXPRESSION is false |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `! EXPRESSION` | 此表达式为假 |'
- en: '| `EXPRESSION1 -a EXPRESSION2` | Both the expressions are true (the AND operation)
    |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `EXPRESSION1 -a EXPRESSION2` | 两个表达式都为真（AND操作） |'
- en: '| `EXPRESSION1 -o EXPRESSION2` | Either one of the expressions is true (the
    OR operation) |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `EXPRESSION1 -o EXPRESSION2` | 两个表达式中的一个为真（OR操作） |'
- en: 'Shell script shows various string checks on and between strings as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本显示了字符串之间的各种字符串检查，如下所示：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of running this script is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本的输出如下：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Similar to other checks with the `test` command, the `0` exit code means the
    expression evaluated is true and `1` means false evaluation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与`test`命令的其他检查类似，`0`退出代码表示表达式评估为真，`1`表示评估为假。
- en: Using conditional statements with if and else
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用if和else的条件语句
- en: Shell provides `if` and `else` to run conditional statements depending upon
    whether the evaluation is `true` or `false`. It is useful if we want to perform
    certain tasks only if a certain condition is `true`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Shell提供了`if`和`else`，根据评估是`true`还是`false`来运行条件语句。如果我们只想在某个条件为`true`时执行某些任务，这将非常有用。
- en: The test condition to if can be given using a test condition or [condition].
    We have already learned multiple use cases and examples of testing an expression
    in the previous section, *Testing expressions with a test*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: if的测试条件可以使用测试条件或[条件]给出。我们已经在上一节*使用测试测试表达式*中学习了多个用例和示例。
- en: Simple if and else
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的if和else
- en: 'The syntax of the `if` condition is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`条件的语法如下：'
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If `conditional_expression` is `true`—that is, the exit status is `0`—then the
    statements inside it get executed. If not, then it will be just be ignored and
    the next line after `fi` will be executed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`conditional_expression`为`true`——也就是说，退出状态为`0`——那么其中的语句将被执行。如果不是，则它将被忽略，`fi`后的下一行将被执行。
- en: 'The syntax of `if` and `else` is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`和`else`的语法如下：'
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Sometimes, when a condition is not true, we might want to execute some statements.
    In such cases, use `if` and `else`. Here, if `conditional_statement` is true,
    statements within if get executed. Otherwise, statements within else will be executed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当条件不成立时，我们可能希望执行一些语句。在这种情况下，使用`if`和`else`。在这里，如果`conditional_statement`为真，则if内的语句将被执行。否则，else内的语句将被执行。
- en: 'The following shell script prints the message if a file exists:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本在文件存在时打印消息：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output after running the script is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后的输出如下：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another example shows the greater one among two integers as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例显示了两个整数中的较大者，如下所示：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the output after running the script:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后的输出如下：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The if, elif, and else statements
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if、elif和else语句
- en: 'In some cases, more than two choices exist, of which only one needs to be executed.
    The `elif` allows you to use another `if` condition instead of using `else` if
    a condition is not true. The syntax is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，存在超过两个选择，其中只有一个需要执行。`elif`允许您在条件不成立时使用另一个`if`条件，而不是使用`else`。语法如下：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following shell script will make the `elif` usage more clear. This script
    asks a user to input a valid file or directory name with the absolute path. On
    a valid regular file or directory, it displays the following content:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本将使`elif`的用法更清晰。此脚本要求用户输入带有绝对路径的有效文件或目录名称。对于有效的常规文件或目录，它显示以下内容：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output after running the script is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后的输出如下：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Nested if
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套if
- en: 'In many cases, multiple `if` conditions are required because the execution
    of a condition depends upon the result of another condition. The syntax will be
    as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，需要多个`if`条件，因为条件的执行取决于另一个条件的结果。 语法如下：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following script example explains the nested `if` in more detail. In this
    script, we will see how to find the greatest one of the three integer values:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本示例更详细地解释了嵌套的`if`。 在此脚本中，我们将看到如何找到三个整数值中的最大值：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output after running the script will be as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后的输出如下：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Indexed arrays and associative arrays
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引数组和关联数组
- en: Bash provides a feature to declare a list (or array) of variables in a one-dimensional
    array that can be an indexed array or associative array. The size of an array
    can be `0` or more.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Bash提供了一个声明变量列表（或数组）的功能，可以是索引数组或关联数组的一维数组。 数组的大小可以是`0`或更多。
- en: Indexed arrays
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引数组
- en: An indexed array contains variables that may or may not have been initialized
    continuously. Indices of an indexed array start from `0`. This means that the
    first element of an array will start at an index `0`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 索引数组包含可能已初始化或未初始化的变量。 索引数组的索引从`0`开始。 这意味着数组的第一个元素将从索引`0`开始。
- en: Array declaration and value assignment
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组声明和赋值
- en: 'An indexed array can be declared by just initializing any index as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过初始化任何索引来声明索引数组，如下所示：
- en: '`array_name[index]=value`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_name[index]=value`'
- en: Here, an index can be any positive integer or an expression must be evaluated
    to a positive integer.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，索引可以是任何正整数，或者表达式必须评估为正整数。
- en: 'Another way of declaring is by using the `declare` shell built in as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种声明方式是使用内置的`declare` shell，如下所示：
- en: '`declare -a array_name`'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`declare -a array_name`'
- en: 'We can also initialize an array with values during a declaration. Values are
    enclosed within parentheses and each value is separated with a blank space as
    follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在声明时使用值初始化数组。 值用括号括起来，每个值用空格分隔，如下所示：
- en: '`declare -a array_name=(value1 value2 value3 …)`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`declare -a array_name=(value1 value2 value3 …)`'
- en: Operations on arrays
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组的操作
- en: Initializing and declaring values to a variable is not sufficient. The actual
    usage of an array is when we perform different operations on it to get the desired
    result.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化和声明变量的值是不够的。 当我们对其执行不同的操作以获得所需的结果时，数组的实际用法才体现出来。
- en: 'The following operations can be done on an indexed array:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对索引数组执行以下操作：
- en: 'Accessing an array element by an index: An element of an array can be accessed
    by referring to its index value:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过索引访问数组元素：可以通过引用其索引值来访问数组的元素：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Printing the array''s contents: The contents of an array can be printed if
    an index of an array is given as `@` or `*`:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印数组的内容：如果给出数组的索引为`@`或`*`，则可以打印数组的内容：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Obtaining the length of an array: The length of an array can be obtained using
    `$#` with the array variable:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数组的长度：可以使用带有数组变量的`$#`获取数组的长度：
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Obtaining the length of an array element: The length of an array element can
    be obtained using `$#` on nth index:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数组元素的长度：可以使用`$#`获取第n个索引的数组元素的长度：
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Deleting an element or an entire array: An element can be removed from an array
    using the `unset` keyword:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除元素或整个数组：可以使用`unset`关键字从数组中删除元素：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following shell script demonstrates the different operations on an indexed
    array:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本演示了对索引数组的不同操作：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output after executing this script is as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本后的输出如下：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The associative array
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联数组
- en: The associative array contains a list of elements in which each element has
    a key-value pair. The elements of an associative array are not referred by using
    an integer value `0` to `N`. It is referred by providing a key name that contains
    a corresponding value. Each key name should be unique.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 关联数组包含一个元素列表，其中每个元素都有一个键值对。 关联数组的元素不是通过使用整数值`0`到`N`来引用的。 它是通过提供包含相应值的键名来引用的。
    每个键名都应该是唯一的。
- en: The declaration and value assignment
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明和赋值
- en: 'The declaration of an associative array is done by using the `-A` option with
    the `declare` shell builtin as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`declare` shell内置的`-A`选项进行关联数组的声明如下：
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'An associate array uses a key instead of an index within a square bracket in
    order to initialize a value as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 关联数组使用键而不是索引在方括号中初始化值，如下所示：
- en: '[PRE44]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Multiple values can be initialized in the following way:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以以下方式初始化多个值：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Operations on arrays
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组的操作
- en: 'A few operations on an associative array can be done similar to how an indexed
    array does, such as printing the length and content of an array. The operations
    are as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 关联数组的一些操作与索引数组类似，例如打印数组的长度和内容。 操作如下：
- en: 'Accessing an array element by the key name; to access an element of an associative
    array, use a unique key as follows:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过键名访问数组元素；要访问关联数组的元素，请使用唯一键，如下所示：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Printing associative array content: The following syntax is used to print an
    associative array:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印关联数组内容：使用以下语法打印关联数组：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Getting the value and length of a given key:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取给定键的值和长度：
- en: '[PRE48]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Adding a new element; to add a new element in an associative array, use the
    `+=` operator as follows:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新元素；要在关联数组中添加新元素，请使用`+=`运算符，如下所示：
- en: '[PRE49]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Deleting an element of an associative array with the `k` key as follows:'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`k`键删除关联数组的元素如下：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Deleting an associative array `array_name` as follows:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除关联数组`array_name`如下：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following shell script demonstrates the different operations on an associative
    array:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本演示了关联数组的不同操作：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output after executing this script is as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本后的输出如下：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Looping around with for
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用for循环
- en: The `for` loop can be used to iterate over the items in a list or till the condition
    is true.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环可用于遍历列表中的项目或直到条件为真。'
- en: 'The syntax of using the `for` loop in bash is as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在bash中使用`for`循环的语法如下：
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Another way of writing the `for` loop is the way C does, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种编写`for`循环的方式是C的方式，如下所示：
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, `expr1` is initialization, `expr2` is condition, and `expr3` is increment.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`expr1`是初始化，`expr2`是条件，`expr3`是增量。
- en: Simple iteration
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单迭代
- en: 'The following shell script explains how we can use the `for` loop to print
    the values of a list:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本解释了如何使用`for`循环打印列表的值：
- en: '[PRE56]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output of the script is as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的输出如下：
- en: '[PRE57]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Iterating over a command output
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代命令输出
- en: We know that a lot of commands give multiline output such as `ls`, `cat`, `grep`,
    and so on. In many cases, it makes sense to loop over each line of output and
    do further processing on them.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道很多命令会给出多行输出，比如`ls`、`cat`、`grep`等。在许多情况下，循环遍历每行输出并对其进行进一步处理是有意义的。
- en: 'The following example loops over the content of ''`/`'' and prints directories:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例循环遍历'`/`'的内容并打印目录：
- en: '[PRE58]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output after running this script is as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后的输出如下：
- en: '[PRE59]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Specifying a range to the for loop
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为for循环指定范围
- en: 'We can also specify a range of integers in the `for` loop with an optional
    increment value for it:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`for`循环中指定整数范围，并为其指定可选的增量值：
- en: '[PRE60]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output after running this script is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后的输出如下：
- en: '[PRE61]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Small and sweet for loop
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小巧的for循环
- en: In some cases, we don't want to write a script and then execute it; rather,
    we prefer to do a job in shell itself. In such cases, it is very useful and handy
    to write the complete for loop in one line, rather than making it multiline.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们不想编写脚本然后执行它；相反，我们更喜欢在shell中完成工作。在这种情况下，将完整的for循环写在一行中非常有用和方便，而不是将其变成多行。
- en: 'For example, printing the multiples of 3 between 3 to 20 numbers can be done
    with the following code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，打印3到20之间3的倍数可以使用以下代码完成：
- en: '[PRE62]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The select, while, and until loops
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择、while和until循环
- en: The `select`, `while` and `until` loops are also used to loop and iterate over
    each item in a list or till the condition is true with slight variations in syntax.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`、`while`和`until`循环也用于循环和迭代列表中的每个项目，或者在条件为真时进行轻微变化的语法。'
- en: Loop using select
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用select循环
- en: The select loop helps in creating a numbered menu in an easy format from which
    a user can select one or more options.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 选择循环有助于以简单格式创建带编号的菜单，用户可以从中选择一个或多个选项。
- en: 'The syntax of the `select` loop is as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`循环的语法如下：'
- en: '[PRE63]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `list` can be pre-generated or specified while using the `select` loop in
    the form `[item1 item2 item3 …]`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`可以在使用`select`循环时预先生成或指定为`[item1 item2 item3 …]`的形式。'
- en: 'For example, consider a simple menu listing the contents of ''`/`'' and asking
    a user to enter an option for which you want to know whether it is a directory
    or not:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个简单的菜单，列出'`/`'的内容，并要求用户输入一个选项，以便知道它是否是一个目录：
- en: '[PRE64]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following is the screenshot of the output after running the script:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后的输出如下：
- en: '![Loop using select](img/4335_03_01.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![使用select循环](img/4335_03_01.jpg)'
- en: To exit from the script, press *Ctrl* + *C*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出脚本，请按*Ctrl* + *C*。
- en: The while loop
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while循环
- en: 'The `while` loop allows you to do repetitive tasks until the condition is true.
    The syntax is very similar to what we have in the C and C++ programming language,
    which is as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环允许您重复任务，直到条件为真。语法与C和C++编程语言中的语法非常相似，如下所示：'
- en: '[PRE65]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'For example, read the name of the application and display pids of all the running
    instances of that application, as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，读取应用程序的名称并显示该应用程序所有运行实例的pids，如下所示：
- en: '[PRE66]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output after running this script is as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后的输出如下：
- en: '[PRE67]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: To exit from the script, press *Ctrl* + *C*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出脚本，请按*Ctrl* + *C*。
- en: The until loop
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直到循环
- en: 'The `until` loop is very similar to the `while` loop, but the only difference
    is that it executes code block until the condition executes to false. The syntax
    of `until` is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`until`循环与`while`循环非常相似，但唯一的区别是它执行代码块，直到条件执行为false。`until`的语法如下：'
- en: '[PRE68]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: For example, consider that we are interested in knowing `pid` of an application
    whenever any instance of it is running. For this, we can use `until` and check
    `pidof` of an application at a certain interval using `sleep`. When we find `pid`,
    we can exit from the `until` loop and print `pid` of the running instance of the
    application.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有兴趣知道应用程序的`pid`，每当它的任何实例正在运行时。为此，我们可以使用`until`并使用`sleep`在一定间隔内检查应用程序的`pidof`。当我们找到`pid`时，我们可以退出`until`循环并打印应用程序运行实例的`pid`。
- en: 'The following shell script demonstrates the same:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本演示了相同的内容：
- en: '[PRE69]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The output after executing this script is as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此脚本后的输出如下：
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Switch to my choice
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换到我的选择
- en: Switch is used to jump and run a certain case as per the result of the condition
    or expression is evaluated. It acts as an alternative to using multiple **if**
    in bash and keeps bash script much clear and readable.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Switch用于根据条件或表达式的结果跳转和运行特定的case。它作为在bash中使用多个**if**的替代方案，并使bash脚本更清晰和可读。
- en: 'The syntax of `switch` is as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`的语法如下：'
- en: '[PRE71]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In syntax, `$variable` is the expression or value that needs to be matched among
    the list of choices provided.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法中，`$variable`是需要在提供的选择列表中匹配的表达式或值。
- en: In each choice, a pattern or a combination of patterns can be specified. The
    `;;` tells bash that end of given choice block. The `esac` keyword specify end
    of case block.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个选择中，可以指定一个模式或模式的组合。`;;`告诉bash给定选择块的结束。`esac`关键字指定case块的结束。
- en: 'The following is an example to count the number of files and directories in
    a given path:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，用于计算给定路径中文件和目录的数量：
- en: '[PRE72]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output after running this script is as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后的输出如下：
- en: '[PRE73]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In this example, we first read an input path from a user using the `read` shell
    builtin. Then, we initialize the counter variable of files and directories count
    to `0`. Furthermore, we use `ls -l $path | cut -d ' ' -f1` to get a long list
    of file attributes of the path content and then retrieve its first column. We
    know that the first character of the first column of `ls -l` tells the type of
    the file. If it is `d`, then it is a directory, and `-` represents a regular file.
    The `dirs_count` or `files_count` variables get incremented accordingly.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先使用`read` shell内置命令从用户那里读取输入路径。然后，我们将文件和目录计数的计数变量初始化为`0`。此外，我们使用`ls
    -l $path | cut -d ' ' -f1`来获取路径内容的文件属性的长列表，然后检索其第一列。我们知道`ls -l`的第一列的第一个字符表示文件的类型。如果是`d`，那么它是一个目录，`-`表示一个常规文件。`dirs_count`或`files_count`变量相应地递增。
- en: Passing stdout as a parameter using xargs
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用xargs传递stdout作为参数
- en: 'The `xargs` command is used to build and execute a command line from a standard
    input. Commands such as `cp`, `echo`, `rm`, `wc`, and so on, don''t take input
    from a standard input or redirected output from another command. In such commands,
    we can use `xargs` to provide an input as an output of another command. The syntax
    is as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令用于从标准输入构建和执行命令行。诸如`cp`、`echo`、`rm`、`wc`等命令不从标准输入获取输入，也不从另一个命令的重定向输出获取输入。在这样的命令中，我们可以使用`xargs`将输入作为另一个命令的输出。语法如下：'
- en: '`xargs [option]`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs [option]`'
- en: 'Some of options are explained in the following table:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格解释了一些选项：
- en: '| Option | Description |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| -`a` file | This reads items from a file instead of stdin |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| -`a` file | 这从文件中读取项目，而不是从stdin中读取 |'
- en: '| `-0`, `--null` | Inputs are null-terminated instead of whitespace |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `-0`, `--null` | 输入以空字符而不是空格终止 |'
- en: '| `-t`, `--verbose` | Prints a command line on a standard output before executing
    |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `-t`, `--verbose` | 在执行之前在标准输出上打印命令行 |'
- en: '| `--show-limits` | This displays the limit on the length of the command line
    imposed by OS |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `--show-limits` | 这显示操作系统强加的命令行长度限制 |'
- en: '| `-P max-procs` | Runs upto the max-procs processes one at a time |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `-P max-procs` | 一次运行最多max-procs个进程 |'
- en: '| `-n max-args` | This at most uses the max-args argument per command line
    |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `-n max-args` | 最多使用每个命令行的max-args参数 |'
- en: Basic operations with xargs
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用xargs的基本操作
- en: 'The `xargs` command can be used without any option. It allows you to enter
    an input from stdin, and when `ctrl + d` is called, it prints whatever was typed:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`xargs`命令可以不带任何选项。它允许您从stdin输入，并在调用`ctrl + d`时打印输入的任何内容：'
- en: '[PRE74]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `--show-limits` option can be used to know the limit of the command line
    length:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`--show-limits`选项可用于了解命令行长度的限制：'
- en: '[PRE75]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Using xargs to find a file with the maximum size
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用xargs查找具有最大大小的文件
- en: 'The following shell script will explain how `xargs` can be used to get a file
    with the maximum size in a given directory recursively:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本将解释如何使用`xargs`递归地获取给定目录中具有最大大小的文件：
- en: '[PRE76]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output after running this script is as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后的输出如下：
- en: '[PRE77]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this example, we are using `xargs` to pass each regular file obtained from
    the `find` command for size calculation. Furthermore, the output of `du` is redirected
    to the `sort` command for a human-numeric sort and then we can print the last
    line or sort to get the file with a maximum size.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`xargs`将从`find`命令获取的每个常规文件传递给大小计算。此外，`du`的输出被重定向到`sort`命令进行人类数字排序，然后我们可以打印最后一行或排序以获得具有最大大小的文件。
- en: Archiving files with a given pattern
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用给定模式归档文件
- en: Another useful example of using `xargs` is to archive all the files that we
    are interested in, and these files can be kept as back files.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`xargs`的另一个有用的例子是归档我们感兴趣的所有文件，并将这些文件作为备份文件保留。
- en: 'The following shell script finds all the shell script in a specified directory
    and creates `tar` of it for further reference:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本在指定目录中查找所有的shell脚本，并为进一步参考创建`tar`文件：
- en: '[PRE78]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output after running the script is as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本后的输出如下：
- en: '[PRE79]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In this example, all the files with an extension `.sh` are searched and passed
    as parameters to the `tar` command to create an archive. The file `scripts.tar`
    is created in the directory from where the scripts are being called.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，搜索所有扩展名为`.sh`的文件，并将其作为参数传递给`tar`命令以创建一个归档。文件`scripts.tar`被创建在调用脚本的目录中。
- en: Using functions and positional parameters
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数和位置参数
- en: Similar to other programming languages, function is a way to write a set of
    actions once and use it multiple times. It makes the code modular and reusable.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言类似，函数是一种编写一组操作一次并多次使用的方法。它使代码模块化和可重用。
- en: 'The syntax of writing a function is as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 编写函数的语法如下：
- en: '[PRE80]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here, `function` is a keyword to specify a function and `function_name` is
    the name of the function; we can also define a function in the following ways:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`function`是一个关键字，用于指定一个函数，`function_name`是函数的名称；我们也可以以下列方式定义一个函数：
- en: '[PRE81]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The actions written within curly braces are executed whenever a particular function
    is invoked.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在花括号内编写的操作在调用特定函数时执行。
- en: Calling a function in bash
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在bash中调用函数
- en: 'Consider the following shell script that defines the `my_func()`function:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下定义`my_func()`函数的shell脚本：
- en: '[PRE82]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'To call `my_func()` in shell script, we just have to write a function''s name:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 要在shell脚本中调用`my_func()`，我们只需写出函数的名称：
- en: '[PRE83]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `my_func` function has a return value as 3\. The return value of a function
    is the exit status of a function. In the preceding example, the exit status of
    the `my_func` function is assigned to the `return_value` variable.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_func`函数的返回值为3。函数的返回值是函数的退出状态。在前面的例子中，`my_func`函数的退出状态被赋给`return_value`变量。'
- en: 'The result of running the preceding script is as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述脚本的结果如下：
- en: '[PRE84]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The return value of a function is what the return shell builtin is specified
    in its argument. If no `return` is used, then the exit code of the last command
    is executed in the function. In this example, the exit code will be the exit code
    of the `echo` command.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值是其参数中指定的返回shell内置命令。如果没有使用`return`，则函数中执行最后一个命令的退出代码。在这个例子中，退出代码将是`echo`命令的退出代码。
- en: Passing parameters to functions
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向函数传递参数
- en: An argument to a function can be provided by specifying the first name of the
    function followed by space-separated arguments. A function in shell doesn't use
    parameters by its name but by positions; we can also say that the shell function
    takes positional parameters. Positional parameters are accessed by the variable
    names `$1`, `$2`, `$3`, `$n`, and so on, inside a function.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定函数的第一个名称，后跟以空格分隔的参数，可以为函数提供参数。shell中的函数不是通过名称而是通过位置来使用参数；我们也可以说shell函数使用位置参数。在函数内部，通过变量名`$1`、`$2`、`$3`、`$n`等访问位置参数。
- en: The length of arguments can be obtained using `$#`, a list of arguments passed
    can be fetched together using `$@` or `$*`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`$#`获取参数的长度，使用`$@`或`$*`一起获取传递的参数列表。
- en: 'The following shell script explains how parameters are passed to the function
    in bash:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下shell脚本解释了如何在bash中传递参数给函数：
- en: '[PRE85]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output of the preceding script is as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本的输出如下：
- en: '[PRE86]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In the preceding shell script example, we called the `upper_case()` method twice
    with the `hello` and `Linux shell scripting` parameters. Both of them get converted
    to uppercase. In a similar way, other functions can be written to avoid writing
    repetitive work again and again.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的shell脚本示例中，我们两次使用`upper_case()`方法，参数分别为`hello`和`Linux shell scripting`。它们都被转换为大写。类似地，其他函数也可以编写，以避免重复编写工作。
- en: Alias
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 别名
- en: Alias in shell refers to giving another name to a command or group of commands.
    It is very useful when a name of a command is long. With the help of alias, we
    can avoid typing a bigger name and invoke a command by a name as per your convenience.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: shell中的别名指的是给命令或一组命令取另一个名称。当命令的名称很长时，它非常有用。借助别名，我们可以避免输入更长的名称，并根据自己的方便性来调用命令。
- en: 'To create an alias, alias shell builtin command is used. The syntax is as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建别名，使用别名shell内置命令。语法如下：
- en: '`alias alias_name="Commands to be aliased"`'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias alias_name="要别名的命令"`'
- en: Creating alias
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建别名
- en: To print a disk space in a human-readable format, we use the `df` command with
    the `-h` option. By making alias of `df -h` to `df`, we can avoid typing again
    and again `df -h`.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 要以人类可读的格式打印磁盘空间，我们使用带有`-h`选项的`df`命令。通过将`df -h`的别名设置为`df`，我们可以避免反复输入`df -h`。
- en: 'The output of the `df` command before aliasing it to `df -h` is shown in the
    following screenshot:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在将其别名设置为`df -h`之前，`df`命令的输出如下所示：
- en: '[PRE87]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '![Creating alias](img/4335_03_02.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![创建别名](img/4335_03_02.jpg)'
- en: 'Now, to create alias for df -h to df, we will execute the following command:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要将`df -h`的别名设置为`df`，我们将执行以下命令：
- en: '[PRE88]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output obtained is as follows:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的输出如下：
- en: '![Creating alias](img/4335_03_03.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![创建别名](img/4335_03_03.jpg)'
- en: We see that after creating alias of `df -h` to `df`, a default disk space is
    printed in a human-readable format.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，在将`df -h`的别名设置为`df`后，以人类可读的格式打印了默认磁盘空间。
- en: 'Another useful example can be aliasing the `rm` command to `rm -i`. Using `rm`
    with the `-i` option asks the user for a confirmation before deleting them:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的例子是将`rm`命令别名设置为`rm -i`。使用带有`-i`选项的`rm`会在删除文件之前要求用户确认：
- en: '[PRE89]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The output after executing the preceding script is as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述脚本后的输出如下：
- en: '[PRE90]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: We can see that after alias creation, `rm` asks for a confirmation before deleting
    the `/tmp/file.txt` file.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在创建别名后，`rm`在删除`/tmp/file.txt`文件之前要求确认。
- en: Listing all aliases
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出所有别名
- en: 'To see the aliases that are already set for the current shell, use an alias
    without any argument or with the `–p` option:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看当前shell已设置的别名，可以使用不带任何参数或带`-p`选项的别名：
- en: '[PRE91]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We can see that the `df` alias that we created still exists, along with the
    already other existing aliases.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们创建的`df`别名仍然存在，并且还有其他已存在的别名。
- en: Removing an alias
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除别名
- en: 'To remove an already existing alias, we can use the `unalias` shell builtin
    command:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除已经存在的别名，可以使用`unalias` shell内置命令：
- en: '[PRE92]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We see that the `df` alias has been removed. To remove all aliases, use `unalias`
    with the `a` option:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`df`别名已被移除。要删除所有别名，请使用`unalias`和`a`选项：
- en: '[PRE93]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: We can see that all aliases have now been deleted.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有的别名现在都已经被删除。
- en: pushd and popd
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pushd和popd
- en: Both `pushd` and `popd` are shell builtin commands. The `pushd` command is used
    to save the current directory into a stack and move to a new directory. Furthermore,
    `popd` can be used to return back to the previous directory that is on top of
    the stack.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushd`和`popd`都是shell内置命令。`pushd`命令用于将当前目录保存到堆栈中并移动到新目录。此外，`popd`可用于返回到堆栈顶部的上一个目录。'
- en: It is very useful when we have to switch between two directories frequently.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要频繁在两个目录之间切换时，它非常有用。
- en: 'The syntax of using `pushd` is as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pushd`的语法如下：
- en: '`pushd [directory]`'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushd [目录]`'
- en: If no directory is specified, `pushd` changes the directory to whatever is on
    the top of the stack.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定目录，`pushd`会将目录更改为堆栈顶部的目录。
- en: 'The syntax of using `popd` is as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`popd`的语法如下：
- en: '`popd`'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`popd`'
- en: Using the `popd` switch, we can go back to the previous directory that is on
    top of the stack and pop that directory from stack.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`popd`开关，我们可以返回到堆栈顶部的上一个目录并弹出该目录。
- en: 'The following example counts the number of files or directories in a specified
    directory until one level:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例计算指定目录中文件或目录的数量，直到一个级别为止：
- en: '[PRE94]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output after running the preceding script is as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述脚本后的输出如下：
- en: '[PRE95]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: After reading this chapter, you should now be confident enough to write an effective
    shell script by using conditional statements, loops, and so on. Now, you can also
    write a modular and reusable code using the function in shell. Having the knowledge
    of exit code will help in knowing whether the command was executed successfully
    or not. You should also know a few more useful shell builtins such as `alias`,
    `pushd`, and `popd`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你现在应该有足够的信心来使用条件语句、循环等编写有效的shell脚本。现在，你也可以使用shell中的函数来编写模块化和可重用的代码。了解退出代码的知识将有助于知道命令是否成功执行。你还应该了解一些更有用的shell内建命令，比如`alias`、`pushd`和`popd`。
- en: In the next chapter, we will learn more about modularizing our script by knowing
    how to write a reusable shell script itself, which can be used in shell scripts.
    We will also see how we can debug our shell scripts to fix problems.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过了解如何编写可重用的shell脚本本身来学习如何模块化我们的脚本，这些脚本可以在shell脚本中使用。我们还将看到如何调试我们的shell脚本以解决问题。
