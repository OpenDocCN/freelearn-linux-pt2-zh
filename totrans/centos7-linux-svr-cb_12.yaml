- en: Chapter 12. Providing Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Apache and serving web pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling system users and building publishing directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing name-based hosting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing CGI with Perl and Ruby
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing, configuring, and testing PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing Apache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up HTTPS with Secure Sockets Layer (SSL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a collection of recipes that provides the necessary steps to
    serve web pages. From installing a web server to delivering a dynamic page through
    SSL, this chapter provides the starting point required to implement an industry
    standard hosting solution anywhere and at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Apache and serving web pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to install and configure the Apache web server
    to enable the serving of static web pages. Apache is one of the world's most popular
    open source web servers. It runs as the backend for over half of all the Internet's
    web sites and can be used to serve both static and dynamic web pages. Commonly
    referred to as `httpd`, it supports an extensive range of features. It is the
    purpose of this recipe to show you how easily it can be installed using the YUM
    package manager so that you can maintain your server with the latest security
    updates. Apache 2.4 is available on CentOS 7.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet in order to download additional packages. It
    is expected that your server will be using a static IP address and a hostname.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apache is not installed by default and for this reason we will begin by installing
    the necessary packages using the YUM package manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in as root and type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a home page by typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the required HTML. You can use the following code as a starting point
    but it is expected that you will want to modify it to suit your own needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now remove the Apache 2 test page with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Having completed these steps, we will now consider the need to configure the
    `httpd` service for basic usage. To do this, open the `httpd` configuration file
    in your favorite text editor by typing (after you have made a backup of the file):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now scroll down to find the line `ServerAdmin root@localhost`. The traditional
    approach to setting this value is based on the use of the webmaster identity,
    so simply modify the e-mail address to reflect something more relevant to your
    own needs. For example, if your server''s domain name was `www.centos7.home` then
    your entry will look similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now scroll down a few more lines to find the `ServerName` directive as follows:
    `#ServerName www.example.com:80`. Uncomment this line (which means remove the
    leading # sign at its beginning) and replace the value `www.example.com` with
    something more appropriate to your own needs. For example, if your server''s domain
    name was `www.centos7.home` then your entry will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will expand the `DirectoryIndex` directive a bit more. Find the line
    `DirectoryIndex index.html`, which is part of the `<IfModule dir_module>` block,
    then change it to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and close the file, and then type the following command to test the config
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s configure our web server''s firewall by allowing incoming `http`
    connections (this defaults to port 80) to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now proceed to set the `httpd` service to start at boot and start the service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now test `httpd` from any computer in the same network as your web
    server (both systems should be able to see and ping each other), pointing your
    browser at the following URL by replacing `XXX.XXX.XXX.XXX` with the IP address
    of your server in order to see our own custom Apache test page we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, if you don''t have a web browser, you can check if Apache is
    up and running using `curl` by fetching our test page on any computer in your
    network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apache is a software package that enables you to publish and serve web pages,
    and is more commonly known as `httpd`, Apache2 or simply Apache. It was the purpose
    of this recipe to show you how easily CentOS enables you to get started with your
    very first website.
  prefs: []
  type: TYPE_NORMAL
- en: So what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'We began the recipe by installing Apache via the YUM package manager and the
    package named `httpd`. Having done this, we learned that on CentOS 7 the default
    location to serve static HTML is `/var/www/html` so our first task was to create
    a suitable home page, which we put in `/var/www/html/index.html`. Here we used
    a basic HTML template to get you started and it is expected that you would like
    to customize the look and feel of this page yourself. Following this, we then
    removed the default Apache 2 welcome page found in `/etc/httpd/conf.d/welcome.conf`.
    Following this, the next stage was to open the `httpd.conf` configuration file
    in our favorite text editor after making a backup of it so we could revert our
    changes if any problems occurred. First we defined the server''s e-mail address
    and the server name, which often appear in the error messages on the server-generated
    web pages; for this reason it should reflect your domain name. Next, we adjusted
    the `DirectoryIndex` directive, which defines which files will be sent first to
    the browser if a directory is requested. Often people request not a specific web
    page but a directory instead. For example, if you browse to `www.example.com`,
    you request a directory, while `www.example.com/welcome.html` is a specific web
    page. By default Apache sends the `index.html` in the requested directory but
    we expanded this since a lot of websites use the `.htm` extension instead. Finally,
    we saved and closed the `httpd` configuration file in the usual way before proceeding
    to check if the Apache configuration file contained any errors by using the `apachectl
    configtest` command. This should print out a `Syntax OK` message so we could enable
    the `httpd` service to start at boot time. We had to open the standard HTTP port
    80 in our firewalld to allow incoming HTTP requests to the server, and finally
    we then started the `httpd` service. Remember, you can also always reload Apache''s
    configuration file if it has been changed without fully restarting the service,
    by using: `systemctl reload httpd`. Having completed these steps, it was simply
    a matter of opening your browser from another computer in the same network and
    electing a method of viewing our new Apache start page. You can use your server''s
    IP address (for example, `http://192.168.1.100`), while those with hostname support
    can type the hostname (for example, `http://www.centos7.home`) instead. Apache''s
    access and error log files can be found in `/var/log/httpd`. To get a live view
    of who is currently accessing your web server, open `/var/log/httpd/access_log`;
    to see all the errors, type `/var/log/httpd/error_log`.'
  prefs: []
  type: TYPE_NORMAL
- en: Apache is a big subject and we cannot cover every nuance, but over the coming
    recipes we will continue to expose additional functionalities that will enable
    you to build a web server of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling system users and building publishing directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how Apache provides you with the option to allow
    your system users to host web pages within their home directories. This approach
    has been used by ISPs since the outset of web hosting and in many respects it
    continues to flourish due to its ability to avoid the more complex method of virtual
    hosting. In the previous recipe you were shown how to install the Apache web server,
    and with the desire to provide hosting facilities for system users, it is the
    purpose of this recipe to show you how this can be achieved in CentOS 7.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice. It is expected that your server will be using a static IP address that
    supports a hostname or domain name and that the Apache web server is already installed
    and currently running. Also, at least one system user account should be available
    on the server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To provide the functionality offered by this recipe, no additional packages
    are required but we will need to make some modifications to the Apache configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in as root and open the Apache userdir configuration file in
    your favorite text editor by typing the following command, after you have created
    a backup copy of it first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the file, locate the directive that reads as `UserDir disabled`. Change
    it to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now scroll down to the `<Directory "/home/*/public_html">` section and replace
    the existing block with the one here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and exit the file. Now log in as any system user to work with your publishing
    web directory (`su - <username>`), and then create a web publishing web folder
    in your home directory and a new home page for your user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the required HTML. You can use the following code as a starting point
    but it is expected that you will modify it to suit your own needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now modify the permissions of the Linux system user''s `<username>` home folders
    by typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the read/write permissions for `public_html` `755` so Apache can execute
    it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now log in as root again using `su - root` to configure SELinux appropriately
    for the use of http home directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As root, change the SELinux security context for your user''s web public directory
    (this needs `policycoreutils-python` package to be installed) with the username
    `<user>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete this recipe, simply reload the `httpd` service configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now test your setup by browsing to (substitute <username> appropriately):
    `http://<SERVER IP ADDRESS>/~<username>` in any browser.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we learned how easy it is to host your own peers by enabling
    user directories on the Apache web server.
  prefs: []
  type: TYPE_NORMAL
- en: So what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'We began the recipe by making a few minor configuration changes to Apache''s
    `userdir.conf` in order to set up the user directory support. We activated the
    user directories by adjusting the `UserDir` directive from disabled to pointing
    to the name of the HTML web directory within each user''s home directory, which
    will contain all our user''s web content, and call this `public_html` (you can
    change this directory name to anything you like but `public_html` is the de facto
    standard for naming it). Then we proceeded to modify the `<Directory /home/*/public_html>`
    tag. This directive applies all its enclosed options to the parts of the filesystem
    defined in the beginning tag `/home/*/public_html`. In our example, the following
    options are enabled for this directory: `Indexes` are used whenever a directory
    does not have `index.html`. This will show the file and folder content of the
    directory as HTML. As we will see in the recipe *Securing Apache*, this should
    be avoided for your web root whereas, for serving user directories, this can be
    a good choice if you just want to make your home folder accessible to your peers
    so they can quickly share some files (if you have any security concerns, remove
    this option). The `FollowSymLinks` option allows symbolic links (`man ln`) from
    this `public_html` directory to any other directory or file in the filesystem.
    Again, avoid this in your web root folder but for home directories it can be useful
    if you need to make files or folders accessible within the `public_html` folder
    without the need to copy them into it (user directories often have disk quotas).
    Next we configured access control to the `public_html` folder. We did so by setting
    `Require` `all granted`, which tells Apache that in this `public_html` folder
    anyone from everywhere can access the contents through the HTTP protocol. If you
    want to restrict access to your `public_html` folder then you can replace `all
    granted` with different options. To allow access based on a hostname use, for
    example `Require host example.com`. With the `ip` parameter we can restrict the
    `public_html` folder to an internally available network only, for example `Require
    ip 192.168.1.0/24`. This is particularly useful if your web server has multiple
    network interfaces and one IP address is used for connecting to the public Internet
    and another one for your internal private network. You can add multiple `Require`
    lines within a `Directory` block. Remember to always set at least `Require local`
    which allows local access.'
  prefs: []
  type: TYPE_NORMAL
- en: Having saved our work, we then began to make various changes to the home directories.
    First we created the actual `public_html` folder within our user's home directory,
    which will be the actual personal web publishing folder later. Next, we changed
    its permissions to `755` which means that our user can do everything in the folder
    but all the other users and groups can only read and execute its content (and
    change into this folder). This type of permission is needed because all the files
    in the `public_html` folder will be accessed by a user named `apache` with the
    group `apache` if someone requests its content via the Apache web server later.
    If no read or execute permissions are set for the `other users` flag (`man chmod`),
    we will get an `Access denied` message in our browser. This will also be the case
    if we do not change the permissions for the parent `/home/<username>` directory
    in advance because parent directory permissions can affect its child subfolder
    permissions. A normal user home directory in CentOS Linux has the permissions
    `700` which means that the home directory's owner can do anything but everyone
    else is completely locked out of the home folder and its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'As written before, the Apache user needs access to the subfolder `public_html`
    so we have to change the permissions to `711` for the home folder so that everyone
    else can at least change into the directory (and then access the subfolder `public_html`
    as well since this is set to be read/write accessible). Next, we set the security
    context of our new web folder for SELinux. On systems running SELinux, it''s mandatory
    to set all the Apache web publishing folders to the `httpd_user_content_t` SELinux
    label (along with their contents) in order to make them available to Apache. Also,
    we made sure to set the correct SELinux Boolean to enable Apache home directories
    (which is enabled by default): `httpd_enable_homedirs` is `true`. Read [Chapter
    14](part0111_split_000.html#39REE1-4cf34a6d07944734bb93fb0cd15cce8c "Chapter 14. Working
    with SELinux"), *Working with SELinux* to learn more about SELinux.'
  prefs: []
  type: TYPE_NORMAL
- en: You should be aware that the previous process of managing the home directories
    should be repeated for each user. You will not have to restart Apache every time
    you enable a new system user but, having completed these steps for the first time,
    it will be simply a matter of reloading the configuration of the `httpd` service
    to reflect the initial changes made to the configuration file. From this point
    on, your local system users can now publish web pages using a unique URL based
    on their username.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing name-based hosting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, if you install Apache as shown in the previous recipe, you can host
    exactly one website that is accessible as the server's IP address or the domain
    name Apache is running on, for example, `http://192.168.1.100` or `http://www.centos7.home`.
    Such a system is very wasteful for your server resources as you would need individual
    servers with Apache installed for every single domain you want to host. **Name-based**
    or **virtual hosting** is used to host multiple domains on the same Apache web
    server. If a number of different domain names have already been assigned to your
    Apache web server's IP address using a DNS server or through a local `/etc/hosts`
    file, virtual hosts can be configured for every available domain name to direct
    the user to a specific directory on the Apache server containing the site's information.
    Any modern webspace provider uses this kind of virtual hosting to divide one web
    server's space into multiple sites. There is no limit to this system and to the
    number of sites to create from it as long as your web server can handle its traffic.
    In this recipe, we will learn how to configure name-based virtual hosting on the
    Apache web server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice. It is expected that your server will be using a static IP address and
    Apache is installed and currently running, and that you have enabled system users
    publishing directories in an earlier recipe. Virtual host names cannot work without
    previously setting up one or more domains or subdomains outside Apache.
  prefs: []
  type: TYPE_NORMAL
- en: For testing, you could set up your `/etc/hosts` (see the *Setting your hostname
    and resolving the network* recipe in [Chapter 2](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 2. Configuring the System"), *Configuring the System*) or configure some
    A or CNAMES in your BIND DNS server (refer to [Chapter 9](part0080_split_000.html#2C9D01-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 9. Working with Domains"), *Working with Domains*) to use different domain
    names or subdomains, such as `www.centos7.home`, all pointing to your Apache web
    server's IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common misconception is that Apache can create domain names for your Apache
    web server on its own. This is not true. The different domain names you want to
    wire to different directories using virtual hosts need to be set up in a DNS server
    or `/etc/hosts` file to point to your Apache server's IP address before you can
    use them with virtual hosts.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the purpose of this recipe we will be building some local virtual hosts
    with the following Apache example subdomain names: `www.centos7.home`, `web1.centos7.home`,
    `web2.centos7.home` and `<username>.centos7.home` for the corresponding web publishing
    folders `/var/www/html`, `/var/www/web1`, `/var/www/web2`, and `/home/<username>/public_html`
    for the domain''s network name `centos7.home`. These names are interchangeable
    and it is expected that you will want to customize this recipe based on something
    more appropriate to your own needs and circumstances.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in as root on your Apache server and create a new configuration
    file that will hold all our virtual host definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now put in the following content, customizing the `centos7.home` value and
    the username `<username>` to fit your own needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now save and close the file in the usual way before proceeding to create the
    directories for both virtual hosts that are currently missing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Having done this, we can now create default index pages for the missing subdomains
    `web1` and `web2` by using our favorite text editor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now reload the Apache web server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, for simple testing purposes, we will just configure all our new Apache
    web server''s subdomains in the `hosts` file of the client computer that wants
    to access these virtual hosts, but remember that you can also configure these
    subdomains in a BIND DNS server. Login to this client computer (it needs to be
    in the same network as our Apache server) as root and add the following lines
    to the `/etc/hosts` file, assuming our Apache server has the IP address 192.168.1.100:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now on this computer, open a browser and test things out by typing the following
    addresses into the address line (replace `<username>` with the username you defined
    for the virtual host): `http://www.centos7.home`, `http://web1.centos7.home, http://web2.centos7.home`
    and `http://<username>.centos7.home`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of this recipe was to show you how easy it is to implement name-based
    virtual hosting. This technique will boost your productivity and using this approach
    will give you unlimited opportunities to domain-based web hosting.
  prefs: []
  type: TYPE_NORMAL
- en: So what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We began by creating a new Apache configuration file to hold all our virtual
    host configuration. Remember, all files ending with the `.conf` extension in the
    `/etc/httpd/conf.d/` directory will be loaded automatically when Apache is started.
    Following this, we then proceeded to put in the relevant directive blocks, starting
    with our default server root `centos7.home` and the alias `www.centos7.home`.
    The most important option in any virtual host block is the `ServerName` directive,
    which maps an existing domain name for our web server's IP address to a specific
    directory on the filesystem. Of course, there are many more settings you can include,
    but the previous solution provides the basic building blocks that will enable
    you to use it as the perfect starting point. The next step was to then create
    individual entries for our `centos7.home` subdomains `web1`, `web2`, and `<username>`.
    Remember, each virtual host supports the typical Apache directives and can be
    customized to suit your needs. Refer to the official Apache manual (install the
    YUM package `httpd-manual`, then go to the location `/usr/share/httpd/manual/vhosts/`)
    to learn more. After we created our virtual host blocks for every subdomain we
    wanted, we then proceeded to create the directories to hold the actual content
    and created a basic `index.html` in each directory. In this example, our `web1`
    and `web2` content directories were added to `/var/www`. This is not to imply
    that you cannot create these new folders in another place. In fact most production
    servers generally place these new directories in the home folder, as shown with
    our `/home/<username>/public_html` example. However, if you do intend to take
    this approach, remember to modify the permissions and ownership, as well as SELinux
    labels (outside`/var/www` you need to label Apache directories as `httpd_sys_content_t`)
    of these new directories so that they can be used as they were intended. Finally,
    we reloaded the Apache web service so that our new settings would take immediate
    effect. We could then directly use the subdomain names in our browser to browse
    to our virtual hosts when correctly set up in `/etc/hosts` on the client or on
    a BIND DNS server.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CGI with Perl and Ruby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes in this chapter, our Apache service only served static
    content, which means that everything requested by a web-browser already existed
    in a constant state on the server, for example as plain HTML text files that don't
    change. Apache simply sends the content of a specific file from the web server
    to the browser as a response where it then gets interpreted and rendered. If there
    were no way to change the contents sent to the client, the Internet would be really
    boring and not the huge success it is today. Not even the simplest example of
    dynamic content, such as showing a web page with the web server's current local
    time would be possible.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, early in the 1990's, some smart people started inventing mechanisms
    to make communication possible between a web server and some executable programs
    installed on the server to generate web pages dynamically. This means that the
    content of the HTML sent to the user can change in response to different contexts
    and conditions. Such programs are often written in scripting languages such as
    Perl or Ruby but can be written in any other computer language as well, such as
    Python, Java, or PHP (see later). Because Apache is written in pure C and C++,
    it cannot execute or interpret any other programming language such as Perl directly.
    Therefore, a bridge between the server and the program is needed to define how
    some external programs can interact with the server. One of these methods is called
    the **Common Gateway Interface** (**CGI**) which is a very old way to serve dynamic
    content. Most Apache web servers use some form of CGI applications and in this
    recipe we will show you how to install and configure CGI for use with Perl and
    Ruby to generate our first dynamic content.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There also exist some special Apache web server modules such as `mod_perl`,
    `mod_python`, `mod_ruby`, and so on which should be generally preferred as they
    directly embed the interpreter of the language into the web server process and
    therefore are a lot faster in comparison to any interface technology such as CGI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet in order to facilitate the download of additional
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: It is expected that your server will be using a static IP address, Apache is
    installed and currently running, and that your server supports one or more domains
    or subdomains.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As both scripting languages Perl as well as Ruby are not installed by default
    on CentOS 7 Minimal, we will start this recipe by installing all required packages
    using YUM.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in as root and type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, restart the Apache web server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to configure SELinux appropriately for the use of CGI scripts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we need to change the correct security context for our `cgi-bin` directory
    for SELinux to work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating your first Perl CGI script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now create the following Perl CGI script file by opening the new file `vi /var/www/cgi-bin/perl-test.cgi`
    and putting in the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, change the file''s permission to 755, so our `apache` user can execute
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, to test and actually see what HTML is being generated from the preceding
    script, you can execute the `perl` script directly on the command line; just type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now open a browser on a computer in your network and run your first Perl CGI
    script, which will print the local time by using the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the script is not working, have a look at the log file `/var/log/httpd/error_log`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating your first Ruby CGI script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create the new Ruby CGI script file `vi /var/www/cgi-bin/ruby-test.cgi` and
    put in the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now change the file''s permission to `755` so our `apache` user can execute
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To actually see what HTML is being generated from the preceding script, you
    can execute the Ruby script directly on the command line; just type `/var/www/cgi-bin/ruby-test.cgi`.
    When the line `offline mode: enter name=value pairs on standard input` is shown,
    press *Ctrl*+*D* to see the actual HTML output.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now open a browser on a computer in your network and run your first Ruby CGI
    script which will print the local time by using the following URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If it is not working, have a look at the log file `/var/log/httpd/error.log`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here in this recipe we showed you how easy it is to create some dynamic web
    sites using CGI. When a CGI resource is accessed, the Apache server executes that
    program on the server and sends its output back to the browser. The main advantage
    of this system is that CGI is not restricted to any programming language but works
    as long as a program is executable on the Linux command line and generates some
    form of text output. The big disadvantage of CGI technology is that it is a very
    old and outdated technology: every user request to a CGI resource starts a new
    process of the program. For example, every request to a Perl CGI script will start
    and load a new interpreter instance into memory, which will produce a lot of overhead,
    therefore making CGI only usable for smaller websites or lower parallel user request
    numbers. As said before, there are other technologies to deal with this issue,
    for example FastCGI or Apache modules such as `mod_perl`.'
  prefs: []
  type: TYPE_NORMAL
- en: So what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We began this recipe by logging in as root and installing the `perl` interpreter
    and the `CGI.pm` module for it as it is not included in the Perl standard library
    (we will use it in our script), as well as by installing the `ruby` interpreter
    for the Ruby programming language. Afterwards, to make sure our Apache web server
    takes notice of our new programming languages installed on the system, we restarted
    the Apache process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we made sure that SELinux is enabled to work with CGI scripts and then
    we provided the standard Apache `cgi-bin` directory `/var/www/cgi-bin` with the
    proper SELinux context type to allow system-wide execution. To learn more about
    SELinux, read [Chapter 14](part0111_split_000.html#39REE1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 14. Working with SELinux"), *Working with SELinux*. In this directory
    we then put our Perl and Ruby CGI scripts and made them executable afterwards
    for the Apache user. In the main Apache configuration file, the `/var/www/cgi-bin`
    directory has been defined as the standard CGI directory by default, which means
    that every executable file you put into this directory, with proper access and
    execution permissions and the `.cgi` extension, is automatically defined as a
    CGI script and can be accessed and executed from your web browser, no matter which
    programming or scripting language it has been written in. To test our scripts,
    we then opened a web browser and went to the URL `http://<server name or IP address>/cgi-bin/`
    with the name of the `.cgi` script to follow.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you would like to allow execution of CGI scripts in other web directories
    as well, you need to add the following two lines (`Options` and `AddHandler`)
    to any virtual host or existing `Directive` directive, or create a new one in
    the following way (remember that you then also have to set the SELinux `httpd_sys_script_exec_t`
    label on the new CGI location as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Installing, configuring, and testing PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hypertext Preprocessor** (**PHP**) remains one of the most popular server-side
    scripting languages designed for web development. It already supports some nice
    features, such as connecting to relational databases like MariaDB out-of-the-box
    which can be used to implement modern web applications very fast. While a current
    trend can be seen for larger enterprises to move away from PHP in favor of some
    newer technologies such as Node.js (server-side JavaScript), it is still the superior
    scripting language on the consumer market. Every hosting company in the world
    provides some kind of LAMP stack (Linux, Apache, MySQL, PHP) to run the PHP code.
    Also, a lot of very popular web applications are written in PHP, such as WordPress,
    Joomla, and Drupal, so it''s fair enough to say that PHP represents a must-have
    feature for almost any Apache web server. Here in this recipe, we will show you
    how to get started with installing and running PHP in your Apache web server with
    the module `mod_php`.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice and a Internet connection. It is expected that your server will be using
    a static IP address and Apache is installed and currently running, and that your
    server supports one or more domains or subdomains.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will begin this recipe by installing the PHP Hypertext Processor together
    with the Apache `mod_php` module, both not installed by default on CentOS 7 minimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in as root and type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s open the standard PHP configuration file after we have made a backup
    of the original file first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the line `; date.timezone =` and replace it with your own timezone. A
    list of all the available PHP time zones can be found at `http://php.net/manual/en/timezones.php`.
    For example (be sure to remove the leading `;` as this is disabling the interpretation
    of a command; this is called commenting out) to set the timezone to the city Berlin
    in Europe use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make sure the new module and settings have been properly loaded, restart
    the Apache web server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To be consistent with the CGI examples from the former recipe, here we will
    create our first dynamic PHP script which will print out the current local server
    time in the script `vi /var/www/html/php-test.php`, and run the popular PHP function
    `phpinfo()` that we can use to print out important PHP information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To actually see what HTML is being generated from the preceding script, you
    can execute the PHP script directly on the command line; just type: `php /var/www/html/php-test.php`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now open a browser on a computer in your network and run your first PHP script
    which will print the local time by using the following URL: `http://<server name
    or IP address>/php-test.php`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we showed you how easy it is to install and incorporate PHP
    into any Apache web server by using the `mod_php` module. This module enables
    an internal PHP interpreter, which directly runs in the Apache process and is
    much more efficient than using CGI, and should always be your preferred method
    whenever is available.
  prefs: []
  type: TYPE_NORMAL
- en: So what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We began this recipe by installing the `mod_php` module using YUM, which will
    install PHP as a dependency as well as both are not available on any standard
    CentOS 7 minimal installations. Installing `mod_php` added the `/etc/php.ini`
    configuration file which we then opened after making a backup of the original
    file first. This file is the main PHP configuration file and should be edited
    with care because a lot of settings can be security relevant to your web server.
    If you are just starting out with PHP, leave everything as it is in the file and
    don't change anything despite the `date.timezone` variable. We set this to reflect
    our current time zone and it is necessary for PHP because it is used by a lot
    of different time and date functions (we will use some date functions in our first
    PHP script as well, see below). Next, we restarted the Apache web server which
    automatically reloads the PHP configurations as well. Afterwards, we created our
    first PHP script and put it in the main web root folder `/var/www/html/php-test.php`;
    this prints out the current server time as well as the result of the `phpinfo()`
    PHP function. This gives you a well categorized tabular overview of your current
    PHP installation, helping you diagnose server-related problems or see which modules
    are available in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: In comparison to CGI, you may ask yourself why we don't have to put the PHP
    scripts into any special folder such as `cgi-bin`. By installing `mod_php`, an
    Apache configuration file called `/etc/httpd/conf.d/php.conf` gets deployed into
    the Apache configuration folder, which exactly answers this question, it specifies
    that PHP scripts will get executed as valid PHP code whenever they get the extension
    `.php` from anywhere in every web directory.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Apache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though the Apache HTTP server is one of the most mature and safe server
    applications included in CentOS 7, there is always room for improvement and a
    large number of options and techniques are available to harden your web server's
    security even more. While we cannot show the user every single security feature
    as it is outside of the scope this book, in this recipe, we will try to teach
    what is considered to be good practice when it comes to securing your Apache web
    server for a production system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice. It is expected that your server will be using a static IP address and
    Apache is installed and currently running, and that your server supports one or
    more domains or subdomains.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the security options and techniques have to be set up in the main Apache
    configuration file, so we will begin this recipe by opening it in our favorite
    text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring httpd.conf to provide better security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin, log in as root and open the main Apache config file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now go to your main document root. To do so, search the directive called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the beginning `<Directory "/var/www/html">` and closing `</Directory>`
    tags find the line `Options Indexes FollowSymLinks`, then disable (comment out)
    this line by putting a `#` in front of it, so it reads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now scroll down to the end of the configuration file and insert the following
    line one line before the line `# Supplemental configuration`. We do not want our
    server to leak any detailed information through the header, so we type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterwards, reload the Apache configuration to apply your changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Removing unneeded httpd modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even the most stable, mature, and well-tested programs can include bugs and
    cause vulnerabilities, as the latest news about the Heartbleed bug in OpenSSL
    or Shellshock in Bash have shown, and the Apache web server is no exception. Therefore,
    it is often beneficial to remove all unneeded software to limit the functionality,
    and thus the likelihood of security problems in your system. For the Apache web
    server, we can remove all unneeded modules to increase security (this can also
    increase performance and memory consumption). Let's start this process by reviewing
    all the currently installed Apache modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show all currently installed and loaded Apache modules, type as user root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All the modules outputted by the preceding command are loaded into the Apache
    web server by special configuration files in the `/etc/httpd/conf.modules.d` folder
    where they are grouped together by their primary target into the following files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So instead of going through all the modules individually, this file structure
    in the `conf.modules.d` folder can make our life much easier because we can disable/enable
    whole groups of modules. For example, if you know that you will not need any Apache
    DAV modules because you will not provide any WebDAV server, you can disable all
    DAV-related modules by renaming the extension of the `00-dav.conf` configuration
    file since only files with the ending `.conf` are read and loaded automatically
    by Apache. In order to do so, type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterwards, reload the Apache configuration to apply your changes to the modules
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need more fine-grained control, you can also enable/disable single modules
    in all the configuration files in this directory as well. For example, open `00-base.conf`
    in your favorite text editor and disable a single line by adding a `#` to the
    beginning of the line of choice you want to disable. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you decide to use some disabled modules files later, just rename the `.BAK`
    file to the original file name or remove the `#` in a specific module config file
    before reloading `httpd` once again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Protecting your Apache files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another really simple way to increase the security of your Apache web server
    is to protect your server-side scripts and configurations. In our scenario, we
    have one user (root) who alone is responsible and maintains the complete Apache
    web server, websites (for example, uploading new HTML pages to the server), server-side
    scripts, and configurations. Therefore, we will give him/her full file permissions
    (read/write/execute). The `apache` user still needs proper read and execute permissions
    to serve and access all Apache related files, thus minimizing the risk that your
    Apache web server is exposing some potential security risks to other system users
    or can get compromised through HTTP hacks. Do this in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we will change or reset the ownership of the complete Apache configuration
    directory and the standard web root directory to owner `root` and group `apache`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterwards, we will change the file permissions so no one other than our dedicated
    `apache` user (and also `root`) can read those files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We began this recipe by opening the main Apache configuration file `httpd.conf`
    to change settings for our main Apache root web content directory `/var/www/html`.
    Here we disabled the complete `Options` directive which included the `Indexes`
    as well as the `FollowSymLinks` parameter. As we have learned, if you request
    a directory instead of a file from the Apache server, `index.html` or the `index.htm`
    file within this directory will be sent automatically. Now the `Indexes` option
    configures the Apache web server in such a way that if no such file can be found
    in the requested directory, Apache will auto-generate a listing of the directory's
    content, as if you had typed `ls` (for list directory) in that directory on the
    command line, and show it to the user as a HTML page. We don't want this feature
    in general because it can expose secret or private data to unauthorized users
    and a lot of system administrators will tell you that indexing is considered to
    be a security threat in general. The `FollowSymLinks` directive should also not
    be used in production systems because if you make a mistake with it, it can easily
    expose parts of the file system, such as the complete root directory. Finally,
    we add another measurement to increase the server's base security and this is
    done by disabling the server version banner information. When the Apache web server
    generates either a web page or an error page, valuable information, for example
    the Apache server version and the activated modules, is sent automatically to
    the browser and a possible attacker can gain valuable information about your system.
    We stopped this from happening by simply setting `ServerTokens` to `Prod`. Afterwards,
    we showed you how to disable Apache modules to reduce the general risk of bugs
    and exploitations of your system. Finally, we showed how to adjust your Apache
    file permissions which can also be a good general protection.
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of other things to consider when it comes to hardening your Apache
    web server but most of these techniques, such as Limiting HTTP request methods,
    `TraceEnable`, setting cookies with `HttpOnly` and secure flags, disabling the
    HTTP 1.0 protocol or SSL v2, or modifying the HTTP header with useful security-related
    HTTP or custom headers such as `X-XSS-Protection`, are much more advanced concepts
    and can restrict a general purpose Apache web server too much.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up HTTPS with Secure Sockets Layer (SSL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to add a secure connection to the Apache web
    server by creating a self-signed SSL certificate using OpenSSL. This is often
    a requirement for web servers if the sites running on them transfer sensitive
    data such as credit card or login information from the web browser to the server.
    In a previous recipe you were shown how to install the Apache web server, and
    with the growing demand for secure connections, it is the purpose of this recipe
    to show you how to enhance your current server configuration by teaching you how
    to extend the features of the Apache web server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet in order to facilitate the download of additional
    packages. It is expected that Apache web server has been installed and that it
    is currently running. Here we will create a new SSL certificate for Apache. If
    you want to learn more about it, refer to [Chapter 6](part0061_split_000.html#1Q5IA1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 6. Providing Security"), *Providing Security* for advice on generating
    self-signed certificates. As a correct domain name is crucial for SSL to work,
    we will continue naming our Apache web server's configured domain name `centos7.home`
    to make this recipe work (change it to fit your own needs).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apache does not support SSL encryption by default and for this reason we will
    begin by installing the necessary package `mod_ssl` using the yum package manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in as root and type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'During installation of the mod_ssl package, a self-signed certificate as well
    as the key pair for the Apache web server are generated automatically; these lack
    a proper common name for your web server''s domain name. Before we can re-generate
    our own required SSL files using the `Makefile` in the next steps, we need to
    delete those files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now required to create our intended self-signed certificate and server
    key for our Apache web server. To do this, type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create the self-signed Apache SSL keypair, consisting of the certificate
    and its embedded public key as well as the private key, type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the process of creating the certificate, first you will be asked to enter
    a new passphrase and then to verify it. Afterwards, you need to type it in again
    for the third time. As usual, enter a secure password. You will then be asked
    a number of questions. Complete all the required details by paying special attention
    to the common name value. This value should reflect the domain name of your web
    server or the IP address the SSL certificate is for. For example, you may type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the process of creating your certificate is complete, we will proceed
    by opening the main Apache SSL configuration in the following way (after making
    a backup):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Scroll down to the section that begins with `<VirtualHost _default_:443>` and
    locate the line `# DocumentRoot "/var/www/html"` within this block. Then activate
    it by removing the `#` character, so it reads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right below, find the line that reads `#ServerName www.example.com:443`. Activate
    this line and modify the value shown to match the common name value used during
    the creation of your certificate, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and close the file, next we need to enable the HTTPS port in our firewalld
    to allow incoming HTTP SSL connections over port `443`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now restart the Apache `httpd` service to apply your changes. Note that if
    prompted you have to enter the SSL passphrase you added when you created the SSL
    test certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Well done! You can now visit your server with a secure connection by replacing
    all the available HTTP URLs we have defined for the server using HTTPS instead.
    For example, go to `https://www.centos7.home` instead of `http://www.centos7.home`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: When you browse to this website, you will get a warning message that the signing
    certificate authority is not known. This exception is to be expected when using
    self-signed certificates and can be confirmed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We began the recipe by installing `mod_ssl` using the YUM package manager, which
    is the default Apache module to enable SSL. The next step was then to go to the
    standard location where all the system's certificates can be found in CentOS 7,
    that is, `/etc/pki/tls/certs`. Here we can find a `Makefile`, which is a helper
    script for conveniently generating self-signed SSL test certificates and which
    hides away complicated command line parameters for the OpenSSL program from you.
    Remember that the `Makefile` currently lacks a `clean` option and therefore every
    time we run it, we need to delete any old versions of the generated files from
    a former run manually, otherwise it will not start doing anything. After deleting
    the old Apache SSL files, we used `make` with the `testcert` parameter, which
    creates self-signed certificates for the Apache web server and puts them in the
    standard locations, already configured in the `ssl.conf` file (the `SSLCertificateFile`
    and `SSLCertificateKeyFile` directives), so we didn't have to change anything
    here. During the process, you were asked to provide a password before completing
    a series of questions. Complete the questions but pay special attention to the
    Common name. As was mentioned in the main recipe, this value should reflect either
    the domain name of your server or your IP address. In the next phase, you were
    required to open Apache's SSL configuration file in your favorite text editor
    which can be found at `/etc/httpd/conf.d/ssl.conf`. In it we enabled the `DocumentRoot`
    directive to put it under SSL control and activated the `ServerName` directive
    with an expected domain value that must be the same as the one we defined as our
    common name value. We than saved and closed the configuration file and enabled
    the HTTPS ports in our firewall, thus allowing incoming connections over the standard
    HTTPS `443` port. Having completed these steps, you can now enjoy the benefits
    of a secure connection using a self-signed server certificate. Just type `https://`
    instead of `http://` for any URL address available on your Apache web browser.
    However, if you are intending to use an SSL Certificate on a production server
    for members of the public, then your best option is to purchase an SSL certificate
    from a trusted Certificate Authority.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned that since our SSL certificate is protected by a passphrase, so whenever
    we need to restart our Apache web server, we need to enter the password. This
    is impractical for server restarts as Apache will refuse to start without a password.
    To get rid of the password prompt, we will provide the passphrase in a special
    file and make sure it is only accessible by root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a backup of the file that will contain your password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now overwrite this password file with the following content, replacing `XXXX`
    in the following command line with your current SSL passphrase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, change the permissions so that only root can read and execute them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
