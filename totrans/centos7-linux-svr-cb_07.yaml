- en: Chapter 7. Building a Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Printing with CUPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a DHCP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using WebDAV for file sharing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring NFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with NFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securely sharing resources with Samba
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a collection of recipes that covers the many facets of today's
    working environment. From printing and file sharing across different types of
    office computer systems to keeping your computers online, this chapter provides
    the necessary details on how quickly you can use CentOS to implement the necessary
    tools that will maximize efficiencies within your networking environment.
  prefs: []
  type: TYPE_NORMAL
- en: Printing with CUPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Print servers** allow local printing devices to be connected to a network
    and be shared among several users and departments. There are many advantages using
    such a system, including the lack of a need to buy dedicated printer hardware
    for each user, room, or department. The **Common Unix Printing System** (**CUPS**)
    is the de-facto standard for print servers on Linux, as well as Unix distributions
    including OS X. It is built with a typical client/server architecture, where clients
    in the network send print jobs to the centralized print server that schedules
    these tasks, then delegates and executes the actual printing on a printer that
    is locally connected to our printer server or sends the print job remotely to
    the computer that has the physical connection to the requested printer or to a
    standalone network printer. If you set up your printers within the CUPS system,
    almost all Linux and OS X printing application on any client in your network will
    be automatically configured to use them out-of-the box, without the need to install
    additional drivers. Here, in this recipe, we will show you how to get started
    with the CUPS printing server system.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet in order to download additional packages. In
    this recipe, we will use the network interface with the IP address, `192.168.1.8`,
    and the corresponding network address of `192.168.1.0/24` to serve the CUPS printer
    server to our network.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We begin this recipe by installing the CUPS printing server software, which
    is not available by default on a fresh CentOS 7 minimal system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, log in as `root` and install the following package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create an SSL certificate for the CUPS server, which we will need for
    secure authentication to the CUPS web application (add a secure password when
    asked):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s open the CUPS main configuration file to customize the server (backup
    first):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, to make CUPS available on the entire network, find the following line:
    `Listen localhost:631`, than change it to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want to configure access to all normal web pages of the web-based
    CUPS frontend. Search for the `<Location />` directive (don''t confuse this with
    other directives such as `<Location /admin>`) and change the complete block by
    adding your network address. After changing, the complete block looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, set access permissions for the `/admin` and `/admin/conf Location` directives,
    granting access to the local server only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add our SSL certificate information to the end of the configuration
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close and save the file, then restart the CUPS server and enable it on boot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have to open the CUPS server ports in firewalld so that other computers
    in the network can connect to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can test the accessibility of your CUPS server from another computer in
    your `192.168.1.0/24` network by browsing to the following location (allow a security
    exception in the browser when asked):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To access the administration area within the CUPS frontend, you need to be on
    the same server as CUPS is running (on a CentOS 7 minimal installation, please
    install a window manager and browser), and then use the system user, `root`, with
    the appropriate password to login.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we showed you how easy it is to install and set up a CUPS printing
    server.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We began our journey by installing the CUPS server package on our server because
    it is not available on the CentOS 7 system by default. Afterwards, we generated
    a SSL key-pair, which we will need later in the process (to learn more, read the
    *Generating self-signed certificates* recipe in [Chapter 6](part0061_split_000.html#1Q5IA1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 6. Providing Security"), *Providing Security*). It is used to allow the
    encrypted submission of your login credentials to the CUPS administration web
    frontend (over secure HTTPS connections). Next, we opened CUPS's main configuration
    file, `/etc/cups/cupsd.conf`, with the text editor of our choice. As you may notice,
    the configuration format is very similar to the Apache configuration file format.
    We started changing the `Listen` address by removing the localhost name, therefore
    allowing all clients from everywhere in your network (`192.168.1.0/24`) to access
    our CUPS server at port `631` instead of allowing only the local interface to
    connect to the printer server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, the CUPS server has `Browsing On` enabled, which will broadcast,
    every 30 seconds, an updated list of all printers that are being shared in the
    system to all client computers on the same subnet. If you want to broadcast to
    other subnets as well, use the `BrowseRelay` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we configured access to the CUPS web interface. This frontend can be used
    to conveniently browse all available printers on the network, or even install
    new printers or configure them if you log in with an administrator account. As
    there are different tasks in the user interface, there are three different directives
    that can be used to fine-grain its access. Access to all normal web pages can
    be set using the `<Location />` directive, whereas all administration pages can
    be managed with `<Location /admin>` and more specifically to change the configuration
    within the `<Location /admin/conf>` tag. In each of these `Location` tags, we
    added different `Allow` directives, thus granting normal CUPS web pages (such
    as, browsing all available network printers) from your complete network (for example,
    `192.168.1.0/24`) while accessing the special administration pages is restricted
    to the server that runs the CUPS service (`localhost`). Remember, if this is too
    restrictive for your environment, you can always adjust these `Allow` settings.
    Also, there are various other `Location` types available, such as one that is
    used for activating our service in additional subnets. Please read the CUPS configuration
    manual using `man cupsd.conf`. Next, we configured SSL encryption, thus activating
    secure `https://` addresses for the web interface. Then, we started the CUPS server
    for the first time and enabled it to start automatically when the server boots
    up. Finally, we added the `ipp` firewalld service, thus allowing incoming CUPS
    client connections to the server.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have successfully set up and configured our CUPS server, it's time
    to add some printers to it and print a test page. Here, we will show you how to
    add *two different* types of printers to the system using the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding or configuring printers can also be done using the graphical web-based
    CUPS interface.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will install a true *network* printer that is already available in
    the same network (in our case, the `192.168.1.0/24` network) as our CUPS server
    and afterwards a locally connected printer (for example, via USB to our CUPS server
    or any other computer in the same network).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Why should you want to install an already connected network printer to our
    CUPS server? CUPS can do much more than just printing: it is a centralized printer
    server, thus managing scheduling and queuing of printers and their jobs, serving
    printers in different subnets, and providing unified printing protocols and standards
    for convenient access on any Linux or Mac client.'
  prefs: []
  type: TYPE_NORMAL
- en: How to add a network printer to the CUPS server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start adding a network printer to our CUPS server, we will use the command
    `lpinfo -v` to list all the available printing devices or drivers known to the
    CUPS server. Normally, the CUPS server will automatically identify all locally
    (USB, parallel, serial, and so on) and remotely available (network protocols such
    as `socket`, `http`, `ipp`, `lpd`, and so on) printers from most common printing
    protocols without any problems. In our example, the following network printer
    has been successfully identified (the output has been truncated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will install this printer on the CUPS server to put it under its control.
    First, we need to look for the correct printer driver. As we can see in the last
    output, it is an HP Photosmart C5100 series printer. So, let''s search for the
    driver in the list of all currently installed drivers on our CUPS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The list does not contain our model C5100, so we have to install an additional
    HP driver package using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we issue our command again, we can find the correct driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For other printer models and manufacturers, there are other driver packages
    available as well, for example, the `gutenprint-cups` RPM package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct driver for this printer will be shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have everything ready to install the printer using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we installed it using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, the printer should be under our CUPS server's control and should immediately
    be shared and seen in the entire network from any Linux or OS X computer (on a
    CentOS 7 minimal client, you will first need to install the `cups` package as
    well and enable incoming `ipp` connections using firewalld's `ipp-client` service
    before any shared network printer information from our CUPS server will become
    available).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can later change the configuration of this printer by opening and changing
    the file at `/etc/cups/printers.conf`. To actually print a test page, you should
    now be able to access the printer using its name, `hp-photosmart`, from any client
    (on a CentOS 7 minimal client, you would need to install the package `cups-client`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to share a local printer to the CUPS server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to share a local printer physically connected to our CUPS server,
    just plug in the printer to the system (for example, via USB) and follow the previous
    recipe, *How to add a network printer to the CUPS server*. In the step `lpinfo
    -v`, you should see it appear as a `usb://` address, so you need to take this
    address and follow the rest of the steps.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to connect and share a printer on your centralized CUPS server,
    which is physically connected to any other computer on your CUPS network, install
    the `cups` daemon on this other machine (follow all the steps in the main recipe)
    and then install the printer driver for it as shown here in this section. This
    will make sure that the local CUPS daemon will make the printer available on the
    network, as it would be on our centralized CUPS server. Now that it is available
    on the network, you can easily add it to our main CUPS server to enjoy all the
    benefits of a centralized printing server.
  prefs: []
  type: TYPE_NORMAL
- en: Here in this recipe, we have only scratched the surface and introduced you to
    the basics of setting up a CUPS server for your network. There is always more
    to learn, and you can build very complex CUPS server systems managing hundreds
    of printers in the corporate environment, which is outside the scope of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Running a DHCP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a connection to a network needs to be made, every computer needs a correct
    **Internet Protocol** (**IP**) configuration installed on their system to communicate.
    Assigning IP client configurations automatically from a *central point* using
    the **Dynamic Host Control Protocol** (**DHCP**) can make the administrator's
    life easier and simplify the process of adding new machines to a network in comparison
    to the tedious work of manually setting up static IP information on each computer
    system in your network. In small home-based networks, people often use DHCP servers
    directly installed in silico on their Internet routers, but such devices often
    lack advanced features and have only a basic set of configuration options available.
    Most of the time, this is not sufficient for bigger networks or in the corporate
    environment, where you are more likely to find dedicated DCHP servers for more
    complex scenarios and better control. In this recipe, we will show you how to
    install and configure a DHCP server on a CentOS 7 system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet in order to facilitate the download of additional
    packages. It is expected that your DHCP server will be using a static IP address;
    if you do not have one, refer to the recipe *Building a static network connection*
    in [Chapter 2](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 2. Configuring the System"), *Configuring the System*. If you plan to
    send DNS information to the clients through DHCP as well, you should have already
    applied the recipe *Installing and configuring a simple nameserver* in [Chapter
    8](part0075_split_000.html#27GQ61-4cf34a6d07944734bb93fb0cd15cce8c "Chapter 8. Working
    with FTP"), *Working with FTP*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here in this example, we will configure a DHCP server for a static network interface
    serving a single network with all its available IP addresses to all the computers
    connected directly to it (they are all in the same subnet).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, log in as `root` and type the following command in order to install
    the DHCP server packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our example, we will use a network interface with the name, `ifcfg-enp5s0f1`,
    to serve our DHCP requests. Next, we need to collect some very important network
    information, which we will use later for configuring the DHCP server (change the
    network interface name to fit your own needs):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From this output, we need the following information, so please write it down
    (most likely, your output will be different):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need the subnet network address, which can be calculated using the
    following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print the following output (write it down for later):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will open our main DHCP configuration file, after we make a backup
    of the original file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the following lines to the end of the file, taking into account your
    individual network interface''s configuration from the preceding steps (`routers
    = GATEWAY`, `subnet = NETWORK`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, start and enable the DHCP service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here in this recipe, we showed you how easy it is to set up a DHCP server for
    a single network. With this, every time a new machine gets added to the network,
    the computer gets the correct IP information automatically, which it needs in
    order to connect to the network without any further human action.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We started this recipe by installing the DHCP server package because it does
    not come with CentOS 7 out-of-the-box. Since our DHCP daemon communicates with
    its clients to assign IP information over a network interface, in the next step
    we had to choose a network device that would be used for the service. In our example,
    we selected the device named `enp5s0f1`. By default, the DHCP server can manage
    all available IP addresses from the same subnet as the associated network interface.
    Remember that your primary DHCP server's network interface must be configured
    to get its own IP information statically and not through (another) DHCP server!
    Next, we used the `cat` command to print out all the interesting lines from our
    `enp5s0f1` network interface configuration file, which we will need for configuring
    the DHCP server. Afterwards, we used the `ipcalc` tool to calculate the (subnet)
    network address for our DHCP server's network interface. Then, we opened the main
    DHCP server configuration, started configuring some *global* settings, and defined
    a new *shared network*. In the global settings, we first set our DHCP server to
    be `authoriative`, which means it is the only and main responsible DHCP server
    in the network. Next, we defined `default-lease-time` to `28800` seconds, which
    is eight hours, and the `max-lease-time` to `86400`, which is 24 hours. The lease
    time is the amount of time the DHCP server "rents out" an IP address to a client
    before it has to sign up again on the DHCP server asking for an extension of the
    IP. If it is not requesting a renewal of an existing lease at that time, the IP
    address will be released from the client and put into the pool of free IP addresses
    again, ready to be served to new machines that want to connect to the network.
    The client can define the amount of time it wants to lease an IP address by itself.
    If no time frame has been supplied from the client to the DHCP server, the default
    lease time will be used.
  prefs: []
  type: TYPE_NORMAL
- en: All subnets that share the same physical network interface should be defined
    within a `shared-network` declaration, so we defined this area using square brackets.
    This is also called a scope. In our example, we only have one network, so we only
    need one shared-network scope. Within it, we first defined a `domain-name` option,
    which will be sent and can be used by clients as their base domain name. Next,
    we added the **domain name servers** (**DNS**) to our configuration. Sending DNS
    information to the client is not mandatory for the DHCP server but can be useful.
    The more information a client gets for a given network, the better, because fewer
    manual configuration steps have to be made.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can send out a lot of other useful information to the client (using DHCP)
    about the network he is connecting to: gateway, time, WINS, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here in our example, we used the official Google DNS servers; if you have already
    set up your own DNS server (see [Chapter 8](part0075_split_000.html#27GQ61-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 8. Working with FTP"), *Working with FTP*), you could also use these
    addresses here. Next, we specified a `routers` option, which is another useful
    piece of information that will be sent out to the clients as well. Afterwards,
    we specified the most important part of any DHCP server: the `subnet` scope. Here,
    we defined our network ranges for assigning IP addresses for clients. We need
    to provide the subnet network address, its submask, and then the starting and
    ending IP address range that we want to allow to clients. In our example, we allow
    host IP addresses from `192.168.1.10`, `192.168.1.11`, `192.168.1.12` ... to `192.168.1.160`.
    If you have more than one subnet, you can use multiple `subnet` scope directives
    (called a multihomed DHCP server).'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we started the DHCP server and enabled it on boot. Your clients should
    now be able to get IP addresses dynamically from our new system.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we have only showed you some very basic DHCP server configuration
    options to get you started, and there are many more settings available, letting
    you build very complex DHCP server solutions. To get a better overview of its
    possibilities, please have a look at the example configuration file provided with
    the DHCP server documentation at `less /usr/share/doc/dhcp-4*/dhcpd.conf.example`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the main recipe, we configured our basic DHCP server to be able to send complete
    IP network information to our clients so that they should be able to join our
    network. To use this server, you need to enable DHCP addressing on your client's
    network interfaces. On CentOS clients, please do not forget to use `BOOTPROTO=dhcp`
    and remove all static entries such as `IPADDR` in the appropriate network-scripts
    `ifcfg` file (read the recipe, *Building a static network connection* in [Chapter
    2](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c "Chapter 2. Configuring
    the System"), *Configuring the System* to get you started on network-scripts files).
    Then, to make a DHCP request, restart the network using `systemctl restart network`
    or try to do a reboot of the client system (with the `ONBOOT=yes` option). Confirm
    with `ip addr list`.
  prefs: []
  type: TYPE_NORMAL
- en: Using WebDAV for file sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Web-based Distributed Authoring and Versioning** (**WebDAV**) open standard
    can be used for sharing files over the network. It is a popular protocol to conveniently
    access remote data as an *online hard disk*. There are a lot of online storage
    and e-mail providers who offer online space through WebDAV accounts. Most graphical
    Linux or Windows systems can access WebDAV servers in their file managers out-of-the-box.
    For other operating systems, there are also free options available. Another big
    advantage is that WebDAV is running over normal HTTP or HTTPS ports, so you can
    be sure that it will work in almost any environment, even behind restricted firewalls.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will show you how to install and configure WebDAV as an alternative
    for the FTP protocol for your file sharing needs. We will use HTTPS as our communication
    protocol for secure connections.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice. You will need a working Apache web server with SSL encryption enabled
    and reachable in your network; see [Chapter 11](part0093_split_000.html#2OM4A1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 11. Providing Mail Services"), *Providing Mail Services* for how to install
    the HTTP daemon, and especially the recipe *Setting up HTTPS with SSL*. Also,
    some experience working with the Apache config file format is advantageous.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a location for sharing your data and for a WebDAV lock file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since WebDAV is running as an Apache module over HTTPS, we have to set proper
    permissions to the standard `httpd` user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create and open the following Apache WebDAV configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put in the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and close the file. Now, to add a new WebDAV user named `john` (enter
    a new password for the user as prompted):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, restart the Apache2 web server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To test if we can connect to our WebDAV server, you can use a graphical user
    interface (most Linux file managers support WebDAV browsing) from any client in
    your network, or we can mount the drive using the command line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Log in on any client machine as `root` in the same network as our WebDAV server
    (on CentOS, you need the `davfs2` filesystem driver package to be installed from
    the EPEL repository, and the usage of file locks must be disabled as the current
    version is not capable of working with file locks), enter the password for our
    DAV user account named `john`, and confirm the self-signed certificate when asked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to see if we can write to the new network storage type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you've got connection problems, check the firewall settings on your WebDAV
    server for the services `http` and `https`, as well as on your client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here in this recipe, we showed you how easy it is to set up a WebDAV server
    for easy file sharing.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'We started our journey by creating two directories: one, where all the shared
    files of our WebDAV server will live, and one for creating a lock file database
    for the WebDAV server process. The latter is needed so that users can *block*
    access to documents to avoid collisions with others if files are currently modified
    by them. As WebDAV runs as a native Apache module (`mod_dav`) that is already
    enabled by default in CentOS 7, all we need to do is create a new Apache virtual
    host configuration file, where we can set up all our WebDAV settings. First, we
    have to link our WebDAV host to the full path of the lock database that is used
    to track user locks. Next, we defined an alias for our WebDAV sharing folder,
    which we then configured using a `Location` directive. This will be activated
    if someone is using specific HTTP methods on the `/webdav` path URL. Within this
    area, we specified that this URL will be a DAV-enabled share, enabled SSL encryption
    for it, and specified basic user-based password authentication. The user account''s
    passwords will be stored in a user account database called `/etc/httpd/conf/dav_passwords`.
    To create valid accounts in this database file, we then used the Apache2 `htpasswd`
    utility on the command line. Finally, we restarted the service to apply our changes.'
  prefs: []
  type: TYPE_NORMAL
- en: For testing, we used the `davfs` filesystem driver, which you need to install
    on CentOS 7 using the `davfs2` package from the EPEL repository. There are many
    other options available, such as the `cadaver` WebDAV command-line client (also
    from the EPEL repository); alternatively, you can access it directly using integrated
    WebDAV support in a graphical user interface such as GNOME, KDE, or Xfce.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring NFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Network File System** (**NFS**) protocol enables remote access to filesystems
    over a network connection. It is based on a client-server architecture, allowing
    a centralized server to share files with other computers. A client can attach
    those exported shares in their own file system to access it conveniently, as they
    will be located on a local storage. While Samba and AFP are more common distributed
    filesystems on Windows and OS X, NFS is now the de-facto standard and a key element
    of any Linux server system. Here in this recipe, we will show you how easy it
    is to set up an NFS server for file sharing over the network.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet in order to facilitate the download of additional
    packages. It is expected that your NFS server and all the clients will be able
    to ping each other and are connected to each other by a static IP address (see
    the recipe, *Building a static network connection*, in [Chapter 2](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 2. Configuring the System"), *Configuring the System*). In our example,
    the NFS server is running with IP `192.168.1.10` and two clients with the IPs
    `192.168.1.11` and `192.168.1.12` and the network's domain name `example.com`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this particular section, we are going to learn how to install and configure
    the NFS server, and create and export a share on a client.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring the NFS server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NFSv4 is not installed by default, and for this reason we will begin by downloading
    and installing the required packages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, log in as `root` on the server that you want to run the NFS daemon
    on and type the following command in order to install the required packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For NFSv4 to work, we need the *same base* domain for all clients and the NFS
    server. So, let''s define sub-domain names for our NFS server and the clients,
    if you haven''t set up a domain name using DNS (see [Chapter 9](part0080_split_000.html#2C9D01-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 9. Working with Domains"), *Working with Domains*), we will set up a
    new hostname for our computers in the `/etc/hosts` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the `/etc/idmapd.conf` file and put in the base domain name (not
    the full domain name) of your NFS server; search for the line that reads `#Domain
    = local.domain.edu`, and replace it with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to open some firewall ports for the server to have proper NFS
    access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s start the NFS server service and enable it on reboot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating an export share
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that our NFS server is configured and up-and-running, it''s time to create
    some file shares that we can export to our clients:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a folder for our shares and change its permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new group with a specific GID and associate it with the export, and
    then change permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the following file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, enter the following text, but be very focussed while typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and close the file, then re-export all entries from `/etc/exports` using
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On CentOS 7, you can install version 4 of the NFS, which has some enhancements
    over former versions, such as more flexible authentication options and being fully
    backward compatible with older NFS versions. Here, we showed you how easy it is
    to install and configure the NFS server and create some shared exports for our
    clients to use.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'We started this recipe by installing the `nfs-utils` package, since the NFS
    server functionality is not available on CentOS 7 by default. Next, we configured
    our server''s domain name using the `/etc/hosts` file, as in our example, no DNS
    server of our own has been configured. If you have set up a DNS server, you should
    follow a similar domain name schema as shown here, because this is very important
    for NFSv4 to work, as all clients and the server should be in the same base domain.
    In our example, we specified that they are all sub-domains of `example.com: myClient1.example.com`,
    `myClient2.example.com`, and `myServer.example.com`. This is a means of securing
    the sharing of data, as the NFS server will only allow access to files from a
    client to a server if the domain names match (in our example, both server and
    client are part of the `example.com` domain). Next, we put this base domain in
    the `idmapd.conf` file, which takes care of mapping user names and group IDs to
    NFSv4 IDs. Afterwards, we enabled the `nfs`, `mountd`, and `rpc-bind` firewalld
    services in our firewalld instance, which are all needed for full support and
    communication between our clients and server. To finish our base configuration,
    we started the `rpcbind` and NFS servers and enabled them on boot.'
  prefs: []
  type: TYPE_NORMAL
- en: After the NFS server was successfully set up, we added some export to it, to
    actually allow clients to access some shared folders from the server. Therefore,
    we created a special directory in the filesystem, which will keep all our shared
    files. We associated this sharing folder, `/srv/nfs-data`, with a new group, `nfs-share`,
    and gave it read/write/execute permissions. For practical reasons we will control
    Linux file permissions for our export on a group level. The name is unimportant
    but its group identifier (GID) has to be set to a static value (for example, `50000`).
    This new GID must be the same on the server as well as on every client for every
    user who wants to have write permissions because NFS transfers any access permissions
    between server and client on a user (UID) or GID level over the network. The whole
    sharing magic then happens in the `/etc/exports` file. It contains a table; in
    it you specify all the important information about your shared folders and their
    access securities for the clients. Every line in this file is equivalent to one
    shared folder in your system, and a whitespaced list of all the hosts allowed
    to access them together with their accessing options in brackets. As you can see,
    there are different possibilities to define your target clients using IP addresses
    or hostnames. For hostnames, you can use wildcards such as `*` and `?` to keep
    the file more compact and allow for multiple machines at once, but you can also
    define export options for each single host name. Explaining all the options is
    outside the scope of this book; if you need more help, read the exports manual,
    which can be found using `man exports`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the line, `/srv/nfs-data *(ro) 192.168.1.11(rw) 192.168.1.12(rw)`,
    defines that we want to export the content of the folder `/srv/nfs-data` to all
    hostnames (because of the `*` symbol); read-only (`ro`) means that every client
    can read the content of the folder but not write in it. For clients with the IP
    address `192.168.1`, ending with `11` and `12,` we allow reading and writing (`rw`).
    The second line defines that we are exporting the `/home` directory to all clients
    in the subdomain of `*.example.com` with read/write capacity. Whenever you make
    a change to the `/etc/exports` file, run the `exportfs -r` command to apply your
    changes to the NFS server.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can say that NFSv4 in CentOS 7 is very easy to set up and start.
    It's the perfect solution for sharing files between Linux systems, or for centralized
    home directories.
  prefs: []
  type: TYPE_NORMAL
- en: Working with NFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before a client computer can use file system exports shared by an NFS server,
    it has to be configured to correctly access this system. Here in this recipe,
    we will show you how to set things up and work with NFS on the client machine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet in order to facilitate the download of additional
    packages. It is expected that you have already followed the *Installing and configuring
    NFS* recipe and have set up an NFS server, such as in this example. It is expected
    that all the clients can ping each other and are connected to the NFS server,
    and will be using a static IP address (see the recipe, *Building a static network
    connection*, in [Chapter 2](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 2. Configuring the System"), *Configuring the System*). In our example,
    the NFS server is running with the IP `192.168.1.10` and two clients with the
    IPs `192.168.1.11` and `192.168.1.12`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On our client systems, we also need the same NFS software package, and a similar
    configuration to the one on the server, in order to establish a communication
    between them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in on your client as `root`, and apply the exact same steps as
    in the *Installing and configuring NFS* recipe until the end of step 3\. Skip
    step 4 because no firewalld service must be opened. Then, instead of step 5, use
    the following commands, which will not start and enable the `nfs-server`, but
    only the `rpcbind` service instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Stop there and do not apply anything else from the original recipe. To test
    the connection to our NFS server, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to test if attaching the NFS exports works you can do so manually using
    a new user, `john`. This needs to be added to the `nfs-share` group first in the
    following way so that we can write on our share:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the creation of the file in the shared directory works, you can put the
    import in the `fstab` file so that it will be automatically mounted on system
    boot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Append the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, to remount everything from `fstab`, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we showed you how easy it is to use some shared file system
    exports from an existing NFSv4 server.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen, to set up an NFS client, you need a very similar setup to
    the one on the NFS server itself, with the exception of starting the `rpcbind`
    service instead of `nfs-server` (which, as the name implies, is only needed for
    the server side). The `rpcbind` service is a port mapper and is used for **Remote
    Procedure Calls** (**RPC**), which is a communication standard needed for NFS
    to work. Another very crucial step in the configuration that you should remember
    was setting up the domain name in the `/etc/idmapd.conf` file. We will have to
    use the *same* base domain name as on the server (`example.com`) in order to make
    the NFSv4 communication between server and client work. After having started and
    enabled the `rpcbind` service, we could then mount the NFS share to a local directory,
    either using the `mount` command (with `-t` type `nfs4`) directly, or via the
    `fstab` file. Remember, that every system user who wants proper read/write/execute
    permissions to a share needs the *same* permissions on the NFS server; in our
    example we manage correct permissions on an identical GID level. We used the default
    options to mount the share; if you need different or advanced options, please
    refer to `man fstab`. In order to apply changes to the `fstab` file, perform `mount
    -a` to remount everything from that file.
  prefs: []
  type: TYPE_NORMAL
- en: Securely sharing resources with Samba
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Samba** is a software package that enables you to share files, printers,
    and other common resources across a network. It is an invaluable tool for any
    working environment. One of the most common ways to share file resources across
    a heterogeneous network (meaning different computer systems such as Windows and
    Linux) is to install and configure Samba as a standalone file server to provide
    basic file-sharing services through *user level security* with the use of the
    system user''s home directories. Standalone servers are configured to provide
    local authentication and access control to all the resources they maintain. All
    in all, every administrator knows that Samba remains a very popular open source
    distribution, and it is the purpose of this recipe to show you how to deliver
    an instant approach to file sharing that provides the seamless integration of
    any number of users on any type of modern computer across your entire working
    environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet in order to facilitate the download of additional
    packages. It is expected that your server will use a static IP address.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Samba is not installed by default, and for this reason we will begin by downloading
    and installing the required packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, log in as `root` and type the following command in order to install
    the required packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Having done this, the first step is to rename the original configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a new configuration file in your preferred text editor by typing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Begin building your new configuration by adding the following lines, replacing
    the values shown with values that better represent your own needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '`WORKGROUP_NAME` is the name of the Windows workgroup. Use the standard Windows
    name `WORKGROUP` if you don''t have this value. `MY_SERVERS_NAME` refers to the
    name of your server. In most situations, this could be in the form of `FILESERVER`
    or `SERVER1` and so on. `XXX.XXX.XXX.XXX/XX` refers to the primary network address
    that your Samba service is operating at, for example, `192.168.1.0/24`. `NETWORK_NAME`
    refers to the name of your Ethernet interface. This could be `enp0s8`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will now configure Samba as a standalone server. To do this, simply continue
    to add the following lines to your main configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the purpose of this recipe, we do not intend to configure Samba as a domain
    master or master browser. To do this, add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now add support for home directory sharing by enabling valid users
    to access their home directories. This feature will support the appropriate read/write
    permissions and all folders will remain private from other users. To do this,
    add the following new lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and close the file. To test the syntax of the Samba configuration file
    we just created, use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add an existing system user, `john`, to the Samba user management system
    (this is for testing later; change it appropriately to a user name on your system):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, save the file and close it; back on the command line, open the ports in
    the firewall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure SELinux to use the Samba home directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, ensure that the `samba` and `nmb` services will start up during the boot
    process and start them right away:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It was the purpose of this recipe to install Samba and configure its file sharing
    services, thus providing full connectivity across all modern computer systems
    in your network.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: Having installed the necessary packages, we renamed the originally installed
    configuration file to have a backup in place if anything broke later, and then
    we began setting up Samba from scratch, starting with an empty `smb.conf` configuration
    file. Having opened this new file, we began with the global configuration options;
    the first step was to declare compatibility with Unicode-based character sets.
    You will need to be aware that the values can vary as a result of your circumstances
    and network. Read more at `man smb.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: Having done this, we then proceeded to confirm the name of our workgroup and
    server, disable WINS, establish a Samba log file, and register the network interface.
    Then, we elected the following standalone options by choosing a user-based security
    option, password encryption, and a `tdbsam` database backend. The preferred mode
    of security is user-level security, and using this approach implies that each
    share can be assigned to a specific user. Therefore, when a user requests a connection
    for a share, Samba authenticates this request by validating the given username
    and password with the authorized users in the configuration file and the Samba
    database. Next, we added the `master` information. In the case of a mixed operating
    system environment, a known conflict will result when a single client attempts
    to become the master browser. This situation may not disrupt the file-sharing
    service as a whole, but it will give rise to a potential issue being recorded
    by the Samba log files. So by configuring the samba server to not assert itself
    as the master browser, you will be able to reduce the chance of such issues being
    reported. So, having completed these steps, the recipe then considered the main
    task of enabling the `homes` directory file-sharing. Of course, you can experiment
    with the options shown, but this simple set of instructions not only ensures that
    valid users will be able to access their home directory with the relevant read/write
    permissions, but also, by setting the `browseable` flag to `no`, you will be able
    to hide the home directory from public view and achieve a greater degree of privacy
    for the user concerned. In our setup, Samba works with your Linux system users,
    but you should remember that any existing or new user is not added automatically
    to Samba and must be added manually using `smbpasswd -a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, having saved your new configuration file, we tested its correctness using
    the `testparm` program and opened the Samba related incoming ports in firewalld
    using the `samba` service. The next step was to ensure that Samba and its related
    processes would be made available during the boot process using `systemctl`. Samba
    requires two primary processes in order to work correctly: `smbd` and `nmbd`.
    Beginning with `smbd`, it is the role of this service to provide file-sharing,
    printing services, user authentication, and resource locking to Windows-based
    clients using the SMB (or CIFS) protocol. At the same time, it is the role of
    the `nmbd` service to listen, understand, and reply to the NetBIOS name service''s
    requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Samba often includes another service call named `winbindd`, but it has been
    largely ignored because the intention to provide a **Windows Internet Naming Service**
    (**WINS**)-based service or Active Directory authentication requires additional
    consideration, which is beyond the scope of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, our final task was to start both the Samba service (`smb`) and
    the associated NetBIOS service (`nmb`).
  prefs: []
  type: TYPE_NORMAL
- en: You now know how incredibly simple Samba is to install, configure, and maintain.
    There is always more to learn, and yet this simple introduction has served to
    illustrate Samba's relative ease of use and the simplicity of its syntax. It has
    delivered a solution that has the ability to support a wide variety of different
    needs and a range of different computer systems, one that will fulfill your file-sharing
    requirements for many years to come.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can test our Samba server configuration from any client in your network
    that can ping the server. If it is a windows-based client, open the **Windows
    Explorer** address bar and use the following syntax: `\\<ip address of the Samba
    server>\<linux username>`. For example, we use `\\192.168.1.10\john` (on successfully
    connecting to it, you need to enter your Samba username''s password). On any Linux
    client system, (the package, `samba-client`, needs to be installed on CentOS 7)
    to list all the available shares of an NFS server, use the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To test, mount a share (this requires the `cifs-utils` package on CentOS 7)
    with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also put this import in the `/etc/fstab` file for permanent mounting
    using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'for example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, add the following line to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: If you don't want to use passwords in plaintext in this file, read the section
    about credentials using `man mount.cifs`, then create a credentials file and protect
    it with `chmod 600` in your home directory so that no other person can read it.
  prefs: []
  type: TYPE_NORMAL
- en: Here in this chapter, we showed you how to configure Samba as a standalone server
    and enable home directories, and how to connect to it from a client to get you
    started. But Samba can do so much more! It can provide printing services or act
    as a complete domain controller. If you want to learn more, feel free to visit
    [https://www.packtpub.com/](https://www.packtpub.com/) to learn more about other
    available material.
  prefs: []
  type: TYPE_NORMAL
