# 第三章。系统管理

在本章中，我们将涵盖以下主题：

+   了解和管理后台服务

+   解决后台服务问题

+   使用 journald 跟踪系统资源

+   配置 journald 以使其持久化

+   管理用户及其组

+   使用 cron 安排任务

+   使用 rsync 同步文件并执行更多操作

+   维护备份和创建快照

+   监控重要的服务器基础设施

+   使用 Git 和 Subversion 进行控制

# 简介

本章是一系列解决方案的集合，旨在提供基于性能的服务器维护需求。从监控可用磁盘空间，到处理系统服务和管理远程文件同步，本章的目的是展示你如何快速且轻松地掌握服务器维护任务。

# 了解和管理你的后台服务

系统服务是每个 Linux 服务器最基本的概念之一。它们是持续在你的系统中运行的程序，等待外部事件来处理某些事务或一直执行。通常，在使用服务器时，系统用户不会注意到这些正在运行的服务，因为它们作为后台进程运行，因此不可见。任何 Linux 服务器上都有许多服务一直在运行。这些可以是 Web 服务器、数据库、FTP、SSH 或打印、DHCP、或 LDAP 服务器等。在本操作方法中，我们将展示如何管理和处理它们。

## 准备就绪

要完成此操作，你需要一个具有 root 权限的 CentOS 7 操作系统的安装，以及你选择的基于控制台的文本编辑器，以及连接到互联网以便下载额外的软件包。这里展示的一些命令在其输出中使用了*less*导航。请阅读第二章，*系统配置*中的*使用 less 浏览文本文件*操作方法，以学习如何浏览它们。

## 如何操作...

`systemctl`是一个程序，我们将使用它在 CentOS 7 系统中管理所有后台服务任务。在这里，我们将展示如何使用它，以 Apache Web 服务器服务为例，以便熟悉它。要全面了解 Apache，请阅读第十二章，*提供 Web 服务*：

1.  首先，我们以 root 身份登录并安装 Apache Web 服务器软件包：

    ```
    yum install httpd

    ```

1.  接下来，我们将检查 Apache 的服务状态：

    ```
    systemctl status httpd.service

    ```

1.  在后台启动 Web 服务器服务并再次打印出其状态：

    ```
    systemctl start httpd.service
    systemctl status httpd.service

    ```

1.  接下来，让我们打印出系统后台当前运行的所有服务列表；在这个列表中，你应该识别出你刚刚启动的`httpd`服务：

    ```
    systemctl -t service -a --state running

    ```

1.  现在，让我们备份 Apache 配置文件：

    ```
    cp /etc/httpd/conf/httpd.conf /etc/httpd/conf/httpd.conf.BAK

    ```

1.  现在，我们将使用 sed 对主 Apache 配置文件进行一些更改：

    ```
    sed -i 's/Options Indexes FollowSymLinks/Options -Indexes +FollowSymLinks/g' /etc/httpd/conf/httpd.conf

    ```

1.  现在，输入以下命令来停止和启动服务并应用我们的更改：

    ```
    systemctl stop httpd.service
    systemctl start httpd.service
    systemctl status httpd.service

    ```

1.  接下来，让我们启用`httpd`服务，使其在启动时自动启动：

    ```
    systemctl enable httpd.service

    ```

1.  最后一个命令将展示如何重启服务：

    ```
    systemctl restart httpd.service

    ```

## 它是如何工作的...

正如我们所见，`systemctl`实用程序可用于完全控制系统的服务。`systemctl`是`systemd`的控制程序，`systemd`是 CentOS 7 Linux 中的系统和服务的管理器。`systemctl`命令还可以用于其他各种任务，但在这里我们专注于管理服务。

那么，我们从这次经历中学到了什么？

我们从这个配方开始，以 root 身份登录并安装了 Apache Web 服务器包，因为我们想用它来展示如何使用`systemctl`程序管理服务。Apache 或`httpd.service`，正如`systemd`所称的，只是我们将使用的一个例子；在基本服务器环境中可能运行的其他重要服务可能是`sshd.service`、`mariadb.service`、`crond.service`等。之后，我们使用`systemctl status`命令参数检查了 httpd 的当前状态。输出显示了我们两个字段：**Loaded**和**Active**。**Loaded**字段告诉我们它是否当前已加载，以及它是否将在启动时自动启动；**Active**字段表示服务当前是否正在运行。接下来，我们展示了如何使用`systemctl`启动服务。服务的精确启动语法是`systemctl start <服务名称>.service`。

### 注意

通过启动一个服务，程序通过创建一个新进程并将其移动到后台，使其作为非交互式后台进程运行，从而与终端分离。这有时被称为**守护进程**。

接下来，在我们启动了 Apache Web 服务器守护进程之后，我们再次使用 systemctl 的`status`参数来展示如果我们运行它，状态是如何变化的。输出显示该服务当前已加载但在重启时被禁用。我们还看到它正在运行，以及该服务的最新日志输出和其他关于该进程的详细信息。要获取系统上所有服务的所有状态信息的概览，请使用`systemctl --type service --all`。`systemctl`服务不必一直运行。它的状态也可以是停止、降级、维护等。接下来，我们使用以下命令获取系统上所有当前正在运行的服务的列表：

```
systemctl -t service -a --state running

```

如您所见，我们在这里使用了`-t`标志来过滤仅显示类型服务单元。正如您可能猜到的，`systemctl`不仅可以处理服务单元，还可以处理许多其他单元类型。`systemd`单元是`systemd`可以使用配置文件管理的资源，它们封装了关于服务、监听套接字、保存的系统状态快照、挂载设备以及其他与系统相关的对象的信息。要获取所有可能的单元类型的列表，请键入`systemctl -t help`。这些配置单元文件位于系统中的特殊文件夹中，它们所属的类型可以从扩展名中读取；所有服务单元文件都具有文件扩展名`.service`（例如，设备单元文件具有扩展名`.device`）。系统将它们存储在两个地方。所有在安装期间由基本系统安装的`systemd`单元文件都位于`/usr/lib/systemd/system`，所有其他来自安装包（如 Apache）的服务或您自己的配置应该放到`/etc/systemd/system`。我们可以在`/usr/lib/systemd/system/httpd.service`找到我们的 Apache 服务配置文件。接下来，我们向用户展示了如何停止服务，这是启动它的反向操作，使用语法`systemctl stop <服务名称>`。最后，作为最后一步，我们使用了 systemctl 的`restart`参数，它只需一步即可处理服务的停止和启动，减少了输入。如果服务挂起且无响应，并且您需要快速重置它以使其工作，这通常很有用。在展示如何停止和重启服务之前，我们做了另一件重要的事情。当 Apache 服务正在运行时，我们使用`sed`命令更改了其主要服务配置文件，添加了一个`-Indexes`选项，该选项禁用了目录网站文件列表，这是提高 Web 服务器安全性的常见措施。由于 Apache Web 服务器已经在运行并在服务启动期间将配置加载到内存中，因此对该文件的任何更改都不会被正在运行的服务识别。

### 注意

通常情况下，为了应用任何配置文件的更改，运行的服务需要进行完整的服务重启，因为配置文件通常只在启动初始化期间加载。

现在，想象一下你的 Web 服务器可以从互联网访问，并且此刻有很多人在同时访问你的网页或应用程序。如果你正常重启 Apache，Web 服务器将有一段时间无法访问（直到服务器重启完成），因为进程实际上会结束，然后重新开始。所有当前用户如果在那时请求内容，都会收到 HTML 404 错误页面。此外，所有当前会话信息也会丢失；想象一下，你有一个在线网店，人们使用购物车或登录。所有这些信息也会消失。为了避免重要服务（如 Apache Web 服务器）的中断，这些服务中的一些具有`reload`选项（但并非每个服务都有此功能！），我们可以应用此选项而不是`restart`参数。此选项只是重新加载并应用服务的配置文件，而服务本身保持在线，执行过程中不会被打断。对于 Apache，你可以使用以下命令行：`systemctl reload httpd.service`。要获取所有具有重新加载功能的服务列表，请使用以下命令：

```
grep -l "ExecReload" /usr/lib/systemd/system/*.service /etc/systemd/system/*.service

```

因此，完成这个配方后，我们可以说我们现在知道如何使用基本的`systemctl`参数来管理服务。它是一个非常强大的程序，可以用于比仅仅启动和停止服务更多的事情。此外，在这个配方中，我们使用了不同的名称，它们都意味着相同：系统服务、后台进程或守护进程。

## 还有更多...

还有一种重要的单元类型叫做`目标`。目标也是单元文件，你的系统中已经有相当数量的目标可用。要显示它们，请使用以下命令：

```
ls -a /usr/lib/systemd/system/*.target /etc/systemd/system/*.target

```

简而言之，目标是一系列单元文件的集合，如服务或其他目标。它们可以用来创建类似于早期 CentOS 版本中的运行级别环境。运行级别定义了在系统处于何种状态时应加载哪些服务。例如，有图形状态，或救援模式状态等。要查看常见的运行级别如何对应于我们的目标，可以运行以下命令，该命令显示了它们之间的所有符号链接：

```
ls -al /lib/systemd/system | grep runlevel

```

目标可以依赖于其他目标；为了获得目标依赖关系的良好概览，我们可以运行以下命令，显示从多用户目标到所有其他目标的所有依赖关系（绿色表示活跃，红色表示不活跃）：

```
systemctl list-dependencies multi-user.target

```

你可以使用以下命令显示我们当前所在的目标：

```
systemctl get-default

```

你也可以切换到另一个目标：

```
systemctl set-default multi-user.target

```

# 故障排除后台服务

通常，系统管理员工作的大部分时间都在解决服务器出现问题时的故障。这对于系统服务尤其如此，因为它们一直在运行并处理信息。服务可能依赖于其他服务和服务器的系统，系统管理员的生活中将会遇到系统服务失败或拒绝启动的情况。在这里，在这个步骤中，我们将向你展示如果出现问题如何解决它们。

## 准备就绪

要完成这个步骤，你需要一个具有 root 权限的 CentOS 7 操作系统的工作安装，以及你选择的基于控制台的文本编辑器；你还应该完成了本章中的*了解和管理你的后台服务*步骤，在那里我们安装了 Apache 网络服务器。

## 如何做到这一点...

为了向你展示如何解决服务问题，我们将在 Apache 服务的配置文件中引入一个随机错误，然后向你展示如何解决和修复它：

1.  以 root 身份登录，并输入以下命令将内容追加到`httpd.conf`：

    ```
    echo "THIS_IS_AN_ERRORLINE" >> /etc/httpd/conf/httpd.conf

    ```

1.  接下来，重新加载`httpd`服务并显示其输出：

    ```
    systemctl reload httpd.service
    systemctl status httpd.service -l

    ```

1.  让我们撤销这个错误行：

    ```
    sed -i 's/THIS_IS_AN_ERRORLINE//g' /etc/httpd/conf/httpd.conf

    ```

1.  现在，再次重启服务：

    ```
    systemctl reload httpd.service
    systemctl status httpd.service

    ```

## 它是如何工作的...

在这个相当短的步骤中，我们向你展示了如果服务包含错误，示例服务将如何表现，以及你可以做些什么来修复它以开始。当服务出现故障时，有很多不同的场景可能会出现问题，解决这些问题可能是系统管理员工作的重要部分。

那么，我们从这次经历中学到了什么？

我们从这个步骤开始，在 Apache 主配置文件中引入了一行文本，该文本不包含任何有效的配置语法，因此`httpd`服务无法解释它。然后，我们使用`systemctl reload`参数重新加载我们服务器的配置文件。如前所述，并非所有服务都有重新加载选项，因此如果你的服务不支持这一点，请使用`restart`参数代替。由于 Apache 将尝试加载我们当前更改的配置文件，它将拒绝接受新的配置，因为我们在其中引入了错误的语法。由于我们只是重新加载配置，正在运行的 Apache 进程不会受到这个问题的影响，并将继续在线使用其原始配置。`systemctl`参数将打印出以下错误消息，给我们下一步该做什么的提示：

```
Job for httpd.service failed. Take a look at systemctl status httpd.service and journalctl -xe for details.

```

正如错误输出所建议的，`systemctl`状态参数是一个非常强大的工具，可以看到服务背后的情况，并试图找出任何失败的原因（在这里你也可以看到 Apache 仍在运行）。如果你使用`-l`标志启动`systemctl`状态，它会打印出更长的输出版本，这可以帮助你更多。

这个命令的输出向我们展示了配置重新加载失败的精确原因，因此我们可以轻松地追踪问题的根源（输出已被截断）：

```
AH00526: Syntax error on line 354 of /etc/httpd/conf/httpd.conf:
Invalid command ERRORLINE, perhaps misspelled or defined by a module, is not included in the server configuration.

```

这个输出是完整的`journald`日志信息的一部分。如果你想了解更多关于它的信息，请参考本章中的*使用 journald 跟踪系统资源*食谱。因此，通过这个输出中非常有用的信息，我们可以轻松地发现问题，并使用`sed`命令重新引入`ERRORLINE`，然后重新加载服务；这次一切都会正常工作。

因此，总的来说，我们可以说`systemctl status`命令是一个非常方便的命令，在找出服务问题时非常有帮助。大多数服务对语法错误非常敏感，有时可能只是一个错位的空格字符导致服务拒绝工作。因此，系统管理员必须始终精确工作。

# 使用 journald 跟踪系统资源

日志文件包含系统消息和来自服务、内核以及各种运行应用程序的输出。在许多情况下，它们非常有用，例如，用于解决系统问题、监控服务或其他系统资源，或者在安全事件发生后进行安全取证。在本食谱中，你将学习如何使用 journald 进行日志记录服务的基本操作。

## 准备工作

要完成这个食谱，你需要一个安装了 CentOS 7 操作系统的工作环境，具备 root 权限和一个你选择的基于控制台的文本编辑器。此外，正确设置时间和日期对于整个日志记录概念至关重要，因此请在使用本食谱之前，应用来自第二章，*配置系统*的*使用 NTP 和 chrony 套件同步系统时钟*食谱。此外，对 systemd 和单元有基本了解可能会有优势。这在本书的*了解和管理后台服务*食谱中有所涉及。Journalctl 使用*less*导航来显示输出；如果你不知道如何使用它，请阅读来自第二章，*配置系统*的*使用 less 导航文本文件*食谱。

## 如何操作...

在 CentOS 7 中，我们有两个日志记录机制可供选择，分别是`rsyslog`和`journald`日志系统，后者是新的`systemd`系统管理器的一个组件，用于查看和管理日志信息。在这里，我们将向你展示如何使用`journalctl`命令，它是`journald`守护进程的控制客户端：

1.  首先，以 root 身份登录，并输入以下命令来查看整个日志：

    ```
    journalctl

    ```

1.  接下来，我们只想显示在特定时间范围内的消息（相应地更改日期）：

    ```
    journalctl --since "2015-07-20 6:00:00" --until "2015-07-20 7:30:00"

    ```

1.  之后，我们想通过所有来自 sshd 服务的消息来过滤日志系统：

    ```
    journalctl -u sshd.service --since "yesterday"

    ```

1.  现在，我们只想显示类型为错误的消息：

    ```
    journalctl -p err -b

    ```

1.  要获取`journalctl`最详细的版本，请使用`verbose`选项：

    ```
    journalctl -p err -b -o verbose

    ```

1.  要获取日志输出的*当前*视图，请使用以下命令（这不是*less*导航——使用组合键*Ctrl*+*C*退出此视图）：

    ```
    journalctl -f

    ```

## 它是如何工作的...

在 CentOS 7 中，我们可以使用新的`journald`日志记录系统，它是`systemd`系统管理的一部分。它是一个集中式工具，将记录系统上的几乎所有内容，包括从早期启动到内核、服务以及所有程序消息的所有输出。与其他日志记录机制相比，主要优势在于您不必为每个服务或其他资源配置日志记录，因为一切都已经为通过集中式`systemd`系统控制和运行的所有应用程序设置好了。

那么，我们从这次经历中学到了什么？

我们通过运行`journalctl`命令开始了我们的旅程，该命令在不带任何参数的情况下向我们展示了完整的日志记录，包括从系统启动到最新的系统消息，按照它们出现的顺序，将新消息附加到底部（按时间顺序）。如果您的系统已经运行了一段时间，它可能包含数十万行日志数据，以这种原始形式处理非常不切实际。

此输出由`journald`守护进程持续捕获，但不写入文本文件，如`rsyslog`等其他日志系统所做的那样。相反，它使用结构化和索引的二进制文件，存储大量额外的元信息，如用户 ID、时间戳等，这使得将其转换为各种不同的输出格式变得容易。如果您想通过另一个工具进一步处理日志信息，这可能会非常方便。由于无法读取二进制文件，您将需要客户端`journalctl`来查询`journald`数据库。由于手动解析如此大量的数据几乎是不可能的，因此我们利用了 journalctl 丰富的过滤选项。首先，我们使用`--since`和`--until`参数提取特定时间范围内的所有日志消息。指定时间和日期的语法非常灵活，理解诸如`昨天`或`现在`之类的短语，但我们坚持使用简单的日期语法，`YYYY-MM-DD HH:MM:SS`。接下来，我们使用 journalctl 的`-u`参数过滤特定单元类型的日志消息。我们使用它来过滤来自 sshd 守护程序服务的消息。我们添加了另一个使用`--since`参数的过滤器，这进一步收紧了`-u`单元过滤器的结果，仅输出昨天发生的 sshd 服务结果。我们应用的下一个过滤器是使用参数字符串`-p err -b`，它按优先级或日志级别过滤日志数据库。每个日志消息都可以有一个关联的优先级，该优先级确定消息的重要性。要了解有关不同日志级别的更多信息，请参阅手册，使用命令行`man 3 syslog`（如果此手册不可用，请键入`yum install man-pages`进行安装）。我们的命令将打印出所有标记为`错误`或以上的日志消息，包括：`错误`、`严重`、`警报`或`紧急`。

接下来，我们使用了相同的命令参数，但添加了`-o verbose`，这提供了最详细的日志信息输出。最后，我们介绍了`-f`参数（用于跟随），它将为我们提供最新的日志消息的*实时*视图，并保持此连接打开，当新消息出现时，将其附加到输出的末尾。这在测试设置或启动/停止服务时查看系统反应通常很有用。

总之，可以说在 CentOS 7 上，两个日志系统并存：较旧的`rsyslog`和较新的`journald`，后者是您首选的系统故障排除工具。但请记住，在 CentOS 7 上，`journald`并不是`rsyslog`的完全替代品。`journald`中缺少一些`rsyslog`的功能，而且还有许多工具和脚本，如日志摘要工具或监控套件如 Nagios，它们仅与`rsyslog`配合使用。

系统管理员在解决系统错误或意外服务器行为时经常面临巨大挑战。通常，在应用正则表达式搜索或 Linux 命令行功夫时，通过搜索大量不同的日志文件文本来找到单一故障点并不容易。Journald 提供了一个非常方便的替代方案，通过提供一个强大且定义良好的集中查询系统，快速高效地完成日志文件分析！

# 配置 journald 以使其持久

Journald 相对于其他日志系统如`rsyslog`的优势在于，它非常高效，并且会自动记录系统上的几乎所有内容，无需进行任何配置，因为它属于`systemd`套件的一部分。主要缺点是，`journald`的所有日志信息在系统重启后都会丢失。Journald 日志可以产生大量数据，并且默认情况下所有日志信息仅保存在内存中，如果你需要访问较旧的日志信息或分析系统崩溃重启的原因，这并不实用。在本教程中，我们将向你展示如何配置`journald`以使其持久。

## 准备就绪

要完成这个教程，你需要一个具有 root 权限的 CentOS 7 操作系统的最小安装，以及你选择的基于控制台的文本编辑器。

## 如何操作...

开始这个教程，我们需要创建一个位置来保存我们的持久日志数据库：

1.  以 root 用户身份登录并创建以下目录：

    ```
    mkdir /var/log/journal

    ```

1.  接下来，将新目录添加到`journald`中，用作存储位置并修复权限：

    ```
    systemd-tmpfiles --create --prefix /var/log/journal

    ```

1.  现在，重启`journald`：

    ```
    systemctl restart systemd-journald

    ```

1.  最后，为了检查日志是否在重启后存活，重启计算机并输入以下命令：

    ```
    journalctl --boot=-1

    ```

## 工作原理...

我们通过创建新目录`/var/log/journal`开始了这个教程。默认情况下，`journald`将其日志数据库写入`/run/log/journal`，这是一个仅用于运行时信息的目录，其内容在系统重启后不会保留。之后，我们使用`systemd-tmpfiles`命令为`journald`设置新目录。最后，我们重启了`journald`服务器守护进程，以将我们的更改应用到系统。为了测试持久性是否正常工作，重启你的服务器，然后使用`journalctl –boot=-1`。这将向我们展示上次启动以来的所有日志信息。如果持久性没有正常工作，它会打印出以下错误；否则，它会正确显示上次启动之前的所有日志消息：

```
Failed to look up boot -1: Cannot assign requested address

```

在这个相当简单的教程中，我们展示了如何使`journald`在系统重启后保持持久性。如果你需要查看过去的旧日志文件，这会非常有用，有时这能帮助你找出问题，例如过去硬件故障的根源。

# 管理用户及其组

在这个操作中，我们将学习如何在 CentOS 7 上管理系统的用户和组。基本的用户和组管理技能是 CentOS 系统管理员最重要的基础之一。

## 准备就绪

要完成这个操作，您需要一个具有 root 权限的 CentOS 7 操作系统的有效安装，以及您选择的基于控制台的文本编辑器。

## 如何操作...

这个操作向您展示了如何通过学习如何添加、删除和修改用户和组来管理它们：

1.  要开始这个操作，我们以 root 身份登录，并输入以下命令以获取系统中所有已知用户的列表：`cat /etc/passwd`。

1.  现在，显示 root 用户的 ID（**UID**）和组 ID（**GID**）：

    ```
    id root

    ```

1.  接下来，我们将运行以下命令以在系统中添加一个新用户（将`your_new_username`替换为您选择的用户名）：

    ```
    useradd your_new_username

    ```

1.  然而，为了完成这个过程，您将被要求提供一个合适的密码。为此，输入以下命令（将`your_new_username`替换为您选择的用户名），然后在提示时输入一个安全的密码：

    ```
    passwd your_new_username

    ```

    ### 注意

    密码不应少于六个字符，但也不应超过十六个字符。它们应由字母数字值组成，并且出于显而易见的原因，您必须避免使用空格。不要使用字典中的单词，并避免使用已知或明显的短语。

1.  接下来，创建一个新组并给它一个特殊的名称：

    ```
    groupadd your_new_group

    ```

1.  然后，我们将新用户添加到这个新组中：

    ```
    usermod -G your_new_group your_new_username

    ```

1.  最后，让我们打印出新用户的用户 ID 和组 ID，看看发生了哪些变化：

    ```
    id your_new_username

    ```

## 它是如何工作的...

这个操作的目的是创建一个新用户和组，并展示如何将它们连接在一起。

那么，我们从这次经历中学到了什么？

首先，我们打印出`/etc/passwd`文件的内容，以显示系统中所有当前用户。这个列表不仅包含属于真实人物的普通用户账户，还包含用于控制和拥有特定应用程序或服务的账户。然后，我们使用`id`命令来显示我们现有用户 root 的唯一用户 UID 和 GID。在 Linux 中，每个用户都可以通过他们的 UID 和 GID 来识别，并且文件系统中的每个文件都有特定的权限设置，这些设置管理文件所有者、组所有者和其他用户的访问权限。对于这三个组中的每一个，您都可以使用`chmod`命令启用或禁用读、写和执行权限（使用`man chmod`了解更多信息，并查看`man chown`）。所有者和组权限对应于一个 UID 和 GID，我们可以使用`ls -l`为每个文件显示这些信息。

接下来，我们执行了`useradd`命令，要求我们为新用户提供一个合适的名称，这将使服务器能够使用一组默认值和标准建立新身份，包括用户 ID、家目录、主组（GID），并将默认 shell 设置为 bash。完成此过程只需确认一个合适的密码。要删除用户，有相反的命令`userdel`，其工作方式类似，但可以给出`-f`选项以删除家目录而不是将其留在系统上。接下来，我们使用了`groupadd`命令，顾名思义，它将创建一个新组并为它分配一个新的唯一 GID。之后，我们使用`usermod -G`命令将我们的用户添加到之前创建的新组中。如前所述，每个用户都有一个唯一的 UID 和 GID。第一个组是主组，是必需的；但是，用户可以属于多个不同的组，这些组称为辅助组。创建新文件时需要主组，因为它将设置创建它的用户的 GID 和 UID。要删除组，我们可以使用`groupdel`命令。最后，我们再次使用`id`命令查看新用户的 UID、主 GID 以及我们添加给它的新的辅助 GID 组。

现在，您只需使用几个命令即可完全控制用户和组：`useradd`、`usermod`、`userdel`、`groupadd`、`groupmod`和`groupdel`。

# 使用 cron 安排任务

在本食谱中，我们将探讨服务器自动化的作用以及通过引入您到基于时间的作业调度程序 cron 来在预定义周期内运行特定任务的便利性。Cron 允许通过使管理员能够根据任何小时、任何天或任何月确定预定义的计划来自动化任务。它是 CentOS 操作系统的标准组件，本食谱的目的是向您介绍管理重复任务的概念，以便利用这一宝贵工具并使 CentOS 为您工作。

## 准备就绪

要完成本食谱，您需要具有 root 权限的 CentOS 7 操作系统的最小安装，以及您选择的基于控制台的文本编辑器。`crontab`程序使用 Vim 进行文件编辑。如果您不知道如何使用 Vim，请查看食谱*Vim 简介*中的教程，位于第二章，*配置系统*。

## 如何操作...

本食谱的目的是创建一个脚本，该脚本将每五分钟将时间和日期以及您选择的几句话写入文本文件。这可能看起来是一个相对简单的练习，但意图是向您展示，从这种简单性出发，cron 可以用于做更多的事情，这将使与 CentOS 一起工作成为一种绝对的乐趣。

1.  要开始这个配方，请以 root 身份登录并创建您的第一个 cron 作业，方法是输入：

    ```
    crontab -e

    ```

1.  我们现在将创建一个简单的 cron 作业，该作业将日期和时间与单词 `hello world` 一起写入位于 `/root/cron-helloworld.txt` 的文件中，每五分钟一次。为此，添加以下行：

    ```
    */5 * * * * echo `date` "Hello world" >>$HOME/cron-helloworld.txt

    ```

1.  完成后，只需保存文件并退出编辑器。系统现在将响应以下消息：

    ```
    crontab: installing
     new crontab

    ```

1.  前面的消息通知您，服务器现在正在创建新的 `cron` 作业，并将自动激活它。您可以通过查看位于 `/root/cron-helloworld.txt` 的文件来查看脚本的输出（您必须等待 5 分钟），或者通过监视位于 `/var/log/cron` 的日志文件（使用 `tail -f /var/log/cron` 和 `Ctrl+C` 退出）。

## 它是如何工作的...

Cron 是一个程序的名称，它允许 CentOS 用户在指定的时间和日期自动执行命令或脚本。Cron 的设置保存在一个名为 `crontab` 的用户特定文件中，正如我们在本配方中看到的那样，可以编辑此文件以创建所需的自动化任务。

那么我们从这次经历中学到了什么？

使用的示例非常简单，但在许多方面，这是这个配方的目的。Crontab 使用一个守护进程 `crond`，它一直在后台运行，并每分钟检查一次是否有任何计划的任务需要执行。如果找到任务，则 cron 将执行它。要编辑现有的 `crontab` 文件或创建新的 `crontab`，我们使用 `crontab -e` 命令。要查看当前的 cron 作业列表，可以键入 `crontab -l`。或者，要查看另一个用户的当前作业列表，可以键入 `crontab -u username -l`。任务或作业通常称为 cron 作业，并且通过在我们的第一个脚本中避免复杂性，目的是向您展示命令构造的本质非常简单。cron 作业的形成如下所示：

```
<minute> <hour> <day of the month> <month of the year> <day of the week> <command>

```

条目由单个或制表符分隔，允许的值主要是数字（即，`0-59` 表示分钟，`0-23` 表示小时，`1-31` 表示月份中的日期，`1-12` 表示年份中的月份，`0-7` 表示星期几）。然而，这样说也是正确的，即存在更具体的运算符（`/`，`-`）和特定的 cron 快捷方式（即，`@yearly`，`@daily`，`@hourly`，`@weekly`），这些允许额外的控制。例如，`/` 运算符用于逐步指定单位，可以读作 *每*，所以在我们的配方中使用 `*/5` 将使任务每五分钟运行一次，而使用 `*/1` 将使任务每分钟运行一次。此外，您应该知道，使用此语法将使所有命令与小时对齐。因此，考虑到这一点，对于任何想要编写他们的第一个 `cron` 作业的人来说，最合适的模板或起点是开始使用一系列五个星号，然后是命令，如下所示：

```
* * * * * /absolute/path/to/script.sh

```

然后，继续配置所需的分钟、小时、日期、月份和星期值。例如，如果您希望在每个工作日（周一至周五）的晚上 8 点（20:00 小时）运行特定的 PHP 脚本，它可能看起来像这样：

```
0 20 * * 1-5 /full/path/to/your/php/script.php

```

因此，考虑到这一点，通过完成本食谱，您可以看到 cron 如何用于管理数据库备份，运行预定系统备份，通过在预定义间隔激活脚本来支持网站，或运行各种 bash 脚本等等。

## 还有更多...

要删除或禁用 cron 作业，只需从单个用户的 cron 文件中删除指令，或者在行首放置一个哈希（`#`）。单个 cron 文件可以在`/var/spool/cron/<username>`找到，使用哈希将禁用 cron 作业或允许您编写注释。要完全删除`crontab`文件，您还可以使用`crontab -r`。例如，如果您想删除主食谱中创建的 cron 作业，您可以以 root 身份登录并开始输入命令`crontab -e`。此时，您可以删除整行或将其注释掉，如下所示：

```
# */15 * * * * echo `date` "Hello world" >>$HOME/cron-helloworld.txt

```

接下来，保存文件。在文件系统中还有一些特殊的 cron 目录，用于系统范围的 cron 作业。如果您将脚本文件放入其中，它将在特定时间点自动运行。这些目录在`/etc`目录中被称为`cron.daily`、`cron.hourly`、`cron.weekly`和`cron.monthly`，它们的名称指的是它们运行的时间点。如果您不再想执行脚本，只需将其从文件夹中删除即可。查看*监控重要服务器基础设施*的示例。

# 使用 rsync 同步文件并执行更多操作

`rsync`是一个程序，可用于在各种本地和远程位置之间同步文件和目录。它可以与多种操作系统交互，通过 SSH 工作，提供增量备份，在远程机器上执行命令，并取代`cp`和`scp`命令的需求。`rsync`程序对于打算运行服务器或管理计算机网络的任何系统管理员来说都是无价之宝，因为它不仅简化了备份过程，还可以用于执行完整的备份解决方案。因此，本食谱的目的是提供一个合适的起点，以快速成为您信赖的朋友的小工具。

## 准备就绪

要完成本食谱，您需要具有 root 权限的 CentOS 7 操作系统的安装，您选择的基于控制台的文本编辑器以及连接到 Internet 以促进下载其他软件包的连接。

## 如何操作...

在本食谱的过程中，将假定您知道要同步的源文件和目录的位置，并且有一个合适的目的地：

1.  要开始本教程，请以 root 身份登录并键入以下内容安装`rsync`：

    ```
    yum install rsync

    ```

1.  现在，为我们的同步创建一个目标目录（根据需要更改文件夹名称）：

    ```
    mkdir ~/sync-target

    ```

1.  要开始同步过程，只需重复以下命令，通过修改用于`/path/to/source/files/`的值来满足您的需求：

    ```
    rsync -avz --delete /path/to/source/files/  ~/sync-target

    ```

1.  在确认前面的指令后，您的系统现在将响应一个实时报告，说明正在复制的内容。当这个过程完成后，您可以比较两个目录，看看内容是否完全相同。为此，请使用`diff`命令（如果两者相同，则不会写入输出）：

    ```
    diff -r /path/to/source/files/ ~/sync-target

    ```

## 它是如何工作的...

在本教程中，我们考虑了通过命令行使用`rsync`。当然，这只是使用这个工具的众多方式之一，但通过这种方法，我们能够探索这个非常有价值的实用程序提供的一些功能。

那么，我们从这次经历中学到了什么？

Rsync 并不是为了复杂而设计的。它是一个快速且高效的文件同步工具，旨在通过在命令行上为您提供完整的访问权限来实现多功能性。它可以用来在同一台机器上或在完全不同的系统上维护`源`目录的精确副本（或镜像），它通过一次复制所有文件，然后在下次运行时仅更新已更改的文件来实现这一点。这可以节省大量的带宽，并且应该是您在网络上复制数据时的主要工具。使用短语`--delete`很重要，因为它指示`rsync`删除目标上不存在于源中的文件，而所选标志意味着`rsync`应该使用`-a`存档模式来递归复制文件和目录，同时保持所有权限和基于时间的信息；`–v`）详细模式，以便您可以看到正在发生的事情；以及`–z`在文件传输期间压缩数据，以节省带宽并减少完成整个过程所需的时间。

如您所见，`rsync`非常灵活，并且有许多超出本教程目的的选项，但如果您想排除某些文件，您始终可以通过调用`--exclude`标志来扩展原始指令。通过这样做，您告诉`rsync`备份整个目录，但确保不包括预定义的文件和文件夹模式。例如，如果您正在将文件从服务器复制到 USB 设备，并且您不想包括大型文件（如`.iso`映像）或 ZIP 文件，那么您的命令可能与此类似：

```
rsync --delete -avz --exclude="*.zip" --exclude="*.iso"  /path/to/source/ /path/to/external/disk/

```

最后，关于详细程度的话题。详细程度非常有用，但倾向于使用字节作为其主要测量单位可能会引起混淆。因此，为了改变这一点，您可以调用带有`–h`（或人类可读）选项的`rsync`，如下所示：

```
rsync -avzh --exclude="home/path/to/file.txt" /home/ /path/to/external/disk/

```

# 维护备份和快照

在本配方中，我们将向您展示如何定期进行数据备份，这些备份将使用`crond`守护进程对系统的一些目录进行快照。这将定期运行`rsync`程序，以实现完全自动化的备份解决方案。

## 准备就绪

要完成此配方，您需要一个具有 root 权限的 CentOS 7 操作系统的有效安装，以及您选择的基于控制台的文本编辑器。如果您阅读了本章中的*使用 rsync 同步文件并执行更多操作*和*使用 cron 安排任务*配方，以获得对所用命令的更深入理解，那将是有益的。

## 如何操作...

在继续此配方之前，在您的服务器上安装`rsync`程序非常重要。

1.  首先，以 root 身份登录并创建一个目录，我们的备份将存放在那里：

    ```
    mkdir /backups

    ```

1.  现在，我们将创建以下 shell 脚本文件并打开它进行编辑：

    ```
    mkdir ~/bin;vi ~/bin/mybackup.sh

    ```

1.  输入以下内容，将环境变量`DEST`和`SOURCE`中的`/backups`替换为您希望备份的目录，以及收件人的`EMAIL`：

    ```
    #!/bin/bash
    SBJT="cron backup report for `hostname -s` from $(date +%Y%m%d:%T)"
    FROM=root@domain
    EMAIL=johndoe@internet.com
    SOURCE=/root
    DEST=/backups
    LFPATH=/tmp
    LF=$LFPATH/$(date +%Y%m%d_%T)_logfile.log
    rsync --delete --log-file=$LF -avzq $SOURCE $DEST
    (echo "$SBJT"; echo; cat $LF ) | sendmail -f $FROM -t $EMAIL

    ```

1.  使脚本可执行：

    ```
    chmod a+x /root/bin/mybackup.sh

    ```

1.  现在，使用以下命令打开`crontab`：

    ```
    crontab -e

    ```

1.  接下来，通过在文档末尾添加以下行来创建以下条目，然后保存并关闭它：

    ```
    30 20 * * * /root/bin/mybackup.sh

    ```

## 它是如何工作的...

在本配方中，我们为单个系统目录创建了一个完全自动化的备份解决方案，该解决方案将在某个时间点创建文件的快照。备份过程完成后，您将收到一封电子邮件，通知您已进行备份，并附有对所采取行动的简要回顾。

那么我们从这次经历中学到了什么？

我们通过创建一个目录来开始此配方，我们的备份将放置在那里。接下来，我们创建了实际的脚本并填充了一些命令。第 1 行将文件定义为 bash 脚本，第 2-6 行是您可以修改和自定义以满足您自己需求的变量。第 7-8 行根据日期创建日志文件的路径和名称，第 9 行调用`rsync`，它将同步所有源文件到目标目录/backups。它使用特殊的`--log-file`参数，该参数将所有输出写入给定文件。最后一行（10）将此日志文件的内容发送到电子邮件地址。

请记住，您应该根据需要自定义值（即更改使用的电子邮件地址，选择源目录，选择目标目录等）。在它能够被`cron`使用和执行之前，我们使其可执行。最后，我们将此脚本添加为 cron 作业，以便在每天的 20:30 小时运行。但是，由于这可能需要几个小时，如果您想立即测试脚本，可以使用以下命令在命令行上执行它：

```
/root/bin/mybackup.sh

```

总之，不言而喻，备份应该位于外部驱动器或单独的分区上，但是完成这个介绍后，我认为你会同意`rsync`处于理想的位置，它将使任何服务器管理员能够制定自己的政策，以维护重要数据的有效备份。

# 监控重要的服务器基础设施

在本配方中，我们将使用一个小脚本来定期监控可用文件系统的磁盘空间，如果超过某个百分比阈值，脚本将发送带有警告消息的邮件。

## 准备就绪

要完成这个配方，你需要一个具有 root 权限和所选控制台文本编辑器的 CentOS 7 操作系统的有效安装。你应该已经阅读了*使用 cron 安排任务*配方，以便对 cron 系统的原理有一个基本的了解。

## 如何做到这一点...

1.  要开始这个配方，请以 root 身份登录并创建以下文件，该文件将包含我们的监控脚本：

    ```
    vi /etc/cron.daily/monitor_disk_space.sh

    ```

1.  现在，请输入以下内容：

    ```
    #!/bin/bash
    EMAIL="root@localhost"
    THRESHOLD=70
    df -H | grep -vE '^Filesystem|tmpfs|cdrom' | awk '{ print $5 " " $6 }' | while read output;
    do
     usep=$(echo $output | awk '{ print $1}' | cut -d'%' -f1  )
     partition=$(echo $output | awk '{ print $2 }' )
     if [ $usep -ge $THRESHOLD ]; then
     (echo "Subject: Alert: Free space low on `hostname -s`, $usep % used on $partition"; echo)| 
     sendmail -t $EMAIL
     fi
    done

    ```

1.  现在，保存文件并使其可执行：

    ```
    chmod +x /etc/cron.daily/monitor_disk_space.sh

    ```

## 它是如何工作的...

我们使这个脚本可执行，并将其放入`/etc/cron.daily`目录中，这就是我们需要做的所有事情，以便通过`crond`服务每天自动运行这个脚本。

这个简单的脚本向我们展示了构建监控脚本是多么容易，这可以成为安装和配置大型监控套件（如 Nagios）的真正替代方案。您可以使用所示的脚本作为起点，添加更多需要监控的重要资源，例如 CPU 负载、可用 RAM 等。

我们使用了一个执行 Linux 命令`df`的脚本，这是一个报告文件系统磁盘空间使用情况的工具。从这个命令的输出中，脚本然后解析了`USE%`列（使用 Unix 工具`awk`和`cut`），这给了我们总磁盘使用百分比。然后，这个数字将与用户可以通过编辑脚本并更改环境变量`THRESHOLD`设置的阈值进行比较。如果提取的百分比数字高于我们的阈值，将向定义了环境变量`EMAIL`的电子邮件地址发送电子邮件（如果需要，请相应更改）。

# 使用 GIT 和 Subversion 进行控制

文档修订控制系统或版本控制系统，有时也称为版本控制系统，用于管理文档的更改。随着现代工作越来越多地将来自世界各地的人们联系起来，共同合作并共同处理各种文档（例如，软件源代码），这些系统变得越来越重要，因此管理不同人使用修订版进行的文件更改变得非常重要。在本配方中，我们将向您展示如何使用现代版本控制系统，如 GIT 和 Subversion，来管理配置文件的版本控制。

## 准备就绪

要完成本教程，你需要一个具有 root 权限的 CentOS 7 操作系统的工作安装，以及一个互联网连接，以便于下载额外的软件包。

## 如何操作...

在本教程中，我们将把完整的 Linux 主配置目录`/etc/`置于 Git 仓库的版本控制之下，以跟踪我们对配置文件所做的所有更改：

1.  首先，以 root 身份登录，安装 Git，并通过提供电子邮件地址和用户名来配置它（请将`your_username`和`your_email_address`替换为真实姓名）：

    ```
    yum install git
    git config --global user.email  "your_email_address"
    git config --global user.name "your_username"

    ```

1.  现在，让我们在`/etc`目录中创建一个新的仓库：

    ```
    cd /etc/
    git init

    ```

1.  现在，我们有了新的仓库，让我们将`/etc/`目录中的所有文件置于版本控制之下：

    ```
    git add *

    ```

1.  要提交文件到仓库，创建你的第一个版本，请输入以下内容：

    ```
    git commit -a -m "inital commit of the full /etc/ directory"

    ```

1.  现在，让我们更改一个文件：

    ```
    echo "FILE HAS CHANGED" >> yum.conf

    ```

1.  接下来，展示你的仓库中的更改：

    ```
    git status

    ```

1.  接下来，我们将提交这些更改并创建一个新的版本：

    ```
    git commit -a -m "changing yum.conf files"

    ```

1.  接下来，展示迄今为止的所有提交：

    ```
    git log --pretty=oneline --abbrev-commit

    ```

1.  这将输出我的系统上的以下提交（你的系统上的数字哈希值将不同）：

    ```
    8069c4a changing yum.conf
    5f0d50a inital commit of the full /etc directory

    ```

1.  基于前一步骤的输出，我们现在将展示两个版本号之间的所有差异（根据前一步骤的输出，在你的系统上更改数字哈希值）：

    ```
    git diff 8069c4a 5f0d50a

    ```

1.  要完成本教程，我们将撤销我们对原始文件版本的更改（初始提交）：

    ```
    git checkout 5f0d50a

    ```

## 它是如何工作的

在本教程中，我们向你展示了如何使用 Git 来管理`/etc`目录中的系统配置文件的更改。如果你正在进行测试，这可能很重要，因为你会对某些配置文件进行大量更改，并且希望跟踪这些更改。这样做的好处是，如果你以后需要撤销更改或回退到特定版本，或者比较不同文件版本，你不需要记住你采取的每一个步骤。

那么，我们从这次经历中学到了什么？

我们首先安装了 Git，并向其配置中添加了用户名和电子邮件地址，这对于后续使用至关重要。然后，我们切换到 `/etc` 目录，并在那里初始化（使用 `init` 参数）一个新的空 Git 项目，这被称为仓库，用于跟踪与之关联的所有文件。此命令将在其中添加一个隐藏的 `.git` 目录，其中包含完整的文件更改和修订信息。接下来，我们添加了该目录中的所有文件（使用通配符 `*` 运算符），包括所有子目录到下一个修订版。修订版就像文件在给定时间点的状态，由唯一的哈希 ID 标识，例如 `8069c4a`。然后，我们实际创建了一个新修订版，使用 commit 参数并提供有意义的 message 使用 `-m` 参数。在我们设置 Git 仓库并将所有文件添加到其中之后，对 `/etc` 目录中文件的每次更改都会被监视。接下来，我们在仓库中修改了主 YUM 配置文件，通过使用 echo `>>` 命令在末尾添加一个随机字符串。如果我们现在再次使用 git 的 `status` 参数，我们会在输出中看到 Git 系统已通知该文件已被更改。我们现在可以使用 git 的 `commit` 参数再次创建一个包含更改文件的新修订版，并在此处使用另一个有意义的 message 说明 `yum.conf` 已被更改。然后我们使用了 git `log` 命令。这将向我们展示所有已提交的修订版及其唯一的 `md5` 哈希字符串 ID。使用此 ID，我们可以为 git `diff` 命令提供燃料，以查看两个修订版之间的所有文件更改。要了解更多输出格式，请使用 `man git-diff-files` 并阅读其 `COMBINED DIFF FORMAT` 部分。在我们最后一步中，我们使用了 checkout 命令转到特定文件修订版；在这里，我们恢复了所有更改并返回到原始文件状态。

Git 是一个非常强大的版本管理工具，在本教程中我们只是浅尝辄止地了解了它的功能。要学习更多关于 Git 的精彩技巧，如分支、合并、拉取请求等，可以从输入 `man gittutorial` 开始，阅读 Git 教程页面。

## 不仅如此...

您还可以使用 Subversion 程序将 `/etc` 目录置于版本控制之下。Subversion 是另一种常见的文档修订控制系统，与 Git 的主要区别在于它使用中央服务器来跟踪文件更改。Git 是分布式的，这意味着在 Git 项目上工作的每个人都会在本地计算机上拥有完整的仓库。在这里，我们将向您展示使用 Subversion 代替 Git 所需的精确步骤：

1.  首先，安装 Subversion 并为我们的 `/etc` 仓库配置一个新的服务器目录：

    ```
    yum install subversion
    mkdir -p /var/local/svn/etc-repos
    svnadmin create --fs-type fsfs /var/local/svn/etc-repos

    ```

1.  现在，将 `/etc` 文件系统就地导入到我们的新仓库中：

    ```
    svn mkdir file:///var/local/svn/etc-repos/etc 
    -m "Make a directory in the repository to correspond to /etc"

    ```

1.  现在，切换到 `/etc` 目录并将所有文件添加到一个新修订版中：

    ```
    cd /etc
    svn checkout  file:///var/local/svn/etc-repos/etc ./
    svn add *

    ```

1.  现在，创建您的第一个提交：

    ```
    svn commit -m "inital commit of the full /etc/ directory"

    ```

1.  接下来，修改`yum.conf`文件：

    ```
    echo "FILE HAS CHANGED" >> yum.conf

    ```

1.  将你的更改提交到新的文件版本：

    ```
    svn commit -m "changing yum.conf files"

    ```

1.  现在，展示变更日志：

    ```
    svn log -r 1:HEAD

    ```

1.  显示我们两个提交之间的文件差异（第一个提交是`/etc`导入）：

    ```
    svn diff -r 2:3

    ```

1.  最后，恢复到我们`yum.conf`文件的第一个版本：

    ```
    svn update -r 2 yum.conf

    ```
