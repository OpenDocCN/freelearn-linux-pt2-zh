- en: Chapter 6. Providing Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Locking down remote access and hardening SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and configuring fail2ban
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with a firewall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forging the firewall rules by example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating self-signed certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using secure alternatives to FTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a collection of recipes that provides a solid framework on which
    a server can be made secure in almost any environment. Security is the cornerstone
    of a good administrator, and this chapter illustrates how quickly and easily you
    can design and implement a series of checkpoints that will deliver the protection
    you need.
  prefs: []
  type: TYPE_NORMAL
- en: Locking down remote access and hardening SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to provide additional security measures in
    order to harden the secure shell environment. The **Secure Shell** (**SSH**) is
    the basic toolkit that provides remote access to your server. The actual distance
    to the remote machine is negligible, but the shell environment enables you to
    perform maintenance, upgrades, the installation of packages and file transfers;
    you can also facilitate whatever action you need to carry out as the administrator
    in a secure environment. It is an important tool; as the gateway to your system,
    it is the purpose of this recipe to show you how to perform a few rudimentary
    configuration changes that will serve to protect your server from unwanted guests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet in order to download additional packages. It
    is assumed that your server already maintains at least one non-root-based administration
    account that can use the new features provided by this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The role of SSH will be vital if you are forced to administer your server from
    a remote location, and for this reason it is essential that a few basic steps
    are provided to keep it safe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in as `root` and create a backup of the original configuration
    file by typing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the main `sshd` configuration file by typing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We shall begin by adjusting the time allowed to complete the login process,
    so scroll down and find the line that reads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Uncomment this line and change its value to something more appropriate such
    as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, scroll down a couple of more lines and find the line that reads as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change this to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And change it to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and close the file before restarting the SSH service, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this stage, you may want to consider creating a new SSH session using the
    new settings before exiting the current session. This is to ensure that everything
    is working correctly and to avoid locking yourself out of the server accidentally.
    If you have difficulty starting a new SSH session, then simply return to the original
    session window and make the necessary adjustments (followed by a restart of the
    SSH service). However, if no difficulties have been encountered and you are on
    a successful secondary login, you may close the original shell environment by
    typing `exit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, having followed this recipe you should now find that root access to
    the shell is denied and you must log in using a standard user account. Any further
    work requiring root privilege will require the `su` or `sudo` command, depending
    on your preferences.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SSH is a vital service that enables you to access your server remotely. A server
    administrator cannot work without it. In this recipe, you were shown how to make
    that service a little more secure.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We began the recipe by creating a backup copy of our original main `sshd` configuration
    file. The next step was to open and edit it. The configuration file for SSH maintains
    a long list of settings that is ideal for most internal needs, but for a server
    in a production environment it is often advised that the default SSH configuration
    file will need changing to suit your particular needs. In this respect, the first
    step was to make a recommended change to the login grace time, `LoginGraceTime
    30`. Instead of the default two minutes, the preceding value will allow only up
    to 30 seconds. This is the period of time where a user may be connected but will
    have not begun the authentication process; the lower the number, the fewer unauthenticated
    connections are kept open. Following this, we then removed the ability of a remote
    user to log in as the root user by using the `PermitRootLogin no` directive. In
    most cases, this is a must and a remote server should not allow a direct root
    login unless the server is in a controlled environment. The main reason behind
    this is to reduce the risk of getting hacked. The first thing every SSH hacker
    tries to crack is the password for the user root. If you disallow root login,
    an attacker needs to guess the user name as well, which is far more complex. The
    next setting simply disabled `X11Forwarding`. In situations like these, it is
    often a good idea to apply the phrase "if you do not use it, disable it". To complete
    the recipe, you were required to restart the SSH server in order to allow the
    changes to take immediate effect and start a new SSH session with the intention
    of making sure that the modifications did indeed work as expected. No system is
    ever safe, but having done this you can now relax, safe in the knowledge of having
    made the SSH server a little bit safer.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few more topics to cover to make your SSH server even more secure:
    we should change the SSH port number and show you how to limit SSH access to specific
    system users.'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the SSH port number of your server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Port 22 is the default port used by all SSH servers, and changing the port
    number used can go a small way to increase the overall security of your server.
    Again, open the main SSH daemon configuration file, `sshd_config`. Now, scroll
    down and locate the following line that reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the leading `#` character (uncomment) and change the port number to
    another value by replacing `XXXX` with an appropriate port number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You must ensure that the new port number is not already in use, and when complete,
    save the file and close it. It is important to remember that any changes made
    here are reflected in your firewall configuration. So, we need to open the new
    port in firewalld as well. Set the new port via the environment variable `NEWPORT`
    (replace `XXXX` with your new SSH port), then execute the following `sed` command
    to change the SSH firewalld service file and reload the `firewalld` daemon afterwards
    (for details, read the firewall recipe in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we have to tell SELinux (see [Chapter 14](part0111_split_000.html#39REE1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 14. Working with SELinux"), *Working with SELinux* to learn more about
    it) about the port change because it is restricted to port 22 by default. Make
    sure that the SELinux tools have been installed, then create a security label
    for our custom port, replacing `XXXX` with your changed port number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Finally restart the sshd service to apply our port change.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting SSH access by user or group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, all valid users on the system are allowed to log in and enjoy the
    benefit of SSH. However, a more secure policy is to only allow a predetermined
    list of users or groups to log in. When `henry`, `james`, and `helen` represent
    valid SSH users on the system, in the `sshd_config` add this line to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the following method to enable any user that is
    a member of a valid administration group to log in. When admin represents a valid
    SSH group on the system, add this line to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When you have finished, save and close the file before restarting the SSH service.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring fail2ban
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to implement additional security measures
    for protecting the SSH server with a package called `fail2ban`. This is a tool
    that serves to protect a variety of services including SSH, FTP, SMTP, Apache,
    and many more against unwanted visitors. It works by reading log files for patterns
    based on failed login attempts and deals with the offending IP addresses accordingly.
    Of course, you may have already hardened your SSH server or another service on
    a direct application level, but it is the purpose of this recipe to show that,
    when faced with the possibility of Brute Force Attacks, an added layer of protection
    is always useful.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet in order to download additional packages. In
    addition to this, it will be assumed that YUM is already configured to download
    packages from the EPEL repository (see [Chapter 4](part0045_split_000.html#1AT9A1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 4. Managing Packages with YUM"), *Managing Packages with YUM*).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fail2ban is not installed by default, and for this reason we will need to invoke
    the YUM package manager and download the necessary packages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin this recipe, log in as `root` and type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new configuration file in your favorite text editor, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put in the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, append the following line that defines the ban period. It is calculated
    in seconds, so adjust the time period to reflect a more suitable value. In this
    case, we have chosen this to be one hour:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, append the maximum number of login attempts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are running SSH over a custom port other than `22`, you need to tell
    this to `fail2ban` as well (replace `XXXX` with your port number of choice) otherwise
    skip this step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, save and close the file in the usual way before proceeding to enable the
    `fail2ban` service at boot. To do this, type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete this recipe, you should now start the service by typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`fail2ban` is designed to monitor users who repeatedly fail to log in correctly
    on your server, and its main purpose is to mitigate attacks designed to crack
    passwords and steal user credentials. It works by continuously reading your system''s
    log files, and if this contains a pattern indicating a number of failed attempts,
    then it will proceed to act against the offending IP address. We all know that
    servers do not exist in isolation, and by using this tool, within a few minutes,
    the server will be running with an additional blanket of protection.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: '`fail2ban` is not available from the standard CentOS repositories, and for
    this reason your server will need to have access to the EPEL repository. The installation
    of the `fail2ban` packages was very simple; besides the main `fail2ban` package,
    we installed two other packages to integrate it into CentOS 7''s new `systemd`
    and firewalld server technologies. Next, for our local customization, we created
    a new `jail.local` file. We started specifying the `findtime` parameter for all
    targets (specified within the `[DEFAULT]` section), which is the amount of time
    a user has when attempting to log in. This value is measured in seconds and implies
    that, if a user fails to log in within the maximum number of attempts during the
    designated period, then they are banned. Next, we enabled `fail2ban` for the `sshd`
    daemon by adding a `[sshd]` section. In this section, we introduced the `bantime`
    value, which represents the total number of seconds that a host will be blocked
    from accessing the server if they are found to be in violation of the rules. Based
    on this, you were then asked to determine the maximum number of login attempts
    before blocking. Also, if you have changed your service''s standard listening
    port, you have to define the custom port using the `port` directive. To test your
    settings, try to authenticate a user using SSH and provide a wrong password five
    times. On the sixth occasion, you should not be able to get back to the login
    prompt for one hour!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Protecting the `sshd` service from Brute Force Attacks is just the first step
    to get you started, and there is much more to learn with `failban`. To troubleshoot
    the service, please look at its log file at `/var/log/fail2ban.log`. To get some
    ideas about what can be done with it, open the following example `failban` config
    file: `less /etc/fail2ban/jail.conf`.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with a firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A firewall is a program that monitors and controls your system's network interfaces'
    incoming and outgoing network traffic, and can restrict the transmission to only
    useful and non-harmful data into and out of a computer system or network. By default,
    CentOS is made available with an extremely powerful firewall, built right into
    the kernel, called **netfilter**. While, in older versions of CentOS, we used
    the famous iptables application to control it, in version 7, the new standard
    netfilter management program has changed to a service called `firewalld`, which
    is already installed and enabled on every CentOS 7 server by default.
  prefs: []
  type: TYPE_NORMAL
- en: It is a very powerful service to take full control over your server's firewall
    security, and is much easier to work with than iptables. Its main advantages are
    that it features a better structured and more logical approach to managing and
    configuring every aspect of a modern firewall solution. Therefore, it will be
    the foundation of your server's security, and for this reason it is the purpose
    of this recipe to get you started on the fundamentals of firewalld quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the `firewalld` service is running on every CentOS 7 server by default, we
    can start directly working with the service by logging in to your server using
    the `root` user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type the following commands to query zone-related information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can switch to a different firewall `default` zone by using the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a network interface to a `zone` temporarily:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a service to a `zone` temporarily:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test if adding the interface and service has been successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the service permanently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s create a new firewall zone by opening the following file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now put in the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and close, then reload the `firewall` config so that we can see the new
    zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, check that the new zone is available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In comparison to iptables, the new firewalld system hides away the creation
    of sophisticated networking rules and has a very easy syntax that is less error-prone.
    It can dynamically reload netfilter settings at runtime without having to restart
    the complete service and we can have more than one firewall configuration set
    per system, which makes it great for working in changing network environments,
    such as for mobile devices like laptops. In this recipe, we have given you an
    introduction to the two fundamental building blocks of firewalld: the **zone**
    and the **service**.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We started this recipe using `firewall-cmd` to get information about available
    firewall zones on the system. Firewalld introduces the new concept of network
    or firewall zones, which assigns different levels of trust to your server's network
    interfaces and their associated connections. In CentOS 7, there already exist
    a number of predefined firewalld zones, and all of these (for example, `private`,
    `home`, `public`, and so on, with the exception of the `trusted` zone) will block
    any form of incoming network connection to the server unless they are explicitly
    allowed using special rules attached to the zone (these rules are called firewalld
    services, which we will see later). We queried zone information using `firewall-cmd`
    with `--get-zones` or (more detailed) with the `--list-all-zones` parameter. Each
    of these zones acts as a complete and full firewall that you can use, depending
    on your system's environment and location. For example, as the name implies, the
    `home` zone is for use if your computer is located in home areas. If this is selected,
    you mostly trust all other computers and services on the networks to not harm
    your computer, whereas the public zone is more for use in public areas such as
    public access points and so on. Here, you do not trust the other computers and
    services on the network to not harm you. On CentOS 7, the standard `default` zone
    configuration set after installation is the `public` zone, which we displayed
    using the command's `--get-default-zone` parameter, and in more detail using `--list-all`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simply put, firewalld zones are all about controlling incoming connections to
    the server. Limiting outgoing connections with firewalld is also possible but
    is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Also, to get more technical information about all currently available zones,
    we used the firewall client's `--list-all-zones` parameter. In the command's output,
    you will notice that a zone can have some associated networking interfaces and
    a list of services belonging to it, which are special firewall rules applied to
    incoming network connections. You may also notice that, while listing details
    of all zones and their associated services by default, all firewalld zones are
    very restrictive and barely allow anything to connect to the server at all. Also,
    another very important concept can be seen in the command's output from the above.
    Our `public` zone is marked as `default` and `active`. While the `active` zone
    is the one that is directly associated with a network interface, the `default`
    zone can really get important if you have multiple network adapters available.
    Here, it acts as a standard minimum firewall protection and fallback strategy,
    in case you missed to assign some active zone for every interface. For systems
    with only one network interface setting, the `default` zone will set the `active`
    zone automatically as well. To set a `default` zone, we used the `--set-default-zone`
    parameter and, to mark a zone as active for an interface, we used `--add-interface`.
    Please note that, if you don't specify the `--zone` parameter, most `firewall-cmd`
    commands will use the `default` zone to apply settings. Firewalld is listening
    on every network interface in your system, and waiting for new network packets
    to arrive. In summary we can say that if there is a new packet coming into a specific
    interface, the next thing firewalld has to do is find out which zone is the correct
    one associated with our network interface (using its active or if not available
    its default configuration); after finding it, it will apply all the service rules
    against the network packets belonging to it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we showed you how to work with firewalld services. Simply put, firewalld
    services are rules that open and allow a certain connection within our firewall
    to our server. Using such service file definitions allows the reusability of the
    containing rules because they can be added or removed to any zone. Also, using
    the predefined firewalld services already available in your system, as opposed
    to manually finding out and opening protocols, ports, or port ranges using a complicated
    iptables syntax for your system services of interest, can make your administrative
    life much easier. We added the `ftp` service to the `work` zone by invoking `--add-service`.
    Afterwards, we printed out details of the work zone using `--list-all`. Firewalld
    is designed to have a separated runtime and permanent configuration. While any
    change to the runtime configuration has immediate effect but will be gone, the
    permanent configuration will survive reload or restart of the firewalld service.
    Some commands such as switching the default zone are writing the changes into
    both configurations which mean they are immediately applied at runtime and are
    persistent over service restart. Other configuration settings such as adding a
    service to a zone are only writing to the runtime configuration. If you restart
    firewalld, reload its configuration, or reboot your computer, these temporary
    changes will be lost. To make those temporary changes permanent, we can use the
    `--permanent` flag with the `firewall-cmd` program call to write it to the permanent
    configuration file as well.
  prefs: []
  type: TYPE_NORMAL
- en: Other than with the runtime options, here the changes are not effective immediately,
    but only after a service restart/reload or system reboot. Therefore, the most
    common approach to apply permanent settings for such runtime-only commands is
    to first apply the setting with the `--permanent` parameter, and afterwards reload
    the firewall's configuration file to actually activate them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we showed you how to create your own zone, which is just a XML file
    you have to create in the `/etc/firewalld/zones/` directory, and where we specified
    a name, description, and all the services that you want to activate. If you change
    something in any firewall configuration file, don't forget to reload the firewall
    config afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish this recipe, we will revert our permanent changes made to the `work`
    zone and reload firewalld to reset all the non-permanent changes we applied in
    this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To troubleshoot blocking services, instead of turning off the firewall completely,
    you should just switch `zone` to `trusted`, which will open all the incoming ports
    to the firewall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have finished your tests, just switch back to the zone that you were
    in before, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Forging the firewall rules by example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we want to show you how to create your own firewalld service
    definitions or how to change existing ones, which any CentOS 7 system administrator
    should know if the predefined service files don't fit your system's need.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with `root` privileges and a console-based text editor of your
    choice. We will be changing the SSH service's port number in firewalld, so make
    sure that you have configured the new port as shown in the recipe *Locking down
    remote access and hardening SSH*. Here, in our example, we have changed the port
    to `2223`. Also, we will create a new firewalld service for a small Python-based
    web server that we will use to demonstrate the integration of new system service's
    into firewalld. It's advantageous to grasp the basics of firewalld by working
    through the *Working with a firewall* recipe before starting here.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here in this recipe, we will show you how to change and how to create new firewalld
    service definitions. In this recipe, it is considered that we are in the default
    public zone.
  prefs: []
  type: TYPE_NORMAL
- en: To change an existing firewalld service (ssh)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, log in as `root` and copy the `ssh` service to the right place to edit
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open the `ssh` service definition file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the port from `22` to `2223`, then save the file and close it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, reload the firewall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To create your own new service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Perform the following steps to create your own new service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put in the following service definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and close the file, and then finally reload the firewall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add this new service to our `default` zone:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterwards, run the following command to start a simple Python web server in
    the foreground on port `8000` (press the key combination *Ctrl* + *C* to stop
    it):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Congratulations! Your new web server sitting at port `8000` can now be reached
    from other computers in your network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here in this recipe, we have shown how easy it is to customize or define new
    firewalld services if the predefined needs to be changed, or for new system services
    that are not defined at all. Service definition files are simple XML files where
    you define rules for a given system service or program. There are two distinct
    directories where our firewalld service files live: `/usr/lib/firewalld/services`
    for all predefined services available from the system installation, and `/etc/firewalld/services`
    for all custom and user-created services.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'We started this recipe by making a working copy of the SSH firewalld service
    file in the right place at `/etc/firewalld/services`. We could just copy the original
    file because all files in this directory will overload the default configuration
    files from `/usr/lib/firewalld/services`. In the next step, we then modified it
    by opening it and changing the default port from `22` to `2223`. We have to do
    this every time we change a system''s service standard listening port to make
    the firewall aware that it should allow network traffic to flow through the changed
    port. As you can see when opening this file, service files are simple XML text
    files with some mandatory and some optional tags and attributes. They contain
    a list of one or more ports and protocols that defines exactly what firewalld
    should enable if the service is connected to a zone. There can be another important
    setting in the XML file: helper modules. For example, if you open the SAMBA service
    file at `/usr/lib/firewalld/services/samba.xml`, you will see the tag, `<module
    name="nf_conntrack_netbios_ns"/>`. These are special kernel netfilter helper modules
    that can be dynamically loaded into the underlying kernel-based firewall, and
    which are needed for some system services, such as Samba or FTP, which create
    dynamic connections on temporary TCP or UDP ports instead of using static ports.
    After reloading the firewall configuration, we should now be able to test the
    connection from another computer in our network using the altered port.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this recipe, we created a brand-new service file for a
    new system service, which is a simple Python web server listening on port 8000
    displaying a simple directory content listing. Therefore, we created a simple
    XML service file for the Python web server including the right port 8000, restarted
    the firewall, and afterwards added this new service to our default public zone
    so that we can actually open connections through this service. You should now
    be able to browse to our web server's start page using another computer in the
    same network. However, as we did not use the `--permanent` flag, if you restart
    the firewalld daemon, the `python-webserver` service will be gone from the `public`
    zone (or you can also use the parameter, `--remove-service=python-webserver`).
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we can say that the recommended firewall choice in CentOS 7 is firewalld,
    as all important system services have already been set up to use it via predefined
    service rules. You should remember that Linux firewalls are a very complex topic
    that can easily fill up a whole book, and you can do a lot more with the `firewall-cmd`
    that cannot be covered here in this book.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, you just want to quickly open a specific port to test out things before
    writing your own custom-made service definition. In order to do this, you can
    use the following command line, which will open port `2888` using the tcp protocol
    temporarily on the `default` zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Once you have finished your tests, just reload the firewall configuration to
    remove and close the specific port again.
  prefs: []
  type: TYPE_NORMAL
- en: Generating self-signed certificates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create self-signed **Secure Sockets Layer**
    (**SSL**) certificates using the OpenSSL toolkit. SSL is a technology used to
    encrypt messages between two ends of a communication (for example, a server and
    client) so that a third-party cannot read the messages sent between them. Certificates
    are not used for encrypting the data, but they are very important in this communication
    process to ensure that the party you are communicating with is exactly the one
    you suppose it to be. Without them, impersonation attacks would be much more common.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally speaking, if you are intending to use an SSL Certificate on a production
    server, you will probably want to purchase a SSL Certificate from a trusted Certificate
    Authority. There are many options open to you regarding what certificate best
    suits your requirements and your budget, but for the purpose of this recipe we
    will confine our discussion to a self-signed certificate that is more than adequate
    for any development server or internal network.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, log in as `root` and go to the following directory so that we can
    use the Makefile to generate our intended certificates and keyfiles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to create a self-signed certificate with an embedded public key (both
    in the file, `server.crt`) along with its private key for the server (with the
    filename as `server.key`), type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will then be asked for a password and will receive a series of questions,
    to which you should respond with the appropriate values. Complete all the required
    details by paying special attention to the common name value, which should reflect
    the domain name of the server or IP address that you are going to use this certificate
    for. For example, you may type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a `pem` file that includes a self-signed certificate and a public
    and a private key in one file, and is valid for five years, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create a key pair (a private key and self-signed certificate that
    includes the public key) for an Apache web server that we will need for enabling
    `https`, and which will be generated in `/etc/pki/tls/private/localhost.key` and
    `/etc/pki/tls/certs/localhost.crt` (use a secure password and repeat it in the
    second command):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a **Certificate Signing Request** (**CSR**) file instead of a self-signed
    certificate, use this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here in this recipe, we introduced you to the SSL technology that uses **public
    key cryptography** (**PKI**) (where two forms of keys exist: public and private).
    On the server, we store the private key and our clients get a public key. Every
    message sent from one end to the other is encrypted by the key belonging to one
    side and can only be decrypted by the corresponding key from the other. For example,
    a message encrypted with the server''s private key can only be decrypted and read
    by the client''s public key and vice versa. The public key is sent to the client
    through a certificate file, where it is part of the file. As said before, the
    public key is encrypting and decrypting the data and the certificate is not responsible
    for this, but rather for identifying a server against a client and making sure
    that you are actually connected to the same server you are trying to connect.
    If you want to set up secure services using SSL encryption in protocols such as
    FTPS, HTTPS, POP3S, IMAPS, LDAPS, SMTPS, and so on, you need a signed server certificate
    to work with. If you want to use these services for your business, and you want
    them to be trusted by the people who are using and working with them, for example,
    on the public Internet, your certificate should be signed from a official **certification
    authority** (**CA**). Certificate prices are paid by subscription and can be very
    expensive. If you don''t plan to offer your certificate or SSL-enabled services
    to a public audience, or you want to offer them only within a company''s intranet
    or just want to test out things before buying, here you can also sign the certificate
    by yourselves (self-signed) with the OpenSSL toolkit.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The only difference between a self-signed certificate and one coming from an
    official CA is that most programs using the certificate for communication will
    give you a warning that it does not know about the CA and that you should not
    trust it. After confirming the security risk, you can work with the service normally.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'We started this recipe by going to the standard location where all the system''s
    certificates can be found in CentOS 7: `/etc/pki/tls/certs`. Here, we can find
    a Makefile, which is a helper script for conveniently generating public/private
    key pairs, SSL CSRs, and self-signed SSL test certificates. It works by hiding
    away from you complicated command line parameters for the OpenSSL program. It
    is very easy to use and will automatically recognize your target through the file
    extension of your file name parameter. So, it was a simple process to generate
    an SSL key pair by providing an output filename with the `.crt` extension. As
    said before, you will be asked for a password and a list of questions regarding
    the ownership of the certificate, with the most important question being the common
    name. This should reflect the domain name of the server you are planning to use
    this certificate for, because most programs, such as web browsers or email clients,
    will check the domain names to see if they are valid. The result of running this
    command was the certificate with its embedded public key in file `server.crt`,
    as well as the corresponding private key for the server called `server.key`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we created a `.pem` file and provided a `DAYS` parameter to make the
    certificate valid for five years instead of the default one year when you are
    running without it. A `pem` file is a container file that contains both parts
    of the key pair: the private keys and the self-signed certificate (with its embedded
    public key). This file format is sometimes required by some programs, such as
    `vsftpd`, to enable SSL encryption instead of providing the key-pair in two separated
    files. Next, we ran the Makefile target `testcert`, which generates a private
    key as well as public key, plus the certificate in the correct location, where
    the Apache web server is expecting them for setting up HTTPS. Please note that,
    if you need to repeat any Makefile run later, you need to delete the generated
    output files; for example, for Apache, you need to delete the following files
    before you can build the output files again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we showed you how to generate a CSR file, which will be needed if you
    plan to purchase an SSL certificate from a trusted certificate authority.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We did not cover all the possibilities that the Makefile script has to offer
    to generate certificates. If you run the command, `make,` without giving any target
    parameter, the program will print out a usage help text with all possible options.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have learned, the public and private keys are generated in pairs, and
    will encrypt and decrypt each partner''s messages. You can verify that your key
    pairs are valid and belong together by comparing the output of the following (which
    must be exactly the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Using secure alternatives to FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using FTP is still popular to share data or to transfer files over the
    network, you must be aware that you are using a very unsecure network protocol
    that has no protection built into it out-of-the-box. This means that, during network
    transfer, your data is fully exposed to potential attackers. This is not what
    you want for transferring sensitive data, such as login credentials, at all. To
    avoid these potential risks, we will show you in this recipe how to use and set
    up two alternatives for securing FTP using FTPS (FTP over SSL or FTP/SSL) or SFTPS
    (SSH-enabled FTP).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice. You should already have installed and configured a basic vsftpd server
    (see [Chapter 12](part0098_split_000.html#2TEN41-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 12. Providing Web Services"), *Providing Web Services* for how to do
    it). Also, for setting up SFTP, we will need to create some self-signed certificates;
    if you want to know the details behind it, please read the *Generating self-signed
    certificates* recipe in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have to choose beforehand if you want to use SFTP or FTPS. These two methods
    cannot be applied together, so you have to decide which option to choose first.
    If you switch between those methods, you need to restore the default configuration
    file state of `vsftpd.conf` or `sshd_config` first.
  prefs: []
  type: TYPE_NORMAL
- en: Securing your vsftpd server with SSL–FTPS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To secure your vsftpd server with SSL-FTPS perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in as `root` and go to the standard certificate location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create a SSL key pair consisting of the certificate and its embedded
    public key, as well as the private key in one file for our `ftp-server` configuration
    (remember that the `Common name` value should reflect the domain name of your
    FTP server):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change to a more secure file access rule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, before working on it, first make a backup of the `vsftpd.conf` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, enable SSL and add the key pair file that we just created to our `vsftpd`
    configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add a new firewalld service file, so open the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put in the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, reload the firewall, add the `ftps` service, and restart your `vsftpd`
    server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Securing your vsftpd server using SSH – SFTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To secure your vsftpd server using SSL-SFTP perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a group for all valid SFTP users:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will work on the `sshd` main config file, so please make a backup before
    making any changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open the `sshd_config` file, go to the line containing the `Subsystem`
    directive, disable it (which means putting a `#` sign at the beginning of the
    line), and add the following line to read as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following lines to the end of the file to enable SFTP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, restart the `sshd` daemon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here in this recipe, you have learned how to make your file sharing more secure
    by switching from the standard FTP protocol to using FTP over SSL, or FTP over
    SSH. Regardless of which option you prefer, SSL is used to encrypt the data during
    transmitting, which helps you keep your privacy. Which variant you choose is up
    to you, but remember that SFTP is a bit easier to set up as you do not have to
    configure additional ports or certificates in your firewall, because everything
    runs over SSH and this should be enabled by default on most systems.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'We began the recipe by configuring FTPS. We went into a special directory called
    `/etc/pki/tls/certs`, where CentOS stores all its certificates. In it, there is
    a Makefile, which we used to create a `.pem` file that contains the public/private
    key pair and a self-signed certificate that we needed for our FTP server''s configuration.
    Afterwards, we used chmod to ensure that only the root user can read this file.
    Then, we appended six lines of code to our main `vsftpd` configuration file (first,
    we made a backup of the original file); they are pretty self-explanatory: enable
    the SSL protocol, use the self-signed certificate, disallow any non-SSL communication,
    and use a static range of passive control ports. Also, we created a new firewall
    service that will open these passive control ports that are needed for FTPS.'
  prefs: []
  type: TYPE_NORMAL
- en: Afterwards, we configured SFTP using a chroot jail. If setting up SFTP without
    it, every login user can view the root filesystem, which is very unsecure. Configuring
    SFTP is done completely in the main `sshd` config file. After making a backup
    of the original file, we changed the FTP subsystem to `internal-sftp`, which is
    a newer ftp server version, has better performance, and runs in the same process.
    Next, we added three lines to the `vsftpd` configuration file; only users in the
    `sshftp` group are using SFTP and are put into a chroot jail and can only view
    files up to their `home` directory. `ForceCommand` ignores all local settings
    by the users and enforces these rules here instead. To add new chrooted SFTP users,
    all you have to do is create a standard Linux user account and add them to the
    `sshftp` user group.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to test your enabled FTPS server, you need an FTP client that supports
    "FTP over TLS." You have to find and enable this option in your FTP client''s
    settings. Under Linux, you can install the `lftp` client to test if you can connect
    to our FTPS server. First, install the `lftp` package (for example, `yum install
    lftp`). Then, configure the client using TLS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can connect and test your FTPS server using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to test your enabled SFTP server, you need the program called `sftp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You have to remember that all the changes to `sshd_config` will be reflected
    in SFTP as well. So, if you disabled root login or ran SSH over a different port
    than `22`, you have to take it into consideration when you try to log in to SFTP.
  prefs: []
  type: TYPE_NORMAL
