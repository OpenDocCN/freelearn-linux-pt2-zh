- en: Chapter 5. Administering the Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual block device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting and mounting a filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using disk quotas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining a filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the capacity of the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a collection of recipes that provides for the need to drive
    a CentOS-based server solution. From formatting and mounting disks to extending
    a logical volume and maintaining your filesystem and disk quotas, the purpose
    of this chapter is to show you how quickly and easily you can get to grips with
    the task of managing the needs of its users in today's most demanding environments.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual block device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a virtual block device that we will use to simulate
    real devices and partitions so that we can test-drive concepts and commands used
    in all later recipes in this chapter. Working with real disks and partitions often
    involves the risk of losing important data or even having to re-install your complete
    system. A virtual block device is ideal to learn the techniques and try things
    out before switching to "production mode". Later, if you have gained enough experience
    and feel safe, you can easily replace it with "real" hardware devices, partitions,
    and logical volumes (which is a part of LVM; see the later recipe). All you need
    to do is substitute your virtual device with "real" block device names.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with root access. To create a virtual block device, you should
    have at least one gigabyte of free hard disk space that we will use temporarily
    to create and make. You can delete this reserved space later (or it will be automatically
    deleted on reboot). It's just for testing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, log in as `root` and create an empty file with the exact size of
    1 gigabyte:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create a loop device from the file we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, print the generated loop device name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As this will be the first loop device created in the current system, the output
    will be as follows (`loop0` can be a different number if you have created a loop
    device before):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get a list of all the block devices currently attached to the system, as
    well as important details, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create a new partition table of the type `gpt` on our new loop
    device (confirm the deletion of any data):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create device maps from your loop device to make it more similar to
    real hard disk partitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have learned how to create a virtual block device that acts
    as a starting point for testing out how to create partitions, logical volumes,
    and filesystems in later recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'We started this recipe by creating a new empty file, which was one gigabyte
    in size, in the `/tmp` directory using the `dd` utility. `dd` is used to make
    exact copies of files (which is sometimes called cloning) and expects two parameters:
    an input file (the `if` parameter) and an output file (the `of` parameter). We
    used the `zero` device (`/dev/zero`) as our input file that returns an endless
    stream of bytes containing zero. We then limited the stream by defining a blocksize
    (`bs`) and `count` parameter. The `bs` defines the amount of data in bytes read
    at a time, while the `count` parameter counts how many repetitions of `bs` will
    be allowed. So, these arguments can be read as *stop the copying process when
    we reach a blocksize times count data received*. In our example, we used a blocksize
    of `1` *Megabyte times 1000 = 1 Gigabyte*. This zero byte data was written to
    our output file (`of`) called `/tmp/test-image.dd`.'
  prefs: []
  type: TYPE_NORMAL
- en: After we created this empty file, we created a temporary **loop** device with
    it. A loop device is just a pseudo-device that makes it possible to use a file
    as a **block device**. Often, such a file is a CD ISO image, and using it as a
    loop device will make it accessible as if it were a normal hardware drive. Any
    device that allows reading or writing data in blocks can be called a block device;
    in order to get a list of all available block devices in your system, we used
    the `lsblk` command, and as you can see, this includes our loop device as well.
    Standard loop device names start with the number zero, as in `/dev/loop0`.
  prefs: []
  type: TYPE_NORMAL
- en: Afterwards, we created a new **partition table** on our loop device using the
    `parted` command. A partition table is a table maintained on a disk by the operating
    system describing the partitions on it, and it must be created before we can create
    them. We used the partition table type `gpt`, but you can also use the old msdos
    type here instead.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, when creating a partition table on a virtual block device, we cannot
    access individual partitions or make filesystems for different partitions on it,
    because the partitions cannot be addressed individually. Here we used the `kpartx`
    command to create device mappings from partition tables, which allows us later
    to access single partitions for creating filesystems using the notation, `/dev/loop0p1`,
    for partition 1 on loop device 0 and `/dev/loop0p2` for partition 2 on loop device
    0.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have now created a brand new virtual block device with
    a standard partition table, which can be used and accessed as if it were a normal
    disk device.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to remove a virtual block device, we first have to unmount it from
    the filesystem if it is currently mounted (for example, `umount /dev/loo0p1`).
    Next, we need to detach the virtual block device file from the loop device using
    the `-d` parameter like so: `losetup -d /dev/loop0`. Afterwards, we can delete
    the block file if we want to: `rm /tmp/test-image.dd`.'
  prefs: []
  type: TYPE_NORMAL
- en: Formatting and mounting a filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will be introduced to the standard CentOS filesystems **XFS**,
    **Ext4**, and **Btrfs**. Filesystems form one of the most fundamental parts of
    any operating system and nearly everything depends on them. Here, you will learn
    how to create different types of standard filesystems available in CentOS 7, and
    how to link them to your system so that we can access them afterwards for reading
    and writing. These two techniques are called **formatting** and **mounting** filesystems;
    while you do not do this very often, it remains one of the most fundamental Linux
    system administrator tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with root access. We will also use virtual block devices instead
    of real disk devices because it's better to demonstrate the usage of creating
    filesystems and formatting disks using "dummy" devices, instead of erasing your
    real hard disk contents. Therefore, you should have applied the *Creating a virtual
    block device* recipe and created a 1 Gigabyte virtual block device, which will
    be named `/dev/loop0` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to apply this recipe for real disk devices, all you have to do is
    replace `/dev/loop0` with your correct partition—for logical volumes (lv) for
    example, `/dev/mapper/myServer/data`, for a SATA device `/dev/sdX`, or for an
    IDE-based hard disk name `/dev/hdX` (where `X` is a character `a-z`).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our example, this block device is labeled at `/dev/loop0`. Please note that,
    if you have created more than one block device, your number could be different,
    so please change the name accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s log in as `root` and show information about all currently available
    block devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, recheck that we have a valid partition table installed on the device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding line should print out the following content: `Partition Table:
    gpt`. If this is not the case, let''s create a new partition table (confirm the
    deletion of any data):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create a new partition spanning the complete disk space with an
    `ext4` filesystem label (no filesystem will be installed yet; it''s just a label):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the partition table again to show the new partition we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s remove the partition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also create a btrfs-labeled partition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterwards, let''s create an XFS-labeled partition spanning the whole disk:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, show the block table again to see what we have changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we have only defined the partition type *label*, we still don''t have a
    valid filesystem on our partition; so, in the next step, we format our disk using
    the correct type. We use XFS in our example. Please change `mkfs -t <type>` if
    you use `ext4` or `btrfs` instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s mount our virtual block device partition on the system, into the
    directory `/media/vbd-1`, and please change `-t <type>` if you use `ext4` or `btrfs`
    instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, test if we can read and write to the new filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, in this recipe, we showed the user how to create CentOS 7 standard partitions
    spanning the whole disk, and then we created some filesystems on them, which is
    called formatting, using different filesystem types. The standard filesystem available
    in CentOS 7 is XFS, but as we have learned in this recipe, there are lots of other
    ones available as well, including the popular ext4 and btrfs. XFS is a very robust
    and high-performing file system for large storage configurations; it is considered
    very mature and stable. Before CentOS 7, the standard file system was ext4, but
    it had some limitations and not the best performance when working with millions
    of files and is considered barely suitable for today's very large filesystems.
    btrfs is a relatively new filesystem and is included in CentOS 7, but at the time
    of writing it is still under development and should not be used for production
    systems. It is considered to be fully supported in later CentOS 7 minor releases
    and is likely to replace XFS as the standard CentOS filesystem type in the future,
    as it has a list of very promising features and enhancements, such as copy-on-write,
    which copies files each time you write to them, and which makes it possible to
    go back to former file versions.
  prefs: []
  type: TYPE_NORMAL
- en: So, what have we learned from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We started this recipe by using the `lsblk` command to print a list of all available
    block devices currently attached to the system. We used this command to check
    if our target block device that we want to use for installing partitions and filesystems
    on is available. In our example we will use the `/dev/loop0` device, please change
    this name if it's different on your system (as said before, you could also use
    a "real" disk block device, such as `/dev/sda`, but always be careful!). After
    confirming that we have our device ready, we used the `parted` command to check
    the partition table of the disk. A partition table is mandatory for any hard disk
    to keep track of the partition information on it. As you have seen, our primary
    tool for creating partition tables and partitions is *parted*, as it is the officially
    recommended CentOS 7 tool for these tasks, but there are other programs that do
    the same as well, such as `fdisk` or `gdisk`. If there is no partition table available,
    we must create one of type `gpt` using parted's `mklabel gpt` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, after we created the partition table, we put some partitions on it. Therefore,
    we issued parted's `mkpart` command with the `-a optimal primary ext4 2048KiB
    100%` options.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful with the `parted` command all the time and recheck everything before
    executing, as most of its commands will completely destroy all the data currently
    stored on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: This will create a new partition starting at 2,048 kilobytes (kb) until the
    end of the disk. We did not start at the very beginning of the disk (0%) as 2,048
    kb is the start of the first sector on the disk to leave some space left to store
    some additional data. `-a optimal` aligns the partition to a multiple of the physical
    block size that will guarantee optimal performance. Next, we removed the partition
    again using the `rm` option and number `1`, which refers to the first partition
    we just created. We recreated new partitions of type `btrfs` and finally `xfs`.
    After the disk is partitioned, we need an actual filesystem on it, as parted only
    labels the partition to a specific type, but does not do the actual formatting.
    To make the filesystem, we use the `mkfs` utility. You can either run it with
    the `-t` flag, as we did, or use a dot notation, such as `mkfs.xfs`, to specify
    the type you want to format it to. The `mkfs` command gives us a detailed output
    of what it has done, such as how many blocks have been written and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, after we have created the filesystem on our disk partition, we can
    use the `mount` command to make it available and work with it in our current system.
    `mount` either attaches or detaches a device's filesystem to our system's root
    filesystem. Therefore, we need to first create a directory to define where we
    want to attach it to. We use the directory, `/media/vbd-1`, as a parameter for
    the actual `mount` command with the syntax, `mount -t <file system type> <device>
    <dir>`. For almost all standard filesystems, you can skip the `-t` parameter as
    it will automatically detect the right type. To detach a filesystem from your
    system, you can use the `umount` command with the argument of the device you want
    to remove (you can also use the folder it's mounted to; both do work!). In our
    example, to unmount our loop device's first partition, type `umount /dev/loop0p1`.
  prefs: []
  type: TYPE_NORMAL
- en: After mounting our formatted partition device, we can access it like any other
    component beneath the root folder.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we always use one partition spanning the complete available
    disk space. Often, you have more than one partition on a disk, so let''s create
    this kind of layout instead. In this example, we create three 100 MB partitions
    on `/dev/loop0`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s delete our partition once again using the `rm` parameter so that
    we can add new ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create three equal partitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s review our layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `gpt` partition table, we can create up to 128 primary partitions
    on any disk; when using the older `msdos` partition type, there is a maximum of
    four primary partitions. If you need more, you have to create extended partitions
    out of primary ones.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using disk quotas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When administering a Linux multiuser system with many system users, it is wise
    to set some kind of restrictions or limits to the resources shared by the system.
    On a filesystem level, you can either restrict the available hard disk space or
    the total file number to a fixed size at a user, group, or directory level. The
    introduction of such rules can prevent people from "spamming" the system, filling
    up its free space, and generally your users will get more aware of the differentiation
    between important and unimportant data and will be more likely to keep their home
    directories tidy and clean. Here in this recipe, we will show you how to set up
    a **disk quota** limiting system for XFS filesystems, which puts restrictions
    on the amount of data your system's user accounts are allowed to store.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with root access and a console-based text editor of your choice.
    For this recipe to work, and in order to set quotas, you will need at least one
    system user account next to your root account; if you don't have one yet, please
    refer to the recipe *Managing users and their groups* in [Chapter 3](part0034_split_000.html#10DJ41-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 3. Managing the System"), *Managing the System* to learn how to create
    one. Also, in the main recipe, it is expected that your CentOS 7 uses the XFS
    filesystem, which is standard on installation. Finally, your CentOS 7 installation
    needs to have been installed on a disk with at least 64 GB space, otherwise the
    installer will not create a *separate* logical `/home` volume, which is required
    in this recipe to make quotas work.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we will learn how to set up a quota system for the XFS filesystem in
    two different ways: first, setting limits on the user and groups, and then on
    the directory (project) level. Disk quota systems have to be set on filesystem
    mount.'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling user and group quotas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To begin, log in as `root` and open the `fstab` file, which contains static
    mount information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, navigate the cursor to the line containing `/home` (with the *up* and
    *down* arrow keys) and move it to the word `defaults`, and then add the following
    text after `defaults`, separated by commas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete line will look like the following (your device name will be different,
    depending on your individual LVM name; here, it is `myserver`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and close the file, then remount the `/home` partition to activate the
    `quota` directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a user quota on the total file size for a specific user named
    `john` (change appropriately to match a user available on your system):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a user quota for the total *amount* of files another user, `joe`,
    can have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s create a file amount and size limit for everyone in the user group `devgrp`
    (the filesystem group `devgrp` must exist):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, show the whole quota report for the `home` volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enabling project (directory) quotas
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to enable disk quotas for a single directory instead of user or group
    quotas, we have to add the project quota directive called `pquota` to the volume
    containing the directory. As we will use a directory called `/srv/data` for our
    project quota, we need to take the full underlying `/` root partition under quota
    control. For the root partition, we have to set quota flags as kernel boot options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, open the following file as root after first making a backup
    of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `rootflags=pquota` directive to the end of the line (add one whitespace
    character before it) starting with `GRUB_CMDLINE_LINUX=` before the closing double
    quote as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and close the file, and then rebuild the `grub` configuration with our
    new `boot` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the `pquota` flag to your root volume in `/etc/fstab` as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate the cursor to the line containing the root mount point / and move
    it to the word `defaults`, and then add the following text, separated by a comma:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete line will look similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, reboot your computer to apply your changes to the `root` volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After rebooting, make sure that the `root` volume has project quota enabled,
    which is defined as the `prjquota` flag in the volume''s options (otherwise, if
    it is wrong and doesn''t work, it will show as `noquota`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s create our target folder that we want to set quotas for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to add a project name and an associated new, unique ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, define that `/srv/data` will use quota rules from our project ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, initialize the `project` quota for the `root` volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, apply the following rule to create specific directory limits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out our quota rules for this device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, you learned how easy it is to set up a quota system on a user,
    group, or directory (project) level. Also, you have learned that there are two
    basic ways of defining quotas: either put a restriction on the *total file size*
    (called blocks), or a limit on the *number* of files (called inodes).'
  prefs: []
  type: TYPE_NORMAL
- en: So, what have we learned from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'We began this recipe by setting user and group quotas. As you have seen, a
    quota system can easily be enabled by adding associated directives to the partition
    of choice in the `/etc/fstab` file. Therefore, we began this recipe by opening
    this file and adding the special quota keywords for the XFS user, and group quotas
    to our `/home` partition. In order to apply these changes, we had to remount the
    filesystem using the `mount` command. As the quota system had been successfully
    started, we used the `xfs_quota -x -c` command line to set some quota limits on
    our enabled filesystem `/home`. `-x` enables expert mode while `-c` lets us run
    commands as arguments on the command line. When running `xfs_quota` without the
    `-c` option, you will get to an interactive prompt instead. First, we set some
    user limits for the users, `john` and `joe`. We did this by defining the following
    parameters with numbers: `bsoft`, `bhard`, `isoft`, `ihard`. As you can see, there
    are both soft and hard limits for file size (**blocks**) and file amount (**inodes**).
    Block quotas can be given in the typical metrics such as kilobyte (`k`), megabyte
    (`m`), and gigabyte (`g`), whereas an inode is a number. A soft limit is a threshold
    that, when crossed, prints out a warning message to the command line, whereas
    a hard limit will stop the user from adding any more data or files to the filesystem
    under quota protection. Afterwards, we set a group-based quota. If you use the
    `-g` flag, the limit will be defined for a group instead of the user. Using group
    rules can be very helpful to separate your users into different groups depending
    on the amount of files or total file size they should be allowed to have. Finally,
    we generated a report for all our current quota limits. The command we used there
    was `''report -bi -h''`, which generates reports for used filespace (`-b` for
    blocks) and the total amount of files (`-i` for inodes). `-h` specified that we
    want the output to be human-readable in megabytes or gigabytes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test that quotas work, let''s create the following block and inode quotas
    for the user `jack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in as the user `jack` (`su - jack`) and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With this command, the user `john` will try to create a 21 megabyte size file,
    but when starting to write the twentieth megabyte, the following error message
    will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, delete the `~/test.dd` file so that we can start another test. The same
    happens if you exceed your file amount limit. Test the following quota limit by
    trying to create 2,000 multiple files while the quota is limited to 1,000; do
    this by adding a lot of new files: `for i in {1..2000}; do touch ~/test$i.txt;
    done`. This results in the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To temporarily turn off user and group quota checking for a specific filesystem,
    you can run `xfs_quota -x -c ''off -u -g'' /home/` (`-u` for user, `-g` for group)
    as `root` user. This is only temporary; to re-enable it, you need to remount the
    filesystem of interest, which is `umount /home;mount -a`. To remove a specific
    quota rule, just set its limit to zero, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Next, we set up quota on a *directory*, instead of the user/group level. This
    is a feature only XFS file systems are capable of; all other filesystems can only
    set quotas on a disk or partition level. Being able to control the disk usage
    of a directory hierarchy is useful if you do not otherwise want to set quota limits
    for a privileged user or groups. To activate directory quota, we first had to
    enable this as a kernel boot option because, by default, the root volume is flagged
    as `noquota`. Also, we added the `prjquota` directive in `/etc/fstab` to the root
    partition to make it work. If you want to learn more about kernel boot options,
    read the boot loader recipe in [Chapter 1](part0015_split_000.html#E9OE1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 1. Installing CentOS"), *Installing CentOS*. To set file system flags
    for the root partition, we needed to reboot the system. After doing this, we made
    sure that the boot option has been set successfully by looking into the `mtab`
    file, which is a file that lists all currently mounted filesystems. Next, we set
    up a project name with an associated unique project ID (we randomly choose `1400`)
    in the `/etc/projid` file. In the next step, we applied this new project ID (`1400`)
    to a directory in the `/etc/projects` file called `/srv/data`. This system allows
    the application of specific project quota rules to many different directories.
    Afterwards, we initialized project quota for the root partition using the `project`
    option with the `xfs_quota` command, and then created a `limit` quota rule for
    this project name. All directories that are defined in the `/etc/projects` file
    under the corresponding project id are affected by this rule. This type of system
    can be used for fine-grain multiple folder quota rules. For every directory, you
    can set up a new project name or reuse a specific one, making this system very
    flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we have created a block size hard limit of 1,200 megabytes
    for our project name, which is `myProject`. To test this quota, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This should stop `dd`, exactly after writing 1200 megabytes, with the following
    command line error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name implies, the `xfs_quota` program shown in this recipe only works
    for XFS filesystems. If you want to use disk quotas on a user or group level for
    other file systems such as ext4 or btrfs, you have to install the `quota` package
    (`yum install quota`). Setting quotas works in a similar way to the steps shown
    in this recipe; please read the manual `man quota` to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining a filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to check the consistency and optionally repair
    CentOS 7 filesystems. Filesystem inconsistencies are rare events and filesystem
    checks normally are running automatically at boot time. But system administrators
    should also know how to run such tests manually, if they believe there is a problem
    with the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges. We will use virtual block devices instead
    of real disk devices because we *cannot* apply any file system check on a *mounted*
    disk. Therefore, you should have applied the *Formatting and mounting a filesystem*
    recipe and created a 1 gigabyte virtual block device with two partitions of half
    the total size: first, a partition with an XFS, and then another one with an ext4
    filesystem. We will use the virtual block device named `/dev/loop0` in this example.'
  prefs: []
  type: TYPE_NORMAL
- en: As said before, these can be easily exchanged with real disk names.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin with, log in as `root` and show information about the current block
    devices attached to the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, you should see two partitions on the `loop0` device: `/dev/loop0p1` and
    `/dev/loop0p2`. If you see that they are currently mounted to the system, unmount
    them now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s check the XFS filesystem which in our example is loop0p1 (change
    appropriately):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the second partition on the disk that is ext4, we will use the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have learned how easy it is to run a filesystem check on
    a XFS or ext4 filesystem. The most important lesson you should have learned here
    is that you always have to *unmount* your disk partitions before running any filesystem
    checks!
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: Since we cannot run any filesystem checks on any mounted device, if you want
    to check your system's disks and partitions, often you have to run such checks
    in the *rescue* mode where your filesystems are not mounted (for example, you
    cannot unmount the root partition to check because it's needed by the system all
    the time, whereas, for a separate home partition, it would be possible).
  prefs: []
  type: TYPE_NORMAL
- en: For the XFS file system, we use the `xfs_repair` tool, and for all others we
    will use the `fsck` program with the `-f` parameter (force) to check our filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that we always need to run `fsck` instead of the specific
    `fsck.<file system type>` (such as `fsck.ext4`, `fsck.btrfs`), because it auto-detects
    the right tool for you. This is necessary because if you run the wrong specific
    `fsck.<file system type>` tool on the wrong filesystem (let's say running `fsck.ext4`
    on a btrfs filesystem), it can completely destroy it!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have only showed you how to *check* a filesystem using `xfs_repair`
    and `fsck`. If some errors occur during the "checking" run on an XFS filesystem,
    run `xfs_repair` without the `-n` option—for example, use `xfs_repair /dev/loop0p1`.
    On a non-XFS partition, such as ext4, you would run `fsck` with the `-a` option
    (`a` for auto repair)—for example, `fsck -a /dev/loop0p2`. For `fsck`, if you
    got a lot of errors, it's best to use `-y` as well so that you do not have to
    confirm every error fix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s simulate what would happen if we got a corrupted XFS filesystem
    using our virtual block device (*never* do this on any real disk partition!):'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, mount the `/dev/loop0p1` partition to your root filesystem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a large number of files on this mounted filesystem—for example,
    `2000` files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, unmount the device and corrupt the filesystem using `dd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run a filesystem check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will most likely show you a list of corrupted files; in order to fix it,
    use the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can also simulate such a filesystem corruption on your ext4 virtual block
    device, and then repair it using `fsck -ay /dev/loop0p2`.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the capacity of the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CentOS 7 uses the **Logical Volume Manager** (**LVM**) to organize the structure
    and available capacity of your partitions. It is a very dynamic and flexible system
    that can be extended or rearranged over time, and which is essential in today's
    most demanding and ever-changing environments. At the moment, buzzwords such as
    big data or cloud computing can be heard everywhere. Since massive amounts of
    data get produced all the time, storage requirements and disk space have to grow
    at the same steady pace. In this recipe, you will learn how to work with the LVM
    system and how to extend your physical drives, and also how to shrink and extend
    the capacity of your filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges. We will use virtual block devices instead
    of real disk devices to show you from scratch how to set up a LVM first, and afterwards
    how to work with it. Please read the *Creating a virtual block device* recipe
    and create three 1 gigabyte virtual block devices with the GPT partition table,
    which will be labeled as `/dev/loop0`, `/dev/loop1`, and `/dev/loop2` in this
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Again, feel free to use real disk devices if you feel ready for it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will start by creating an LVM test environment similar to the standard
    CentOS 7 LVM structure, which is set up during the installation of every server
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s log in as `root` and show information about our virtual block
    devices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create new partitions spanning the whole disk on each of the three virtual
    block devices (without a filesystem label):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create LVM *physical volumes* on each of the loop devices (type
    `yes` to remove the `gpt` label):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, show information about our physical volumes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create a new LVM volume group on our first physical volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, show information about the created group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterwards, let''s create some logical volumes on our first volume group, which
    will be treated as virtual partitions in our Linux system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, show information about the logical volumes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, display how much free space our underlying volume group has left, which
    becomes important if you want to expand some logical volumes (see the section
    `Free PE / Size` in the output):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterwards, let''s create the filesystems on those new logical volumes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, after we have created our test LVM system (which is very similar to the
    real CentOS LVM standard layout, but with smaller sizes), let's start working
    with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, let''s shrink the `root` partition, which is currently `400` megabytes
    (`M`) in size, by `200` megabytes, and afterwards, let''s increase the `home`
    partition by `500` megabytes (confirm the possible data loss):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use `vgdisplay myVG1` again to see how the volume group's free space changes
    by running the previous commands (see `Free PE / Size`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s expand the XFS filesystem on the grown logical volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very important not to use `resize2fs` for growing XFS filesystems, because
    it's incompatible and can corrupt them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s say that after some time your data has grown again, and you need
    the home partition to be 1.5 gigabytes (`G`), but you only have 184.00 MiB left
    on the underlying volume group. First, we need to add our two prepared physical
    volumes from the beginning of this recipe to our volume group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterwards, we have enough free space in our volume group (see `Free PE / Size`)
    to expand our home logical volume (the volume must stay mounted):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, in this recipe, we have shown you how to work with the LVM for XFS partitions.
    It has been developed with the purpose of managing disk space on several hard
    disks dynamically. You can easily merge many physical hard disks together to make
    them appear as a single virtual hard disk to the system. This makes it a flexible
    and very scalable system in comparison to working with plain old static partitions.
    Traditional partitions are bound to, and cannot grow over, the total disk capacity
    they reside on, and their static partition layout cannot be changed easily. Also,
    we have introduced some important LVM technical terms that provide different abstraction
    layers to a hard disk, and which will be explained in this section so as to understand
    the concepts behind it: **physical** **volume** (**pv**), **volume** **group**
    (**vg**), and **logical volume** (**lv**).'
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We started this recipe by creating three virtual block devices of 1 gigabyte
    (`G`) each and then one partition spanning the whole device on each of them. Afterwards,
    we defined these single-partition devices as physical volumes (pv) using the `pvcreate`
    command. A pv is an LVM term that defines a storage unit in the LVM world. It
    must be defined on a partition, full drive, or loop device. A pv is just an abstraction
    of all the space available in the surrounding partition so that we can work with
    it on an LVM basis. Next, we created a volume group (vg) with the `vgcreate` command,
    where we also had to define a volume group name of our choice and put the first
    pv in it as a basic storage volume. As you can see, a vg is a container for at
    least one pv (we add more pv's later). Adding or removing pv's to or from a vg
    is the heart of the whole scalability concept of the LVM system. The pv's don't
    have to be all the same size, and it is possible to grow your vg over time by
    adding dozens of new physical drives all defined as pv. You can have more than
    one vg on your system, and you can identify them by the unique names you are giving
    to them. So, in summary, to extend the space of your vg, you have to create pv's
    out of physical drives, which you can then add to.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we created logical volumes (lv) on our vg, which can be seen and used
    like real physical partitions within a vg. Here, we created three lv's using the
    `lvcreate` command, by which we need to define the name of the vg (remember, there
    can be more than one vg on your system) that we want to put our target lv on,
    along with the size of the volume, as well as a name for it as the last parameter.
    You can add multiple lvs into a vg and you don't need to use the whole allocated
    space from the underlying free space of the vg. You can be very flexible with
    it. The best part is that your decision about your volumes' size and layout doesn't
    have to be fixed for all time; you can change them anytime later. It is a very
    dynamic system that can be extended and shrunk, deleted and created, without having
    to unmount the volume beforehand. But you have to remember that all lvs are bound
    to a vg, and it is not possible to create them without it or outside its spacial
    boundaries. If you need to extend an lv's space over the borders of the underlying
    vg, you have to extend the vg, as show in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As you may have seen, for every LVM term, there is a "display" and "create"
    command, so it''s easy to remember: `pvdisplay`, `vgdisplay`, `lvdisplay`, `pvcreate`,
    `vgcreate`, `lvcreate`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have successfully created your lv''s, you can work with them as you
    would with every other block device partition on your system. The only difference
    is that they reside in special device folders: `/dev/<vg name>/<lv name>` or `/dev/mapper/<vg
    name>/<lv name>`. For example, the home volume created in this example has the
    name `/dev/myVG1/home`. Finally, in order to use them as normal mount points,
    we created some test filesystems on them.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this recipe, we showed you how to extend our vg and how
    to shrink and expand our lv's test system.
  prefs: []
  type: TYPE_NORMAL
- en: We started by using the `vgdisplay myVG1` command to show the currently available
    space on the vg. In the command output, we saw that our current volume group has
    a total of `996M` (`VG Size`), the allocated size from our lv's (`swap`, `home`,
    `root`) is `512M` (`Alloc PE / Size`), and the free size is `484M` (`Free PE /Size`).
    Next, we used the `lvresize` command to shrink and expand the logical volume's
    root and home. The `-L` parameter sets the new size of the volume, and with the
    `+` or `-` sign, the value is added to or subtracted from the actual size of the
    logical volume. Without it, the value is taken as an absolute one. Remember that
    we could only increase the home partition because the current volume layout does
    not occupy the complete vg's total space. After resizing, if we use the `vgdisplay`
    command again, we see that we now occupy more space in the vg; its free size has
    been decreased to `184M`. Since we expanded the `home` volume from `100M` to `500M`
    in total, we need to remember to expand its XFS filesystem too, since expanding
    a volume does not automatically expand its filesystem. Therefore, `400M` of the
    current volume are unallocated without any filesystem information. We used the
    command, `xfs_growfs`, which will, without defining a limit parameter, use the
    complete unallocated area for the XFS filesystem. If you want to resize any other
    filesystem type, such as ext4, you would use the `resize2fs` command instead.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we wanted to grow the home volume by `1.5G`, but we only have `184M`
    left on our vg to expand. This is where LVM really *shines*, because we can just
    add some more physical volumes to it (in the real world, you would just install
    new hard disks in your server and use them as pvs). We showed you how to *extend*
    the capacity of your vg by adding two 1G-sized pvs to it using the `vgextend`
    command. Afterwards, we used `vgdisplay` to see that our vg has now grown to 3G
    in total size, so finally we could extend our home lv as it would now fit into
    it. As a last step, we expanded the XFS file system once again to fill up the
    whole 2G home volume size.
  prefs: []
  type: TYPE_NORMAL
- en: Please remember, all the time, that if you use vg's with several physical hard
    disks, your data will be distributed among these. An LVM is not a RAID system
    and has no redundancy, so if one hard disk fails, your complete vg will fail too
    and your data will be lost! In order to deal with this problem, a proposed solution
    could be to use a physical RAID system for your hard disks and create an LVM on
    top of that.
  prefs: []
  type: TYPE_NORMAL
