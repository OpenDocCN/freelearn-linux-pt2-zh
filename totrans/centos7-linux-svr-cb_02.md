# 第二章 配置系统

在本章中，我们将涵盖以下主题：

+   使用 less 浏览文本文件

+   介绍 Vim

+   使用正确的语言

+   使用 NTP 和 chrony 套件同步系统时钟

+   设置主机名并解析网络

+   成为超级用户

+   建立静态网络连接

+   自定义系统横幅和消息

+   初始化内核

# 介绍

本章是一系列涵盖建立服务器基本需求的基本实践的集合。对于许多人来说，构建服务器可能常常看起来是一项艰巨的任务，因此本章的目的是为您提供一种即时方法来实现所需的目标。

# 使用 less 浏览文本文件

在本书中，您将经常使用使用 less 程序或类似导航的程序和工具来查看和阅读文件内容或显示输出。起初，控制可能会显得有些不直观。在本节中，我们将向您展示如何使用 less 控制来浏览文件的基本知识。

## 准备工作

要完成本节内容，您需要一个具有 root 权限的 CentOS 7 操作系统的有效安装。

## 如何操作...

1.  首先，以 root 身份登录并输入以下命令以打开使用 less 进行导航的程序：

    ```
    man man

    ```

1.  要导航，请按*上*和*下*键以逐行滚动，按*空格键*以向下滚动一页，按*b*键以向上滚动一页。您可以使用正斜杠键*/*在文本中搜索，然后输入搜索词，按*Return*键进行搜索。按*n*键跳转到下一个搜索结果。按*q*键退出。

## 工作原理...

在这里，在这篇简短的节中，我们向您展示了 less 导航的基本知识，这对于阅读 man 页面至关重要，并且在本书中被许多其他程序用于显示文本。我们只向您展示了基本命令，还有很多需要学习。请阅读 less 手册以了解更多关于`man less`命令的信息。

# 介绍 Vim

在本节中，我们将简要介绍文本编辑器 Vim，它是本书中使用的标准文本编辑器。您也可以使用您喜欢的任何其他文本编辑器，例如 nano 或 emacs。

## 准备工作

要完成本节内容，您需要一个具有 root 权限的 CentOS 7 操作系统的有效安装。

## 如何操作...

我们将从安装`vim-enhanced`包开始本节，因为它包含一个您可以用来学习使用 Vim 的教程：

1.  首先，以 root 身份登录并安装以下包：

    ```
    yum install vim-enhanced

    ```

1.  之后，输入以下命令以启动 Vim 教程：

    ```
    vimtutor

    ```

1.  这将打开 Vim 教程，在 Vim 编辑器中。要导航，请按*上*和*下*键以逐行滚动。要退出教程，请按*Esc*键，然后输入`:q!`，接着按*Return*键退出。

1.  现在，你应该阅读文件并学习课程，以获得对 Vim 的基本理解，学习如何编辑你的文本文件。

## 它是如何工作的...

本配方中显示的教程应该被视为学习 Linux 最强大和有效的文本编辑器之一的基础知识的起点。Vim 的学习曲线非常陡峭，但如果你花大约半小时的时间来学习 vimtutor 指南，你应该能够毫无问题地完成所有常见的文本编辑任务，例如打开、编辑和保存文本文件。

# 说正确的语言

在本配方中，我们将向你展示如何为整个系统和单个用户更改 CentOS 7 安装的语言设置。更改这个的需求很少，但可能是重要的，例如，如果我们不小心在安装过程中选择了错误的语言。

## 准备工作

要完成这个配方，你需要一个具有 root 权限的 CentOS 7 操作系统的工作安装，以及你选择的基于控制台的文本编辑器。你应该已经阅读了*使用 less 导航文本文件*配方，因为本配方中的一些命令将使用 less 来打印输出。

## 如何做到这一点...

如果你想更改 CentOS 7 系统的系统范围语言设置，你需要调整两个类别的设置。我们首先更改系统区域设置信息，然后更改键盘设置：

1.  首先，以 root 用户身份登录并输入以下命令，以显示控制台、图形窗口管理器（X11 布局）的当前区域设置，以及当前键盘布局：

    ```
    localectl status

    ```

1.  接下来，要更改这些设置，我们首先需要了解系统上所有可用的区域设置和键盘设置（两个命令都使用`less`导航）：

    ```
    localectl list-locales
    localectl list-keymaps

    ```

1.  如果你在我们的示例中从上面的输出中选择了正确的区域设置，`de_DE.utf8`和`keymap de-mac`（根据你自己的适当需求进行更改），你可以使用以下命令更改你的区域设置和键盘设置：

    ```
    localectl set-locale LANG=de_DE.utf8
    localectl set-keymap de-mac

    ```

1.  现在，使用相同的命令再次验证你的更改的持久性：

    ```
    localectl status

    ```

## 它是如何工作的...

正如我们所见，`localectl`命令是一个非常方便的工具，可以管理 CentOS 7 系统中所有重要的语言设置。

那么我们从这次经历中学到了什么？

我们首先以 root 用户身份登录到命令行。然后，我们使用`status`参数运行`localectl`命令，这为我们提供了系统当前语言设置的概览。该命令的输出向我们展示了 CentOS 7 系统中的语言属性可以分为区域设置（系统区域设置）和键盘映射（VC 键盘映射和所有 X11 布局属性）设置。

Linux 上的区域设置用于设置系统的语言以及其他特定于语言的属性。这可以包括来自错误消息、日志输出、用户界面以及如果您使用的是 Gnome 等窗口管理器，甚至是 **图形用户界面**（**GUI**）的文本。区域设置还可以定义特定于区域的格式，例如纸张尺寸、数字及其自然排序、货币信息等。它们还定义字符编码，如果您选择了一种具有无法在标准 ASCII 编码中找到的字符的语言，这可能很重要。

另一方面，键盘映射设置定义了键盘上每个键的确切布局。

接下来，要更改这些设置，我们首先使用 `localectl` 命令和 `list-locales` 参数来检索系统上所有区域设置的完整列表，以及 `list-keymaps` 来显示系统上所有键盘设置的列表。从 `list-locales` 参数输出的区域设置使用非常紧凑的注释来定义语言：

```
Language[_Region][.Encoding][@Modificator]

```

只有 `Language` 部分是强制性的，其余部分都是可选的。语言和地区的示例包括：`en_US` 表示英语和美国地区或美式英语，`es_CU` 表示西班牙语和古巴地区或古巴西班牙语。

编码对于特殊字符（如德语变音符号或法语重音符号）很重要。这些特殊字符的内存表示可以根据所使用的编码类型以不同的方式解释。通常应使用 UTF-8，因为它能够对每种语言中的几乎任何字符进行编码。

修饰符用于更改由区域设置定义的设置。例如，`sr_RS.utf8@latin` 用于您希望为塞尔维亚的塞尔维亚语提供拉丁语设置，而通常使用西里尔语定义。这将更改为西方设置，例如排序、货币信息等。

要更改实际的区域设置，我们使用了 `set-locale LANG=de_DE.utf8` 参数。在这里，编码被选择来正确显示德语变音符号。请注意，我们使用了 `LANG` 选项来为所有可用的区域设置选项设置相同的区域设置值（例如，`de_DE.utf8`）。如果您不想为所有可用选项设置相同的区域设置值，您可以使用更精细的控制来控制单个区域设置选项。请参考使用手册页的区域设置描述，`man 7 locale`（在最小安装上；您需要在使用 `yum install man-pages` 命令之前安装所有 Linux 文档手册页）。您可以使用类似的语法设置这些附加选项，例如，要设置时间区域设置，请使用：

```
localectl set-locale LC_TIME="de_DE.utf8"

```

接下来，我们使用`list-keymaps`参数显示所有可用的键盘映射代码。正如我们从运行`localectl status`中看到的，键盘映射可以分为非图形（VC 键盘映射）和图形（X11 布局）设置，这允许在使用 Gnome 等窗口管理器时以及在控制台中灵活配置不同的键盘布局。运行带有参数`set-keymap de-mac`的`localectl`命令，将当前键盘映射设置为德国苹果 Macintosh 键盘模型。此命令将给定的键盘类型应用于正常的 VC 和 X11 键盘映射。如果希望 X11 与控制台的映射不同，请使用`localectl --no-convert set-x11-keymap cz-querty`，其中我们使用`cz-querty`作为键盘映射代码到捷克 querty 键盘模型（根据需要更改此设置）。

## 还有更多…

有时，单个系统用户需要与系统区域设置（只能由 root 用户设置）不同的语言设置，根据他们的区域键盘差异以及与系统交互时使用他们首选的人类语言。只要没有被本地环境变量覆盖，系统范围的区域设置就会由每个用户继承。

### 注意

更改系统范围的区域设置并不一定会影响用户已为自己定义的其他区域设置。

要打印任何系统用户的当前区域设置环境变量，我们可以使用命令`locale`。要设置具有适当变量名称的单个环境变量；例如，要将时间区域设置为美国时间，我们将使用以下行：

```
export LC_TIME="en_US.UTF-8"

```

但是，我们很可能希望将所有区域设置更改为相同的值；这可以通过设置`LANG`来实现。例如，要将所有区域设置更改为美式英语，请使用以下行：

```
export LANG="en_US.UTF-8"

```

要测试区域设置更改的效果，我们现在可以生成一个错误消息，该消息将显示在由`locale`命令设置的语言中。以下是将区域设置从英语更改为德语的不同语言输出：

```
export LANG="en_US.UTF-8"
ls !

```

以下输出将被打印：

```
ls: cannot access !: No such file or directory

```

现在，更改为德语区域设置：

```
export LANG="de_DE.UTF-8"
ls !

```

以下输出将被打印：

```
ls: Zugriff auf ! nicht möglich: Datei oder Verzeichnis nicht gefunden

```

在活动控制台中使用`export`命令设置区域设置不会在关闭窗口或打开新终端会话后继续存在。如果希望使这些更改永久生效，可以在主目录中的名为`.bashrc`的文件中设置任何区域设置环境变量，例如`LANG`变量，该文件将在每次打开 shell 时读取。在我们的示例中，要将区域设置永久更改为`de_DE.UTF-8`（根据需要更改此设置），请使用以下行：

```
echo "export LANG='de_DE.UTF-8'" >> ~/.bashrc

```

# 使用 NTP 和 chrony 套件同步系统时钟

在本食谱中，我们将学习如何使用**网络时间协议**（**NTP**）和 chrony 套件将系统时钟与外部时间服务器同步。从需要为文档、电子邮件和日志文件打时间戳，到安全运行和调试网络，或者仅仅与共享设备和服务交互，您的服务器上的所有操作都依赖于保持一个准确的系统时钟，本食谱的目的就是向您展示如何实现这一点。

## 准备工作

要完成本食谱，您需要一个具有 root 权限的 CentOS 7 操作系统的工作安装，您选择的基于控制台的文本编辑器，以及连接到互联网以便下载额外软件包的能力。

## 如何操作...

在本食谱中，我们将使用`chrony`服务来管理我们的时间同步。由于 chrony 在 CentOS 最小化安装中默认未安装，我们将从安装它开始：

1.  首先，以 root 身份登录并安装`chrony`服务，然后启动它并验证它是否正在运行：

    ```
    yum install -y chrony
    systemctl start chronyd
    systemctl status chronyd

    ```

1.  此外，如果我们想让 chrony 永久运行，我们需要在服务器启动时启用它：

    ```
    systemctl enable chronyd

    ```

1.  接下来，我们需要检查系统是否已经使用 NTP 通过网络同步我们的系统时钟：

    ```
    timedatectl  | grep "NTP synchronized"

    ```

1.  如果上一步的输出显示`NTP 同步`为`否`，我们需要使用以下命令启用它：

    ```
    timedatectl set-ntp yes

    ```

1.  如果您再次运行第 3 步中的命令，您应该会看到它现在正在同步 NTP。

1.  chrony 的默认安装将使用一个可以访问原子钟的公共服务器，但为了优化服务，我们需要对使用哪些时间服务器进行一些简单的更改。为此，使用您喜欢的文本编辑器打开主要的 chrony 配置文件，如下所示：

    ```
    vi /etc/chrony.conf

    ```

1.  在文件中，向下滚动并查找包含以下内容的行：

    ```
    server 0.centos.pool.ntp.org iburst
    server 1.centos.pool.ntp.org iburst
    server 2.centos.pool.ntp.org iburst
    server 3.centos.pool.ntp.org iburst

    ```

1.  用首选本地时间服务器的列表替换显示的值：

    ```
    server 0.uk.pool.ntp.org iburst
    server 1.uk.pool.ntp.org iburst
    server 2.uk.pool.ntp.org iburst
    server 3.uk.pool.ntp.org iburst

    ```

    ### 注意

    访问[`www.pool.ntp.org/`](http://www.pool.ntp.org/)以获取一份地理位置接近您当前位置的本地服务器列表。请记住，使用三个或更多服务器往往有助于提高 NTP 服务的准确性。

1.  完成后，保存并关闭文件，然后使用`sytstemctl`命令同步您的服务器：

    ```
    systemctl restart chronyd

    ```

1.  要检查`config`文件中的修改是否成功，您可以使用以下命令：

    ```
    systemctl status chronyd

    ```

1.  要检查 chrony 是否正在处理您的系统时间同步，请使用以下命令：

    ```
    chronyc tracking

    ```

1.  要检查 chrony 用于同步的网络源，请使用以下命令：

    ```
    chronyc sources

    ```

## 工作原理...

我们的 CentOS 7 操作系统在每次启动时都会根据硬件时钟设置时间，这是一个位于计算机主板上的小型电池驱动时钟。通常，这个时钟不够准确或者设置不正确，因此最好从互联网上的可靠来源（使用真正的原子时间）获取系统时间。chrony 守护进程`chronyd`通过使用 NTP 协议与远程服务器进行通信的过程来设置和维护系统时间。

那么，我们从这次经历中学到了什么？

作为第一步，我们安装了`chrony`服务，因为它在 CentOS 7 最小安装中默认不可用。之后，我们使用`timedatectl set-ntp yes`命令启用了系统时间与 NTP 的同步。

之后，我们打开了主要的 chrony 配置文件`/etc/chrony.conf`，并展示了如何更改使用的外部时间服务器。如果您的服务器位于企业防火墙后面并且拥有自己的 NTP 服务器基础设施，这尤其有用。

重新启动服务后，我们学习了如何使用`chronyc`命令检查和监视我们的新配置。这是一个有用的命令行工具（c 代表客户端），用于与 chrony 守护进程（本地或远程）交互和控制。我们使用`tracking`参数与`chronyc`一起使用，这向我们展示了与特定服务器的当前 NTP 同步过程的详细信息。如果您需要进一步帮助关于输出中显示的属性，请参考`chronyc`命令的`man`页面（`man chronyc`）。

我们还使用`sources`参数与`chronyc`程序一起使用，这向我们展示了使用的 NTP 时间服务器的概述。

您还可以使用较旧的`date`命令来验证正确的时间同步。重要的是要意识到同步服务器的过程可能不是即时的，并且可能需要一段时间才能完成。然而，您现在可以放心地知道，您现在知道如何安装、管理和使用 NTP 协议同步时间。

## 还有更多...

在本食谱中，我们使用`chrony`服务和 NTP 协议设置系统时间。通常，系统时间设置为**协调世界时**（**UTC**）或世界时间，这意味着它是全球统一使用的一种标准时间。从它开始，我们需要使用时区来计算我们的本地时间。要找到正确的时间区域，请使用以下命令（阅读*使用 less 浏览文本文件*食谱以处理输出）：

```
timedatectl list-timezones

```

如果您找到了正确的时间区域，请记下来并在下一个命令中使用它；例如，如果您位于德国并且靠近柏林市，请使用以下命令：

```
timedatectl set-timezone Europe/Berlin

```

再次使用`timedatectl`检查您的本地时间是否正确：

```
timedatectl | grep "Local time"

```

最后，如果它是正确的，您可以同步硬件时钟与系统时间以使其更精确：

```
hwclock --systohc

```

# 设置主机名和解决网络问题

设置主机名的过程通常与安装过程相关联。如果您需要更改它或您服务器的**域名系统**（**DNS**）解析器，本指南将向您展示如何操作。

## 准备

要完成本指南，您需要具备具有 root 权限的 CentOS 7 操作系统的有效安装，以及您选择的基于控制台的文本编辑器。

## 如何操作...

要开始本指南，我们将首先以 root 身份访问系统并打开以下文件，以便为您的当前服务器命名或重命名主机名：

1.  以 root 身份登录并输入以下命令以查看当前主机名：

    ```
    hostnamectl status

    ```

1.  现在，将主机名值更改为您的首选名称。例如，如果您想将服务器称为`jimi`，您将输入（适当更改）：

    ```
    hostnamectl set-hostname jimi

    ```

    ### 注意

    静态主机名区分大小写，并且限制为使用互联网友好的字母数字字符串。总长度不应超过 63 个字符，但尽量保持更短。

1.  接下来，我们需要服务器的 IP 地址。输入以下命令以查找它（您需要在输出中识别正确的网络接口）：

    ```
    ip addr list

    ```

1.  之后，我们将设置**完全限定域名**（**FQDN**），为此，我们需要打开并编辑主机文件：

    ```
    vi /etc/hosts

    ```

1.  在这里，您应该添加一条符合您需求的新行。例如，如果您的服务器主机名称为 jimi（IP 地址为`192.168.1.100`，域名为`henry.com`），您需要追加的最终行将如下所示：

    ```
    192.168.1.100        jimi.henry.com jimi

    ```

    ### 注意

    对于仅在本地网络上找到的服务器，建议使用非基于互联网的顶级地址。例如，您可以使用`.local`或`.lan`，甚至是`.home`，通过使用这些引用，您将避免与典型的`.com`、`.co.uk`或`.net`域名混淆。

1.  接下来，我们将打开`resolv.conf`文件，该文件负责配置系统将使用的静态 DNS 服务器地址：

    ```
    vi /etc/resolv.conf

    ```

1.  用以下内容替换文件内容：

    ```
    # use google for dns
    nameserver 8.8.8.8
    nameserver 8.8.4.4

    ```

1.  完成后，保存并关闭文件，然后重新启动服务器以使更改立即生效。为此，请返回控制台并输入：

    ```
    reboot

    ```

1.  成功重启后，您可以通过输入以下命令并等待响应来检查您的新主机名和 FQDN：

    ```
    hostname --fqdn

    ```

1.  要测试我们是否可以使用静态 DNS 服务器地址将域名解析为 IP 地址，请使用以下命令：

    ```
    ping -c 10 google.com

    ```

## 它是如何工作的...

主机名是为网络上的机器创建的唯一标签。它限制为基于字母数字的字符，并且可以通过使用`hostnamectl`命令来更改服务器的主机名。DNS 服务器用于将域名翻译成 IP 地址。有多个公共 DNS 服务器可用；在后面的指南中，我们将构建我们自己的 DNS 服务。

那么，我们从这次经历中学到了什么？

在本食谱的第一阶段，我们使用`hostnamectl`命令更改了服务器当前使用的主机名。该命令可以设置三种不同类型的主机名。使用带有`set-hostname`参数的命令将为所有三个主机名设置相同的名称：高级的`pretty`主机名，可能包含各种特殊字符（例如，`Lennart's Laptop`），静态主机名，用于在启动时初始化内核主机名（例如`lennarts-laptop`），以及瞬态主机名，它是从网络配置中接收的默认主机名。

接下来，我们设置了服务器的 FQDN。FQDN 是主机名加上其后的域名。当你运行私有 DNS 或允许外部访问你的服务器时，域名变得重要。除了使用 DNS 服务器设置 FQDN 外，还可以通过更新位于`/etc/hosts`的 hosts 文件来实现。

该文件由 CentOS 用于将主机名映射到 IP 地址，并且在新安装的、未配置的服务器上经常发现它是错误的。因此，我们首先必须使用`ip addr list`找出服务器的 IP 地址。

一个 FQDN 应该由一个简短的主机名和域名组成。根据本食谱中所示的示例，我们为名为`henry`的服务器设置了 FQDN，其 IP 地址为`192.168.1.100`，域名为`henry.com`。

保存此文件可以说完成了这个过程。然而，由于内核在启动过程中记录了主机名，因此别无选择，只能重启服务器才能使用更改后的设置。

接下来，我们打开了系统的`resolv.conf`文件，该文件保存了系统 DNS 服务器的 IP 地址。如果服务器没有使用或没有 DNS 记录，系统将无法在任何程序中使用域名作为网络目的地。在我们的示例中，我们输入了公共 Google DNS 服务器的 IP 地址，但你可以使用任何你想要或必须使用的 DNS 服务器（在企业环境中，在防火墙后面，你通常必须使用内部 DNS 服务器基础设施）。在成功重启后，我们使用`hostname`命令确认了你的新设置，该命令可以根据给定的参数打印出主机名或 FQDN。

因此，综上所述，可以说这个食谱不仅向你展示了如何重命名服务器和解决网络问题，还向你展示了主机名和域名之间的区别：

正如我们所学，服务器不仅可以通过更短、更易记、更快捷的单字节主机名来识别，还由三个用句点分隔的值组成（例如 jimi.henry.com）。这些值之间的关系可能在一开始显得奇怪，尤其是对于许多人来说，它们似乎是一个单一的值。但是，通过完成这个配方，您已经发现域名与主机名是不同的，因为域名是由解析器子系统确定的，只有将它们组合在一起，您的服务器才会产生整个系统的完全限定域名（FQDN）。

## 还有更多...

主机文件包含一系列 IP 地址及其对应的域名。如果您的网络中存在未在现有 DNS 记录中列出的 IP 地址的计算机，为了加快网络速度，通常建议您将这些计算机添加到此文件中。

此操作可在任何操作系统上实现，但在 CentOS 上，只需使用您喜欢的文本编辑器打开主机文件，如下所示：

```
vi /etc/hosts

```

现在，滚动到文件底部，通过将此处显示的域名和 IP 地址替换为更适合您自己需求的值，添加以下值：

```
192.168.1.100    www.example1.lan
192.168.1.101    www.example2.lan
```

您甚至可以使用外部地址，例如：

```
83.166.169.228  www.packtpub.com
```

这种方法为您提供了创建域名与 IP 地址映射的机会，无需使用 DNS。它可以应用于任何工作站或服务器。列表大小不受限制，您甚至可以使用这种方法通过将所有请求重定向到已知网站的不同 IP 地址来阻止对某些网站的访问。例如，如果`www.website.com`的真实地址是`192.168.1.200`，而您想限制对其的访问，只需在您希望阻止访问的计算机上对主机文件进行以下更改：

```
127.0.0.1    www.website.com
```

这并非万无一失，但在这种情况下，任何尝试访问`www.website.com`的系统都会自动被重定向到`127.0.0.1`，即本地网络地址，从而阻止访问。

完成操作后，请记得以常规方式保存并关闭文件，然后继续享受更快速、更安全的域名解析带来的好处，无论是在任何可用的网络上。

# 建立静态网络连接

在本配方中，我们将学习如何为新创建或现有的 CentOS 服务器配置静态 IP 地址。

虽然动态分配的 IP 地址或 DHCP 保留可能适用于大多数台式机和笔记本电脑用户，但如果您正在设置服务器，通常需要静态 IP 地址。从网页到电子邮件，从数据库到文件共享，静态 IP 地址将成为您的服务器提供一系列应用程序和服务的永久位置。本配方的目的是向您展示实现这一目标是多么容易。

## 准备就绪

要完成此操作，您需要一个具有 root 权限和您选择的基于控制台的文本编辑器的 CentOS 7 操作系统的工作安装。

## 如何操作...

为了本操作的目的，您将能够在目录`/etc/sysconfig/network-scripts/`中找到所有相关文件。首先，您需要找出要设置为静态的网络接口的正确名称。如果您需要将多个网络接口设置为静态，请为每个设备重复此操作。

1.  要执行此操作，以 root 身份登录并键入以下命令以获取系统所有网络接口的列表：

    ```
    ip addr list

    ```

1.  如果您只安装了一个网络卡，那么很容易找到其名称；只需选择未命名为`lo`（这是环回设备）的那个。如果您有多个，查看不同设备的 IP 地址可以帮助您选择正确的设备。在我们的示例中，设备名为`enp0s3`。

1.  接下来，备份网络接口配置文件（根据需要更改`enp0s3`部分，如果您的网络接口名称不同）：

    ```
    cp /etc/sysconfig/network-scripts/ifcfg-enp0s3/etc/sysconfig/network-scripts/ifcfg-enp0s3.BAK

    ```

1.  当您准备好继续时，在您最喜欢的文本编辑器中打开以下文件，如下所示：

    ```
    vi /etc/sysconfig/network-scripts/ifcfg-enp0s3

    ```

1.  现在，向下浏览文件并应用以下更改：

    ```
    NM_CONTROLLED="no"
    BOOTPROTO=none
    DEFROUTE=yes
    PEERDNS=no
    PEERROUTES=yes
    IPV4_FAILURE_FATAL=yes

    ```

1.  现在，通过根据需要自定义`XXX.XXX.XXX.XXX`的值来添加您的 IP 信息：

    ```
    IPADDR=XXX.XXX.XXX.XXX
    NETMASK= XXX.XXX.XXX.XXX
    BROADCAST= XXX.XXX.XXX.XXX

    ```

1.  我们现在必须添加一个默认网关。通常，这应该是您的路由器的地址。要执行此操作，只需在文件底部添加新行，如下所示，并根据需要自定义值：

    ```
    GATEWAY=XXX.XXX.XXX.XXX

    ```

1.  准备好后，保存并关闭文件，然后为要设置为静态的任何剩余以太网设备重复此步骤。执行此操作时，请记住为每个设备分配不同的 IP 地址。

1.  完成后，保存并关闭此文件，然后重新启动您的网络服务：

    ```
    systemctl restart network

    ```

## 它是如何工作的...

在本操作中，您已经看到了将服务器的 IP 地址从外部 DHCP 提供商获得的动态值更改为由您分配的静态值的过程。此 IP 地址现在将形成一个独特的网络位置，您将能够从中提供各种服务和应用程序。这是一个永久性的修改，是的，您可以说这个过程本身相对简单。

那么，我们从这次经历中学到了什么？

通过识别您选择的网络接口名称并创建原始以太网配置文件的备份来开始本教程，然后我们打开了位于`/etc/sysconfig/network-scripts/ifcfg-XXX`（其中`XXX`是您的接口名称，例如`enp0s3`）的配置文件。由于不再需要网络管理器的服务，我们通过将值设置为`no`来禁用`NM_CONTROLLED`。接下来，由于我们正在转向静态 IP 地址，`BOOTPROTO`已被设置为`none`，因为我们不再使用 DHCP。为了完成我们的配置更改，我们接着添加了特定的网络值，并设置了 IP 地址、子网掩码、广播和默认网关地址。

为了帮助创建静态 IP 地址，默认网关是一个非常重要的设置，因为它允许服务器通过路由器与更广阔的世界通信。

完成后，我们被要求保存并关闭文件，然后为任何剩余的以太网设备重复此步骤。完成这些操作后，我们被要求重新启动网络服务，以完成本教程并使我们的更改立即生效。

# 成为超级用户

在本教程中，我们将学习如何授予指定的用户或组执行各种具有提升权限的命令的能力。

在 CentOS Linux 系统中，许多文件、文件夹或命令只能由名为`root`的用户访问或执行，该用户可以控制 Linux 系统上的所有内容。每个系统拥有一个 root 用户可能满足您的需求，但对于那些希望获得更高灵活性、可靠的审计跟踪以及能够向选定的可信用户提供有限的管理权限的人来说，您来对地方了。本教程的目的是向您展示如何激活和配置**sudo**（**超级用户执行**）命令。

## 准备工作

为了完成本教程，您需要一个具有 root 权限的 CentOS 7 最小安装操作系统。假设您的服务器维护一个或多个用户（除了 root 之外），他们有资格获得这种权限提升。如果在安装过程中没有创建系统用户账户，请首先应用本教程，*管理用户及其组*，在第三章，*管理系统*。

## 如何操作...

为了开始本教程，我们将首先使用非特权用户测试`sudo`命令。

1.  首先，使用非 root 用户账户登录到您的系统，然后输入以下命令以验证`sudo`未启用（在提示时使用您的用户账户密码）：

    ```
    sudo ls /var/log/audit

    ```

1.  这将打印出以下错误输出，其中`<username>`是您当前登录的用户：

    ```
    <username> is not in the sudoers file.  This incident will be reported.

    ```

1.  现在，使用以下命令注销系统用户：

    ```
    logout

    ```

1.  接下来，以 root 身份登录并使用以下命令为非 root 用户赋予 sudo 权限（适当更改`<username>`）：

    ```
    usermod -G wheel <username>

    ```

1.  现在，你可以通过再次注销 root 并重新登录步骤 1 中的用户来测试`sudo`是否工作，然后再次尝试：

    ```
    sudo ls /var/log/audit

    ```

1.  祝贺你，现在你已经将一个普通用户设置为拥有 sudo 权限，可以查看和执行限制给 root 用户的文件和目录。

## 它是如何工作的...

与某些 Linux 发行版不同，CentOS 默认不提供 sudo。相反，你通常只被允许以 root 用户身份访问系统的受限部分。这提供了一定程度的安全性，但对于多用户服务器来说，除非你简单地为这些人提供完整的管理员 root 访问权限，否则几乎没有灵活性。这并不明智，因此本食谱的目的是向你展示如何为一个或多个用户提供执行具有提升权限的命令的权利。

那么，我们从这次经历中学到了什么？

我们首先以一个没有 root 权限或 sudo 权限的普通用户账户登录系统。使用这个用户，我们尝试列出一个通常只有 root 用户才能看到的目录，因此我们在其上应用了`sudo`命令。但失败了，给出了我们不在 sudoers 列表中的错误。

`sudo`命令为指定的用户或组提供了执行命令的能力，就像他们是 root 用户一样。所有操作都会被记录（在一个名为`/var/log/secure`的文件中），因此将会有所有命令和参数使用的痕迹。

我们随后以真正的 root 用户身份登录，并为希望获得 sudo 权限的系统用户添加了一个名为 wheel 的组。这个组被用作特殊的管理组，其所有成员都会自动获得 sudo 权限。

从现在开始，指定的用户可以使用 sudo 来执行任何具有提升权限的命令。为此，用户需要在任何命令前输入`sudo`这个词，例如，他们可以运行以下命令：

```
sudo yum update

```

系统会要求他们确认自己的用户密码（不是 root 密码！），在成功验证后，程序将以 root 用户身份执行。

最后，我们可以说在 CentOS Linux 系统上有三种成为 root 的方式：

首先，以真正的 root 用户身份登录系统。其次，你可以使用命令`su – root`，同时任何普通系统用户登录，输入 root 用户的密码以永久切换到 root shell 提示符。第三，你可以给一个普通用户 sudo 权限，以便他们可以使用自己的密码执行单个命令，就像他们是 root 用户一样，同时保持自己的登录状态。

### 注意

**sudo**（**超级用户执行**）不应与**su**（**替代用户**）命令混淆，后者允许你永久切换到另一个用户，而不是像 root 用户那样只执行单个命令。

`sudo`命令为拥有大量用户的服务器提供了极大的灵活性，其中一名管理员不足以管理整个系统。

# 自定义系统横幅和消息

在本食谱中，我们将学习如何在用户通过 SSH 或控制台成功登录到我们的 CentOS 7 系统，或在图形窗口管理器中打开新的终端窗口时显示欢迎消息。这通常用于向用户显示信息性消息，或出于法律原因。

## 准备就绪

要完成此食谱，你需要具有 root 权限的 CentOS 7 操作系统的最小安装和所选的基于控制台的文本编辑器。

## 如何操作...

1.  首先，使用你的 root 用户账户登录到你的系统，并使用你喜欢的文本编辑器创建以下新文件：

    ```
    vi /etc/motd

    ```

1.  接下来，我们将在此新文件中放入以下内容：

    ```
    ###############################################
    # This computer system is for authorized users only.
    # All activity is logged and regularly checked.
    # Individuals using this system without authority or
    # in excess of their authority are subject to
    # having all their services revoked...
    ###############################################

    ```

1.  保存并关闭此文件。

1.  恭喜，现在你已经为通过 ssh 或控制台成功登录系统的用户设置了横幅消息。

## 它是如何工作的...

出于法律原因，强烈建议计算机在允许用户登录之前显示横幅；律师建议，只有在犯罪者知道他打算获得未经授权的访问时，才能犯下未经授权访问的罪行。登录横幅是实现这一点的最佳方式。除了这个原因，你还可以向用户提供有用的系统信息。

那么，我们从这次经历中学到了什么？

我们从这个食谱开始，打开文件`/etc/motd`，代表每日消息；用户在控制台或 ssh 登录后将显示此内容。接下来，我们在该文件中放入标准的法律免责声明并保存文件。

## 还有更多...

正如我们所见，`/etc/motd`文件在用户成功登录系统后显示静态文本。如果你想在首次建立 ssh 连接时也显示一条消息，可以使用 ssh 横幅。默认情况下，ssh 守护进程配置文件中的横幅行为是禁用的，这意味着如果用户建立 ssh 连接，将不会显示任何消息。要启用此功能，请以 root 身份登录到服务器，使用你喜欢的文本编辑器打开`/etc/ssh/sshd_config`文件，并在文件末尾添加以下内容：

```
Banner /etc/ssh-banner

```

然后，创建并打开一个名为`/etc/ssh-banner`的新文件，并输入一个新的自定义 ssh 问候消息。

最后，使用以下命令重新启动你的 ssh 守护进程：

```
systemctl restart sshd.service

```

下次有人建立到你的服务器的 ssh 连接时，将打印出这条新消息。

`motd`文件只能打印静态消息和一些系统信息细节，但如果用户成功登录，则无法在其中生成真正的动态消息或使用 bash 命令。

此外，`motd`在非登录 shell 中不起作用，例如当你在图形窗口管理器中打开一个新的终端时。为了实现这一点，我们可以在`/etc/profile.d`目录中创建一个自定义脚本。如果用户登录到系统，该目录中的所有脚本都会自动执行。首先，我们删除`/etc/motd`文件中的任何内容，因为我们不想显示两个欢迎横幅。然后，我们打开新文件`/etc/profile.d/motd.sh`，使用文本编辑器创建一个自定义消息，例如以下内容，我们可以在其中使用 bash 命令并编写小脚本（使用反引号在该文件中运行 bash shell 命令）：

```
#!/bin/bash
echo -e "
##################################
#
# Welcome to `hostname`, you are logged in as `whoami`
# This system is running `cat /etc/redhat-release`
# kernel is `uname -r`
# Uptime is 
`uptime | sed 's/.*up ([^,]*), .*/1/'`
# Mem total `cat /proc/meminfo | grep MemTotal | awk {'print $2'}` kB
###################################"

```

# 初始化内核

Linux 内核是一个构成操作系统核心的程序。它可以直接访问底层硬件，并使用户能够通过 shell 与之交互。

在本食谱中，我们将学习如何通过使用动态加载的内核模块来初始化内核。内核模块是设备驱动程序文件（或文件系统驱动程序文件），它们为特定的硬件部件添加支持，以便我们可以访问它们。

作为系统管理员，你不会经常与内核模块打交道，但如果你遇到设备驱动问题或不支持的硬件，对它们有一个基本的了解可能是有益的。

## 准备就绪

要完成本食谱，你需要具备具有 root 权限的 CentOS 7 操作系统的最小安装。

## 如何做到这一点...

1.  首先，使用 root 用户账户登录到你的系统，并输入以下命令以显示当前加载的所有 Linux 内核模块的状态：

    ```
    lsmod

    ```

1.  在输出中，你将看到所有加载的设备驱动程序（模块）；让我们看看`cdrom`和`floppy`模块是否已被加载：

    ```
    lsmod | grep "cdrom\|floppy"

    ```

1.  在大多数服务器上，将会有以下输出：

    ```
    cdrom                  42556  1 sr_mod
    floppy                 69417  0

    ```

1.  现在，我们想要展示关于`sr_mod` cdrom 模块的详细信息：

    ```
    modinfo sr_mod

    ```

1.  接下来，从内核中卸载这两个模块（只有当模块和硬件已经在你的系统上被找到并加载时，你才能这样做；否则跳过此步骤）：

    ```
    modprobe -r -v sr_mod floppy

    ```

1.  检查模块是否已被卸载（输出现在应该是空的）：

    ```
    lsmod | grep "cdrom\|floppy"

    ```

1.  现在，要显示系统上所有可用的内核模块列表，请使用以下目录，你可以在其中浏览：

    ```
    ls /lib/modules/$(uname -r)/kernel

    ```

1.  让我们从子目录`/lib/modules/$(uname -r)/kernel/drivers/`中选择一个名为`bluetooth`的模块，并验证它尚未加载（输出应该是空的）：

    ```
    lsmod | grep btusb

    ```

1.  获取有关模块的更多信息：

    ```
    modinfo btusb

    ```

1.  最后，加载这个蓝牙 USB 模块：

    ```
    modprobe btusb

    ```

1.  再次验证它现在是否已加载：

    ```
    lsmod | grep "btusb"

    ```

## 它是如何工作的...

内核模块是系统硬件与内核和操作系统通信所需的驱动程序（此外，加载和启用文件系统也需要它们）。它们是动态加载的，这意味着只有驱动程序或模块在运行时加载，这反映了你自己的特定硬件。

那么，我们从这次经历中学到了什么？

我们开始使用`lsmod`命令查看系统中当前加载的所有内核模块。输出显示三列：模块名称、模块加载时占用的 RAM 量，以及使用该模块的进程数和使用它的其他模块的依赖项列表。接下来，我们检查内核是否已经加载了`cdrom`和`floppy`模块。在输出中，我们看到`cdrom`模块依赖于`sr_mod`模块。因此，接下来我们使用`modinfo`命令获取有关它的详细信息。在这里，我们了解到`sr_mod`是 SCSI `cdrom`驱动程序。

由于我们只在首次安装基础系统时需要软盘和 cdrom 驱动程序，我们现在可以禁用这些内核模块，为我们节省一些内存。我们使用`modprobe -r`命令卸载模块及其依赖项，并再次使用`lsmod`检查这是否成功。

接下来，我们浏览了标准内核模块目录（例如，`/lib/modules/$(uname -r)/kernel/drivers`）。`uname`子字符串命令打印出当前内核版本，以确保在系统上安装了多个内核版本后，我们总是列出当前内核模块。

这个内核模块目录使用子目录将系统上所有可用的模块结构化和分类。我们导航到`drivers/bluetooth`并选择了`btusb`模块。对`btusb`模块执行`modinfo`，我们发现它是通用蓝牙 USB 驱动程序。最后，我们决定我们需要这个模块，所以我们再次使用`modprobe`命令加载它。

## 还有更多...

重要的是要说明，使用`modprobe`命令加载和卸载内核模块不是持久的；这意味着如果你重新启动系统，所有对内核模块的更改都将消失。要在启动时加载内核模块，创建一个新的可执行脚本文件，`/etc/sysconfig/modules/<filename>.modules`，其中`<filename>`是你选择的名称。在那里，你放入`modprobe`执行命令，就像在正常命令行上一样。以下是启动时额外加载蓝牙驱动程序的示例，例如`/etc/sysconfig/modules/btusb.modules`：

```
#!/bin/sh
if [ ! -c /dev/input/uinput ] ; then
exec /sbin/modprobe btusb >/dev/null 2>&1
fi

```

最后，你需要通过以下行使你的新模块文件可执行：

```
chmod +x /etc/sysconfig/modules/btusb.modules

```

重启后，使用`lsmod`命令重新检查新模块的设置。

例如，要在启动时移除内核模块`sr_mod`，我们需要使用`rdblacklist`内核启动选项将模块名称列入黑名单。我们可以通过将此选项附加到 GRUB2 配置文件`/etc/default/grub`中的`GRUB_CMDLINE_LINUX`指令末尾来设置此选项，使其看起来像：

```
GRUB_CMDLINE_LINUX="rd.lvm.lv=centos/root rd.lvm.lv=centos/swap crashkernel=auto rhgb quiet rdblacklist=sr_mod"

```

如果你需要将多个模块列入黑名单，`rdblacklist`选项可以像`rdblacklist=sr_mod rdblacklist=nouveau`这样指定多次。

接下来，使用`grub2-mkconfig`命令重新创建 GRUB2 配置（要了解更多信息，请阅读第一章中的*入门和自定义引导加载程序*配方，*安装 CentOS*）。

```
grub2-mkconfig -o /boot/grub2/grub.cfg

```

最后，我们还需要使用位于`/etc/modprobe.d/`目录下您选择的`new.conf`文件中的黑名单指令来`blacklist`模块名称。

```
echo "blacklist sr_mod" >> /etc/modprobe.d/blacklist.conf

```
