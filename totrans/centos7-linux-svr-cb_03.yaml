- en: Chapter 3. Managing the System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing and managing background services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting background services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking system resources with journald
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring journald to make it persistent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing users and their groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling tasks with cron
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing files and doing more with rsync
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintaining backups and taking snapshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring important server infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking control with Git and Subversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a collection of recipes that provides for the need to maintain
    a performance-based server solution. From monitoring your free disk space, to
    working with system services and managing the synchronization of remote files,
    the purpose of this chapter is to show you how quickly and easily you can get
    to grips with the task of server maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing and managing your background services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux system services are one of the most fundamental concepts of every Linux
    server. They are programs which run continuously in your system, waiting for external
    events to process something or do it all the time. Normally, when working with
    your server, a system user will not notice the existence of such a running service
    because it is running as a background process and is therefore not visible. There
    are many services running all the time on any Linux server. These can be a web
    server, database, FTP, SSH or printing, DHCP, or LDAP server to name a few. In
    this recipe, we will show you how to manage and work with them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet to facilitate the download of additional packages.
    Some commands shown here use *less* navigation in their output. Read the *Navigating
    text files with less* recipe from [Chapter 2](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 2. Configuring the System"), *Configuring the System* to learn how to
    browse them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`systemctl` is a program that we will use to manage all our background service
    tasks in a CentOS 7 system. Here, we will show you how to use it, taking the Apache
    web server service as an example in order to get familiar with it. For a full
    explanation of Apache, read [Chapter 12](part0098_split_000.html#2TEN41-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 12. Providing Web Services"), *Providing Web Services*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we log in as root and install the Apache web server package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next we will check Apache''s service status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the webserver service in the background and print out it''s status again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s print out a list of all services currently running in the background
    of your system; in this list, you should identify the `httpd` service you just
    started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s make a backup of the Apache configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will make some changes to the main Apache configuration file using
    sed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, type the following command to stop and start the service and apply our
    changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s enable the `httpd` service to start automatically at boot time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last command will show how to restart a service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen, the `systemctl` utility can be used to take full control of
    your system's services. The `systemctl` is the control program for `systemd`,
    which is the system and service manager in CentOS 7 Linux. The `systemctl` command
    can be used for a variety of other tasks as well, but here we concentrate on managing
    services.
  prefs: []
  type: TYPE_NORMAL
- en: So, what have we learned from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'We started this recipe by logging in as root and installed the Apache web server
    package as we want to use it for showing how to manage services in general using
    the `systemctl` program. Apache or the `httpd.service`, as it is called by `systemd`,
    is just an example we will use; other important services that might be running
    in a basic server environment could be `sshd.service`, `mariadb.service`, `crond.service`,
    and so on. Afterwards, we checked httpd''s current status with the `systemctl
    status` command parameter. The output showed us two fields: **Loaded** and **Active**.
    The **Loaded** field tells us if it is currently loaded and if it will automatically
    be started at boot time; the **Active** field denotes whether the service is currently
    running or not. Next, we showed how to start a service using `systemctl`. The
    command''s exact starting syntax for services is the `systemctl start <name of
    the service>.service`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By starting a service, the program gets detached from the terminal by forking
    off a new process that gets moved into the background where it runs as a non-interactive
    background process. This is sometimes called **daemon**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after we started the Apache webserver daemon, we then used systemctl''s
    `status` parameter again to show how the status changes if we run it. The output
    shows us that it is currently loaded but disabled on reboot. We also see that
    it is running, along with the latest logging output from this service and other
    detailed information about the process. To get an overview of all status information
    for all services on the system, use `systemctl --type service --all`. A `systemctl`
    service must not be running all the time. Its state can also be stopped, degraded,
    maintained, and so on. Next, we used the following command to get a list of all
    currently running services on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, we used the `-t` flag in order to filter only for type
    service units. As you may guess, `systemctl` can not only deal with service units,
    but also with a lot of other unit types. `systemd` units are resources `systemd`
    can manage using configuration files, and which encapsulate information about
    services, listening sockets, saved system state snapshots, mounting devices, and
    other objects that are relevant to the system. To get a list of all possible unit
    types, type `systemctl -t help`. These configuration unit files reside in special
    folders in the system, and the type they belong to can be read from the extension;
    all the service unit files have the file extension, `.service` (for example, device
    unit files have the extension, `.device`). There are two places where the system
    stores them. All the `systemd` unit files installed by the basic system during
    installation are in `/usr/lib/systemd/system`, all other services that come from
    installing packages such as Apache or for your own configurations should go to
    `/etc/systemd/system`. We can find our Apache service configuration file exactly
    at `/usr/lib/systemd/system/httpd.service`. Next, we showed the user how to stop
    a service, which is the opposite of starting it, using the syntax, `systemctl
    stop <name of the service>`. Finally, as a last step, we used systemctl's `restart`
    parameter, which just handles the stopping and starting of a service in one step
    with less typing. This is often useful if a service hangs and is unresponsive,
    and you quickly need to reset it to get it working. Before showing how to stop
    and restart a service, we did another important thing. While the Apache service
    was running, we changed its main service configuration file with the `sed` command,
    adding an `-Indexes` option that disables the directory web site file listings,
    and which is a common measure to increase the security of your web server. Since
    the Apache web server was already running and loading its configuration into memory
    during service startup, any changes to this file will never be recognized by the
    running service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Normally, to apply any configuration file change, running services need a full
    service restart, because configuration files will normally only be loaded during
    startup initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine that your web server is reachable from the Internet and at the
    moment there are a lot of people accessing your web pages or applications in parallel.
    If you restart the Apache normally, the web server will be inaccessible for a
    while (as long as it takes to restart the server) as the process will actually
    end and afterwards start all over again. All the current users would get HTML
    404 error pages if they were to request something at that moment. Also, all the
    current session information would have gone; imagine you have an online web shop
    where people use shopping carts or logging in. All this information would also
    be gone. To avoid the disruption of important services such as the Apache web
    server, some of these services have a `reload` option (but not every service has
    this feature!) that we can apply instead of the `restart` parameter. This option
    just reloads and applies the service''s configuration file, while the service
    itself stays online and does not get interrupted during execution. For Apache,
    you can use the following command-line: `systemctl reload httpd.service`. To get
    a list of all the services that have the reload functionality, use the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So, having completed this recipe, we can say that we now know how to work with
    the basic `systemctl` parameters to manage services. It can be a very powerful
    program and can be used for much more than only starting and stopping services.
    Also, in this recipe, we have used different names that all mean the same: system
    service, background process, or daemon.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another important unit type called `target`. Targets are also unit
    files and there are quite a number of them already available in your system. To
    show them, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply said, targets are collections of unit files such as services or other
    targets. They can be used to create runlevel-like environments, which you may
    know from earlier CentOS versions. Runlevels define which services should be loaded
    at which system state. For example, there is a graphical state, or a rescue mode
    state, and so on. To see how the common runlevels correspond to our targets, run
    the following command, which shows us all the symbolic links between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Targets can be dependent on other targets; to get a nice overview of target
    dependencies, we can run the following command to show all dependencies from the
    multi-user target to all the other targets (green means active and red means inactive):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can show the current target that we are in at the moment with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also switch to another target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Troubleshooting background services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, a big part of every system administrator's work is troubleshooting the
    server when something goes wrong. This is especially true for your system's services,
    as they are constantly running and processing information all the time. Services
    can be dependent on other services and on the server's system, and there will
    be situations in your administrator's life where the system services will fail
    or refuse to start. Here, in this recipe, we will show you how to troubleshoot
    them if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice; you should also have completed the *Knowing and managing your background
    services* recipe from this chapter, where we installed the Apache web server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to show you how to troubleshoot services, we will introduce a random
    error in the Apache service''s configuration file and then show you how to troubleshoot
    and fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in as root and type the following command to append content to the `httpd.conf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, reload the `httpd` service and show its output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s revert this error line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, restart the service again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this fairly short recipe, we showed you how an example service will behave
    if it contains errors, and what you can do to fix it to get you started. There
    are a lot of different scenarios where something can go wrong when services malfunction,
    and it can be a big part of a system administrator's job to solve those kinds
    of problem.
  prefs: []
  type: TYPE_NORMAL
- en: So, what have we learned from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'We started this recipe by introducing a line of text in the main Apache configuration
    file, which does not contain any valid configuration syntax, and therefore the
    `httpd` service cannot interpret it. Then, we used the `systemctl reload` parameter
    to reload our server''s configuration file. As said before, not all services have
    the reload option, so if your service of interest does not support this, use the
    `restart` parameter instead. Since Apache will try to reload the configuration
    file with our current changes, it will refuse to accept the new configuration
    because of the wrong syntax that we introduced. Since we are just reloading the
    configuration, the running Apache process will not be affected by this problem
    and will stay online using its original configuration. The `systemctl` parameter
    will print out the following error message, giving us a hint of what to do next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As suggested by the error output, the `systemctl` status parameter is a very
    powerful tool to see what's going on behind the scenes with this service, and
    to try and find out the reason for any failure (here you can also see that Apache
    is still running). If you start the `systemctl` `status` with the `-l` flag, it
    prints out an even longer version of the output, which can help you even more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this command shows us the exact reason for failing the configuration
    reload, so we can easily trace down the cause of the problem (the output has been
    truncated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This output is part of the complete `journald` log information. If you want
    to read more about it, please refer to the *Tracking system resources with journald*
    recipe in this chapter. So, with this very useful information from the output,
    we can easily spot the problem and redo the introduction of `ERRORLINE` using
    the `sed` command and reload the service again; this time everything will work
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: So, in summary, we can say that the `systemctl status` command is a very comfortable
    command that can be tremendously helpful in finding out problems with your service.
    Most services are very sensitive to syntax errors, and sometimes it can be just
    a misplaced space character that caused the service to refuse to work. Therefore,
    system administrators must work precisely all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking system resources with journald
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log files contain system messages and output from services, the kernel, and
    all kinds of running applications. They can be very useful in many situations,
    for instance, to troubleshoot system problems and monitor services or other system
    resources, or doing security forensics after a breach of security. In this recipe,
    you will learn the basics of how to work with logging services using journald.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice. Also, setting the time and date correctly is very crucial for the whole
    logging concept, so please apply the *Synchronizing the system clock with NTP
    and the chrony suite* recipe from [Chapter 2](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 2. Configuring the System"), *Configuring the System* before using this
    recipe. Also, a basic knowledge of systemd and units can be advantageous. This
    is covered in the *Knowing and managing background services* recipe in this chapter.
    Journalctl uses *less* navigation to show output; please read the *Navigating
    text files with less* recipe from [Chapter 2](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 2. Configuring the System"), *Configuring the System* if you don't know
    how to work with it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On CentOS 7, we have a choice between two logging mechanisms called `rsyslog`
    and the `journald` log system, which is a component of the new `systemd` system
    manager, for viewing and managing logging information. Here, we will show you
    how to work with the `journalctl` command, which is the controlling client for
    the `journald` daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in as root and type the following command to view the whole journal
    log:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want to show only the messages within a specific time frame (change
    the date accordingly):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterwards, we want to filter the log system by all messages from the sshd
    service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we want to show only messages with type error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the most verbose version of `journalctl`, use the `verbose` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get a *current* view on the log output, use the following command (this
    is not *less* navigation—use the key combination *Ctrl*+*C* to exit this view):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In CentOS 7, we can use the new `journald` logging system, which is a part of
    the `systemd` system management. It is a centralized tool that will log just about
    everything on your system including all output from the early boot over kernel
    to services and all program messages. The main advantage over other logging mechanisms
    is that you don't have to configure logging for each of your services or other
    resources, because everything is already set up for all applications that are
    controlled and running through the centralized `systemd` system.
  prefs: []
  type: TYPE_NORMAL
- en: So, what have we learned from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We began our journey by running the `journalctl` command, which when applied
    without any parameters show us the complete journal log, which includes everything
    from starting your system and capturing the first boot log entries to the latest
    system messages in the order they appeared, appending new messages to the bottom
    (chronological order). If your system has been running for a while, it can contain
    hundreds of thousands of lines of logging data, and is very impractical to work
    with in this raw form.
  prefs: []
  type: TYPE_NORMAL
- en: 'This output is constantly captured by the `journald` daemon, but is not written
    to text files as other logging systems such as `rsyslog` do it. Instead, it uses
    a structured and indexed binary file, which stores a lot of additional meta information
    such as user Id, timestamp, and so on, and which makes it easy to transform into
    all kinds of different output formats. This can be very convenient if you want
    to further process journal information by another tool. As you cannot read binary
    files, you will need the client `journalctl` for it, which is used to query the
    `journald` database. Since it is almost impossible to parse through this sheer
    amount of data manually, we then take advantage of journalctl''s rich filtering
    options. First, we used the `--since` and `--until` parameters to extract all
    log messages within a specific time frame. The syntax for specifying the time
    and date here is very flexible and understands phrases such as `yesterday` or
    `now`, but we stick with the simple date syntax, `YYYY-MM-DD HH:MM:SS`. Next,
    we used journalctl''s `-u` parameter to filter log messages for a specific unit
    type. We used it to filter messages coming from the sshd daemon service. We added
    another filter using the `--since` parameter, which tightens the result of the
    `-u` unit filter even more, outputting only sshd service results that occurred
    yesterday. The next filter we applied was using the parameter string, `-p err
    -b`, which filters the log database by priority or log level. Every log message
    can have an associated priority that determines the importance of the message.
    To find out more about different log levels, refer to the manual using the command
    line `man 3 syslog` (if this manual is not available, install it by typing `yum
    install man-pages`). Our command will print out all log messages labeled as `error`
    or above, which includes: `error`, `critical`, `alert`, or `emergency`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we used the same command parameters but added `-o verbose`, which gives
    the most verbose output of logging information. Lastly we presented the `-f` parameter
    (for follow), which will give us a *live* view of the latest log messages and
    leaves this connection open, appending any new messages to the end of the output
    when they occur. This is often useful to see how the system reacts if you are
    currently testing out settings or starting/stopping services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summing up, one can say that, on CentOS 7, two logging systems do coexist:
    the older `rsyslog` and the newer `journald`, with the latter being your primary
    tool of choice for troubleshooting your system. But remember that on CentOS 7,
    `journald` is not a full replacement for `rsyslog` though. There are some `rsyslog`
    features that are missing in `journald`, and also there are lots of tools and
    scripts, such as log digesting tools or monitoring suites such as Nagios, that
    work exclusively with `rsyslog`.'
  prefs: []
  type: TYPE_NORMAL
- en: System administrators often face a big challenge troubleshooting system errors
    or unexpected server behaviors. Often, it's not easy to find the single point
    of failure by searching through massive amounts of different log file texts while
    applying regular expression searches or Linux command line kung fu. Journald provides
    a very convenient alternative by providing a powerful and well-defined centralized
    querying system to get the log file analysis done quickly and efficiently!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring journald to make it persistent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Journald's advantages over other logging systems such as `rsyslog` is that it
    is very efficient and logs just about everything on your system automatically
    without the need to configure anything, because it is a part of the `systemd`
    suite. The main disadvantage is that all `journald` log information will get lost
    after a system's restart. Journald logging can produce huge amounts of data and
    by default all logging information is only kept in memory, which is not very practicable
    if you need to access older log information or analyze causes of system crash
    reboots. Here, in this recipe, we show you how to configure `journald` to make
    it persistent.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin this recipe, we need to create a location that will hold our persistent
    journal database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in as the root user and create the following directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the new directory to `journald` to use it as a storage location and
    fix permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, restart `journald`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, to check whether the log survived the reboot, restart the computer
    and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We started this recipe by creating the new directory, `/var/log/journal`. By
    default, `journald` writes its log database to `/run/log/journal`, which is a
    directory only for runtime information, and its content does not survive system
    reboots. Afterwards, we used the `systemd-tmpfiles` command to set up our new
    directory for `journald`. Finally, we restarted the `journald` server daemon to
    apply our changes to the system. To test if persistence is working, restart your
    server and afterwards use `journalctl –boot=-1`. This will show us all journal
    information from the last boot. If persistence is not working, it will print out
    the following error; otherwise it will correctly show all journal messages before
    the last boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this fairly simple recipe, we have shown how to make `journald` persistent
    over system reboots. This is really useful if you need to review older log files
    from the past, which can sometimes help you find out problems, for example, the
    roots of past hardware failures.
  prefs: []
  type: TYPE_NORMAL
- en: Managing users and their groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to manage your system's users and groups on
    CentOS 7\. Essential user and group managing skills are one of the most important
    CentOS system administrator fundamentals.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will need a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe shows you how to manage users and groups by learning how to add,
    delete, and modify them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin this recipe, we log in as root and type the following command to get
    a list of all the users known to the system: `cat /etc/passwd`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, show the root user ID (**UID**) and group ID (**GID**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will run the following command to add a new user to the system (exchange
    `your_new_username` with a username of your choice):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, in order to complete this process, you will be expected to provide
    a suitable password. To do this, type the following command (change `your_new_username`
    with a username of choice) than enter a secure password when prompted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Passwords should not be less than six characters, but should not be longer than
    sixteen characters. They should consist of alphanumeric values, and for obvious
    reasons you must avoid the use of whitespaces. Do not use a dictionary-based word
    and refrain from using a known or obvious phrase.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, create a new group and give it a special name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we add our new user to this new group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s print the user ID and group IDs of our new user to see what
    has changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of this recipe was to create a new user and group and show how to
    connect them together.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: First, we printed out the content of file `/etc/passwd` to show all the current
    users in the system. This list not only contains normal user-accounts that belong
    to real persons, but also accounts that are used to control and own a specific
    application or service. Then, we used the `id` command to display the unique user
    UID and GID for our existing user root. In Linux, every user can be identified
    by their UID and GID, and every file in the filesystem has specific permission
    settings that manage its access for the file owner, group owner, and the rest
    of the users. For each of those three groups, you can enable or disable read,
    write, and execute permissions using the command, `chmod` (use `man chmod` to
    learn more, and also check out `man chown`). The owner and group permissions correspond
    to a UID and GID that we can display for every file using `ls -l`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we issued the `useradd` command that required us to supply a suitable
    name for the new user, which in turn will enable the server to establish the new
    identity with a default set of values and criteria that includes a user ID, home
    directory, primary group (GID), and also set the default shell to bash. Completing
    this process is simply a matter of confirming a suitable password. To remove a
    user, there is the opposite command, `userdel`, which works similarly but can
    be given the option `-f` to remove the home directory instead of leave it on the
    system. Next, we used the `groupadd` command, which, as the name implies, will
    create a new group and associate a new unique GID to it. Afterwards, we made our
    user in question a member of the new group that we created before using the `usermod
    -G` command. As said before, each user has exactly one unique UID and GID. The
    first group is the primary group and is mandatory; however a user can belong to
    a number of different groups, which are then called secondary groups. The primary
    group is needed when creating a new file because it will set the GID and UID of
    the user creating it. To delete a group, we can use the `groupdel` command. Finally,
    we used the `id` command again on our new user to show its UID, primary GID, and
    the new secondary GID groups we added to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are now able to fully control your user and groups with just a few commands:
    `useradd`, `usermod`, `userdel`, `groupadd`, `groupmod`, and `groupdel`.'
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling tasks with cron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will investigate the role of server automation and the convenience
    of running specific tasks at predefined periods by introducing you to the time-based
    job scheduler known as cron. Cron allows for the automation of tasks by enabling
    the administrator to determine a predefined schedule based on any hour, any day,
    or any month. It is a standard component of the CentOS operating system, and it
    is the purpose of this recipe to introduce you to the concept of managing recurring
    tasks in order to take advantage of this invaluable tool and to make CentOS work
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with root privileges, and a console-based text editor of your
    choice. The `crontab` program uses Vim for file editing. If you do not know how
    to work with Vim, go through the tutorial shown in the recipe *Introduction to
    Vim* in [Chapter 2](part0024_split_000.html#MSDG1-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 2. Configuring the System"), *Configuring the System*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of this recipe is to create a script that will write the time and
    date with a few words of your choice to a text file every five minutes. This may
    seem to be a relatively simple exercise, but the intention is to show you that,
    from such simplicity, cron can be used to do so much more that will make working
    with CentOS an absolute pleasure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin this recipe, log in as root and create your first cron job by typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now create a simple cron job that will write the date and time with
    the words `hello world` to a file located at `/root/cron-helloworld.txt` every
    five minutes. To do this, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When complete, simply save the file and exit the editor. The system will now
    respond with the following message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding message informs you that the server is now creating the new `cron`
    job and will automatically activate it. You can view the output of the script
    by reviewing the file found at `/root/cron-helloworld.txt` (you have to wait 5
    minutes), or by monitoring the logfile found at `/var/log/cron` (use `tail -f
    /var/log/cron` and `Ctrl+C` to exit).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cron is the name of a program that enables CentOS users to execute commands
    or scripts automatically at a specified time and date. Cron's settings are kept
    in a user-specific file called `crontab`, and as we have seen in this recipe this
    file can be edited to create automated tasks as often as they are required.
  prefs: []
  type: TYPE_NORMAL
- en: So what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'The example used was very simple, but in many ways this was the purpose of
    this recipe. Crontab uses a daemon, `crond`, which runs constantly in the background
    and checks once a minute to see if any of the scheduled jobs need to be executed.
    If a task is found, then cron will execute it. To edit an existing `crontab` file
    or to create a new `crontab`, we use the `crontab -e` command. To view a list
    of current cron jobs, you can type `crontab -l`. Alternatively, to view a list
    of the current jobs for another user, you can type `crontab -u username -l`. Tasks
    or jobs are generally referred to as cron jobs, and by avoiding complication in
    our first script, it was the intention to show you that the nature of command
    construction was very simple. The formation of a cron job looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Entries are separated by a single or tabbed space, and the allowed values are
    primarily numeric (that is, `0-59` for a minute, `0-23` for an hour, `1-31` for
    a day of the month, `1-12` for month of the year, and `0-7` for day of the week).
    However, in saying this, it is also true to say that there are more specific operators
    ( `/` , `-`) and cron-specific shortcuts (that is, `@yearly`, `@daily`, `@hourly`,
    and `@weekly`) that do allow for additional controls. For example, where the `/`
    operator is used to step through specified units, it can be read as *every*, so
    in our recipe the use of `*/5` will run the task every five minutes while the
    use of `*/1` runs the task every minute. As an addition to this, you should be
    aware that the use of this syntax will align all commands on the hour. So, with
    this in mind, the most suitable template or starting point for anyone wanting
    to write their first `cron` job is to start with a series of five asterisks followed
    by the command, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, proceed to configure the minute, hour, day, month, and day-of-the-week
    values as desired. For example, if you want a particular PHP script to run at
    8 P.M. (20:00 hrs) on every weekday (Monday-Friday), it may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: So, with this in mind, and by completing this recipe, you can see how cron can
    be used to manage a database backup, run a scheduled system backup, provide support
    to websites by activating scripts at predefined intervals, or run various bash
    scripts and a whole lot more.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete or disable a cron job, it is simply a matter of either removing the
    instruction from an individual user''s cron file or by placing a hash (`#`) at
    the beginning of the line. Individual cron files can be found at `/var/spool/cron/<username>`,
    and the use of the hash will either disable the cron job or allow you to write
    comments. To completely remove a `crontab` file, you can also use `crontab -r`.
    For example, if you want to remove the cron job created in the main recipe, you
    can log in as root and begin by typing the command, `crontab -e`. At this point,
    you may either remove the entire line or comment it out, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Next, save the file. There are also some special cron directories in the filesystem
    for system-wide cron jobs that will, if you drop a script file in it, run it automatically
    at a certain time point. The folders are called `cron.daily`, `cron.hourly`, `cron.weekly`,
    and `cron.monthly` in the `/etc` directory, and their names refer to the time
    point that they are run. Just remove the script from the folder if you don't want
    to execute it anymore. Take a look at the *Monitoring important server infrastructure*
    recipe for an example.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing files and doing more with rsync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`rsync` is a program that can be used to synchronize files and directories
    across a variety of local and remote locations. It can interact with multiple
    operating systems, work over SSH, provide incremental backups, execute commands
    on a remote machine, and replace the need for the `cp` and `scp` commands. The
    `rsync` program is an invaluable asset for any system administrator who intends
    to run a server or manage a network of computers, as it not only simplifies the
    process of making backups in general, but it can be used to action a complete
    backup solution. For this reason, it is the purpose of this recipe to offer a
    suitable starting point for a small utility that will quickly become your trusted
    friend.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet in order to facilitate the download of additional
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During the course of this recipe, it will be assumed that you know the location
    of the source files and directories that you wish to synchronize, and that a suitable
    destination is available:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin this recipe, log in as root and install `rsync` by typing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a target directory for our synchronization (change the folder name
    appropriately):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To begin the synchronization process, simply repeat the following command by
    modifying the value used for `/path/to/source/files/` with something more applicable
    to your needs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Having used the *Return* key to confirm the preceding instruction, your system
    will now respond with a live report of what is being copied. When this process
    has finished, you can then compare both directories to see that the contents are
    exactly the same. To do this, use the `diff` command (if both are the same, no
    output will be written):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we considered the use of `rsync` through the command line. Of
    course, this is only one of the many ways that this tool can be used, but by using
    this approach we were able to explore a handful of the features provided by this
    very valuable utility.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: Rsync is not intended to be complicated. It is a fast and efficient file synchronization
    tool that is designed to be versatile by giving you complete access to an array
    of features on the command line. It can be used to maintain an exact copy (or
    mirror) of the `source` directory on the same machine or on a completely different
    system, and it does this by copying all the files once and then only updating
    the files that have changed the next time you run it. This can save tremendous
    bandwidth and should be your primary tool when copying data over the network.
    The use of the phrase, `--delete`, is important, as it instructs `rsync` to delete
    files on the target that do not exist in the source, while the chosen flags imply
    that `rsync` should use `-a` archive mode in order to recursively copy files and
    directories while keeping all permissions and time-based information; `–v`)verbosity
    mode so you can see what is happening; and `–z` to compress the data during the
    file transfer in order to save bandwidth and reduce the amount of time required
    to complete the entire process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, `rsync` is very flexible and has many options that go beyond
    the purpose of this recipe, but if you want to exclude certain files you could
    always extend the original instruction by invoking the `--exclude` flag. By doing
    this, you tell `rsync` to back up an entire directory but ensure that it does
    not include a predefined pattern of files and folders. For example, if you are
    copying files from your server to a USB device and you do not want to include
    large files (such as an `.iso` image) or ZIP files, then your command may look
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'On a final note, there is the subject of verbosity. Verbosity is very useful,
    but a tendency to use bytes as its primary unit of measurement can be a source
    of confusion. So, in order to change this, you can invoke `rsync` with the `–h`
    (or human readable) option, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Maintaining backups and taking snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show you how to do data backups, on a regular basis,
    that will take snapshots of some of your system's directory using the `crond`
    daemon. This will run the `rsync` program at regular intervals to implement a
    fully automated backup solution.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice. It is also advantageous if you have read the *Synchronizing files and
    doing more with rsync* and *Scheduling tasks with cron* recipes in this chapter
    to get a deeper understanding of used commands.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's important to install the `rsync` program on your server before proceeding
    with this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, log in as root and create a directory where our backups will land:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create the following shell script file and open it for editing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Put in the following content, replacing `/backups` in the environment variable
    `DEST` and `SOURCE` with the one you would like to backup as well as the recipient''s
    `EMAIL`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Make the script executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open `crontab` using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create the following entry by adding the following line to the end of
    the document, then save and close it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have created a full automatic backup solution for a single
    system directory, which will create a snapshot of the files at a certain time
    point. At the time the backup process is complete you will receive an e-mail informing
    you that a backup has been made with a brief review of the actions taken.
  prefs: []
  type: TYPE_NORMAL
- en: So what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We started this recipe by creating a directory where our backup will be placed.
    Next we created the actual script and filled it with some commands. Line 1 defines
    the file as a bash script, lines 2-6 are variables you can modify and customize
    to fit your own needs. lines 7-8 create a path and name for the log file based
    on the date, and line 9 calls `rsync` which will synchronize all our source files
    to the target directory /backups. It uses a special `--log-file` parameter which
    writes all output to the given file. The final line (10) sends the content of
    this log file to an email address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, you should customize the values as required (that is, change the
    e-mail address used, select a source directory, and choose a destination directory,
    and so on.). Before it can be used and executed by `cron`, we made it executable.
    Finally, we added this script as a cron job to run on a daily schedule at 20:30
    hours. However, as this may be some hours away, if you would like to test your
    script right now, you can execute it on the command line using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In conclusion, it will go without saying that a backup should be located on
    an external drive or on a separate partition, but having completed this introduction
    I think you will agree that `rsync` is ideally positioned in such a way that it
    will enable any server administrator to develop their own policy with regard to
    maintaining an effective backup of important data.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring important server infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use a small script that will monitor the available filesystem's
    disk space periodically using cron, and if it exceeds a certain percentage threshold
    the script will send out a mail with a warning message.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice. You should have read the *Scheduling tasks with cron* recipe to have a
    basic understanding of the principles behind the cron system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin this recipe, log in as root and create the following file that will
    contain our monitoring script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, put in the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, save the file and make it executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We made this script executable and put it in the `/etc/cron.daily` directory,
    which is all we need to do to run this script automatically every day via the
    `crond` service.
  prefs: []
  type: TYPE_NORMAL
- en: This simple script showed us how easy it is to build monitoring scripts, and
    this can be a real alternative to installing and configuring big monitoring suites
    such as Nagios. You can use the shown script as a starting point to expand on,
    adding further resources that are important to monitor, such as CPU load, available
    RAM, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We used a script that executes the Linux command `df`, which is a tool to report
    file system disk space usage. From this command's output, the script then parsed
    the `USE%` column (with the Unix tools `awk` and `cut`), which gives us the total
    disk percentage used. This number will then be compared to a threshold the user
    can set by editing the script and changing the environment variable, `THRESHOLD`.
    If the extracted percentage number is higher than our threshold, there will be
    an email sent to the email address defined with the environment variable, `EMAIL`
    (change appropriately if needed).
  prefs: []
  type: TYPE_NORMAL
- en: Taking control with GIT and Subversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Document revision control systems or version control systems, as they are sometimes
    called, are used for the management of changes to documents. These systems get
    more and more important these days as modern work often connects people from around
    the globe to collaborate and work together on all kinds of documents (for example,
    software source code) making it important to manage the file changes by different
    people using revisions. In this recipe, we will show you how to use modern version
    control systems such as GIT and Subversion to manage the versioning of config
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, and a connection to the Internet in order
    to facilitate the download of additional packages.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here in this recipe, we will put the complete main Linux configuration directory,
    `/etc/`, under version control of a Git repository to keep track of all our changes
    to configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in as root, install Git, and configure it by providing an email
    address and username (please substitute `your_username` and `your_email_address`
    with real names):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s create a new repository in the `/etc` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, after we have our new repository, let''s add all the files in the `/etc/`
    directory under version control:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To commit the files to the repository creating your first revision, type the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s change a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, show the changes to your repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will commit these changes and create a new revision of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, show all the commits so far:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will output the following commits on my system (the number hashes will
    be different on yours):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Based on the output from the earlier step, we will now show all the differences
    between the two revision numbers (change the number hashes on your system based
    on the output from the earlier step):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To complete this recipe, we will revert our changes to the original file revision
    (the initial commit):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, in this recipe, we showed you how to use Git to manage changes to system
    config files in the `/etc` directory. This can be important, for example, if you
    are testing things out, so a lot of changes will be made to some configuration
    files and you will want to keep track of your changes, which is nice because you
    don't need to memorize every single step you have taken if you later have to revert
    the changes or go back to a specific revision, or compare different file versions.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We started by installing Git and added a username and an e-mail address to its
    configuration, which is essential for using it later in the process. Then, we
    changed to the `/etc` directory and initialized (using the `init` parameter) a
    new empty Git project there, which is called repository and keeps track of all
    the files associated to it. This command will add a hidden `.git` directory to
    it, which will contain the complete file changes and revision information. Next,
    we added all the files (using the wildcard `*` operator) from this directory,
    including all sub-directories to the next revision. A revision is like a state
    the files are in at a given time point, and is identified by a unique hash ID
    such as `8069c4a`. Then, we actually created a new revision using the commit parameter
    and supplied a meaningful message using the `-m` parameter. After we set up the
    Git repository and added all the files to it, every change to the files gets watched
    in the `/etc` directory. Next, we changed the main YUM configuration file in our
    repository by adding a random string to the end of it using the echo `>>` command.
    If we now use git's `status` parameter again, we see in the output that the Git
    system has notified that this file has been changed. We can now create a new revision
    with the changed file by using git's `commit` parameter again, using another meaningful
    message here stating that `yum.conf` has been changed. We then used the git `log`
    command. This will show us all the committed revisions with their unique `md5`
    hash string IDs. With this ID, we can fuel the git `diff` command to see all the
    file changes between two revisions. To learn more about the output format, use
    `man git-diff-files` and read its section `COMBINED DIFF FORMAT`. In our last
    step, we used the checkout command to go to a specific file revision; here we
    reverted all our changes and went back to the original file state.
  prefs: []
  type: TYPE_NORMAL
- en: Git is a very powerful version management tool, and in this recipe we just scratched
    the surface of what can be done with it. To learn more about Git's wonderful techniques,
    such as branching, merging, pull requests, and so on, start with the Git tutorial
    pages by typing in `man gittutorial`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also use the program Subversion to bring your `/etc` directory under
    version control. Subversion is another common document revision control system
    whose main difference from Git is that it uses a centralized server to keep track
    of the file changes. Git is distributed, meaning that everybody working on a Git
    project will have the complete repository locally on their computer. Here, we
    will show you the exact steps necessary to use Subversion instead of Git for this
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install Subversion and configure a new server directory for our `/etc`
    repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, make an in-place import of the `/etc` filesystem to our new repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, switch to the `/etc` directory and add all the files to a new revision:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create your first commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, change the `yum.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Commit your changes to a new file revision:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, show the change log:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Show the file differences between our two commits (the first commit was the
    `/etc` import):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, revert to the first revision of our `yum.conf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
