- en: Chapter 2. Configuring the System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating text files with less
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Vim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speaking the right language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing the system clock with NTP and the chrony suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting your hostname and resolving the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Becoming a superuser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a static network connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing your system banners and messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Priming the kernel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a collection of recipes that covers the basic practice of establishing
    the basic needs of a server. For many, building a server can often seem to be
    a daunting task, and so the purpose of this chapter is to provide you with an
    instant method to achieve the desired goals.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating text files with less
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this book, you will often use programs and tools that use the program
    less or a less-like navigation to view and read file content or display output.
    At first, the control can seem a bit unintuitive .Here, in this recipe, we will
    show you the basics of how to navigate through a file using less controls.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, log in as root and type the following command to open a program that
    uses less for navigation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To navigate, press the *up* and *down* key to scroll up and down one line at
    a time, the *spacebar* to scroll down a page, and the *b* key to scroll up a page.
    You can search within the text using the forward slash key, */*,followed by the
    search term, then press *Return* to search. Press *n* to jump to the next search
    result. Press the *q* key to exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, in this short recipe, we have shown you the very basics of less navigation,
    which is essential for reading man pages and is used by a lot of other programs
    throughout this book to display text. We only showed you the basic commands and
    there is much more to learn. Please read the less manual to find out more on `man
    less` command.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Vim
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will give you a very brief introduction to the text editor,
    Vim, which is used as the standard text editor throughout this book. You can also
    use any other text editor you prefer, such as nano or emacs, instead.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start this recipe by installing the `vim-enhanced` package, as it contains
    a tutorial you can use to learn working with Vim:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in as root and install the following package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterwards, type the following command to start the Vim tutorial:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will open the Vim tutorial in the Vim editor. To navigate, press the *up*
    and *down* key to scroll up and down single-line wise. To exit the tutorial, press
    the *Esc* key, then type `:q!`, followed by the *Return* key to exit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should now read through the file and go through the lessons to get a basic
    understanding of Vim, to learn how to edit your text documents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tutorial shown in this recipe should be seen as a starting point from which
    to learn the basics for working with one of the most powerful and effective text
    editors available for Linux. Vim has a very steep learning curve, but after dedicating
    about half an hour to the vimtutor guide you should be able to do all the common
    text editing tasks without any problem, such as opening, editing, and saving text
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking the right language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will show you how to change the language settings of your
    CentOS 7 installation for the whole system and for single users. The need to change
    this is rare but can be important, for example if we accidentally chose the wrong
    language during installation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, and a console-based text editor of your
    choice. You should have read the *Navigating text files with less* recipe, because
    some commands in this recipe will use less for printing output.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two categories of settings that you have to adjust if you want to
    change the system-wide language settings of your CentOS 7 system. We begin by
    changing the system locale information and then the keyboard settings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in as root and type the following command to show the current
    locale settings for the console, graphical window managers (X11 layout), and also
    the current keyboard layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, to change these settings, we first need to know all the available locale
    and keyboard settings on this system (both commands use `less` navigation):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have picked the right locale from the output above in our example, `de_DE.utf8`
    and `keymap de-mac` (change to your own appropriate needs), you can change your
    locale and keyboard settings using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, verify the persistence of your changes using the same command again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen, the `localectl` command is a very convenient tool that can
    take care of managing all important language settings in a CentOS 7 system.
  prefs: []
  type: TYPE_NORMAL
- en: So what have we learned from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We started by logging in to our command line with the root user. Then, we ran
    the `localectl` command with the parameter `status`, which gave us an overview
    of the current language settings in the system. The output of this command showed
    us that language properties in a CentOS 7 system can be separated into locale
    (system locale) and keymap (VC keymap and all X11 layout properties) settings.
  prefs: []
  type: TYPE_NORMAL
- en: Locales on Linux are used to set the system's language as well as other language-specific
    properties. This can include texts from error messages, log output, user interfaces,
    and, if you are using a window manager such as Gnome, even **Graphical User Interfaces**
    (**GUI**). Locale settings can also define region-specific formatting such as
    paper sizes, numbers and their natural sorting, currency information, and so on.
    They also define character encoding, which can be important if you chose a language
    that has characters that cannot be found in the standard ASCII encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Keymap settings on the other hand define the exact layout of each key on your
    keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to change these settings, we first issued the `localectl` command with
    the `list-locales` parameter to retrieve a full list of all locales on the system,
    and `list-keymaps` to show a list of all keyboard settings available in the system.
    Locales as outputted from the `list-locales` parameter use a very compact annotation
    for defining a language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the `Language` part is mandatory, all the rest is optional. Examples for
    language and region are: `en_US` for English and region United States or American
    English, `es_CU` would be language Spanish and Region Cuba or Cuban Spanish.'
  prefs: []
  type: TYPE_NORMAL
- en: Encodings are important for special characters such as German umlaut or accents
    in the French language. The memory representation of these special characters
    can be interpreted differently depending on the used encoding type. In general
    UTF-8 should be used as it is capable of encoding almost any character in every
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Modificators are used to change settings defined by the locale. For example,
    `sr_RS.utf8@latin` is used if you want to have Latin settings for serbian Serbia,
    which normally uses Cyrillic definitions. This will change to western settings
    such as sorting, currency information, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the actual locale, we used the `set-locale LANG=de_DE.utf8` parameter.
    Here, the encoding was selected to display proper German umlauts. Please note
    that we used the `LANG` option to set the same locale value (for example, `de_DE.utf8`)
    for all available locale options. If you don''t want to have the same locale value
    for all available options, you can use a more fine-grained control over single
    locale options. Please refer to the locale description using the man page, `man
    7 locale` (on minimal installation; you need to install all Linux documentation
    man pages before using the `yum install man-pages` command). You can set these
    additional options using a similar syntax, for example, to set the time locale
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next, we showed all available keymap codes using the `list-keymaps` parameter.
    As we have seen from running `localectl status`, the keymaps can be separated
    in non-graphical (VC keymap) and graphical (X11 layout) settings, which allows
    the flexible configuration of different keyboard layouts when using a window manager
    such as Gnome and for the console. Running `localectl` with the parameter, `set-keymap
    de-mac`, sets the current keymap to a German Apple Macintosh keyboard model. This
    command applies the given keyboard type to both the normal VC and the X11 keyboard
    mappings. If you want different mappings for X11 than for the console, use `localectl
    --no-convert set-x11-keymap cz-querty`, where we use `cz-querty` for the keymap
    code to a Czech querty keyboard model (change this accordingly).
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, single system users need different language settings than the system's
    locale (which can only be set by the root user), according to their regional keyboard
    differences and for interacting with the system in their preferred human language.
    System-wide locales get inherited by every user as long as they are not overwritten
    by local environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Changing system-wide locales does not necessarily have an effect on your user's
    locales if they have already defined something else for themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print all the current locale environment variables for any system user,
    we can use the command, `locale`. To set single environment variables with the
    appropriate variable name; for example, to set the time locale to US time we would
    use the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'But, most likely we would want to change all the locales to the same value;
    this can be done by setting `LANG`. For example, to set all the locales to American
    English, use the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the effect of locale changes, we can now produce an error message that
    will be shown in the language set by the `locale` command. Here is the different
    language output for changing locale from English to German:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output will be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, change to German locale settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output will be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting a locale in an active console using the `export` command will not survive
    closing the window or opening a new terminal session. If you want to make those
    changes permanent, you can set any locale environment variables, such as the `LANG`
    variable, in a file called `.bashrc` in your home directory, which will be read
    everytime a shell is opened. To change the locale settings permanently to `de_DE.UTF-8`
    in our example (change this to your own needs) use the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Synchronizing the system clock with NTP and the chrony suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to synchronize the system clock with an external
    time server using the **Network Time Protocol** (**NTP**) and the chrony suite.
    From the need to time-stamp documents, e-mails, and log files, to securing, running,
    and debugging a network, or to simply interact with shared devices and services,
    everything on your server is dependent on maintaining an accurate system clock,
    and it is the purpose of this recipe to show you how this can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, a console-based text editor of your choice,
    and a connection to the Internet to facilitate downloading additional packages.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the `chrony` service to manage our time synchronization.
    As chrony is not installed by default on CentOS minimal, we will start this recipe
    by installing it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in as root and install the `chrony` service, then start it and
    verify that it is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, if we want to use chrony permanently, we will have to enable it on server
    startup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to check whether the system already uses NTP to synchronize our
    system clock over the network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the output from the last step showed `No` for `NTP synchronized`, we need
    to enable it using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run the command (from step 3) again, you should see that it is now synchronizing
    NTP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The default installation of chrony will use a public server that has access
    to the atomic clock, but in order to optimize the service we will need to make
    a few simple changes to streamline and optimize at what time servers are used.
    To do this, open the main chrony configuration file with your favorite text editor,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the file, scroll down and look for the lines containing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the values shown with a list of preferred local time servers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Visit [http://www.pool.ntp.org/](http://www.pool.ntp.org/) to obtain a list
    of local servers geographically near your current location. Remember, the use
    of three or more servers will have a tendency to increase the accuracy of the
    NTP service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When complete, save and close the file before synchronizing your server using
    the `sytstemctl` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether the modifications in the `config` file were successful, you
    can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check whether chrony is taking care of your system time synchronization,
    use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check the network sources chrony uses for synchronization, use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our CentOS 7 operating system's time is set on every boot based on the hardware
    clock, which is a small-battery driven clock located on the motherboard of your
    computer. Often, this clock is too inaccurate or has not been set right, therefore
    it's better to get your system time from a reliable source over the Internet (that
    uses real atomic time). The chrony daemon, `chronyd`, sets and maintains system
    time through a process of synchronization with a remote server using the NTP protocol
    for communication.
  prefs: []
  type: TYPE_NORMAL
- en: So, what have we learned from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: As a first step, we installed the `chrony` service, since it is not available
    by default on a CentOS 7 minimal installation. Afterwards, we enabled the synchronization
    of our system time with NTP using the `timedatectl set-ntp yes` command.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we opened the main chrony configuration file, `/etc/chrony.conf`,
    and showed how to change the external time servers used. This is particularly
    useful if your server is behind a corporate firewall and have your own NTP server
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Having restarted the service, we then learned how to check and monitor our new
    configuration using the `chronyc` command. This is a useful command line tool
    (c stands for client) for interacting and controlling a chrony daemon (locally
    or remotely). We used the `tracking` parameter with `chronyc`, which showed us
    detailed information of the current NTP synchronization process with a specific
    server. Please refer to the `man` pages of the `chronyc` command if you need further
    help about the properties shown in the output (`man chronyc`).
  prefs: []
  type: TYPE_NORMAL
- en: We also used the `sources` parameter with the `chronyc` program, which showed
    us an overview of the used NTP time servers.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the older `date` command to validate correct time synchronization.
    It is important to realize that the process of synchronizing your server may not
    be instantaneous, and it can take a while for the process to complete. However,
    you can now relax in the full knowledge that you now know how to install, manage
    and synchronize your time using the NTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we set our system''s time using the `chrony` service and the
    NTP protocol. Usually, system time is set as **Coordinated Universal Time** (**UTC**)
    or world time, which means it is one standard time used across the whole world.
    From it, we need to calculate our local time using time zones. To find the right
    time zone, use the following command (read the *Navigating textfiles with less*
    recipe to work with the output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have found the right time zone, write it down and use it in the next
    command; for example, if you are located in Germany and are near the city of Berlin,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `timedatectl` again to check if your local time is correct now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if it is correct, you can synchronize your hardware clock with your
    system time to make it more precise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Setting your hostname and resolving the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of setting the hostname is typically associated with the installation
    process. If you ever need to change it or your server's **Domain Name System**
    (**DNS**) resolver, this recipe will show you how.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges, and a console-based text editor of your
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin this recipe, we shall start by accessing the system as root and opening
    the following file in order to name or rename your current server''s hostname:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in as root and type in the following command to see the current hostname:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, change the hostname value to your preferred name. For example, if you
    want to call your server `jimi`, you would type (change appropriately):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Static hostnames are case-sensitive and restricted to using an Internet-friendly
    alphanumeric string of text. The overall length should be no longer than 63 characters,
    but try to keep it much shorter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need the IP address of the server. Type in the following command to
    find it (you need to identify the correct network interface in the output):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Afterwards, we will set the **Fully Qualified Domain Name** (**FQDN**), in
    order to do this, we will need to open and edit the hosts file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, you should add a new line appropriate to your needs. For example, if
    your server''s hostname was called jimi, (with an IP address of `192.168.1.100`,
    and a domain name of `henry.com`) your final line to append will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: For a server found on a local network only, it is advisable to use a non-Internet
    based top-level address. For example, you could use `.local` or `.lan`, or even
    `.home`, and by using these references you will avoid any confusion with the typical
    `.com`, `.co.uk`, or `.net` domain names.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will open the `resolv.conf` file, which is responsible for configuring
    static DNS server addresses that the system will use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the content of the file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When complete, save and close your file before rebooting your server to allow
    the changes to take immediate effect. To do this, return to your console and type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On a successful reboot, you can now check your new hostname and FQDN by typing
    the following commands and waiting for the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To test if we can resolve domain names to IP addresses using our static DNS
    server addresses, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A hostname is a unique label created to identify a machine on a network. It
    is restricted to alphanumeric-based characters, and making a change to your server's
    hostname can be achieved by using the `hostnamectl` command. A DNS server is used
    to translate domain names to IP addresses. There are several public DNS servers
    available; in a later recipe, we will build our own DNS service.
  prefs: []
  type: TYPE_NORMAL
- en: So, what have we learned from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first stage of the recipe, we changed the current hostname used by our
    server with the `hostnamectl` command. This command can set three different types
    of hostnames. Using the command with the `set-hostname` parameter will set the
    same name for all three hostnames: the high-level `pretty` hostname, which might
    include all kinds of special characters (for example, `Lennart''s Laptop`), the
    static hostname which is used to initialize the kernel hostname at boot (for example
    `lennarts-laptop`), and the transient hostname, which is a default received from
    network configurations.'
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we set the FQDN of our server. A FQDN is the hostname along
    with a domain name after it. A domain name gets important when you are running
    a private DNS, or allowing external access to your server. Besides using a DNS
    server setting the FQDN can be achieved by updating the hosts file found at `/etc/hosts`.
  prefs: []
  type: TYPE_NORMAL
- en: This file is used by CentOS to map hostnames to an IP address, and it is often
    found to be incorrect on a new, un-configured, or recently installed server. For
    this reason, we first had to find out the IP address of the server using `ip addr
    list`.
  prefs: []
  type: TYPE_NORMAL
- en: An FQDN should consist of a short hostname and the domain name. Based on the
    example shown in this recipe, we set the FQDN for a server named `henry`, whose
    IP address is `192.168.1.100` and domain name is `henry.com`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving this file would arguably complete this process. However, because the
    kernel makes a record of the hostname during the boot process, there is no choice
    but to reboot your server before you can use the changed settings.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we opened the system's `resolv.conf` file, which keeps the IP addresses
    of the system's DNS servers. If your server does not use or have any DNS records,
    your system is not able to use domain names for network destinations in any program
    at all. In our example, we entered the public Google DNS server IP addresses,
    but you are allowed to use any DNS server you want or have to use (often in a
    cooperate environment, behind a firewall, you have to use internal DNS server
    infrastructures). On a successful reboot, we confirmed your new settings by using
    the `hostname` command, which can print out the hostname or the FQDN based on
    the parameters given.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in conclusion, you can say that this recipe has not only served to show
    you how to rename your server and resolve the network, but has also showed you
    the difference between a hostname and domain name:'
  prefs: []
  type: TYPE_NORMAL
- en: As we have learned, a server is not only known by the use of a shorter, easier-to-remember,
    and quicker-to-type single-word-based host name, it also consists of three values
    separated with a period (for example jimi.henry.com). The relationship between
    these values may have seemed strange at first, especially where many people would
    have seen them as a single value, but by completing this recipe you have discovered
    that the domain name remains distinct from the hostname by virtue of being determined
    by the resolver subsystem, and it is only by putting them together that your server
    will yield the FQDN of the system as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The hosts file consists of a list of IP addresses and corresponding hostnames,
    and if your network contains computers whose IP addresses are not listed in an
    existing DNS record, then in order to speed up your network it is often recommended
    that you add them to this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be achieved on any operating system, but to do this on CentOS, simply
    open the hosts file in your favorite text editor, as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, scroll down to the bottom of the file and add the following values by
    substituting the domain names and IP addresses shown here with something more
    appropriate to your own needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even use external address such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This method provides you with the chance to create mappings between domain
    names and IP addresses without the need to use a DNS, and it can be applied to
    any workstation or server. The list is not restricted by size, and you can even
    employ this method to block access to certain websites by simply re-pointing all
    requests to visit a known website to a different IP address. For example, if the
    real address of `www.website.com` is `192.168.1.200` and you want to restrict
    access to it, then simply make the following changes to the hosts file on the
    computer that you want to block from access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It isn't failsafe, but in this instance anyone trying to access `www.website.com`
    on this system will automatically be sent to `127.0.0.1`, which is your local
    network address, so this will just block access.
  prefs: []
  type: TYPE_NORMAL
- en: When you have finished, remember to save and close your file in the usual way
    before proceeding to enjoy the benefits of faster and safer domain name resolution
    across any available network.
  prefs: []
  type: TYPE_NORMAL
- en: Building a static network connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to configure a static IP address for a new
    or existing CentOS server.
  prefs: []
  type: TYPE_NORMAL
- en: While a dynamically assigned IP address or DHCP reservation may be fine for
    most desktop and laptop users, if you are setting up a server, it is often the
    case that you will require a static IP address. From web pages to e-mail, databases
    to file sharing, a static IP address will become a permanent location from which
    your server will deliver a range of applications and services, and it is the intention
    of this recipe to show you how easily it can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a working installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the purpose of this recipe, you will be able to find all the relevant files
    in the directory, `/etc/sysconfig/network-scripts/`. First, you need to find out
    the correct name of the network interface that you want to set as static. If you
    need to set more than one network interface as static, repeat this recipe for
    every device.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, log in as root and type the following command to get a list of
    all of your system''s network interfaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you have only one network card installed, it should be very easy to find
    out its name; just select the one not named `lo` (which is the loopback device).
    If you got more than one, having a look at the IP addresses of the different devices
    can help you choose the right one. In our example, the device is called `enp0s3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, make a backup of the network interface configuration file (change the
    `enp0s3` part accordingly, if your network interface is named differently):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you are ready to proceed, open the following file in your favorite text
    editor by typing what is shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, work down the file and apply the following changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add your IP information by customizing the values of `XXX.XXX.XXX.XXX`
    as required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must now add a default gateway. Typically, this should be the address of
    your router. To do this, simply add a new line at the bottom of the file, as shown
    next, and customize the value as required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When ready, save and close the file before repeating this step for any remaining
    Ethernet devices that you want to make static. When doing this, remember to assign
    a different IP address to each device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When finished, save and close this file before restarting your network service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have seen the process associated with changing the state
    of your server's IP address from a dynamic value obtained from an external DHCP
    provider, to that of a static value assigned by you. This IP address will now
    form a unique network location from which you will be able to deliver a whole
    host of services and applications. It is a permanent modification, and yes, you
    could say that the process itself was relatively straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: So, what have we learned from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: Having started the recipe by identifying your network interface name of choice
    and creating a backup of the original Ethernet configuration files, we then opened
    the configuration file located at `/etc/sysconfig/network-scripts/ifcfg-XXX` (with
    `XXX` being the name of your interface, for example, `enp0s3`). As being static
    no longer requires the services of the network manager, we disabled `NM_CONTROLLED`
    by setting the value to `no`. Next, as we are in the process of moving to a static
    IP address, `BOOTPROTO` has been set to `none`, as we are no longer using DHCP.
    To complete our configuration changes, we then moved on to add our specific network
    values and set the IP address, the netmask, broadcast, and the default gateway
    address.
  prefs: []
  type: TYPE_NORMAL
- en: In order to assist the creation of a static IP address, the default gateway
    is a very important setting in as much as it allows the server to contact the
    wider world through a router.
  prefs: []
  type: TYPE_NORMAL
- en: When finished, we were asked to save and close the file before repeating this
    step for any remaining Ethernet devices. Having done this, we were then asked
    to restart the network service in order to complete this recipe and to enable
    our changes to take immediate effect.
  prefs: []
  type: TYPE_NORMAL
- en: Becoming a superuser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to provide nominated users or groups with
    the ability to execute a variety of commands with elevated privileges.
  prefs: []
  type: TYPE_NORMAL
- en: On CentOS Linux, many files, folders, or commands can only be accessed or executed
    by a user called `root`, which is the name of the user who can control everything
    on a Linux system. Having one root user per system may suit your needs, but for
    those who want a greater degree of flexibility, a solid audit trail, and the ability
    to provide a limited array of administrative capabilities to a select number of
    trusted users, you have come to the right place. It is the purpose of this recipe
    to show you how to activate and configure the **sudo** (**superuser do**) command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with root privileges. It is assumed that your server maintains
    one or more users (other than root) who qualify for this escalation in powers.
    If you did not create a system user account during installation, please do so
    by first applying the recipe, *Managing users and their groups*, in [Chapter 3](part0034_split_000.html#10DJ41-4cf34a6d07944734bb93fb0cd15cce8c
    "Chapter 3. Managing the System"), *Managing the System*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start this recipe, we will first test the `sudo` command with a non-privileged
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, log in to your system using a non-root user account, then type the
    following to verify that `sudo` is not enabled (use your user account''s password
    when asked):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will print the following error output with `<username>`, which is the
    user you are currently logged in with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, log out the system user using the command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, log in as root and use the following command to give the non-root user
    sudo power (change `<username>` appropriately):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can test if `sudo` is working by logging out root again and re-logging
    in the user from step 1, and then trying again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Congratulations, you've now set a normal user to have sudo powers and can view
    and execute files and directories restricted to the root user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike some Linux distributions, CentOS does not provide sudo by default. Instead,
    you are typically allowed to access restricted parts of the system with the root
    user only. This offers a certain degree of security, but for a multi-user server
    there is little to no flexibility unless you simply provide these individuals
    with full administrative root access permissions. This is not advisable, and for
    this reason it was the purpose of this recipe to show you how to provide one or
    more users with the right to execute commands with elevated privileges.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We started by logging in to the system with a normal user account having no
    root privileges or sudo powers. With this user, we then tried to list a directory
    that normally only the root user is allowed to see, so we applied the `sudo` command
    on it. It failed, giving us the error that we are not in the sudoers list.
  prefs: []
  type: TYPE_NORMAL
- en: The `sudo` command provides nominated users or groups with the ability to execute
    a command as if they were the root user. All actions are recorded (in a file called
    `/var/log/secure`), so there will be a trace of all the commands and arguments
    used.
  prefs: []
  type: TYPE_NORMAL
- en: We then logged in as the true root user and added a group called wheel to the
    system user that we wanted sudo rights for. This group is used as a special administration
    group and every member of it is granted sudo rights automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on, the nominated user can implement sudo in order to execute any
    command with elevated privileges. To do this, the user would be required to type
    the word `sudo` before any command, for example, they could run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: They will be asked to confirm their user password (not the root password!),
    and after successful authentication the program will be executed as the user root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can say that there are three ways to become root on a CentOS Linux
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: First, to log in as the true user root to the system. Second, you can use the
    command, `su – root`, while any normal system user is logged in, giving the root
    user's password to switch to a root shell prompt permanently. Third, you can give
    a normal user sudo rights so that they can execute single commands using their
    own passwords as if they were the root user, while staying logged in as themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**sudo** (**superuser do**) should not be confused with the **su** (**substitute
    user**) command, which allows you to switch to another user permanently instead
    of executing only single commands as you would do being the root user.'
  prefs: []
  type: TYPE_NORMAL
- en: The `sudo` command allows great flexibility for servers that have a lot of users,
    where one administrator is not enough to manage the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing your system banners and messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to display a welcome message if a user successfully
    logs in to our CentOS 7 system using SSH or console, or opens a new terminal window
    in a graphical window manager. This is often used to show the user informative
    messages, or for legal reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with root privileges and a console-based text editor of your
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, log in to your system using your root user account and create the
    following new file with your favorite text editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will put in the following content in this new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save and close this file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Congratulations, you have now set a banner message for whenever a user successfully
    logs in to the system using ssh or a console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For legal reasons, it is strongly recommended that computers display a banner
    before allowing users to log in; lawyers suggest that the offense of unauthorized
    access can only be committed if the offender knows at the time that the access
    he intends to obtain is unauthorized. Login banners are the best way to achieve
    this. Apart from this reason, you can provide the user with useful system information.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: We started this recipe by opening the file, `/etc/motd`, which stands for message
    of the day; this content will be displayed after a user logged in a console or
    ssh. Next, we put in that file a standard legal disclaimer and saved the file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen, the `/etc/motd` file displays static text after a user successfully
    logs in to the system. If you want to also display a message when an ssh connection
    is first established, you can use ssh banners. The banner behavior is disabled
    in the ssh daemon configuration file by default, which means that no message will
    be displayed if a user establishes an ssh connection. To enable this feature,
    log in as root on your server and open the `/etc/ssh/sshd_config` file using your
    favorite text editor, and put in the following content at the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Then, create and open a new file called `/etc/ssh-banner`, and put in a new
    custom ssh greeting message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, restart your ssh daemon using the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The next time someone establishes an ssh connection to your server, this new
    message will be printed out.
  prefs: []
  type: TYPE_NORMAL
- en: The `motd` file can only print static messages and some system information details,
    but it is impossible to generate real dynamic messages or use bash commands in
    it if a user successfully logs in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, `motd` does not work in non-login shells, such as when you open a new
    terminal within a graphical window manager. In order to achieve this, we can create
    a custom script in the `/etc/profile.d` directory. All scripts in this directory
    get executed automatically if a user logs in to the system. First, we delete any
    content in the `/etc/motd` file, as we don''t want to display two welcome banners.
    Then, we open the new file, `/etc/profile.d/motd.sh`, with our text editor and
    create a custom message, such as the following, where we can use bash commands
    and write little scripts (use the back ticks to run bash shell commands in this
    file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Priming the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux kernel is a program that constitutes the central core of the operating
    system. It can directly access the underlying hardware and make it available to
    the user to work with it using the shell.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to prime the kernel by working with dynamically
    loaded kernel modules. Kernel modules are device driver files (or filesystem driver
    files) that add support for specific pieces of hardware so that we can access
    them.
  prefs: []
  type: TYPE_NORMAL
- en: You will not work very often with kernel modules as a system administrator,
    but having a basic understanding of them can be beneficial if you have a device
    driver problem or an unsupported piece of hardware.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To complete this recipe, you will require a minimal installation of the CentOS
    7 operating system with root privileges.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, log in to your system using your root user account, and type the
    following command in order to show the status of all Linux kernel modules currently
    loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the output, you will see all loaded device drivers (module); let''s see
    if a `cdrom` and `floppy` module have been loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On most servers, there will be the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we want to show detailed information about the `sr_mod` cdrom module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, unload these two modules from the kernel (you can only do this if the
    module and hardware have been found and loaded on your system; otherwise skip
    this step):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check if the modules have been unloaded (output should be empty now):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, to show a list of all kernel modules available on your system, use the
    following directory where you can look around:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s pick a module from the subfolder `/lib/modules/$(uname -r)/kernel/drivers/`
    called `bluetooth` and verify that it is not loaded yet (output should be empty):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get more information about the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, load this bluetooth USB module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify again that it is loaded now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kernel modules are the drivers that your system's hardware needs to communicate
    with the kernel and operating system (also, they are needed to load and enable
    filesystems). They are loaded dynamically, which means that only the drivers or
    modules are loaded at runtime, which reflects your own custom specific hardware.
  prefs: []
  type: TYPE_NORMAL
- en: So, what did we learn from this experience?
  prefs: []
  type: TYPE_NORMAL
- en: 'We started using the `lsmod` command to view all the currently loaded kernel
    modules in our system. The output shows three columns: the module name, the amount
    of RAM the module occupies while loaded, and the number of processes this module
    is used by and a list of dependencies of other modules using it. Next, we checked
    if the `cdrom` and `floppy` modules have been loaded by the kernel yet. In the
    output, we saw that the `cdrom` module is dependent on the `sr_mod` module. So,
    next we used the `modinfo` command to get detailed information about it. Here,
    we learned that `sr_mod` is the SCSI `cdrom` driver.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we only need the floppy and cdrom drivers while we first installed the
    base system we can now disable those kernel modules and save us some memory. We
    unloaded the modules and their dependencies with the `modprobe -r` command and
    rechecked whether this was successful by using `lsmod` again.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we browsed the standard kernel module directory (for example, `/lib/modules/$(uname
    -r)/kernel/drivers`). The `uname` substring command prints out the current kernel
    version so that it makes sure that we are always listing the current kernel modules
    after having installed more than one version of the kernel on our system.
  prefs: []
  type: TYPE_NORMAL
- en: This kernel module directory keeps all the available modules on your system
    structured and categorized using subdirectories. We navigated to `drivers/bluetooth`
    and picked the `btusb` module. Doing `modinfo` on the `btusb` module, we found
    out that it is the generic bluetooth USB driver. Finally, we decided that we needed
    this module, so we loaded it using the `modprobe` command again.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s important to say that loading and unloading kernel modules using the
    `modprobe` command is not persistent; this means that if you restart the system,
    all your changes to kernel modules will be gone. To load a kernel module at boot
    time create a new executable script file, `/etc/sysconfig/modules/<filename>.modules`,
    where `<filename>` is a name of your choice. There you put in `modprobe` execution
    commands just as you would on the normal command line. Here is an example of additionally
    loading the bluetooth driver on startup, for example `/etc/sysconfig/modules/btusb.modules`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you need to make your new module file executable via the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Recheck your new module settings with `lsmod` after reboot.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove a kernel module at boot time for example `sr_mod`, we need to blacklist
    the module''s name using the `rdblacklist` kernel boot option. We can set this
    option by appending it to the end of the `GRUB_CMDLINE_LINUX` directive in the
    GRUB2 configuration file `/etc/default/grub` so it will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: If you need to blacklist multiple modules, the `rdblacklist` option can be specified
    multiple times like `rdblacklist=sr_mod rdblacklist=nouveau`.
  prefs: []
  type: TYPE_NORMAL
- en: Next recreate the GRUB2 configuration using the `grub2-mkconfig` command (to
    learn more read the *Getting started and customizing the boot loader* recipe in
    [Chapter 1](part0015_split_000.html#E9OE1-4cf34a6d07944734bb93fb0cd15cce8c "Chapter 1. Installing
    CentOS"), *Installing CentOS*).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we also need to `blacklist` the module name using the blacklist directive
    in a `new.conf` file of your choice in the `/etc/modprobe.d/` directory for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
